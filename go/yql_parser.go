// Code generated from YQL.g4 by ANTLR 4.13.2. DO NOT EDIT.

package parser // YQL
import (
	"fmt"
	"strconv"
  	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}


type YQLParser struct {
	*antlr.BaseParser
}

var YQLParserStaticData struct {
  once                   sync.Once
  serializedATN          []int32
  LiteralNames           []string
  SymbolicNames          []string
  RuleNames              []string
  PredictionContextCache *antlr.PredictionContextCache
  atn                    *antlr.ATN
  decisionToDFA          []*antlr.DFA
}

func yqlParserInit() {
  staticData := &YQLParserStaticData
  staticData.LiteralNames = []string{
    "", "'='", "'=='", "'!='", "'<>'", "'<'", "'<='", "'>'", "'>='", "'<<'", 
    "'|<<'", "'&'", "'|'", "'||'", "'<|'", "'|>'", "'+'", "'-'", "'~'", 
    "'*'", "'/'", "'%'", "';'", "'.'", "','", "'('", "')'", "'?'", "':'", 
    "'@'", "'$'", "'{'", "'}'", "'^'", "'::'", "'->'", "']'", "'['",
  }
  staticData.SymbolicNames = []string{
    "", "EQUALS", "EQUALS2", "NOT_EQUALS", "NOT_EQUALS2", "LESS", "LESS_OR_EQ", 
    "GREATER", "GREATER_OR_EQ", "SHIFT_LEFT", "ROT_LEFT", "AMPERSAND", "PIPE", 
    "DOUBLE_PIPE", "STRUCT_OPEN", "STRUCT_CLOSE", "PLUS", "MINUS", "TILDA", 
    "ASTERISK", "SLASH", "PERCENT", "SEMICOLON", "DOT", "COMMA", "LPAREN", 
    "RPAREN", "QUESTION", "COLON", "COMMAT", "DOLLAR", "LBRACE_CURLY", "RBRACE_CURLY", 
    "CARET", "NAMESPACE", "ARROW", "RBRACE_SQUARE", "LBRACE_SQUARE", "ABORT", 
    "ACTION", "ADD", "AFTER", "ALL", "ALTER", "ANALYZE", "AND", "ANSI", 
    "ANY", "ARRAY", "AS", "ASC", "ASSUME", "ASYMMETRIC", "ASYNC", "AT", 
    "ATTACH", "ATTRIBUTES", "AUTOINCREMENT", "AUTOMAP", "BACKUP", "COLLECTION", 
    "BEFORE", "BEGIN", "BERNOULLI", "BETWEEN", "BITCAST", "BY", "CALLABLE", 
    "CASCADE", "CASE", "CAST", "CHANGEFEED", "CHECK", "CLASSIFIER", "COLLATE", 
    "COLUMN", "COLUMNS", "COMMIT", "COMPACT", "CONDITIONAL", "CONFLICT", 
    "CONNECT", "CONSTRAINT", "CONSUMER", "COVER", "CREATE", "CROSS", "CUBE", 
    "CURRENT", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "DATA", 
    "DATABASE", "DECIMAL", "DECLARE", "DEFAULT", "DEFERRABLE", "DEFERRED", 
    "DEFINE", "DELETE", "DESC", "DESCRIBE", "DETACH", "DICT", "DIRECTORY", 
    "DISABLE", "DISCARD", "DISTINCT", "DO", "DROP", "EACH", "ELSE", "EMPTY", 
    "EMPTY_ACTION", "ENCRYPTED", "END", "ENUM", "ERASE", "ERROR", "ESCAPE", 
    "EVALUATE", "EXCEPT", "EXCLUDE", "EXCLUSION", "EXCLUSIVE", "EXISTS", 
    "EXPLAIN", "EXPORT", "EXTERNAL", "FAIL", "FALSE", "FAMILY", "FILTER", 
    "FIRST", "FLATTEN", "FLOW", "FOLLOWING", "FOR", "FOREIGN", "FROM", "FULL", 
    "FUNCTION", "GLOB", "GLOBAL", "GRANT", "GROUP", "GROUPING", "GROUPS", 
    "HASH", "HAVING", "HOP", "IF", "IGNORE", "ILIKE", "IMMEDIATE", "IMPORT", 
    "IN", "INCREMENT", "INCREMENTAL", "INDEX", "INDEXED", "INHERITS", "INITIAL", 
    "INITIALLY", "INNER", "INSERT", "INSTEAD", "INTERSECT", "INTO", "IS", 
    "ISNULL", "JOIN", "JSON_EXISTS", "JSON_QUERY", "JSON_VALUE", "KEY", 
    "LAST", "LEFT", "LEGACY", "LIKE", "LIMIT", "LIST", "LOCAL", "LOGIN", 
    "MANAGE", "MATCH", "MATCHES", "MATCH_RECOGNIZE", "MEASURES", "MICROSECONDS", 
    "MILLISECONDS", "MODIFY", "NANOSECONDS", "NATURAL", "NEXT", "NO", "NOLOGIN", 
    "NOT", "NOTNULL", "NULL", "NULLS", "OBJECT", "OF", "OFFSET", "OMIT", 
    "ON", "ONE", "ONLY", "OPTION", "OPTIONAL", "OR", "ORDER", "OTHERS", 
    "OUTER", "OVER", "PARALLEL", "PARTITION", "PASSING", "PASSWORD", "PAST", 
    "PATTERN", "PER", "PERMUTE", "PLAN", "POOL", "PRAGMA", "PRECEDING", 
    "PRESORT", "PRIMARY", "PRIVILEGES", "PROCESS", "QUERY", "QUEUE", "RAISE", 
    "RANGE", "REDUCE", "REFERENCES", "REGEXP", "REINDEX", "RELEASE", "REMOVE", 
    "RENAME", "REPEATABLE", "REPLACE", "REPLICATION", "RESET", "RESOURCE", 
    "RESPECT", "RESTART", "RESTORE", "RESTRICT", "RESULT", "RETURN", "RETURNING", 
    "REVERT", "REVOKE", "RIGHT", "RLIKE", "ROLLBACK", "ROLLUP", "ROW", "ROWS", 
    "SAMPLE", "SAVEPOINT", "SCHEMA", "SECONDS", "SEEK", "SELECT", "SEMI", 
    "SET", "SETS", "SHOW", "TSKIP", "SEQUENCE", "SOURCE", "START", "STREAM", 
    "STRUCT", "SUBQUERY", "SUBSET", "SYMBOLS", "SYMMETRIC", "SYNC", "SYSTEM", 
    "TABLE", "TABLES", "TABLESAMPLE", "TABLESTORE", "TAGGED", "TEMP", "TEMPORARY", 
    "THEN", "TIES", "TO", "TOPIC", "TRANSACTION", "TRIGGER", "TRUE", "TUPLE", 
    "TYPE", "UNBOUNDED", "UNCONDITIONAL", "UNION", "UNIQUE", "UNKNOWN", 
    "UNMATCHED", "UPDATE", "UPSERT", "USE", "USER", "USING", "VACUUM", "VALUES", 
    "VARIANT", "VIEW", "VIRTUAL", "WHEN", "WHERE", "WINDOW", "WITH", "WITHOUT", 
    "WRAPPER", "XOR", "STRING_VALUE", "ID_PLAIN", "ID_QUOTED", "DIGITS", 
    "INTEGER_VALUE", "REAL", "BLOB", "WS", "COMMENT",
  }
  staticData.RuleNames = []string{
    "sql_query", "sql_stmt_list", "ansi_sql_stmt_list", "lambda_body", "lambda_stmt", 
    "sql_stmt", "sql_stmt_core", "expr", "or_subexpr", "and_subexpr", "xor_subexpr", 
    "distinct_from_op", "cond_expr", "match_op", "eq_subexpr", "shift_right", 
    "rot_right", "double_question", "neq_subexpr", "bit_subexpr", "add_subexpr", 
    "mul_subexpr", "con_subexpr", "unary_op", "unary_subexpr_suffix", "unary_casual_subexpr", 
    "in_unary_casual_subexpr", "unary_subexpr", "in_unary_subexpr", "list_literal", 
    "expr_dict_list", "dict_literal", "expr_struct_list", "struct_literal", 
    "atom_expr", "in_atom_expr", "cast_expr", "bitcast_expr", "exists_expr", 
    "case_expr", "lambda", "in_expr", "json_api_expr", "jsonpath_spec", 
    "json_variable_name", "json_variable", "json_variables", "json_common_args", 
    "json_case_handler", "json_value", "json_exists_handler", "json_exists", 
    "json_query_wrapper", "json_query_handler", "json_query", "smart_parenthesis", 
    "expr_list", "pure_column_list", "pure_column_or_named", "pure_column_or_named_list", 
    "column_name", "without_column_name", "column_list", "without_column_list", 
    "named_expr", "named_expr_list", "invoke_expr", "invoke_expr_tail", 
    "using_call_expr", "key_expr", "when_expr", "literal_value", "bind_parameter", 
    "opt_bind_parameter", "bind_parameter_list", "named_bind_parameter", 
    "named_bind_parameter_list", "signed_number", "type_name_simple", "integer_or_bind", 
    "type_name_tag", "struct_arg", "struct_arg_positional", "variant_arg", 
    "callable_arg", "callable_arg_list", "type_name_decimal", "type_name_optional", 
    "type_name_tuple", "type_name_struct", "type_name_variant", "type_name_list", 
    "type_name_stream", "type_name_flow", "type_name_dict", "type_name_set", 
    "type_name_enum", "type_name_resource", "type_name_tagged", "type_name_callable", 
    "type_name_composite", "type_name", "type_name_or_bind", "value_constructor_literal", 
    "value_constructor", "declare_stmt", "module_path", "import_stmt", "export_stmt", 
    "call_action", "inline_action", "do_stmt", "pragma_stmt", "pragma_value", 
    "sort_specification", "sort_specification_list", "select_stmt", "select_unparenthesized_stmt", 
    "select_kind_parenthesis", "select_op", "select_kind_partial", "select_kind", 
    "process_core", "external_call_param", "external_call_settings", "reduce_core", 
    "opt_set_quantifier", "select_core", "row_pattern_recognition_clause", 
    "row_pattern_rows_per_match", "row_pattern_empty_match_handling", "row_pattern_measures", 
    "row_pattern_measure_list", "row_pattern_measure_definition", "row_pattern_common_syntax", 
    "row_pattern_skip_to", "row_pattern_skip_to_variable_name", "row_pattern_initial_or_seek", 
    "row_pattern", "row_pattern_term", "row_pattern_factor", "row_pattern_quantifier", 
    "row_pattern_primary", "row_pattern_primary_variable_name", "row_pattern_permute", 
    "row_pattern_subset_clause", "row_pattern_subset_list", "row_pattern_subset_item", 
    "row_pattern_subset_item_variable_name", "row_pattern_subset_rhs", "row_pattern_subset_rhs_variable_name", 
    "row_pattern_definition_list", "row_pattern_definition", "row_pattern_definition_variable_name", 
    "row_pattern_definition_search_condition", "search_condition", "row_pattern_variable_name", 
    "order_by_clause", "ext_order_by_clause", "group_by_clause", "grouping_element_list", 
    "grouping_element", "ordinary_grouping_set", "ordinary_grouping_set_list", 
    "rollup_list", "cube_list", "grouping_sets_specification", "hopping_window_specification", 
    "result_column", "join_source", "named_column", "flatten_by_arg", "flatten_source", 
    "named_single_source", "single_source", "sample_clause", "tablesample_clause", 
    "sampling_mode", "repeatable_clause", "join_op", "join_constraint", 
    "returning_columns_list", "into_table_stmt", "into_values_source", "values_stmt", 
    "values_source", "values_source_row_list", "values_source_row", "simple_values_source", 
    "create_external_data_source_stmt", "alter_external_data_source_stmt", 
    "alter_external_data_source_action", "drop_external_data_source_stmt", 
    "create_view_stmt", "drop_view_stmt", "upsert_object_stmt", "create_object_stmt", 
    "create_object_features", "alter_object_stmt", "alter_object_features", 
    "drop_object_stmt", "drop_object_features", "object_feature_value", 
    "object_feature_kv", "object_feature_flag", "object_feature", "object_features", 
    "object_type_ref", "create_table_stmt", "create_table_entry", "create_backup_collection_stmt", 
    "alter_backup_collection_stmt", "drop_backup_collection_stmt", "create_backup_collection_entries", 
    "create_backup_collection_entries_many", "table_list", "alter_backup_collection_actions", 
    "alter_backup_collection_action", "alter_backup_collection_entries", 
    "alter_backup_collection_entry", "backup_collection", "backup_collection_settings", 
    "backup_collection_settings_entry", "backup_stmt", "restore_stmt", "table_inherits", 
    "table_partition_by", "with_table_settings", "table_tablestore", "table_settings_entry", 
    "table_as_source", "alter_table_stmt", "alter_table_action", "alter_external_table_stmt", 
    "alter_external_table_action", "alter_table_store_stmt", "alter_table_store_action", 
    "alter_table_add_column", "alter_table_drop_column", "alter_table_alter_column", 
    "alter_table_alter_column_drop_not_null", "alter_table_add_column_family", 
    "alter_table_alter_column_family", "alter_table_set_table_setting_uncompat", 
    "alter_table_set_table_setting_compat", "alter_table_reset_table_setting", 
    "alter_table_add_index", "alter_table_drop_index", "alter_table_rename_to", 
    "alter_table_rename_index_to", "alter_table_add_changefeed", "alter_table_alter_changefeed", 
    "alter_table_drop_changefeed", "alter_table_alter_index", "column_schema", 
    "family_relation", "opt_column_constraints", "column_order_by_specification", 
    "table_constraint", "table_index", "table_index_type", "global_index", 
    "local_index", "index_subtype", "with_index_settings", "index_setting_entry", 
    "index_setting_value", "changefeed", "changefeed_settings", "changefeed_settings_entry", 
    "changefeed_setting_value", "changefeed_alter_settings", "alter_table_setting_entry", 
    "table_setting_value", "ttl_tier_list", "ttl_tier_action", "family_entry", 
    "family_settings", "family_settings_entry", "family_setting_value", 
    "split_boundaries", "literal_value_list", "alter_table_alter_index_action", 
    "drop_table_stmt", "create_user_stmt", "alter_user_stmt", "create_group_stmt", 
    "alter_group_stmt", "drop_role_stmt", "role_name", "create_user_option", 
    "password_option", "login_option", "grant_permissions_stmt", "revoke_permissions_stmt", 
    "permission_id", "permission_name", "permission_name_target", "create_resource_pool_stmt", 
    "alter_resource_pool_stmt", "alter_resource_pool_action", "drop_resource_pool_stmt", 
    "create_resource_pool_classifier_stmt", "alter_resource_pool_classifier_stmt", 
    "alter_resource_pool_classifier_action", "drop_resource_pool_classifier_stmt", 
    "create_replication_stmt", "replication_target", "replication_settings", 
    "replication_settings_entry", "alter_replication_stmt", "alter_replication_action", 
    "alter_replication_set_setting", "drop_replication_stmt", "action_or_subquery_args", 
    "define_action_or_subquery_stmt", "define_action_or_subquery_body", 
    "if_stmt", "for_stmt", "table_ref", "table_key", "table_arg", "table_hints", 
    "table_hint", "object_ref", "simple_table_ref_core", "simple_table_ref", 
    "into_simple_table_ref", "delete_stmt", "update_stmt", "set_clause_choice", 
    "set_clause_list", "set_clause", "set_target", "multiple_column_assignment", 
    "set_target_list", "create_topic_stmt", "create_topic_entries", "create_topic_entry", 
    "with_topic_settings", "alter_topic_stmt", "alter_topic_action", "alter_topic_add_consumer", 
    "topic_create_consumer_entry", "alter_topic_alter_consumer", "alter_topic_alter_consumer_entry", 
    "alter_topic_drop_consumer", "topic_alter_consumer_set", "topic_alter_consumer_reset", 
    "alter_topic_set_settings", "alter_topic_reset_settings", "drop_topic_stmt", 
    "topic_settings", "topic_settings_entry", "topic_setting_value", "topic_consumer_with_settings", 
    "topic_consumer_settings", "topic_consumer_settings_entry", "topic_consumer_setting_value", 
    "topic_ref", "topic_consumer_ref", "null_treatment", "filter_clause", 
    "window_name_or_specification", "window_name", "window_clause", "window_definition_list", 
    "window_definition", "new_window_name", "window_specification", "window_specification_details", 
    "existing_window_name", "window_partition_clause", "window_order_clause", 
    "window_frame_clause", "window_frame_units", "window_frame_extent", 
    "window_frame_between", "window_frame_bound", "window_frame_exclusion", 
    "use_stmt", "subselect_stmt", "named_nodes_stmt", "commit_stmt", "rollback_stmt", 
    "analyze_table", "analyze_table_list", "analyze_stmt", "alter_sequence_stmt", 
    "alter_sequence_action", "identifier", "id", "id_schema", "id_expr", 
    "id_expr_in", "id_window", "id_table", "id_without", "id_hint", "id_as_compat", 
    "an_id", "an_id_or_type", "an_id_schema", "an_id_expr", "an_id_expr_in", 
    "an_id_window", "an_id_table", "an_id_without", "an_id_hint", "an_id_pure", 
    "an_id_as_compat", "view_name", "opt_id_prefix", "cluster_expr", "id_or_type", 
    "opt_id_prefix_or_type", "id_or_at", "id_table_or_type", "id_table_or_at", 
    "keyword", "keyword_expr_uncompat", "keyword_table_uncompat", "keyword_select_uncompat", 
    "keyword_alter_uncompat", "keyword_in_uncompat", "keyword_window_uncompat", 
    "keyword_hint_uncompat", "keyword_as_compat", "keyword_compat", "type_id", 
    "bool_value", "real", "integer",
  }
  staticData.PredictionContextCache = antlr.NewPredictionContextCache()
  staticData.serializedATN = []int32{
	4, 1, 332, 4568, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 
	7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 
	7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 
	15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 
	2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 
	26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 
	7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 
	36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 
	2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 
	47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 
	7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 
	57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 
	2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 
	68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73, 
	7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7, 
	78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83, 
	2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2, 
	89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94, 
	7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7, 
	99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2, 
	104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7, 
	108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2, 
	113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7, 
	117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2, 
	122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7, 
	126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2, 
	131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7, 
	135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2, 
	140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7, 
	144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2, 
	149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7, 
	153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2, 
	158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7, 
	162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2, 
	167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7, 
	171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2, 
	176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7, 
	180, 2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2, 
	185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7, 
	189, 2, 190, 7, 190, 2, 191, 7, 191, 2, 192, 7, 192, 2, 193, 7, 193, 2, 
	194, 7, 194, 2, 195, 7, 195, 2, 196, 7, 196, 2, 197, 7, 197, 2, 198, 7, 
	198, 2, 199, 7, 199, 2, 200, 7, 200, 2, 201, 7, 201, 2, 202, 7, 202, 2, 
	203, 7, 203, 2, 204, 7, 204, 2, 205, 7, 205, 2, 206, 7, 206, 2, 207, 7, 
	207, 2, 208, 7, 208, 2, 209, 7, 209, 2, 210, 7, 210, 2, 211, 7, 211, 2, 
	212, 7, 212, 2, 213, 7, 213, 2, 214, 7, 214, 2, 215, 7, 215, 2, 216, 7, 
	216, 2, 217, 7, 217, 2, 218, 7, 218, 2, 219, 7, 219, 2, 220, 7, 220, 2, 
	221, 7, 221, 2, 222, 7, 222, 2, 223, 7, 223, 2, 224, 7, 224, 2, 225, 7, 
	225, 2, 226, 7, 226, 2, 227, 7, 227, 2, 228, 7, 228, 2, 229, 7, 229, 2, 
	230, 7, 230, 2, 231, 7, 231, 2, 232, 7, 232, 2, 233, 7, 233, 2, 234, 7, 
	234, 2, 235, 7, 235, 2, 236, 7, 236, 2, 237, 7, 237, 2, 238, 7, 238, 2, 
	239, 7, 239, 2, 240, 7, 240, 2, 241, 7, 241, 2, 242, 7, 242, 2, 243, 7, 
	243, 2, 244, 7, 244, 2, 245, 7, 245, 2, 246, 7, 246, 2, 247, 7, 247, 2, 
	248, 7, 248, 2, 249, 7, 249, 2, 250, 7, 250, 2, 251, 7, 251, 2, 252, 7, 
	252, 2, 253, 7, 253, 2, 254, 7, 254, 2, 255, 7, 255, 2, 256, 7, 256, 2, 
	257, 7, 257, 2, 258, 7, 258, 2, 259, 7, 259, 2, 260, 7, 260, 2, 261, 7, 
	261, 2, 262, 7, 262, 2, 263, 7, 263, 2, 264, 7, 264, 2, 265, 7, 265, 2, 
	266, 7, 266, 2, 267, 7, 267, 2, 268, 7, 268, 2, 269, 7, 269, 2, 270, 7, 
	270, 2, 271, 7, 271, 2, 272, 7, 272, 2, 273, 7, 273, 2, 274, 7, 274, 2, 
	275, 7, 275, 2, 276, 7, 276, 2, 277, 7, 277, 2, 278, 7, 278, 2, 279, 7, 
	279, 2, 280, 7, 280, 2, 281, 7, 281, 2, 282, 7, 282, 2, 283, 7, 283, 2, 
	284, 7, 284, 2, 285, 7, 285, 2, 286, 7, 286, 2, 287, 7, 287, 2, 288, 7, 
	288, 2, 289, 7, 289, 2, 290, 7, 290, 2, 291, 7, 291, 2, 292, 7, 292, 2, 
	293, 7, 293, 2, 294, 7, 294, 2, 295, 7, 295, 2, 296, 7, 296, 2, 297, 7, 
	297, 2, 298, 7, 298, 2, 299, 7, 299, 2, 300, 7, 300, 2, 301, 7, 301, 2, 
	302, 7, 302, 2, 303, 7, 303, 2, 304, 7, 304, 2, 305, 7, 305, 2, 306, 7, 
	306, 2, 307, 7, 307, 2, 308, 7, 308, 2, 309, 7, 309, 2, 310, 7, 310, 2, 
	311, 7, 311, 2, 312, 7, 312, 2, 313, 7, 313, 2, 314, 7, 314, 2, 315, 7, 
	315, 2, 316, 7, 316, 2, 317, 7, 317, 2, 318, 7, 318, 2, 319, 7, 319, 2, 
	320, 7, 320, 2, 321, 7, 321, 2, 322, 7, 322, 2, 323, 7, 323, 2, 324, 7, 
	324, 2, 325, 7, 325, 2, 326, 7, 326, 2, 327, 7, 327, 2, 328, 7, 328, 2, 
	329, 7, 329, 2, 330, 7, 330, 2, 331, 7, 331, 2, 332, 7, 332, 2, 333, 7, 
	333, 2, 334, 7, 334, 2, 335, 7, 335, 2, 336, 7, 336, 2, 337, 7, 337, 2, 
	338, 7, 338, 2, 339, 7, 339, 2, 340, 7, 340, 2, 341, 7, 341, 2, 342, 7, 
	342, 2, 343, 7, 343, 2, 344, 7, 344, 2, 345, 7, 345, 2, 346, 7, 346, 2, 
	347, 7, 347, 2, 348, 7, 348, 2, 349, 7, 349, 2, 350, 7, 350, 2, 351, 7, 
	351, 2, 352, 7, 352, 2, 353, 7, 353, 2, 354, 7, 354, 2, 355, 7, 355, 2, 
	356, 7, 356, 2, 357, 7, 357, 2, 358, 7, 358, 2, 359, 7, 359, 2, 360, 7, 
	360, 2, 361, 7, 361, 2, 362, 7, 362, 2, 363, 7, 363, 2, 364, 7, 364, 2, 
	365, 7, 365, 2, 366, 7, 366, 2, 367, 7, 367, 2, 368, 7, 368, 2, 369, 7, 
	369, 2, 370, 7, 370, 2, 371, 7, 371, 2, 372, 7, 372, 2, 373, 7, 373, 2, 
	374, 7, 374, 2, 375, 7, 375, 2, 376, 7, 376, 2, 377, 7, 377, 2, 378, 7, 
	378, 2, 379, 7, 379, 2, 380, 7, 380, 2, 381, 7, 381, 2, 382, 7, 382, 2, 
	383, 7, 383, 2, 384, 7, 384, 2, 385, 7, 385, 2, 386, 7, 386, 2, 387, 7, 
	387, 2, 388, 7, 388, 2, 389, 7, 389, 2, 390, 7, 390, 2, 391, 7, 391, 2, 
	392, 7, 392, 2, 393, 7, 393, 2, 394, 7, 394, 2, 395, 7, 395, 2, 396, 7, 
	396, 2, 397, 7, 397, 2, 398, 7, 398, 2, 399, 7, 399, 2, 400, 7, 400, 2, 
	401, 7, 401, 2, 402, 7, 402, 2, 403, 7, 403, 2, 404, 7, 404, 2, 405, 7, 
	405, 2, 406, 7, 406, 2, 407, 7, 407, 2, 408, 7, 408, 2, 409, 7, 409, 2, 
	410, 7, 410, 2, 411, 7, 411, 2, 412, 7, 412, 2, 413, 7, 413, 2, 414, 7, 
	414, 2, 415, 7, 415, 2, 416, 7, 416, 2, 417, 7, 417, 2, 418, 7, 418, 2, 
	419, 7, 419, 2, 420, 7, 420, 2, 421, 7, 421, 2, 422, 7, 422, 2, 423, 7, 
	423, 2, 424, 7, 424, 2, 425, 7, 425, 2, 426, 7, 426, 2, 427, 7, 427, 2, 
	428, 7, 428, 2, 429, 7, 429, 2, 430, 7, 430, 2, 431, 7, 431, 2, 432, 7, 
	432, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 3, 0, 872, 8, 0, 1, 1, 5, 1, 875, 8, 
	1, 10, 1, 12, 1, 878, 9, 1, 1, 1, 1, 1, 4, 1, 882, 8, 1, 11, 1, 12, 1, 
	883, 1, 1, 5, 1, 887, 8, 1, 10, 1, 12, 1, 890, 9, 1, 1, 1, 5, 1, 893, 8, 
	1, 10, 1, 12, 1, 896, 9, 1, 1, 1, 1, 1, 1, 2, 5, 2, 901, 8, 2, 10, 2, 12, 
	2, 904, 9, 2, 1, 2, 1, 2, 1, 3, 5, 3, 909, 8, 3, 10, 3, 12, 3, 912, 9, 
	3, 1, 3, 1, 3, 4, 3, 916, 8, 3, 11, 3, 12, 3, 917, 5, 3, 920, 8, 3, 10, 
	3, 12, 3, 923, 9, 3, 1, 3, 1, 3, 1, 3, 5, 3, 928, 8, 3, 10, 3, 12, 3, 931, 
	9, 3, 1, 4, 1, 4, 3, 4, 935, 8, 4, 1, 5, 1, 5, 1, 5, 3, 5, 940, 8, 5, 3, 
	5, 942, 8, 5, 1, 5, 1, 5, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 
	6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 
	6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 
	6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 
	6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 
	6, 1, 6, 3, 6, 1003, 8, 6, 1, 7, 1, 7, 1, 7, 5, 7, 1008, 8, 7, 10, 7, 12, 
	7, 1011, 9, 7, 1, 7, 3, 7, 1014, 8, 7, 1, 8, 1, 8, 1, 8, 5, 8, 1019, 8, 
	8, 10, 8, 12, 8, 1022, 9, 8, 1, 9, 1, 9, 1, 9, 5, 9, 1027, 8, 9, 10, 9, 
	12, 9, 1030, 9, 9, 1, 10, 1, 10, 3, 10, 1034, 8, 10, 1, 11, 1, 11, 3, 11, 
	1038, 8, 11, 1, 11, 1, 11, 1, 11, 1, 12, 3, 12, 1044, 8, 12, 1, 12, 1, 
	12, 1, 12, 1, 12, 3, 12, 1050, 8, 12, 1, 12, 3, 12, 1053, 8, 12, 1, 12, 
	1, 12, 3, 12, 1057, 8, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 
	12, 1065, 8, 12, 1, 12, 1, 12, 3, 12, 1069, 8, 12, 1, 12, 3, 12, 1072, 
	8, 12, 1, 12, 1, 12, 3, 12, 1076, 8, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 
	12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 1087, 8, 12, 1, 12, 4, 12, 1090, 
	8, 12, 11, 12, 12, 12, 1091, 3, 12, 1094, 8, 12, 1, 13, 1, 13, 1, 14, 1, 
	14, 1, 14, 5, 14, 1101, 8, 14, 10, 14, 12, 14, 1104, 9, 14, 1, 15, 1, 15, 
	1, 15, 1, 16, 1, 16, 1, 16, 1, 16, 1, 17, 1, 17, 1, 17, 1, 18, 1, 18, 1, 
	18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 1124, 8, 18, 1, 18, 5, 18, 
	1127, 8, 18, 10, 18, 12, 18, 1130, 9, 18, 1, 18, 1, 18, 1, 18, 1, 18, 4, 
	18, 1136, 8, 18, 11, 18, 12, 18, 1137, 3, 18, 1140, 8, 18, 1, 19, 1, 19, 
	1, 19, 5, 19, 1145, 8, 19, 10, 19, 12, 19, 1148, 9, 19, 1, 20, 1, 20, 1, 
	20, 5, 20, 1153, 8, 20, 10, 20, 12, 20, 1156, 9, 20, 1, 21, 1, 21, 1, 21, 
	5, 21, 1161, 8, 21, 10, 21, 12, 21, 1164, 9, 21, 1, 22, 1, 22, 1, 22, 1, 
	22, 3, 22, 1170, 8, 22, 1, 23, 1, 23, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 
	1, 24, 3, 24, 1180, 8, 24, 3, 24, 1182, 8, 24, 5, 24, 1184, 8, 24, 10, 
	24, 12, 24, 1187, 9, 24, 1, 24, 1, 24, 3, 24, 1191, 8, 24, 1, 25, 1, 25, 
	3, 25, 1195, 8, 25, 1, 25, 1, 25, 1, 26, 1, 26, 3, 26, 1201, 8, 26, 1, 
	26, 1, 26, 1, 27, 1, 27, 3, 27, 1207, 8, 27, 1, 28, 1, 28, 3, 28, 1211, 
	8, 28, 1, 29, 1, 29, 3, 29, 1215, 8, 29, 1, 29, 3, 29, 1218, 8, 29, 1, 
	29, 1, 29, 1, 30, 1, 30, 1, 30, 3, 30, 1225, 8, 30, 1, 30, 1, 30, 1, 30, 
	1, 30, 3, 30, 1231, 8, 30, 5, 30, 1233, 8, 30, 10, 30, 12, 30, 1236, 9, 
	30, 1, 31, 1, 31, 3, 31, 1240, 8, 31, 1, 31, 3, 31, 1243, 8, 31, 1, 31, 
	1, 31, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 5, 32, 1255, 
	8, 32, 10, 32, 12, 32, 1258, 9, 32, 1, 33, 1, 33, 3, 33, 1262, 8, 33, 1, 
	33, 3, 33, 1265, 8, 33, 1, 33, 1, 33, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 
	1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 3, 34, 1279, 8, 34, 1, 34, 1, 34, 1, 
	34, 1, 34, 1, 34, 3, 34, 1286, 8, 34, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 
	1, 35, 1, 35, 1, 35, 1, 35, 3, 35, 1297, 8, 35, 1, 35, 1, 35, 1, 35, 1, 
	35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 3, 35, 1308, 8, 35, 1, 36, 1, 36, 
	1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 
	37, 1, 37, 1, 38, 1, 38, 1, 38, 1, 38, 3, 38, 1328, 8, 38, 1, 38, 1, 38, 
	1, 39, 1, 39, 3, 39, 1334, 8, 39, 1, 39, 4, 39, 1337, 8, 39, 11, 39, 12, 
	39, 1338, 1, 39, 1, 39, 3, 39, 1343, 8, 39, 1, 39, 1, 39, 1, 40, 1, 40, 
	1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 3, 40, 1357, 8, 
	40, 3, 40, 1359, 8, 40, 1, 41, 1, 41, 1, 42, 1, 42, 1, 42, 3, 42, 1366, 
	8, 42, 1, 43, 1, 43, 1, 44, 1, 44, 3, 44, 1372, 8, 44, 1, 45, 1, 45, 1, 
	45, 1, 45, 1, 46, 1, 46, 1, 46, 5, 46, 1381, 8, 46, 10, 46, 12, 46, 1384, 
	9, 46, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 3, 47, 1391, 8, 47, 1, 48, 1, 
	48, 1, 48, 1, 48, 3, 48, 1397, 8, 48, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 
	3, 49, 1404, 8, 49, 1, 49, 1, 49, 1, 49, 1, 49, 5, 49, 1410, 8, 49, 10, 
	49, 12, 49, 1413, 9, 49, 1, 49, 1, 49, 1, 50, 1, 50, 1, 50, 1, 50, 1, 51, 
	1, 51, 1, 51, 1, 51, 3, 51, 1425, 8, 51, 1, 51, 1, 51, 1, 52, 1, 52, 3, 
	52, 1431, 8, 52, 1, 52, 1, 52, 3, 52, 1435, 8, 52, 1, 52, 3, 52, 1438, 
	8, 52, 3, 52, 1440, 8, 52, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 3, 
	53, 1448, 8, 53, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 1456, 
	8, 54, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 1462, 8, 54, 1, 54, 1, 54, 1, 
	54, 1, 54, 3, 54, 1468, 8, 54, 1, 54, 1, 54, 1, 55, 1, 55, 3, 55, 1474, 
	8, 55, 1, 55, 3, 55, 1477, 8, 55, 1, 55, 1, 55, 1, 56, 1, 56, 1, 56, 5, 
	56, 1484, 8, 56, 10, 56, 12, 56, 1487, 9, 56, 1, 57, 1, 57, 1, 57, 1, 57, 
	5, 57, 1493, 8, 57, 10, 57, 12, 57, 1496, 9, 57, 1, 57, 1, 57, 1, 58, 1, 
	58, 3, 58, 1502, 8, 58, 1, 59, 1, 59, 1, 59, 1, 59, 5, 59, 1508, 8, 59, 
	10, 59, 12, 59, 1511, 9, 59, 1, 59, 1, 59, 1, 60, 1, 60, 1, 60, 1, 61, 
	1, 61, 1, 61, 1, 61, 1, 61, 3, 61, 1523, 8, 61, 1, 62, 1, 62, 1, 62, 5, 
	62, 1528, 8, 62, 10, 62, 12, 62, 1531, 9, 62, 1, 62, 3, 62, 1534, 8, 62, 
	1, 63, 1, 63, 1, 63, 5, 63, 1539, 8, 63, 10, 63, 12, 63, 1542, 9, 63, 1, 
	63, 3, 63, 1545, 8, 63, 1, 64, 1, 64, 1, 64, 3, 64, 1550, 8, 64, 1, 65, 
	1, 65, 1, 65, 5, 65, 1555, 8, 65, 10, 65, 12, 65, 1558, 9, 65, 1, 66, 1, 
	66, 1, 66, 1, 66, 3, 66, 1564, 8, 66, 1, 66, 3, 66, 1567, 8, 66, 1, 66, 
	1, 66, 1, 66, 1, 67, 1, 67, 3, 67, 1574, 8, 67, 1, 67, 1, 67, 3, 67, 1578, 
	8, 67, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 3, 68, 1588, 
	8, 68, 1, 68, 1, 68, 1, 69, 1, 69, 1, 69, 1, 69, 1, 70, 1, 70, 1, 70, 1, 
	70, 1, 70, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 
	1, 71, 3, 71, 1611, 8, 71, 1, 72, 1, 72, 1, 72, 1, 72, 3, 72, 1617, 8, 
	72, 1, 73, 1, 73, 3, 73, 1621, 8, 73, 1, 74, 1, 74, 1, 74, 5, 74, 1626, 
	8, 74, 10, 74, 12, 74, 1629, 9, 74, 1, 75, 1, 75, 1, 75, 3, 75, 1634, 8, 
	75, 1, 76, 1, 76, 1, 76, 5, 76, 1639, 8, 76, 10, 76, 12, 76, 1642, 9, 76, 
	1, 77, 3, 77, 1645, 8, 77, 1, 77, 1, 77, 3, 77, 1649, 8, 77, 1, 78, 1, 
	78, 1, 79, 1, 79, 3, 79, 1655, 8, 79, 1, 80, 1, 80, 1, 80, 3, 80, 1660, 
	8, 80, 1, 81, 1, 81, 1, 81, 1, 81, 1, 82, 1, 82, 1, 82, 3, 82, 1669, 8, 
	82, 1, 82, 3, 82, 1672, 8, 82, 1, 82, 1, 82, 1, 82, 1, 82, 3, 82, 1678, 
	8, 82, 1, 83, 1, 83, 1, 83, 3, 83, 1683, 8, 83, 1, 83, 1, 83, 1, 84, 1, 
	84, 1, 84, 1, 84, 3, 84, 1691, 8, 84, 1, 85, 1, 85, 1, 85, 5, 85, 1696, 
	8, 85, 10, 85, 12, 85, 1699, 9, 85, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 
	1, 86, 1, 86, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 88, 1, 88, 1, 88, 1, 
	88, 1, 88, 5, 88, 1718, 8, 88, 10, 88, 12, 88, 1721, 9, 88, 1, 88, 3, 88, 
	1724, 8, 88, 3, 88, 1726, 8, 88, 1, 88, 1, 88, 3, 88, 1730, 8, 88, 1, 89, 
	1, 89, 1, 89, 1, 89, 1, 89, 5, 89, 1737, 8, 89, 10, 89, 12, 89, 1740, 9, 
	89, 1, 89, 3, 89, 1743, 8, 89, 3, 89, 1745, 8, 89, 1, 89, 1, 89, 3, 89, 
	1749, 8, 89, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 5, 90, 1756, 8, 90, 10, 
	90, 12, 90, 1759, 9, 90, 1, 90, 3, 90, 1762, 8, 90, 1, 90, 1, 90, 1, 91, 
	1, 91, 1, 91, 1, 91, 1, 91, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 93, 1, 
	93, 1, 93, 1, 93, 1, 93, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 
	1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 5, 
	96, 1798, 8, 96, 10, 96, 12, 96, 1801, 9, 96, 1, 96, 3, 96, 1804, 8, 96, 
	1, 96, 1, 96, 1, 97, 1, 97, 1, 97, 1, 97, 1, 97, 1, 98, 1, 98, 1, 98, 1, 
	98, 1, 98, 1, 98, 1, 98, 1, 99, 1, 99, 1, 99, 1, 99, 3, 99, 1824, 8, 99, 
	1, 99, 3, 99, 1827, 8, 99, 1, 99, 1, 99, 1, 99, 1, 99, 3, 99, 1833, 8, 
	99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 100, 1, 100, 1, 100, 1, 100, 
	1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 
	3, 100, 1853, 8, 100, 1, 100, 5, 100, 1856, 8, 100, 10, 100, 12, 100, 1859, 
	9, 100, 1, 101, 1, 101, 1, 101, 3, 101, 1864, 8, 101, 1, 101, 5, 101, 1867, 
	8, 101, 10, 101, 12, 101, 1870, 9, 101, 3, 101, 1872, 8, 101, 1, 102, 1, 
	102, 3, 102, 1876, 8, 102, 1, 103, 1, 103, 1, 104, 1, 104, 1, 104, 1, 104, 
	1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 
	1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 
	1, 104, 3, 104, 1903, 8, 104, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 
	105, 3, 105, 1911, 8, 105, 1, 106, 3, 106, 1914, 8, 106, 1, 106, 1, 106, 
	1, 106, 5, 106, 1919, 8, 106, 10, 106, 12, 106, 1922, 9, 106, 1, 107, 1, 
	107, 1, 107, 1, 107, 1, 107, 1, 108, 1, 108, 1, 108, 1, 109, 1, 109, 3, 
	109, 1934, 8, 109, 1, 109, 1, 109, 3, 109, 1938, 8, 109, 1, 109, 1, 109, 
	1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 111, 1, 111, 1, 111, 3, 111, 
	1950, 8, 111, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 
	112, 1, 112, 5, 112, 1961, 8, 112, 10, 112, 12, 112, 1964, 9, 112, 1, 112, 
	1, 112, 3, 112, 1968, 8, 112, 1, 113, 1, 113, 1, 113, 1, 113, 1, 113, 3, 
	113, 1975, 8, 113, 1, 114, 1, 114, 3, 114, 1979, 8, 114, 1, 115, 1, 115, 
	1, 115, 5, 115, 1984, 8, 115, 10, 115, 12, 115, 1987, 9, 115, 1, 116, 1, 
	116, 1, 116, 1, 116, 5, 116, 1993, 8, 116, 10, 116, 12, 116, 1996, 9, 116, 
	1, 117, 1, 117, 1, 117, 1, 117, 5, 117, 2002, 8, 117, 10, 117, 12, 117, 
	2005, 9, 117, 1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 3, 118, 2012, 8, 
	118, 1, 119, 1, 119, 3, 119, 2016, 8, 119, 1, 119, 1, 119, 3, 119, 2020, 
	8, 119, 1, 120, 1, 120, 1, 120, 1, 120, 1, 120, 3, 120, 2027, 8, 120, 3, 
	120, 2029, 8, 120, 1, 121, 3, 121, 2032, 8, 121, 1, 121, 1, 121, 1, 121, 
	3, 121, 2037, 8, 121, 1, 121, 1, 121, 1, 121, 3, 121, 2042, 8, 121, 1, 
	122, 1, 122, 3, 122, 2046, 8, 122, 1, 122, 1, 122, 1, 122, 5, 122, 2051, 
	8, 122, 10, 122, 12, 122, 2054, 9, 122, 1, 122, 1, 122, 1, 122, 1, 122, 
	3, 122, 2060, 8, 122, 1, 122, 1, 122, 3, 122, 2064, 8, 122, 1, 122, 1, 
	122, 3, 122, 2068, 8, 122, 1, 122, 1, 122, 3, 122, 2072, 8, 122, 1, 122, 
	1, 122, 3, 122, 2076, 8, 122, 3, 122, 2078, 8, 122, 1, 123, 1, 123, 1, 
	123, 1, 123, 1, 124, 1, 124, 1, 124, 5, 124, 2087, 8, 124, 10, 124, 12, 
	124, 2090, 9, 124, 1, 125, 1, 125, 1, 125, 1, 125, 5, 125, 2096, 8, 125, 
	10, 125, 12, 125, 2099, 9, 125, 1, 125, 1, 125, 3, 125, 2103, 8, 125, 1, 
	125, 1, 125, 1, 125, 1, 125, 3, 125, 2109, 8, 125, 1, 125, 1, 125, 1, 125, 
	3, 125, 2114, 8, 125, 1, 125, 1, 125, 3, 125, 2118, 8, 125, 1, 125, 1, 
	125, 3, 125, 2122, 8, 125, 1, 125, 1, 125, 3, 125, 2126, 8, 125, 1, 126, 
	3, 126, 2129, 8, 126, 1, 127, 1, 127, 3, 127, 2133, 8, 127, 1, 127, 1, 
	127, 3, 127, 2137, 8, 127, 1, 127, 1, 127, 1, 127, 1, 127, 5, 127, 2143, 
	8, 127, 10, 127, 12, 127, 2146, 9, 127, 1, 127, 3, 127, 2149, 8, 127, 1, 
	127, 1, 127, 3, 127, 2153, 8, 127, 1, 127, 1, 127, 3, 127, 2157, 8, 127, 
	1, 127, 1, 127, 3, 127, 2161, 8, 127, 1, 127, 3, 127, 2164, 8, 127, 1, 
	127, 1, 127, 3, 127, 2168, 8, 127, 1, 127, 3, 127, 2171, 8, 127, 1, 127, 
	3, 127, 2174, 8, 127, 1, 128, 1, 128, 1, 128, 3, 128, 2179, 8, 128, 1, 
	128, 3, 128, 2182, 8, 128, 1, 128, 3, 128, 2185, 8, 128, 1, 128, 3, 128, 
	2188, 8, 128, 1, 128, 1, 128, 1, 128, 1, 129, 1, 129, 1, 129, 1, 129, 1, 
	129, 1, 129, 1, 129, 1, 129, 1, 129, 3, 129, 2202, 8, 129, 3, 129, 2204, 
	8, 129, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 
	1, 130, 3, 130, 2215, 8, 130, 1, 131, 1, 131, 1, 131, 1, 132, 1, 132, 1, 
	132, 5, 132, 2223, 8, 132, 10, 132, 12, 132, 2226, 9, 132, 1, 133, 1, 133, 
	1, 133, 1, 133, 1, 134, 1, 134, 1, 134, 3, 134, 2235, 8, 134, 1, 134, 3, 
	134, 2238, 8, 134, 1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 3, 134, 2245, 
	8, 134, 1, 134, 1, 134, 1, 134, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 
	1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 
	1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 3, 135, 2269, 8, 135, 1, 136, 1, 
	136, 1, 137, 1, 137, 1, 138, 1, 138, 1, 138, 5, 138, 2278, 8, 138, 10, 
	138, 12, 138, 2281, 9, 138, 1, 139, 4, 139, 2284, 8, 139, 11, 139, 12, 
	139, 2285, 1, 140, 1, 140, 3, 140, 2290, 8, 140, 1, 141, 1, 141, 3, 141, 
	2294, 8, 141, 1, 141, 1, 141, 3, 141, 2298, 8, 141, 1, 141, 1, 141, 3, 
	141, 2302, 8, 141, 1, 141, 1, 141, 3, 141, 2306, 8, 141, 1, 141, 1, 141, 
	3, 141, 2310, 8, 141, 1, 141, 1, 141, 3, 141, 2314, 8, 141, 1, 141, 1, 
	141, 1, 141, 1, 141, 3, 141, 2320, 8, 141, 1, 142, 1, 142, 1, 142, 1, 142, 
	1, 142, 3, 142, 2327, 8, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 
	142, 1, 142, 1, 142, 3, 142, 2337, 8, 142, 1, 143, 1, 143, 1, 144, 1, 144, 
	1, 144, 1, 144, 1, 144, 5, 144, 2346, 8, 144, 10, 144, 12, 144, 2349, 9, 
	144, 1, 144, 1, 144, 1, 145, 1, 145, 1, 145, 1, 146, 1, 146, 1, 146, 5, 
	146, 2359, 8, 146, 10, 146, 12, 146, 2362, 9, 146, 1, 147, 1, 147, 1, 147, 
	1, 147, 1, 147, 1, 147, 1, 148, 1, 148, 1, 149, 1, 149, 1, 149, 5, 149, 
	2375, 8, 149, 10, 149, 12, 149, 2378, 9, 149, 1, 150, 1, 150, 1, 151, 1, 
	151, 1, 151, 5, 151, 2385, 8, 151, 10, 151, 12, 151, 2388, 9, 151, 1, 152, 
	1, 152, 1, 152, 1, 152, 1, 153, 1, 153, 1, 154, 1, 154, 1, 155, 1, 155, 
	1, 156, 1, 156, 1, 157, 1, 157, 1, 157, 1, 157, 1, 158, 3, 158, 2407, 8, 
	158, 1, 158, 1, 158, 1, 159, 1, 159, 3, 159, 2413, 8, 159, 1, 159, 1, 159, 
	1, 159, 1, 159, 1, 159, 3, 159, 2420, 8, 159, 1, 160, 1, 160, 1, 160, 5, 
	160, 2425, 8, 160, 10, 160, 12, 160, 2428, 9, 160, 1, 161, 1, 161, 1, 161, 
	1, 161, 1, 161, 3, 161, 2435, 8, 161, 1, 162, 1, 162, 1, 163, 1, 163, 1, 
	163, 5, 163, 2442, 8, 163, 10, 163, 12, 163, 2445, 9, 163, 1, 164, 1, 164, 
	1, 164, 1, 164, 1, 164, 1, 165, 1, 165, 1, 165, 1, 165, 1, 165, 1, 166, 
	1, 166, 1, 166, 1, 166, 1, 166, 1, 166, 1, 167, 1, 167, 1, 167, 1, 167, 
	1, 167, 1, 167, 1, 167, 1, 167, 1, 167, 1, 167, 1, 167, 1, 168, 1, 168, 
	1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 3, 168, 2481, 8, 168, 3, 168, 2483, 
	8, 168, 1, 169, 3, 169, 2486, 8, 169, 1, 169, 1, 169, 1, 169, 3, 169, 2491, 
	8, 169, 1, 169, 1, 169, 3, 169, 2495, 8, 169, 5, 169, 2497, 8, 169, 10, 
	169, 12, 169, 2500, 9, 169, 1, 170, 1, 170, 1, 170, 3, 170, 2505, 8, 170, 
	1, 171, 1, 171, 1, 171, 1, 171, 3, 171, 2511, 8, 171, 1, 171, 1, 171, 3, 
	171, 2515, 8, 171, 1, 172, 1, 172, 1, 172, 3, 172, 2520, 8, 172, 1, 172, 
	1, 172, 1, 172, 3, 172, 2525, 8, 172, 3, 172, 2527, 8, 172, 1, 173, 1, 
	173, 3, 173, 2531, 8, 173, 1, 173, 1, 173, 1, 173, 3, 173, 2536, 8, 173, 
	1, 173, 3, 173, 2539, 8, 173, 3, 173, 2541, 8, 173, 1, 173, 1, 173, 3, 
	173, 2545, 8, 173, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 
	1, 174, 1, 174, 3, 174, 2556, 8, 174, 1, 175, 1, 175, 1, 175, 1, 176, 1, 
	176, 1, 176, 1, 176, 1, 176, 1, 176, 3, 176, 2567, 8, 176, 1, 177, 1, 177, 
	1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 179, 1, 179, 3, 179, 2578, 8, 
	179, 1, 179, 1, 179, 3, 179, 2582, 8, 179, 1, 179, 1, 179, 3, 179, 2586, 
	8, 179, 1, 179, 1, 179, 3, 179, 2590, 8, 179, 1, 179, 3, 179, 2593, 8, 
	179, 1, 179, 1, 179, 3, 179, 2597, 8, 179, 1, 179, 3, 179, 2600, 8, 179, 
	1, 180, 1, 180, 1, 180, 1, 180, 3, 180, 2606, 8, 180, 1, 181, 1, 181, 1, 
	181, 1, 181, 1, 181, 5, 181, 2613, 8, 181, 10, 181, 12, 181, 2616, 9, 181, 
	3, 181, 2618, 8, 181, 1, 182, 1, 182, 1, 182, 1, 182, 1, 182, 1, 182, 1, 
	182, 1, 182, 1, 182, 1, 182, 1, 182, 1, 182, 3, 182, 2632, 8, 182, 1, 182, 
	1, 182, 1, 182, 1, 182, 3, 182, 2638, 8, 182, 1, 183, 3, 183, 2641, 8, 
	183, 1, 183, 1, 183, 1, 183, 3, 183, 2646, 8, 183, 1, 184, 1, 184, 1, 184, 
	1, 185, 1, 185, 3, 185, 2653, 8, 185, 1, 186, 1, 186, 1, 186, 5, 186, 2658, 
	8, 186, 10, 186, 12, 186, 2661, 9, 186, 1, 187, 1, 187, 1, 187, 1, 187, 
	1, 188, 1, 188, 3, 188, 2669, 8, 188, 1, 189, 1, 189, 1, 189, 3, 189, 2674, 
	8, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 3, 189, 2682, 8, 
	189, 1, 189, 1, 189, 1, 189, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 
	190, 1, 190, 1, 190, 5, 190, 2695, 8, 190, 10, 190, 12, 190, 2698, 9, 190, 
	1, 191, 1, 191, 1, 191, 3, 191, 2703, 8, 191, 1, 192, 1, 192, 1, 192, 1, 
	192, 1, 192, 1, 192, 3, 192, 2711, 8, 192, 1, 192, 1, 192, 1, 193, 1, 193, 
	1, 193, 1, 193, 1, 193, 3, 193, 2720, 8, 193, 1, 193, 1, 193, 3, 193, 2724, 
	8, 193, 1, 193, 1, 193, 1, 193, 1, 194, 1, 194, 1, 194, 1, 194, 3, 194, 
	2733, 8, 194, 1, 194, 1, 194, 1, 195, 1, 195, 1, 195, 1, 195, 1, 195, 1, 
	195, 1, 195, 1, 195, 3, 195, 2745, 8, 195, 1, 196, 1, 196, 1, 196, 1, 196, 
	1, 196, 3, 196, 2752, 8, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 
	196, 3, 196, 2760, 8, 196, 1, 197, 1, 197, 1, 197, 1, 198, 1, 198, 1, 198, 
	1, 198, 1, 198, 1, 198, 1, 198, 1, 198, 1, 198, 1, 199, 1, 199, 1, 199, 
	1, 200, 1, 200, 1, 200, 1, 200, 3, 200, 2781, 8, 200, 1, 200, 1, 200, 1, 
	200, 1, 200, 1, 200, 1, 200, 3, 200, 2789, 8, 200, 1, 201, 1, 201, 1, 201, 
	1, 202, 1, 202, 1, 202, 1, 202, 3, 202, 2798, 8, 202, 1, 203, 1, 203, 1, 
	203, 1, 203, 1, 204, 1, 204, 1, 205, 1, 205, 3, 205, 2808, 8, 205, 1, 206, 
	1, 206, 1, 206, 1, 206, 1, 206, 5, 206, 2815, 8, 206, 10, 206, 12, 206, 
	2818, 9, 206, 1, 206, 1, 206, 3, 206, 2822, 8, 206, 1, 207, 1, 207, 1, 
	208, 1, 208, 1, 208, 3, 208, 2829, 8, 208, 1, 208, 1, 208, 1, 208, 1, 208, 
	1, 208, 1, 208, 1, 208, 1, 208, 3, 208, 2839, 8, 208, 1, 208, 1, 208, 1, 
	208, 3, 208, 2844, 8, 208, 1, 208, 1, 208, 1, 208, 1, 208, 1, 208, 5, 208, 
	2851, 8, 208, 10, 208, 12, 208, 2854, 9, 208, 1, 208, 3, 208, 2857, 8, 
	208, 1, 208, 1, 208, 3, 208, 2861, 8, 208, 1, 208, 3, 208, 2864, 8, 208, 
	1, 208, 3, 208, 2867, 8, 208, 1, 208, 3, 208, 2870, 8, 208, 1, 208, 3, 
	208, 2873, 8, 208, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 3, 209, 
	2881, 8, 209, 1, 210, 1, 210, 1, 210, 3, 210, 2886, 8, 210, 1, 210, 1, 
	210, 1, 210, 1, 210, 1, 210, 1, 211, 1, 211, 1, 211, 1, 211, 3, 211, 2897, 
	8, 211, 1, 212, 1, 212, 1, 212, 1, 213, 1, 213, 3, 213, 2904, 8, 213, 1, 
	214, 1, 214, 1, 214, 1, 214, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 5, 
	215, 2915, 8, 215, 10, 215, 12, 215, 2918, 9, 215, 1, 216, 1, 216, 1, 216, 
	5, 216, 2923, 8, 216, 10, 216, 12, 216, 2926, 9, 216, 1, 217, 1, 217, 3, 
	217, 2930, 8, 217, 1, 218, 1, 218, 1, 218, 5, 218, 2935, 8, 218, 10, 218, 
	12, 218, 2938, 9, 218, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 
	1, 219, 1, 219, 1, 219, 1, 219, 3, 219, 2950, 8, 219, 1, 220, 1, 220, 1, 
	220, 1, 220, 1, 221, 1, 221, 1, 221, 5, 221, 2959, 8, 221, 10, 221, 12, 
	221, 2962, 9, 221, 1, 222, 1, 222, 1, 222, 1, 222, 1, 223, 1, 223, 1, 223, 
	3, 223, 2971, 8, 223, 1, 224, 1, 224, 1, 224, 1, 224, 3, 224, 2977, 8, 
	224, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 5, 225, 2984, 8, 225, 10, 
	225, 12, 225, 2987, 9, 225, 1, 225, 1, 225, 1, 226, 1, 226, 1, 226, 1, 
	226, 1, 226, 1, 227, 1, 227, 1, 227, 1, 227, 1, 227, 5, 227, 3001, 8, 227, 
	10, 227, 12, 227, 3004, 9, 227, 1, 227, 1, 227, 1, 228, 1, 228, 1, 228, 
	1, 229, 1, 229, 1, 229, 1, 229, 1, 230, 1, 230, 1, 230, 1, 231, 1, 231, 
	1, 231, 1, 231, 1, 231, 1, 231, 5, 231, 3024, 8, 231, 10, 231, 12, 231, 
	3027, 9, 231, 1, 232, 1, 232, 1, 232, 1, 232, 1, 232, 1, 232, 1, 232, 1, 
	232, 1, 232, 1, 232, 1, 232, 1, 232, 1, 232, 1, 232, 1, 232, 1, 232, 1, 
	232, 3, 232, 3046, 8, 232, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 
	1, 233, 5, 233, 3055, 8, 233, 10, 233, 12, 233, 3058, 9, 233, 1, 234, 1, 
	234, 1, 234, 1, 234, 1, 234, 3, 234, 3065, 8, 234, 1, 235, 1, 235, 1, 235, 
	1, 235, 1, 235, 1, 235, 5, 235, 3073, 8, 235, 10, 235, 12, 235, 3076, 9, 
	235, 1, 236, 1, 236, 3, 236, 3080, 8, 236, 1, 237, 1, 237, 3, 237, 3084, 
	8, 237, 1, 237, 1, 237, 1, 238, 1, 238, 3, 238, 3090, 8, 238, 1, 238, 1, 
	238, 1, 239, 1, 239, 1, 239, 1, 239, 1, 239, 1, 239, 1, 240, 1, 240, 1, 
	240, 1, 240, 1, 240, 1, 240, 1, 240, 1, 241, 1, 241, 1, 241, 1, 242, 1, 
	242, 1, 242, 1, 242, 1, 242, 1, 242, 1, 242, 1, 243, 1, 243, 1, 243, 1, 
	243, 1, 244, 1, 244, 1, 244, 1, 244, 1, 244, 5, 244, 3126, 8, 244, 10, 
	244, 12, 244, 3129, 9, 244, 1, 244, 1, 244, 1, 245, 1, 245, 1, 245, 1, 
	245, 1, 245, 5, 245, 3138, 8, 245, 10, 245, 12, 245, 3141, 9, 245, 1, 245, 
	1, 245, 1, 246, 1, 246, 1, 246, 1, 247, 1, 247, 1, 247, 1, 247, 1, 248, 
	1, 248, 1, 248, 1, 248, 1, 249, 1, 249, 1, 249, 1, 249, 1, 249, 1, 249, 
	1, 250, 1, 250, 1, 250, 1, 251, 1, 251, 1, 251, 1, 251, 1, 251, 1, 252, 
	1, 252, 1, 252, 1, 252, 1, 253, 1, 253, 1, 253, 1, 253, 1, 253, 1, 254, 
	1, 254, 1, 254, 3, 254, 3182, 8, 254, 1, 254, 1, 254, 1, 255, 1, 255, 1, 
	255, 1, 256, 3, 256, 3190, 8, 256, 1, 256, 3, 256, 3193, 8, 256, 1, 256, 
	1, 256, 3, 256, 3197, 8, 256, 1, 257, 1, 257, 3, 257, 3201, 8, 257, 1, 
	258, 1, 258, 1, 258, 1, 258, 1, 258, 1, 258, 5, 258, 3209, 8, 258, 10, 
	258, 12, 258, 3212, 9, 258, 1, 258, 1, 258, 1, 258, 1, 258, 1, 258, 1, 
	258, 1, 258, 1, 258, 5, 258, 3222, 8, 258, 10, 258, 12, 258, 3225, 9, 258, 
	1, 258, 1, 258, 1, 258, 1, 258, 1, 258, 1, 258, 1, 258, 1, 258, 5, 258, 
	3235, 8, 258, 10, 258, 12, 258, 3238, 9, 258, 1, 258, 1, 258, 3, 258, 3242, 
	8, 258, 1, 259, 1, 259, 1, 259, 1, 259, 1, 259, 1, 259, 1, 259, 1, 259, 
	5, 259, 3252, 8, 259, 10, 259, 12, 259, 3255, 9, 259, 1, 259, 1, 259, 1, 
	259, 1, 259, 1, 259, 1, 259, 5, 259, 3263, 8, 259, 10, 259, 12, 259, 3266, 
	9, 259, 1, 259, 1, 259, 3, 259, 3270, 8, 259, 1, 259, 3, 259, 3273, 8, 
	259, 1, 260, 1, 260, 3, 260, 3277, 8, 260, 1, 260, 1, 260, 3, 260, 3281, 
	8, 260, 1, 261, 1, 261, 3, 261, 3285, 8, 261, 1, 261, 3, 261, 3288, 8, 
	261, 1, 262, 1, 262, 1, 263, 1, 263, 1, 264, 1, 264, 1, 264, 1, 264, 1, 
	264, 5, 264, 3299, 8, 264, 10, 264, 12, 264, 3302, 9, 264, 1, 264, 3, 264, 
	3305, 8, 264, 1, 264, 1, 264, 1, 265, 1, 265, 1, 265, 1, 265, 1, 266, 1, 
	266, 1, 266, 1, 266, 3, 266, 3317, 8, 266, 1, 267, 1, 267, 1, 267, 1, 267, 
	1, 267, 1, 267, 1, 267, 1, 268, 1, 268, 1, 268, 5, 268, 3329, 8, 268, 10, 
	268, 12, 268, 3332, 9, 268, 1, 269, 1, 269, 1, 269, 1, 269, 1, 270, 1, 
	270, 1, 271, 1, 271, 1, 271, 1, 271, 1, 271, 1, 271, 3, 271, 3346, 8, 271, 
	1, 272, 1, 272, 1, 272, 1, 272, 1, 273, 1, 273, 1, 273, 1, 273, 1, 273, 
	1, 273, 1, 273, 1, 273, 1, 273, 3, 273, 3361, 8, 273, 1, 273, 3, 273, 3364, 
	8, 273, 1, 274, 1, 274, 1, 274, 1, 274, 1, 274, 1, 274, 5, 274, 3372, 8, 
	274, 10, 274, 12, 274, 3375, 9, 274, 3, 274, 3377, 8, 274, 1, 275, 1, 275, 
	1, 275, 1, 275, 1, 275, 1, 275, 3, 275, 3385, 8, 275, 1, 276, 1, 276, 1, 
	276, 1, 276, 1, 277, 1, 277, 1, 277, 1, 277, 5, 277, 3395, 8, 277, 10, 
	277, 12, 277, 3398, 9, 277, 3, 277, 3400, 8, 277, 1, 277, 1, 277, 1, 278, 
	1, 278, 1, 278, 1, 278, 1, 279, 1, 279, 3, 279, 3410, 8, 279, 1, 280, 1, 
	280, 1, 280, 1, 280, 5, 280, 3416, 8, 280, 10, 280, 12, 280, 3419, 9, 280, 
	1, 280, 1, 280, 1, 280, 3, 280, 3424, 8, 280, 1, 281, 1, 281, 1, 281, 1, 
	281, 5, 281, 3430, 8, 281, 10, 281, 12, 281, 3433, 9, 281, 1, 281, 1, 281, 
	1, 282, 1, 282, 1, 282, 3, 282, 3440, 8, 282, 1, 283, 1, 283, 1, 283, 1, 
	283, 1, 283, 3, 283, 3447, 8, 283, 1, 283, 1, 283, 3, 283, 3451, 8, 283, 
	1, 283, 1, 283, 1, 284, 1, 284, 1, 284, 1, 284, 5, 284, 3459, 8, 284, 10, 
	284, 12, 284, 3462, 9, 284, 1, 285, 1, 285, 1, 285, 1, 285, 3, 285, 3468, 
	8, 285, 1, 285, 4, 285, 3471, 8, 285, 11, 285, 12, 285, 3472, 1, 285, 1, 
	285, 1, 285, 3, 285, 3478, 8, 285, 1, 286, 1, 286, 1, 286, 1, 286, 1, 286, 
	1, 286, 1, 286, 1, 286, 5, 286, 3488, 8, 286, 10, 286, 12, 286, 3491, 9, 
	286, 1, 286, 3, 286, 3494, 8, 286, 3, 286, 3496, 8, 286, 1, 287, 1, 287, 
	1, 287, 1, 287, 1, 287, 1, 287, 1, 287, 1, 287, 5, 287, 3506, 8, 287, 10, 
	287, 12, 287, 3509, 9, 287, 1, 287, 3, 287, 3512, 8, 287, 1, 287, 1, 287, 
	1, 287, 3, 287, 3517, 8, 287, 1, 288, 1, 288, 1, 288, 1, 288, 3, 288, 3523, 
	8, 288, 1, 288, 1, 288, 1, 288, 5, 288, 3528, 8, 288, 10, 288, 12, 288, 
	3531, 9, 288, 1, 288, 3, 288, 3534, 8, 288, 1, 289, 1, 289, 3, 289, 3538, 
	8, 289, 1, 290, 1, 290, 3, 290, 3542, 8, 290, 1, 291, 3, 291, 3545, 8, 
	291, 1, 291, 1, 291, 1, 291, 1, 292, 1, 292, 1, 293, 1, 293, 1, 293, 1, 
	293, 1, 293, 1, 293, 5, 293, 3558, 8, 293, 10, 293, 12, 293, 3561, 9, 293, 
	1, 293, 1, 293, 1, 293, 1, 293, 5, 293, 3567, 8, 293, 10, 293, 12, 293, 
	3570, 9, 293, 1, 293, 3, 293, 3573, 8, 293, 1, 293, 1, 293, 1, 293, 3, 
	293, 3578, 8, 293, 1, 294, 1, 294, 1, 294, 1, 294, 3, 294, 3584, 8, 294, 
	1, 294, 1, 294, 1, 294, 1, 294, 1, 294, 5, 294, 3591, 8, 294, 10, 294, 
	12, 294, 3594, 9, 294, 1, 294, 1, 294, 1, 294, 1, 294, 5, 294, 3600, 8, 
	294, 10, 294, 12, 294, 3603, 9, 294, 1, 295, 1, 295, 1, 295, 1, 295, 1, 
	295, 1, 295, 1, 295, 1, 295, 1, 295, 1, 295, 1, 295, 1, 295, 1, 295, 1, 
	295, 3, 295, 3619, 8, 295, 1, 295, 1, 295, 3, 295, 3623, 8, 295, 1, 295, 
	1, 295, 3, 295, 3627, 8, 295, 3, 295, 3629, 8, 295, 1, 296, 1, 296, 3, 
	296, 3633, 8, 296, 1, 297, 1, 297, 1, 297, 5, 297, 3638, 8, 297, 10, 297, 
	12, 297, 3641, 9, 297, 1, 297, 3, 297, 3644, 8, 297, 1, 297, 1, 297, 3, 
	297, 3648, 8, 297, 3, 297, 3650, 8, 297, 1, 298, 1, 298, 1, 298, 1, 298, 
	1, 298, 1, 298, 1, 299, 1, 299, 1, 299, 1, 299, 1, 299, 1, 299, 1, 299, 
	5, 299, 3665, 8, 299, 10, 299, 12, 299, 3668, 9, 299, 1, 300, 1, 300, 3, 
	300, 3672, 8, 300, 1, 301, 1, 301, 1, 301, 1, 301, 1, 301, 1, 302, 1, 302, 
	1, 302, 1, 302, 1, 302, 1, 302, 1, 302, 1, 303, 1, 303, 1, 303, 1, 303, 
	1, 303, 1, 303, 1, 303, 1, 303, 5, 303, 3694, 8, 303, 10, 303, 12, 303, 
	3697, 9, 303, 1, 304, 1, 304, 3, 304, 3701, 8, 304, 1, 305, 1, 305, 1, 
	305, 1, 305, 1, 305, 1, 305, 1, 306, 1, 306, 1, 306, 1, 306, 1, 306, 1, 
	306, 1, 306, 1, 306, 5, 306, 3717, 8, 306, 10, 306, 12, 306, 3720, 9, 306, 
	1, 306, 1, 306, 1, 306, 1, 306, 1, 306, 1, 307, 1, 307, 1, 307, 1, 307, 
	1, 308, 1, 308, 1, 308, 5, 308, 3734, 8, 308, 10, 308, 12, 308, 3737, 9, 
	308, 1, 309, 1, 309, 1, 309, 1, 309, 1, 310, 1, 310, 1, 310, 1, 310, 1, 
	310, 1, 310, 1, 310, 5, 310, 3750, 8, 310, 10, 310, 12, 310, 3753, 9, 310, 
	1, 311, 1, 311, 1, 312, 1, 312, 1, 312, 1, 312, 1, 312, 1, 313, 1, 313, 
	1, 313, 1, 313, 1, 313, 3, 313, 3767, 8, 313, 1, 314, 1, 314, 1, 314, 5, 
	314, 3772, 8, 314, 10, 314, 12, 314, 3775, 9, 314, 1, 315, 1, 315, 1, 315, 
	1, 315, 1, 315, 3, 315, 3782, 8, 315, 1, 315, 1, 315, 1, 315, 1, 315, 1, 
	315, 1, 315, 1, 316, 5, 316, 3791, 8, 316, 10, 316, 12, 316, 3794, 9, 316, 
	1, 316, 1, 316, 4, 316, 3798, 8, 316, 11, 316, 12, 316, 3799, 1, 316, 5, 
	316, 3803, 8, 316, 10, 316, 12, 316, 3806, 9, 316, 1, 316, 5, 316, 3809, 
	8, 316, 10, 316, 12, 316, 3812, 9, 316, 3, 316, 3814, 8, 316, 1, 317, 3, 
	317, 3817, 8, 317, 1, 317, 1, 317, 1, 317, 1, 317, 1, 317, 3, 317, 3824, 
	8, 317, 1, 318, 3, 318, 3827, 8, 318, 1, 318, 3, 318, 3830, 8, 318, 1, 
	318, 1, 318, 1, 318, 1, 318, 1, 318, 1, 318, 1, 318, 3, 318, 3839, 8, 318, 
	1, 319, 1, 319, 1, 319, 3, 319, 3844, 8, 319, 1, 319, 3, 319, 3847, 8, 
	319, 1, 319, 1, 319, 1, 319, 1, 319, 1, 319, 1, 319, 5, 319, 3855, 8, 319, 
	10, 319, 12, 319, 3858, 9, 319, 1, 319, 3, 319, 3861, 8, 319, 3, 319, 3863, 
	8, 319, 1, 319, 1, 319, 1, 319, 1, 319, 1, 319, 3, 319, 3870, 8, 319, 1, 
	319, 3, 319, 3873, 8, 319, 1, 319, 1, 319, 3, 319, 3877, 8, 319, 3, 319, 
	3879, 8, 319, 1, 319, 3, 319, 3882, 8, 319, 1, 320, 1, 320, 1, 320, 3, 
	320, 3887, 8, 320, 1, 321, 3, 321, 3890, 8, 321, 1, 321, 1, 321, 1, 321, 
	3, 321, 3895, 8, 321, 1, 322, 1, 322, 1, 322, 1, 322, 1, 322, 1, 322, 5, 
	322, 3903, 8, 322, 10, 322, 12, 322, 3906, 9, 322, 1, 322, 1, 322, 3, 322, 
	3910, 8, 322, 1, 323, 1, 323, 1, 323, 1, 323, 1, 323, 1, 323, 1, 323, 5, 
	323, 3919, 8, 323, 10, 323, 12, 323, 3922, 9, 323, 1, 323, 3, 323, 3925, 
	8, 323, 1, 323, 1, 323, 3, 323, 3929, 8, 323, 3, 323, 3931, 8, 323, 1, 
	323, 1, 323, 3, 323, 3935, 8, 323, 1, 323, 1, 323, 1, 323, 3, 323, 3940, 
	8, 323, 1, 323, 1, 323, 1, 323, 1, 323, 5, 323, 3946, 8, 323, 10, 323, 
	12, 323, 3949, 9, 323, 3, 323, 3951, 8, 323, 1, 323, 3, 323, 3954, 8, 323, 
	1, 323, 3, 323, 3957, 8, 323, 1, 324, 1, 324, 1, 324, 3, 324, 3962, 8, 
	324, 1, 324, 1, 324, 1, 325, 1, 325, 3, 325, 3968, 8, 325, 1, 325, 3, 325, 
	3971, 8, 325, 1, 326, 1, 326, 3, 326, 3975, 8, 326, 1, 327, 1, 327, 1, 
	327, 1, 327, 3, 327, 3981, 8, 327, 1, 328, 1, 328, 1, 328, 1, 328, 1, 328, 
	1, 328, 1, 328, 3, 328, 3990, 8, 328, 1, 328, 3, 328, 3993, 8, 328, 1, 
	329, 1, 329, 1, 329, 1, 329, 1, 329, 1, 329, 3, 329, 4001, 8, 329, 1, 329, 
	1, 329, 3, 329, 4005, 8, 329, 1, 329, 3, 329, 4008, 8, 329, 1, 330, 1, 
	330, 3, 330, 4012, 8, 330, 1, 331, 1, 331, 1, 331, 5, 331, 4017, 8, 331, 
	10, 331, 12, 331, 4020, 9, 331, 1, 332, 1, 332, 1, 332, 1, 332, 1, 333, 
	1, 333, 1, 334, 1, 334, 1, 334, 1, 334, 1, 334, 1, 334, 1, 335, 1, 335, 
	1, 335, 1, 335, 5, 335, 4038, 8, 335, 10, 335, 12, 335, 4041, 9, 335, 1, 
	335, 1, 335, 1, 336, 1, 336, 1, 336, 1, 336, 1, 336, 3, 336, 4050, 8, 336, 
	1, 336, 1, 336, 3, 336, 4054, 8, 336, 1, 336, 3, 336, 4057, 8, 336, 1, 
	337, 1, 337, 1, 337, 1, 337, 5, 337, 4063, 8, 337, 10, 337, 12, 337, 4066, 
	9, 337, 1, 337, 1, 337, 1, 338, 1, 338, 1, 339, 1, 339, 1, 339, 1, 339, 
	1, 339, 1, 340, 1, 340, 1, 340, 1, 340, 3, 340, 4081, 8, 340, 1, 340, 1, 
	340, 1, 340, 1, 340, 5, 340, 4087, 8, 340, 10, 340, 12, 340, 4090, 9, 340, 
	1, 341, 1, 341, 1, 341, 1, 341, 1, 341, 3, 341, 4097, 8, 341, 1, 342, 1, 
	342, 1, 342, 1, 343, 1, 343, 1, 343, 3, 343, 4105, 8, 343, 1, 344, 1, 344, 
	1, 344, 1, 344, 1, 344, 1, 345, 1, 345, 3, 345, 4114, 8, 345, 1, 346, 1, 
	346, 1, 346, 1, 346, 1, 347, 1, 347, 1, 347, 1, 347, 1, 347, 1, 348, 1, 
	348, 1, 348, 1, 348, 1, 348, 5, 348, 4130, 8, 348, 10, 348, 12, 348, 4133, 
	9, 348, 1, 348, 1, 348, 1, 349, 1, 349, 1, 349, 1, 349, 1, 349, 1, 350, 
	1, 350, 1, 350, 1, 350, 1, 350, 5, 350, 4147, 8, 350, 10, 350, 12, 350, 
	4150, 9, 350, 1, 350, 1, 350, 1, 351, 1, 351, 1, 351, 1, 351, 3, 351, 4158, 
	8, 351, 1, 351, 1, 351, 1, 352, 1, 352, 1, 352, 5, 352, 4165, 8, 352, 10, 
	352, 12, 352, 4168, 9, 352, 1, 353, 1, 353, 1, 353, 1, 353, 1, 354, 1, 
	354, 1, 355, 1, 355, 1, 355, 1, 355, 1, 355, 1, 356, 1, 356, 1, 356, 5, 
	356, 4184, 8, 356, 10, 356, 12, 356, 4187, 9, 356, 1, 357, 1, 357, 1, 357, 
	1, 357, 1, 358, 1, 358, 1, 359, 1, 359, 1, 359, 3, 359, 4198, 8, 359, 1, 
	359, 1, 359, 1, 360, 1, 360, 1, 361, 1, 361, 1, 361, 1, 361, 3, 361, 4208, 
	8, 361, 1, 362, 1, 362, 1, 362, 1, 362, 1, 362, 1, 362, 1, 363, 1, 363, 
	3, 363, 4218, 8, 363, 1, 364, 1, 364, 1, 365, 1, 365, 1, 365, 1, 366, 1, 
	366, 1, 366, 5, 366, 4228, 8, 366, 10, 366, 12, 366, 4231, 9, 366, 1, 367, 
	1, 367, 1, 367, 1, 367, 1, 368, 1, 368, 1, 369, 1, 369, 1, 369, 1, 369, 
	1, 370, 3, 370, 4244, 8, 370, 1, 370, 3, 370, 4247, 8, 370, 1, 370, 3, 
	370, 4250, 8, 370, 1, 370, 3, 370, 4253, 8, 370, 1, 371, 1, 371, 1, 372, 
	1, 372, 3, 372, 4259, 8, 372, 1, 372, 1, 372, 1, 372, 1, 373, 1, 373, 1, 
	374, 1, 374, 1, 374, 3, 374, 4269, 8, 374, 1, 375, 1, 375, 1, 376, 1, 376, 
	3, 376, 4275, 8, 376, 1, 377, 1, 377, 1, 377, 1, 377, 1, 377, 1, 378, 1, 
	378, 1, 378, 1, 378, 3, 378, 4286, 8, 378, 1, 378, 3, 378, 4289, 8, 378, 
	1, 379, 1, 379, 1, 379, 1, 379, 1, 379, 1, 379, 1, 379, 1, 379, 1, 379, 
	1, 379, 3, 379, 4301, 8, 379, 1, 380, 1, 380, 1, 380, 1, 381, 1, 381, 1, 
	381, 1, 381, 1, 381, 3, 381, 4311, 8, 381, 1, 382, 1, 382, 1, 382, 1, 382, 
	3, 382, 4317, 8, 382, 1, 383, 1, 383, 1, 384, 1, 384, 1, 385, 1, 385, 1, 
	385, 1, 385, 1, 385, 3, 385, 4328, 8, 385, 1, 386, 1, 386, 1, 386, 5, 386, 
	4333, 8, 386, 10, 386, 12, 386, 4336, 9, 386, 1, 386, 3, 386, 4339, 8, 
	386, 1, 387, 1, 387, 1, 387, 1, 388, 1, 388, 1, 388, 1, 388, 3, 388, 4348, 
	8, 388, 1, 388, 1, 388, 4, 388, 4352, 8, 388, 11, 388, 12, 388, 4353, 1, 
	389, 1, 389, 3, 389, 4358, 8, 389, 1, 389, 1, 389, 1, 389, 3, 389, 4363, 
	8, 389, 1, 389, 1, 389, 1, 389, 1, 389, 3, 389, 4369, 8, 389, 1, 389, 3, 
	389, 4372, 8, 389, 1, 390, 1, 390, 1, 391, 1, 391, 3, 391, 4378, 8, 391, 
	1, 392, 1, 392, 1, 392, 1, 392, 1, 392, 1, 392, 1, 392, 3, 392, 4387, 8, 
	392, 1, 393, 1, 393, 1, 393, 1, 393, 1, 393, 1, 393, 3, 393, 4395, 8, 393, 
	1, 394, 1, 394, 1, 394, 1, 394, 1, 394, 3, 394, 4402, 8, 394, 1, 395, 1, 
	395, 1, 395, 1, 395, 1, 395, 1, 395, 1, 395, 1, 395, 3, 395, 4412, 8, 395, 
	1, 396, 1, 396, 1, 396, 1, 396, 1, 396, 1, 396, 1, 396, 3, 396, 4421, 8, 
	396, 1, 397, 1, 397, 1, 397, 1, 397, 1, 397, 1, 397, 1, 397, 3, 397, 4430, 
	8, 397, 1, 398, 1, 398, 1, 398, 1, 398, 1, 398, 1, 398, 1, 398, 1, 398, 
	3, 398, 4440, 8, 398, 1, 399, 1, 399, 3, 399, 4444, 8, 399, 1, 400, 1, 
	400, 3, 400, 4448, 8, 400, 1, 401, 1, 401, 3, 401, 4452, 8, 401, 1, 402, 
	1, 402, 3, 402, 4456, 8, 402, 1, 403, 1, 403, 3, 403, 4460, 8, 403, 1, 
	404, 1, 404, 3, 404, 4464, 8, 404, 1, 405, 1, 405, 3, 405, 4468, 8, 405, 
	1, 406, 1, 406, 3, 406, 4472, 8, 406, 1, 407, 1, 407, 3, 407, 4476, 8, 
	407, 1, 408, 1, 408, 3, 408, 4480, 8, 408, 1, 409, 1, 409, 3, 409, 4484, 
	8, 409, 1, 410, 1, 410, 3, 410, 4488, 8, 410, 1, 411, 1, 411, 1, 411, 3, 
	411, 4493, 8, 411, 1, 412, 1, 412, 1, 412, 3, 412, 4498, 8, 412, 1, 413, 
	1, 413, 1, 413, 3, 413, 4503, 8, 413, 1, 413, 1, 413, 3, 413, 4507, 8, 
	413, 1, 414, 1, 414, 3, 414, 4511, 8, 414, 1, 415, 1, 415, 1, 415, 3, 415, 
	4516, 8, 415, 1, 416, 3, 416, 4519, 8, 416, 1, 416, 1, 416, 1, 417, 1, 
	417, 3, 417, 4525, 8, 417, 1, 418, 3, 418, 4528, 8, 418, 1, 418, 1, 418, 
	1, 419, 1, 419, 1, 419, 1, 419, 1, 419, 1, 419, 1, 419, 1, 419, 3, 419, 
	4540, 8, 419, 1, 420, 1, 420, 1, 421, 1, 421, 1, 422, 1, 422, 1, 423, 1, 
	423, 1, 424, 1, 424, 1, 425, 1, 425, 1, 426, 1, 426, 1, 427, 1, 427, 1, 
	428, 1, 428, 1, 429, 1, 429, 1, 430, 1, 430, 1, 431, 1, 431, 1, 432, 1, 
	432, 1, 432, 0, 0, 433, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 
	26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 
	62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 
	98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 
	128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 
	158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 
	188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 
	218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 
	248, 250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 
	278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 
	308, 310, 312, 314, 316, 318, 320, 322, 324, 326, 328, 330, 332, 334, 336, 
	338, 340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360, 362, 364, 366, 
	368, 370, 372, 374, 376, 378, 380, 382, 384, 386, 388, 390, 392, 394, 396, 
	398, 400, 402, 404, 406, 408, 410, 412, 414, 416, 418, 420, 422, 424, 426, 
	428, 430, 432, 434, 436, 438, 440, 442, 444, 446, 448, 450, 452, 454, 456, 
	458, 460, 462, 464, 466, 468, 470, 472, 474, 476, 478, 480, 482, 484, 486, 
	488, 490, 492, 494, 496, 498, 500, 502, 504, 506, 508, 510, 512, 514, 516, 
	518, 520, 522, 524, 526, 528, 530, 532, 534, 536, 538, 540, 542, 544, 546, 
	548, 550, 552, 554, 556, 558, 560, 562, 564, 566, 568, 570, 572, 574, 576, 
	578, 580, 582, 584, 586, 588, 590, 592, 594, 596, 598, 600, 602, 604, 606, 
	608, 610, 612, 614, 616, 618, 620, 622, 624, 626, 628, 630, 632, 634, 636, 
	638, 640, 642, 644, 646, 648, 650, 652, 654, 656, 658, 660, 662, 664, 666, 
	668, 670, 672, 674, 676, 678, 680, 682, 684, 686, 688, 690, 692, 694, 696, 
	698, 700, 702, 704, 706, 708, 710, 712, 714, 716, 718, 720, 722, 724, 726, 
	728, 730, 732, 734, 736, 738, 740, 742, 744, 746, 748, 750, 752, 754, 756, 
	758, 760, 762, 764, 766, 768, 770, 772, 774, 776, 778, 780, 782, 784, 786, 
	788, 790, 792, 794, 796, 798, 800, 802, 804, 806, 808, 810, 812, 814, 816, 
	818, 820, 822, 824, 826, 828, 830, 832, 834, 836, 838, 840, 842, 844, 846, 
	848, 850, 852, 854, 856, 858, 860, 862, 864, 0, 40, 2, 0, 52, 52, 282, 
	282, 6, 0, 143, 143, 154, 154, 180, 180, 186, 186, 238, 238, 258, 258, 
	1, 0, 5, 8, 1, 0, 16, 17, 1, 0, 19, 21, 2, 0, 16, 18, 198, 198, 2, 0, 113, 
	113, 119, 119, 4, 0, 119, 119, 131, 131, 298, 298, 305, 305, 2, 0, 79, 
	79, 302, 302, 2, 0, 50, 50, 101, 101, 2, 0, 24, 24, 204, 204, 2, 0, 42, 
	42, 108, 108, 2, 0, 163, 163, 267, 267, 3, 0, 104, 104, 182, 182, 210, 
	210, 2, 0, 63, 63, 284, 284, 2, 0, 208, 208, 269, 269, 2, 0, 53, 53, 283, 
	283, 3, 0, 190, 191, 193, 193, 266, 266, 2, 0, 40, 40, 110, 110, 2, 0, 
	146, 146, 310, 310, 2, 0, 184, 184, 197, 197, 2, 0, 56, 56, 286, 286, 2, 
	0, 118, 118, 307, 307, 3, 0, 43, 43, 102, 102, 241, 241, 3, 0, 56, 56, 
	261, 261, 286, 286, 2, 0, 141, 141, 309, 309, 3, 0, 105, 105, 233, 233, 
	285, 285, 2, 0, 39, 39, 279, 279, 2, 0, 76, 76, 265, 265, 3, 0, 148, 148, 
	235, 235, 262, 262, 2, 0, 137, 137, 227, 227, 1, 0, 325, 326, 20, 0, 52, 
	52, 64, 65, 69, 70, 87, 87, 89, 91, 114, 114, 126, 126, 140, 141, 151, 
	151, 173, 175, 198, 198, 200, 200, 231, 231, 236, 236, 253, 254, 260, 260, 
	268, 268, 282, 282, 301, 301, 317, 318, 3, 0, 47, 47, 118, 118, 277, 277, 
	11, 0, 42, 42, 49, 49, 51, 51, 108, 108, 122, 122, 150, 150, 168, 168, 
	181, 181, 303, 303, 319, 319, 321, 321, 56, 0, 38, 41, 43, 46, 48, 48, 
	50, 50, 53, 57, 59, 63, 66, 66, 68, 68, 71, 73, 77, 77, 79, 85, 88, 88, 
	92, 98, 100, 103, 105, 107, 110, 113, 115, 116, 119, 121, 123, 123, 125, 
	125, 127, 130, 132, 135, 137, 139, 142, 147, 149, 149, 152, 164, 166, 167, 
	169, 170, 177, 177, 179, 180, 183, 193, 195, 197, 201, 205, 207, 209, 211, 
	213, 216, 227, 229, 230, 232, 234, 237, 242, 244, 246, 248, 251, 255, 256, 
	258, 259, 261, 261, 264, 264, 266, 267, 271, 276, 279, 281, 283, 288, 290, 
	297, 300, 300, 302, 302, 304, 310, 312, 313, 316, 316, 322, 323, 49, 0, 
	38, 41, 43, 46, 48, 48, 50, 50, 53, 57, 59, 63, 66, 66, 68, 68, 71, 74, 
	77, 77, 79, 86, 88, 88, 92, 103, 105, 107, 109, 113, 115, 116, 119, 121, 
	123, 125, 127, 130, 132, 135, 137, 139, 142, 147, 149, 149, 152, 167, 169, 
	172, 176, 180, 183, 197, 199, 199, 201, 209, 211, 230, 232, 234, 237, 242, 
	244, 246, 248, 252, 255, 259, 261, 261, 263, 264, 266, 267, 269, 269, 271, 
	276, 279, 281, 283, 288, 290, 297, 300, 300, 302, 302, 304, 313, 315, 316, 
	320, 320, 322, 323, 12, 0, 67, 67, 104, 104, 117, 117, 136, 136, 182, 182, 
	210, 210, 247, 247, 270, 270, 278, 278, 289, 289, 299, 299, 314, 314, 2, 
	0, 131, 131, 298, 298, 1, 0, 327, 328, 4890, 0, 871, 1, 0, 0, 0, 2, 876, 
	1, 0, 0, 0, 4, 902, 1, 0, 0, 0, 6, 910, 1, 0, 0, 0, 8, 934, 1, 0, 0, 0, 
	10, 941, 1, 0, 0, 0, 12, 1002, 1, 0, 0, 0, 14, 1013, 1, 0, 0, 0, 16, 1015, 
	1, 0, 0, 0, 18, 1023, 1, 0, 0, 0, 20, 1031, 1, 0, 0, 0, 22, 1035, 1, 0, 
	0, 0, 24, 1093, 1, 0, 0, 0, 26, 1095, 1, 0, 0, 0, 28, 1097, 1, 0, 0, 0, 
	30, 1105, 1, 0, 0, 0, 32, 1108, 1, 0, 0, 0, 34, 1112, 1, 0, 0, 0, 36, 1115, 
	1, 0, 0, 0, 38, 1141, 1, 0, 0, 0, 40, 1149, 1, 0, 0, 0, 42, 1157, 1, 0, 
	0, 0, 44, 1169, 1, 0, 0, 0, 46, 1171, 1, 0, 0, 0, 48, 1185, 1, 0, 0, 0, 
	50, 1194, 1, 0, 0, 0, 52, 1200, 1, 0, 0, 0, 54, 1206, 1, 0, 0, 0, 56, 1210, 
	1, 0, 0, 0, 58, 1212, 1, 0, 0, 0, 60, 1221, 1, 0, 0, 0, 62, 1237, 1, 0, 
	0, 0, 64, 1246, 1, 0, 0, 0, 66, 1259, 1, 0, 0, 0, 68, 1285, 1, 0, 0, 0, 
	70, 1307, 1, 0, 0, 0, 72, 1309, 1, 0, 0, 0, 74, 1316, 1, 0, 0, 0, 76, 1323, 
	1, 0, 0, 0, 78, 1331, 1, 0, 0, 0, 80, 1346, 1, 0, 0, 0, 82, 1360, 1, 0, 
	0, 0, 84, 1365, 1, 0, 0, 0, 86, 1367, 1, 0, 0, 0, 88, 1371, 1, 0, 0, 0, 
	90, 1373, 1, 0, 0, 0, 92, 1377, 1, 0, 0, 0, 94, 1385, 1, 0, 0, 0, 96, 1396, 
	1, 0, 0, 0, 98, 1398, 1, 0, 0, 0, 100, 1416, 1, 0, 0, 0, 102, 1420, 1, 
	0, 0, 0, 104, 1439, 1, 0, 0, 0, 106, 1447, 1, 0, 0, 0, 108, 1449, 1, 0, 
	0, 0, 110, 1471, 1, 0, 0, 0, 112, 1480, 1, 0, 0, 0, 114, 1488, 1, 0, 0, 
	0, 116, 1501, 1, 0, 0, 0, 118, 1503, 1, 0, 0, 0, 120, 1514, 1, 0, 0, 0, 
	122, 1522, 1, 0, 0, 0, 124, 1524, 1, 0, 0, 0, 126, 1535, 1, 0, 0, 0, 128, 
	1546, 1, 0, 0, 0, 130, 1551, 1, 0, 0, 0, 132, 1559, 1, 0, 0, 0, 134, 1573, 
	1, 0, 0, 0, 136, 1587, 1, 0, 0, 0, 138, 1591, 1, 0, 0, 0, 140, 1595, 1, 
	0, 0, 0, 142, 1610, 1, 0, 0, 0, 144, 1612, 1, 0, 0, 0, 146, 1618, 1, 0, 
	0, 0, 148, 1622, 1, 0, 0, 0, 150, 1630, 1, 0, 0, 0, 152, 1635, 1, 0, 0, 
	0, 154, 1644, 1, 0, 0, 0, 156, 1650, 1, 0, 0, 0, 158, 1654, 1, 0, 0, 0, 
	160, 1659, 1, 0, 0, 0, 162, 1661, 1, 0, 0, 0, 164, 1677, 1, 0, 0, 0, 166, 
	1682, 1, 0, 0, 0, 168, 1686, 1, 0, 0, 0, 170, 1692, 1, 0, 0, 0, 172, 1700, 
	1, 0, 0, 0, 174, 1707, 1, 0, 0, 0, 176, 1712, 1, 0, 0, 0, 178, 1731, 1, 
	0, 0, 0, 180, 1750, 1, 0, 0, 0, 182, 1765, 1, 0, 0, 0, 184, 1770, 1, 0, 
	0, 0, 186, 1775, 1, 0, 0, 0, 188, 1780, 1, 0, 0, 0, 190, 1787, 1, 0, 0, 
	0, 192, 1792, 1, 0, 0, 0, 194, 1807, 1, 0, 0, 0, 196, 1812, 1, 0, 0, 0, 
	198, 1819, 1, 0, 0, 0, 200, 1852, 1, 0, 0, 0, 202, 1871, 1, 0, 0, 0, 204, 
	1875, 1, 0, 0, 0, 206, 1877, 1, 0, 0, 0, 208, 1902, 1, 0, 0, 0, 210, 1904, 
	1, 0, 0, 0, 212, 1913, 1, 0, 0, 0, 214, 1923, 1, 0, 0, 0, 216, 1928, 1, 
	0, 0, 0, 218, 1933, 1, 0, 0, 0, 220, 1941, 1, 0, 0, 0, 222, 1946, 1, 0, 
	0, 0, 224, 1951, 1, 0, 0, 0, 226, 1974, 1, 0, 0, 0, 228, 1976, 1, 0, 0, 
	0, 230, 1980, 1, 0, 0, 0, 232, 1988, 1, 0, 0, 0, 234, 1997, 1, 0, 0, 0, 
	236, 2011, 1, 0, 0, 0, 238, 2019, 1, 0, 0, 0, 240, 2021, 1, 0, 0, 0, 242, 
	2031, 1, 0, 0, 0, 244, 2043, 1, 0, 0, 0, 246, 2079, 1, 0, 0, 0, 248, 2083, 
	1, 0, 0, 0, 250, 2091, 1, 0, 0, 0, 252, 2128, 1, 0, 0, 0, 254, 2132, 1, 
	0, 0, 0, 256, 2175, 1, 0, 0, 0, 258, 2203, 1, 0, 0, 0, 260, 2214, 1, 0, 
	0, 0, 262, 2216, 1, 0, 0, 0, 264, 2219, 1, 0, 0, 0, 266, 2227, 1, 0, 0, 
	0, 268, 2234, 1, 0, 0, 0, 270, 2268, 1, 0, 0, 0, 272, 2270, 1, 0, 0, 0, 
	274, 2272, 1, 0, 0, 0, 276, 2274, 1, 0, 0, 0, 278, 2283, 1, 0, 0, 0, 280, 
	2287, 1, 0, 0, 0, 282, 2319, 1, 0, 0, 0, 284, 2336, 1, 0, 0, 0, 286, 2338, 
	1, 0, 0, 0, 288, 2340, 1, 0, 0, 0, 290, 2352, 1, 0, 0, 0, 292, 2355, 1, 
	0, 0, 0, 294, 2363, 1, 0, 0, 0, 296, 2369, 1, 0, 0, 0, 298, 2371, 1, 0, 
	0, 0, 300, 2379, 1, 0, 0, 0, 302, 2381, 1, 0, 0, 0, 304, 2389, 1, 0, 0, 
	0, 306, 2393, 1, 0, 0, 0, 308, 2395, 1, 0, 0, 0, 310, 2397, 1, 0, 0, 0, 
	312, 2399, 1, 0, 0, 0, 314, 2401, 1, 0, 0, 0, 316, 2406, 1, 0, 0, 0, 318, 
	2410, 1, 0, 0, 0, 320, 2421, 1, 0, 0, 0, 322, 2434, 1, 0, 0, 0, 324, 2436, 
	1, 0, 0, 0, 326, 2438, 1, 0, 0, 0, 328, 2446, 1, 0, 0, 0, 330, 2451, 1, 
	0, 0, 0, 332, 2456, 1, 0, 0, 0, 334, 2462, 1, 0, 0, 0, 336, 2482, 1, 0, 
	0, 0, 338, 2485, 1, 0, 0, 0, 340, 2501, 1, 0, 0, 0, 342, 2514, 1, 0, 0, 
	0, 344, 2516, 1, 0, 0, 0, 346, 2528, 1, 0, 0, 0, 348, 2555, 1, 0, 0, 0, 
	350, 2557, 1, 0, 0, 0, 352, 2560, 1, 0, 0, 0, 354, 2568, 1, 0, 0, 0, 356, 
	2570, 1, 0, 0, 0, 358, 2599, 1, 0, 0, 0, 360, 2605, 1, 0, 0, 0, 362, 2607, 
	1, 0, 0, 0, 364, 2631, 1, 0, 0, 0, 366, 2645, 1, 0, 0, 0, 368, 2647, 1, 
	0, 0, 0, 370, 2652, 1, 0, 0, 0, 372, 2654, 1, 0, 0, 0, 374, 2662, 1, 0, 
	0, 0, 376, 2668, 1, 0, 0, 0, 378, 2670, 1, 0, 0, 0, 380, 2686, 1, 0, 0, 
	0, 382, 2702, 1, 0, 0, 0, 384, 2704, 1, 0, 0, 0, 386, 2714, 1, 0, 0, 0, 
	388, 2728, 1, 0, 0, 0, 390, 2736, 1, 0, 0, 0, 392, 2746, 1, 0, 0, 0, 394, 
	2761, 1, 0, 0, 0, 396, 2764, 1, 0, 0, 0, 398, 2773, 1, 0, 0, 0, 400, 2776, 
	1, 0, 0, 0, 402, 2790, 1, 0, 0, 0, 404, 2797, 1, 0, 0, 0, 406, 2799, 1, 
	0, 0, 0, 408, 2803, 1, 0, 0, 0, 410, 2807, 1, 0, 0, 0, 412, 2821, 1, 0, 
	0, 0, 414, 2823, 1, 0, 0, 0, 416, 2825, 1, 0, 0, 0, 418, 2880, 1, 0, 0, 
	0, 420, 2882, 1, 0, 0, 0, 422, 2892, 1, 0, 0, 0, 424, 2898, 1, 0, 0, 0, 
	426, 2903, 1, 0, 0, 0, 428, 2905, 1, 0, 0, 0, 430, 2909, 1, 0, 0, 0, 432, 
	2919, 1, 0, 0, 0, 434, 2929, 1, 0, 0, 0, 436, 2931, 1, 0, 0, 0, 438, 2949, 
	1, 0, 0, 0, 440, 2951, 1, 0, 0, 0, 442, 2955, 1, 0, 0, 0, 444, 2963, 1, 
	0, 0, 0, 446, 2967, 1, 0, 0, 0, 448, 2972, 1, 0, 0, 0, 450, 2978, 1, 0, 
	0, 0, 452, 2990, 1, 0, 0, 0, 454, 2995, 1, 0, 0, 0, 456, 3007, 1, 0, 0, 
	0, 458, 3010, 1, 0, 0, 0, 460, 3014, 1, 0, 0, 0, 462, 3017, 1, 0, 0, 0, 
	464, 3045, 1, 0, 0, 0, 466, 3047, 1, 0, 0, 0, 468, 3064, 1, 0, 0, 0, 470, 
	3066, 1, 0, 0, 0, 472, 3079, 1, 0, 0, 0, 474, 3081, 1, 0, 0, 0, 476, 3087, 
	1, 0, 0, 0, 478, 3093, 1, 0, 0, 0, 480, 3099, 1, 0, 0, 0, 482, 3106, 1, 
	0, 0, 0, 484, 3109, 1, 0, 0, 0, 486, 3116, 1, 0, 0, 0, 488, 3120, 1, 0, 
	0, 0, 490, 3132, 1, 0, 0, 0, 492, 3144, 1, 0, 0, 0, 494, 3147, 1, 0, 0, 
	0, 496, 3151, 1, 0, 0, 0, 498, 3155, 1, 0, 0, 0, 500, 3161, 1, 0, 0, 0, 
	502, 3164, 1, 0, 0, 0, 504, 3169, 1, 0, 0, 0, 506, 3173, 1, 0, 0, 0, 508, 
	3178, 1, 0, 0, 0, 510, 3185, 1, 0, 0, 0, 512, 3192, 1, 0, 0, 0, 514, 3198, 
	1, 0, 0, 0, 516, 3241, 1, 0, 0, 0, 518, 3243, 1, 0, 0, 0, 520, 3276, 1, 
	0, 0, 0, 522, 3282, 1, 0, 0, 0, 524, 3289, 1, 0, 0, 0, 526, 3291, 1, 0, 
	0, 0, 528, 3293, 1, 0, 0, 0, 530, 3308, 1, 0, 0, 0, 532, 3316, 1, 0, 0, 
	0, 534, 3318, 1, 0, 0, 0, 536, 3325, 1, 0, 0, 0, 538, 3333, 1, 0, 0, 0, 
	540, 3337, 1, 0, 0, 0, 542, 3345, 1, 0, 0, 0, 544, 3347, 1, 0, 0, 0, 546, 
	3363, 1, 0, 0, 0, 548, 3365, 1, 0, 0, 0, 550, 3384, 1, 0, 0, 0, 552, 3386, 
	1, 0, 0, 0, 554, 3390, 1, 0, 0, 0, 556, 3403, 1, 0, 0, 0, 558, 3409, 1, 
	0, 0, 0, 560, 3423, 1, 0, 0, 0, 562, 3425, 1, 0, 0, 0, 564, 3439, 1, 0, 
	0, 0, 566, 3441, 1, 0, 0, 0, 568, 3454, 1, 0, 0, 0, 570, 3463, 1, 0, 0, 
	0, 572, 3479, 1, 0, 0, 0, 574, 3497, 1, 0, 0, 0, 576, 3518, 1, 0, 0, 0, 
	578, 3537, 1, 0, 0, 0, 580, 3541, 1, 0, 0, 0, 582, 3544, 1, 0, 0, 0, 584, 
	3549, 1, 0, 0, 0, 586, 3551, 1, 0, 0, 0, 588, 3579, 1, 0, 0, 0, 590, 3628, 
	1, 0, 0, 0, 592, 3632, 1, 0, 0, 0, 594, 3649, 1, 0, 0, 0, 596, 3651, 1, 
	0, 0, 0, 598, 3657, 1, 0, 0, 0, 600, 3671, 1, 0, 0, 0, 602, 3673, 1, 0, 
	0, 0, 604, 3678, 1, 0, 0, 0, 606, 3685, 1, 0, 0, 0, 608, 3700, 1, 0, 0, 
	0, 610, 3702, 1, 0, 0, 0, 612, 3708, 1, 0, 0, 0, 614, 3726, 1, 0, 0, 0, 
	616, 3730, 1, 0, 0, 0, 618, 3738, 1, 0, 0, 0, 620, 3742, 1, 0, 0, 0, 622, 
	3754, 1, 0, 0, 0, 624, 3756, 1, 0, 0, 0, 626, 3761, 1, 0, 0, 0, 628, 3768, 
	1, 0, 0, 0, 630, 3776, 1, 0, 0, 0, 632, 3792, 1, 0, 0, 0, 634, 3816, 1, 
	0, 0, 0, 636, 3826, 1, 0, 0, 0, 638, 3843, 1, 0, 0, 0, 640, 3883, 1, 0, 
	0, 0, 642, 3889, 1, 0, 0, 0, 644, 3896, 1, 0, 0, 0, 646, 3956, 1, 0, 0, 
	0, 648, 3961, 1, 0, 0, 0, 650, 3970, 1, 0, 0, 0, 652, 3972, 1, 0, 0, 0, 
	654, 3976, 1, 0, 0, 0, 656, 3982, 1, 0, 0, 0, 658, 3994, 1, 0, 0, 0, 660, 
	4011, 1, 0, 0, 0, 662, 4013, 1, 0, 0, 0, 664, 4021, 1, 0, 0, 0, 666, 4025, 
	1, 0, 0, 0, 668, 4027, 1, 0, 0, 0, 670, 4033, 1, 0, 0, 0, 672, 4044, 1, 
	0, 0, 0, 674, 4058, 1, 0, 0, 0, 676, 4069, 1, 0, 0, 0, 678, 4071, 1, 0, 
	0, 0, 680, 4076, 1, 0, 0, 0, 682, 4096, 1, 0, 0, 0, 684, 4098, 1, 0, 0, 
	0, 686, 4101, 1, 0, 0, 0, 688, 4106, 1, 0, 0, 0, 690, 4113, 1, 0, 0, 0, 
	692, 4115, 1, 0, 0, 0, 694, 4119, 1, 0, 0, 0, 696, 4124, 1, 0, 0, 0, 698, 
	4136, 1, 0, 0, 0, 700, 4141, 1, 0, 0, 0, 702, 4153, 1, 0, 0, 0, 704, 4161, 
	1, 0, 0, 0, 706, 4169, 1, 0, 0, 0, 708, 4173, 1, 0, 0, 0, 710, 4175, 1, 
	0, 0, 0, 712, 4180, 1, 0, 0, 0, 714, 4188, 1, 0, 0, 0, 716, 4192, 1, 0, 
	0, 0, 718, 4197, 1, 0, 0, 0, 720, 4201, 1, 0, 0, 0, 722, 4207, 1, 0, 0, 
	0, 724, 4209, 1, 0, 0, 0, 726, 4217, 1, 0, 0, 0, 728, 4219, 1, 0, 0, 0, 
	730, 4221, 1, 0, 0, 0, 732, 4224, 1, 0, 0, 0, 734, 4232, 1, 0, 0, 0, 736, 
	4236, 1, 0, 0, 0, 738, 4238, 1, 0, 0, 0, 740, 4243, 1, 0, 0, 0, 742, 4254, 
	1, 0, 0, 0, 744, 4256, 1, 0, 0, 0, 746, 4263, 1, 0, 0, 0, 748, 4265, 1, 
	0, 0, 0, 750, 4270, 1, 0, 0, 0, 752, 4274, 1, 0, 0, 0, 754, 4276, 1, 0, 
	0, 0, 756, 4288, 1, 0, 0, 0, 758, 4300, 1, 0, 0, 0, 760, 4302, 1, 0, 0, 
	0, 762, 4310, 1, 0, 0, 0, 764, 4312, 1, 0, 0, 0, 766, 4318, 1, 0, 0, 0, 
	768, 4320, 1, 0, 0, 0, 770, 4322, 1, 0, 0, 0, 772, 4329, 1, 0, 0, 0, 774, 
	4340, 1, 0, 0, 0, 776, 4343, 1, 0, 0, 0, 778, 4371, 1, 0, 0, 0, 780, 4373, 
	1, 0, 0, 0, 782, 4377, 1, 0, 0, 0, 784, 4386, 1, 0, 0, 0, 786, 4394, 1, 
	0, 0, 0, 788, 4401, 1, 0, 0, 0, 790, 4411, 1, 0, 0, 0, 792, 4420, 1, 0, 
	0, 0, 794, 4429, 1, 0, 0, 0, 796, 4439, 1, 0, 0, 0, 798, 4443, 1, 0, 0, 
	0, 800, 4447, 1, 0, 0, 0, 802, 4451, 1, 0, 0, 0, 804, 4455, 1, 0, 0, 0, 
	806, 4459, 1, 0, 0, 0, 808, 4463, 1, 0, 0, 0, 810, 4467, 1, 0, 0, 0, 812, 
	4471, 1, 0, 0, 0, 814, 4475, 1, 0, 0, 0, 816, 4479, 1, 0, 0, 0, 818, 4483, 
	1, 0, 0, 0, 820, 4487, 1, 0, 0, 0, 822, 4492, 1, 0, 0, 0, 824, 4497, 1, 
	0, 0, 0, 826, 4502, 1, 0, 0, 0, 828, 4510, 1, 0, 0, 0, 830, 4515, 1, 0, 
	0, 0, 832, 4518, 1, 0, 0, 0, 834, 4524, 1, 0, 0, 0, 836, 4527, 1, 0, 0, 
	0, 838, 4539, 1, 0, 0, 0, 840, 4541, 1, 0, 0, 0, 842, 4543, 1, 0, 0, 0, 
	844, 4545, 1, 0, 0, 0, 846, 4547, 1, 0, 0, 0, 848, 4549, 1, 0, 0, 0, 850, 
	4551, 1, 0, 0, 0, 852, 4553, 1, 0, 0, 0, 854, 4555, 1, 0, 0, 0, 856, 4557, 
	1, 0, 0, 0, 858, 4559, 1, 0, 0, 0, 860, 4561, 1, 0, 0, 0, 862, 4563, 1, 
	0, 0, 0, 864, 4565, 1, 0, 0, 0, 866, 872, 3, 2, 1, 0, 867, 868, 5, 226, 
	0, 0, 868, 869, 5, 46, 0, 0, 869, 870, 5, 327, 0, 0, 870, 872, 3, 4, 2, 
	0, 871, 866, 1, 0, 0, 0, 871, 867, 1, 0, 0, 0, 872, 1, 1, 0, 0, 0, 873, 
	875, 5, 22, 0, 0, 874, 873, 1, 0, 0, 0, 875, 878, 1, 0, 0, 0, 876, 874, 
	1, 0, 0, 0, 876, 877, 1, 0, 0, 0, 877, 879, 1, 0, 0, 0, 878, 876, 1, 0, 
	0, 0, 879, 888, 3, 10, 5, 0, 880, 882, 5, 22, 0, 0, 881, 880, 1, 0, 0, 
	0, 882, 883, 1, 0, 0, 0, 883, 881, 1, 0, 0, 0, 883, 884, 1, 0, 0, 0, 884, 
	885, 1, 0, 0, 0, 885, 887, 3, 10, 5, 0, 886, 881, 1, 0, 0, 0, 887, 890, 
	1, 0, 0, 0, 888, 886, 1, 0, 0, 0, 888, 889, 1, 0, 0, 0, 889, 894, 1, 0, 
	0, 0, 890, 888, 1, 0, 0, 0, 891, 893, 5, 22, 0, 0, 892, 891, 1, 0, 0, 0, 
	893, 896, 1, 0, 0, 0, 894, 892, 1, 0, 0, 0, 894, 895, 1, 0, 0, 0, 895, 
	897, 1, 0, 0, 0, 896, 894, 1, 0, 0, 0, 897, 898, 5, 0, 0, 1, 898, 3, 1, 
	0, 0, 0, 899, 901, 5, 22, 0, 0, 900, 899, 1, 0, 0, 0, 901, 904, 1, 0, 0, 
	0, 902, 900, 1, 0, 0, 0, 902, 903, 1, 0, 0, 0, 903, 905, 1, 0, 0, 0, 904, 
	902, 1, 0, 0, 0, 905, 906, 5, 0, 0, 1, 906, 5, 1, 0, 0, 0, 907, 909, 5, 
	22, 0, 0, 908, 907, 1, 0, 0, 0, 909, 912, 1, 0, 0, 0, 910, 908, 1, 0, 0, 
	0, 910, 911, 1, 0, 0, 0, 911, 921, 1, 0, 0, 0, 912, 910, 1, 0, 0, 0, 913, 
	915, 3, 8, 4, 0, 914, 916, 5, 22, 0, 0, 915, 914, 1, 0, 0, 0, 916, 917, 
	1, 0, 0, 0, 917, 915, 1, 0, 0, 0, 917, 918, 1, 0, 0, 0, 918, 920, 1, 0, 
	0, 0, 919, 913, 1, 0, 0, 0, 920, 923, 1, 0, 0, 0, 921, 919, 1, 0, 0, 0, 
	921, 922, 1, 0, 0, 0, 922, 924, 1, 0, 0, 0, 923, 921, 1, 0, 0, 0, 924, 
	925, 5, 253, 0, 0, 925, 929, 3, 14, 7, 0, 926, 928, 5, 22, 0, 0, 927, 926, 
	1, 0, 0, 0, 928, 931, 1, 0, 0, 0, 929, 927, 1, 0, 0, 0, 929, 930, 1, 0, 
	0, 0, 930, 7, 1, 0, 0, 0, 931, 929, 1, 0, 0, 0, 932, 935, 3, 764, 382, 
	0, 933, 935, 3, 214, 107, 0, 934, 932, 1, 0, 0, 0, 934, 933, 1, 0, 0, 0, 
	935, 9, 1, 0, 0, 0, 936, 939, 5, 127, 0, 0, 937, 938, 5, 232, 0, 0, 938, 
	940, 5, 224, 0, 0, 939, 937, 1, 0, 0, 0, 939, 940, 1, 0, 0, 0, 940, 942, 
	1, 0, 0, 0, 941, 936, 1, 0, 0, 0, 941, 942, 1, 0, 0, 0, 942, 943, 1, 0, 
	0, 0, 943, 944, 3, 12, 6, 0, 944, 11, 1, 0, 0, 0, 945, 1003, 3, 224, 112, 
	0, 946, 1003, 3, 232, 116, 0, 947, 1003, 3, 764, 382, 0, 948, 1003, 3, 
	416, 208, 0, 949, 1003, 3, 566, 283, 0, 950, 1003, 3, 760, 380, 0, 951, 
	1003, 3, 364, 182, 0, 952, 1003, 3, 766, 383, 0, 953, 1003, 3, 658, 329, 
	0, 954, 1003, 3, 656, 328, 0, 955, 1003, 3, 768, 384, 0, 956, 1003, 3, 
	210, 105, 0, 957, 1003, 3, 214, 107, 0, 958, 1003, 3, 216, 108, 0, 959, 
	1003, 3, 462, 231, 0, 960, 1003, 3, 466, 233, 0, 961, 1003, 3, 222, 111, 
	0, 962, 1003, 3, 630, 315, 0, 963, 1003, 3, 634, 317, 0, 964, 1003, 3, 
	636, 318, 0, 965, 1003, 3, 368, 184, 0, 966, 1003, 3, 568, 284, 0, 967, 
	1003, 3, 570, 285, 0, 968, 1003, 3, 572, 286, 0, 969, 1003, 3, 574, 287, 
	0, 970, 1003, 3, 576, 288, 0, 971, 1003, 3, 392, 196, 0, 972, 1003, 3, 
	396, 198, 0, 973, 1003, 3, 400, 200, 0, 974, 1003, 3, 378, 189, 0, 975, 
	1003, 3, 380, 190, 0, 976, 1003, 3, 384, 192, 0, 977, 1003, 3, 612, 306, 
	0, 978, 1003, 3, 626, 313, 0, 979, 1003, 3, 672, 336, 0, 980, 1003, 3, 
	680, 340, 0, 981, 1003, 3, 702, 351, 0, 982, 1003, 3, 586, 293, 0, 983, 
	1003, 3, 588, 294, 0, 984, 1003, 3, 470, 235, 0, 985, 1003, 3, 390, 195, 
	0, 986, 1003, 3, 386, 193, 0, 987, 1003, 3, 388, 194, 0, 988, 1003, 3, 
	620, 310, 0, 989, 1003, 3, 596, 298, 0, 990, 1003, 3, 598, 299, 0, 991, 
	1003, 3, 602, 301, 0, 992, 1003, 3, 420, 210, 0, 993, 1003, 3, 422, 211, 
	0, 994, 1003, 3, 424, 212, 0, 995, 1003, 3, 774, 387, 0, 996, 1003, 3, 
	604, 302, 0, 997, 1003, 3, 606, 303, 0, 998, 1003, 3, 610, 305, 0, 999, 
	1003, 3, 446, 223, 0, 1000, 1003, 3, 448, 224, 0, 1001, 1003, 3, 776, 388, 
	0, 1002, 945, 1, 0, 0, 0, 1002, 946, 1, 0, 0, 0, 1002, 947, 1, 0, 0, 0, 
	1002, 948, 1, 0, 0, 0, 1002, 949, 1, 0, 0, 0, 1002, 950, 1, 0, 0, 0, 1002, 
	951, 1, 0, 0, 0, 1002, 952, 1, 0, 0, 0, 1002, 953, 1, 0, 0, 0, 1002, 954, 
	1, 0, 0, 0, 1002, 955, 1, 0, 0, 0, 1002, 956, 1, 0, 0, 0, 1002, 957, 1, 
	0, 0, 0, 1002, 958, 1, 0, 0, 0, 1002, 959, 1, 0, 0, 0, 1002, 960, 1, 0, 
	0, 0, 1002, 961, 1, 0, 0, 0, 1002, 962, 1, 0, 0, 0, 1002, 963, 1, 0, 0, 
	0, 1002, 964, 1, 0, 0, 0, 1002, 965, 1, 0, 0, 0, 1002, 966, 1, 0, 0, 0, 
	1002, 967, 1, 0, 0, 0, 1002, 968, 1, 0, 0, 0, 1002, 969, 1, 0, 0, 0, 1002, 
	970, 1, 0, 0, 0, 1002, 971, 1, 0, 0, 0, 1002, 972, 1, 0, 0, 0, 1002, 973, 
	1, 0, 0, 0, 1002, 974, 1, 0, 0, 0, 1002, 975, 1, 0, 0, 0, 1002, 976, 1, 
	0, 0, 0, 1002, 977, 1, 0, 0, 0, 1002, 978, 1, 0, 0, 0, 1002, 979, 1, 0, 
	0, 0, 1002, 980, 1, 0, 0, 0, 1002, 981, 1, 0, 0, 0, 1002, 982, 1, 0, 0, 
	0, 1002, 983, 1, 0, 0, 0, 1002, 984, 1, 0, 0, 0, 1002, 985, 1, 0, 0, 0, 
	1002, 986, 1, 0, 0, 0, 1002, 987, 1, 0, 0, 0, 1002, 988, 1, 0, 0, 0, 1002, 
	989, 1, 0, 0, 0, 1002, 990, 1, 0, 0, 0, 1002, 991, 1, 0, 0, 0, 1002, 992, 
	1, 0, 0, 0, 1002, 993, 1, 0, 0, 0, 1002, 994, 1, 0, 0, 0, 1002, 995, 1, 
	0, 0, 0, 1002, 996, 1, 0, 0, 0, 1002, 997, 1, 0, 0, 0, 1002, 998, 1, 0, 
	0, 0, 1002, 999, 1, 0, 0, 0, 1002, 1000, 1, 0, 0, 0, 1002, 1001, 1, 0, 
	0, 0, 1003, 13, 1, 0, 0, 0, 1004, 1009, 3, 16, 8, 0, 1005, 1006, 5, 211, 
	0, 0, 1006, 1008, 3, 16, 8, 0, 1007, 1005, 1, 0, 0, 0, 1008, 1011, 1, 0, 
	0, 0, 1009, 1007, 1, 0, 0, 0, 1009, 1010, 1, 0, 0, 0, 1010, 1014, 1, 0, 
	0, 0, 1011, 1009, 1, 0, 0, 0, 1012, 1014, 3, 200, 100, 0, 1013, 1004, 1, 
	0, 0, 0, 1013, 1012, 1, 0, 0, 0, 1014, 15, 1, 0, 0, 0, 1015, 1020, 3, 18, 
	9, 0, 1016, 1017, 5, 45, 0, 0, 1017, 1019, 3, 18, 9, 0, 1018, 1016, 1, 
	0, 0, 0, 1019, 1022, 1, 0, 0, 0, 1020, 1018, 1, 0, 0, 0, 1020, 1021, 1, 
	0, 0, 0, 1021, 17, 1, 0, 0, 0, 1022, 1020, 1, 0, 0, 0, 1023, 1028, 3, 20, 
	10, 0, 1024, 1025, 5, 323, 0, 0, 1025, 1027, 3, 20, 10, 0, 1026, 1024, 
	1, 0, 0, 0, 1027, 1030, 1, 0, 0, 0, 1028, 1026, 1, 0, 0, 0, 1028, 1029, 
	1, 0, 0, 0, 1029, 19, 1, 0, 0, 0, 1030, 1028, 1, 0, 0, 0, 1031, 1033, 3, 
	28, 14, 0, 1032, 1034, 3, 24, 12, 0, 1033, 1032, 1, 0, 0, 0, 1033, 1034, 
	1, 0, 0, 0, 1034, 21, 1, 0, 0, 0, 1035, 1037, 5, 170, 0, 0, 1036, 1038, 
	5, 198, 0, 0, 1037, 1036, 1, 0, 0, 0, 1037, 1038, 1, 0, 0, 0, 1038, 1039, 
	1, 0, 0, 0, 1039, 1040, 5, 108, 0, 0, 1040, 1041, 5, 140, 0, 0, 1041, 23, 
	1, 0, 0, 0, 1042, 1044, 5, 198, 0, 0, 1043, 1042, 1, 0, 0, 0, 1043, 1044, 
	1, 0, 0, 0, 1044, 1045, 1, 0, 0, 0, 1045, 1046, 3, 26, 13, 0, 1046, 1049, 
	3, 28, 14, 0, 1047, 1048, 5, 120, 0, 0, 1048, 1050, 3, 28, 14, 0, 1049, 
	1047, 1, 0, 0, 0, 1049, 1050, 1, 0, 0, 0, 1050, 1094, 1, 0, 0, 0, 1051, 
	1053, 5, 198, 0, 0, 1052, 1051, 1, 0, 0, 0, 1052, 1053, 1, 0, 0, 0, 1053, 
	1054, 1, 0, 0, 0, 1054, 1056, 5, 157, 0, 0, 1055, 1057, 5, 78, 0, 0, 1056, 
	1055, 1, 0, 0, 0, 1056, 1057, 1, 0, 0, 0, 1057, 1058, 1, 0, 0, 0, 1058, 
	1094, 3, 82, 41, 0, 1059, 1069, 5, 171, 0, 0, 1060, 1069, 5, 199, 0, 0, 
	1061, 1062, 5, 170, 0, 0, 1062, 1069, 5, 200, 0, 0, 1063, 1065, 5, 170, 
	0, 0, 1064, 1063, 1, 0, 0, 0, 1064, 1065, 1, 0, 0, 0, 1065, 1066, 1, 0, 
	0, 0, 1066, 1067, 5, 198, 0, 0, 1067, 1069, 5, 200, 0, 0, 1068, 1059, 1, 
	0, 0, 0, 1068, 1060, 1, 0, 0, 0, 1068, 1061, 1, 0, 0, 0, 1068, 1064, 1, 
	0, 0, 0, 1069, 1094, 1, 0, 0, 0, 1070, 1072, 5, 198, 0, 0, 1071, 1070, 
	1, 0, 0, 0, 1071, 1072, 1, 0, 0, 0, 1072, 1073, 1, 0, 0, 0, 1073, 1075, 
	5, 64, 0, 0, 1074, 1076, 7, 0, 0, 0, 1075, 1074, 1, 0, 0, 0, 1075, 1076, 
	1, 0, 0, 0, 1076, 1077, 1, 0, 0, 0, 1077, 1078, 3, 28, 14, 0, 1078, 1079, 
	5, 45, 0, 0, 1079, 1080, 3, 28, 14, 0, 1080, 1094, 1, 0, 0, 0, 1081, 1087, 
	5, 1, 0, 0, 1082, 1087, 5, 2, 0, 0, 1083, 1087, 5, 3, 0, 0, 1084, 1087, 
	5, 4, 0, 0, 1085, 1087, 3, 22, 11, 0, 1086, 1081, 1, 0, 0, 0, 1086, 1082, 
	1, 0, 0, 0, 1086, 1083, 1, 0, 0, 0, 1086, 1084, 1, 0, 0, 0, 1086, 1085, 
	1, 0, 0, 0, 1087, 1088, 1, 0, 0, 0, 1088, 1090, 3, 28, 14, 0, 1089, 1086, 
	1, 0, 0, 0, 1090, 1091, 1, 0, 0, 0, 1091, 1089, 1, 0, 0, 0, 1091, 1092, 
	1, 0, 0, 0, 1092, 1094, 1, 0, 0, 0, 1093, 1043, 1, 0, 0, 0, 1093, 1052, 
	1, 0, 0, 0, 1093, 1068, 1, 0, 0, 0, 1093, 1071, 1, 0, 0, 0, 1093, 1089, 
	1, 0, 0, 0, 1094, 25, 1, 0, 0, 0, 1095, 1096, 7, 1, 0, 0, 1096, 27, 1, 
	0, 0, 0, 1097, 1102, 3, 36, 18, 0, 1098, 1099, 7, 2, 0, 0, 1099, 1101, 
	3, 36, 18, 0, 1100, 1098, 1, 0, 0, 0, 1101, 1104, 1, 0, 0, 0, 1102, 1100, 
	1, 0, 0, 0, 1102, 1103, 1, 0, 0, 0, 1103, 29, 1, 0, 0, 0, 1104, 1102, 1, 
	0, 0, 0, 1105, 1106, 5, 7, 0, 0, 1106, 1107, 5, 7, 0, 0, 1107, 31, 1, 0, 
	0, 0, 1108, 1109, 5, 7, 0, 0, 1109, 1110, 5, 7, 0, 0, 1110, 1111, 5, 12, 
	0, 0, 1111, 33, 1, 0, 0, 0, 1112, 1113, 5, 27, 0, 0, 1113, 1114, 5, 27, 
	0, 0, 1114, 35, 1, 0, 0, 0, 1115, 1128, 3, 38, 19, 0, 1116, 1124, 5, 9, 
	0, 0, 1117, 1124, 3, 30, 15, 0, 1118, 1124, 5, 10, 0, 0, 1119, 1124, 3, 
	32, 16, 0, 1120, 1124, 5, 11, 0, 0, 1121, 1124, 5, 12, 0, 0, 1122, 1124, 
	5, 33, 0, 0, 1123, 1116, 1, 0, 0, 0, 1123, 1117, 1, 0, 0, 0, 1123, 1118, 
	1, 0, 0, 0, 1123, 1119, 1, 0, 0, 0, 1123, 1120, 1, 0, 0, 0, 1123, 1121, 
	1, 0, 0, 0, 1123, 1122, 1, 0, 0, 0, 1124, 1125, 1, 0, 0, 0, 1125, 1127, 
	3, 38, 19, 0, 1126, 1123, 1, 0, 0, 0, 1127, 1130, 1, 0, 0, 0, 1128, 1126, 
	1, 0, 0, 0, 1128, 1129, 1, 0, 0, 0, 1129, 1139, 1, 0, 0, 0, 1130, 1128, 
	1, 0, 0, 0, 1131, 1132, 3, 34, 17, 0, 1132, 1133, 3, 36, 18, 0, 1133, 1140, 
	1, 0, 0, 0, 1134, 1136, 5, 27, 0, 0, 1135, 1134, 1, 0, 0, 0, 1136, 1137, 
	1, 0, 0, 0, 1137, 1135, 1, 0, 0, 0, 1137, 1138, 1, 0, 0, 0, 1138, 1140, 
	1, 0, 0, 0, 1139, 1131, 1, 0, 0, 0, 1139, 1135, 1, 0, 0, 0, 1139, 1140, 
	1, 0, 0, 0, 1140, 37, 1, 0, 0, 0, 1141, 1146, 3, 40, 20, 0, 1142, 1143, 
	7, 3, 0, 0, 1143, 1145, 3, 40, 20, 0, 1144, 1142, 1, 0, 0, 0, 1145, 1148, 
	1, 0, 0, 0, 1146, 1144, 1, 0, 0, 0, 1146, 1147, 1, 0, 0, 0, 1147, 39, 1, 
	0, 0, 0, 1148, 1146, 1, 0, 0, 0, 1149, 1154, 3, 42, 21, 0, 1150, 1151, 
	7, 4, 0, 0, 1151, 1153, 3, 42, 21, 0, 1152, 1150, 1, 0, 0, 0, 1153, 1156, 
	1, 0, 0, 0, 1154, 1152, 1, 0, 0, 0, 1154, 1155, 1, 0, 0, 0, 1155, 41, 1, 
	0, 0, 0, 1156, 1154, 1, 0, 0, 0, 1157, 1162, 3, 44, 22, 0, 1158, 1159, 
	5, 13, 0, 0, 1159, 1161, 3, 44, 22, 0, 1160, 1158, 1, 0, 0, 0, 1161, 1164, 
	1, 0, 0, 0, 1162, 1160, 1, 0, 0, 0, 1162, 1163, 1, 0, 0, 0, 1163, 43, 1, 
	0, 0, 0, 1164, 1162, 1, 0, 0, 0, 1165, 1170, 3, 54, 27, 0, 1166, 1167, 
	3, 46, 23, 0, 1167, 1168, 3, 54, 27, 0, 1168, 1170, 1, 0, 0, 0, 1169, 1165, 
	1, 0, 0, 0, 1169, 1166, 1, 0, 0, 0, 1170, 45, 1, 0, 0, 0, 1171, 1172, 7, 
	5, 0, 0, 1172, 47, 1, 0, 0, 0, 1173, 1182, 3, 138, 69, 0, 1174, 1182, 3, 
	132, 66, 0, 1175, 1179, 5, 23, 0, 0, 1176, 1180, 3, 144, 72, 0, 1177, 1180, 
	5, 327, 0, 0, 1178, 1180, 3, 802, 401, 0, 1179, 1176, 1, 0, 0, 0, 1179, 
	1177, 1, 0, 0, 0, 1179, 1178, 1, 0, 0, 0, 1180, 1182, 1, 0, 0, 0, 1181, 
	1173, 1, 0, 0, 0, 1181, 1174, 1, 0, 0, 0, 1181, 1175, 1, 0, 0, 0, 1182, 
	1184, 1, 0, 0, 0, 1183, 1181, 1, 0, 0, 0, 1184, 1187, 1, 0, 0, 0, 1185, 
	1183, 1, 0, 0, 0, 1185, 1186, 1, 0, 0, 0, 1186, 1190, 1, 0, 0, 0, 1187, 
	1185, 1, 0, 0, 0, 1188, 1189, 5, 74, 0, 0, 1189, 1191, 3, 800, 400, 0, 
	1190, 1188, 1, 0, 0, 0, 1190, 1191, 1, 0, 0, 0, 1191, 49, 1, 0, 0, 0, 1192, 
	1195, 3, 786, 393, 0, 1193, 1195, 3, 68, 34, 0, 1194, 1192, 1, 0, 0, 0, 
	1194, 1193, 1, 0, 0, 0, 1195, 1196, 1, 0, 0, 0, 1196, 1197, 3, 48, 24, 
	0, 1197, 51, 1, 0, 0, 0, 1198, 1201, 3, 788, 394, 0, 1199, 1201, 3, 70, 
	35, 0, 1200, 1198, 1, 0, 0, 0, 1200, 1199, 1, 0, 0, 0, 1201, 1202, 1, 0, 
	0, 0, 1202, 1203, 3, 48, 24, 0, 1203, 53, 1, 0, 0, 0, 1204, 1207, 3, 50, 
	25, 0, 1205, 1207, 3, 84, 42, 0, 1206, 1204, 1, 0, 0, 0, 1206, 1205, 1, 
	0, 0, 0, 1207, 55, 1, 0, 0, 0, 1208, 1211, 3, 52, 26, 0, 1209, 1211, 3, 
	84, 42, 0, 1210, 1208, 1, 0, 0, 0, 1210, 1209, 1, 0, 0, 0, 1211, 57, 1, 
	0, 0, 0, 1212, 1214, 5, 37, 0, 0, 1213, 1215, 3, 112, 56, 0, 1214, 1213, 
	1, 0, 0, 0, 1214, 1215, 1, 0, 0, 0, 1215, 1217, 1, 0, 0, 0, 1216, 1218, 
	5, 24, 0, 0, 1217, 1216, 1, 0, 0, 0, 1217, 1218, 1, 0, 0, 0, 1218, 1219, 
	1, 0, 0, 0, 1219, 1220, 5, 36, 0, 0, 1220, 59, 1, 0, 0, 0, 1221, 1224, 
	3, 14, 7, 0, 1222, 1223, 5, 28, 0, 0, 1223, 1225, 3, 14, 7, 0, 1224, 1222, 
	1, 0, 0, 0, 1224, 1225, 1, 0, 0, 0, 1225, 1234, 1, 0, 0, 0, 1226, 1227, 
	5, 24, 0, 0, 1227, 1230, 3, 14, 7, 0, 1228, 1229, 5, 28, 0, 0, 1229, 1231, 
	3, 14, 7, 0, 1230, 1228, 1, 0, 0, 0, 1230, 1231, 1, 0, 0, 0, 1231, 1233, 
	1, 0, 0, 0, 1232, 1226, 1, 0, 0, 0, 1233, 1236, 1, 0, 0, 0, 1234, 1232, 
	1, 0, 0, 0, 1234, 1235, 1, 0, 0, 0, 1235, 61, 1, 0, 0, 0, 1236, 1234, 1, 
	0, 0, 0, 1237, 1239, 5, 31, 0, 0, 1238, 1240, 3, 60, 30, 0, 1239, 1238, 
	1, 0, 0, 0, 1239, 1240, 1, 0, 0, 0, 1240, 1242, 1, 0, 0, 0, 1241, 1243, 
	5, 24, 0, 0, 1242, 1241, 1, 0, 0, 0, 1242, 1243, 1, 0, 0, 0, 1243, 1244, 
	1, 0, 0, 0, 1244, 1245, 5, 32, 0, 0, 1245, 63, 1, 0, 0, 0, 1246, 1247, 
	3, 14, 7, 0, 1247, 1248, 5, 28, 0, 0, 1248, 1256, 3, 14, 7, 0, 1249, 1250, 
	5, 24, 0, 0, 1250, 1251, 3, 14, 7, 0, 1251, 1252, 5, 28, 0, 0, 1252, 1253, 
	3, 14, 7, 0, 1253, 1255, 1, 0, 0, 0, 1254, 1249, 1, 0, 0, 0, 1255, 1258, 
	1, 0, 0, 0, 1256, 1254, 1, 0, 0, 0, 1256, 1257, 1, 0, 0, 0, 1257, 65, 1, 
	0, 0, 0, 1258, 1256, 1, 0, 0, 0, 1259, 1261, 5, 14, 0, 0, 1260, 1262, 3, 
	64, 32, 0, 1261, 1260, 1, 0, 0, 0, 1261, 1262, 1, 0, 0, 0, 1262, 1264, 
	1, 0, 0, 0, 1263, 1265, 5, 24, 0, 0, 1264, 1263, 1, 0, 0, 0, 1264, 1265, 
	1, 0, 0, 0, 1265, 1266, 1, 0, 0, 0, 1266, 1267, 5, 15, 0, 0, 1267, 67, 
	1, 0, 0, 0, 1268, 1286, 3, 142, 71, 0, 1269, 1286, 3, 144, 72, 0, 1270, 
	1286, 3, 80, 40, 0, 1271, 1286, 3, 72, 36, 0, 1272, 1286, 3, 76, 38, 0, 
	1273, 1286, 3, 78, 39, 0, 1274, 1275, 3, 802, 401, 0, 1275, 1278, 5, 34, 
	0, 0, 1276, 1279, 3, 828, 414, 0, 1277, 1279, 5, 324, 0, 0, 1278, 1276, 
	1, 0, 0, 0, 1278, 1277, 1, 0, 0, 0, 1279, 1286, 1, 0, 0, 0, 1280, 1286, 
	3, 208, 104, 0, 1281, 1286, 3, 74, 37, 0, 1282, 1286, 3, 58, 29, 0, 1283, 
	1286, 3, 62, 31, 0, 1284, 1286, 3, 66, 33, 0, 1285, 1268, 1, 0, 0, 0, 1285, 
	1269, 1, 0, 0, 0, 1285, 1270, 1, 0, 0, 0, 1285, 1271, 1, 0, 0, 0, 1285, 
	1272, 1, 0, 0, 0, 1285, 1273, 1, 0, 0, 0, 1285, 1274, 1, 0, 0, 0, 1285, 
	1280, 1, 0, 0, 0, 1285, 1281, 1, 0, 0, 0, 1285, 1282, 1, 0, 0, 0, 1285, 
	1283, 1, 0, 0, 0, 1285, 1284, 1, 0, 0, 0, 1286, 69, 1, 0, 0, 0, 1287, 1308, 
	3, 142, 71, 0, 1288, 1308, 3, 144, 72, 0, 1289, 1308, 3, 80, 40, 0, 1290, 
	1308, 3, 72, 36, 0, 1291, 1308, 3, 78, 39, 0, 1292, 1293, 3, 802, 401, 
	0, 1293, 1296, 5, 34, 0, 0, 1294, 1297, 3, 828, 414, 0, 1295, 1297, 5, 
	324, 0, 0, 1296, 1294, 1, 0, 0, 0, 1296, 1295, 1, 0, 0, 0, 1297, 1308, 
	1, 0, 0, 0, 1298, 1299, 5, 25, 0, 0, 1299, 1300, 3, 232, 116, 0, 1300, 
	1301, 5, 26, 0, 0, 1301, 1308, 1, 0, 0, 0, 1302, 1308, 3, 208, 104, 0, 
	1303, 1308, 3, 74, 37, 0, 1304, 1308, 3, 58, 29, 0, 1305, 1308, 3, 62, 
	31, 0, 1306, 1308, 3, 66, 33, 0, 1307, 1287, 1, 0, 0, 0, 1307, 1288, 1, 
	0, 0, 0, 1307, 1289, 1, 0, 0, 0, 1307, 1290, 1, 0, 0, 0, 1307, 1291, 1, 
	0, 0, 0, 1307, 1292, 1, 0, 0, 0, 1307, 1298, 1, 0, 0, 0, 1307, 1302, 1, 
	0, 0, 0, 1307, 1303, 1, 0, 0, 0, 1307, 1304, 1, 0, 0, 0, 1307, 1305, 1, 
	0, 0, 0, 1307, 1306, 1, 0, 0, 0, 1308, 71, 1, 0, 0, 0, 1309, 1310, 5, 70, 
	0, 0, 1310, 1311, 5, 25, 0, 0, 1311, 1312, 3, 14, 7, 0, 1312, 1313, 5, 
	49, 0, 0, 1313, 1314, 3, 204, 102, 0, 1314, 1315, 5, 26, 0, 0, 1315, 73, 
	1, 0, 0, 0, 1316, 1317, 5, 65, 0, 0, 1317, 1318, 5, 25, 0, 0, 1318, 1319, 
	3, 14, 7, 0, 1319, 1320, 5, 49, 0, 0, 1320, 1321, 3, 156, 78, 0, 1321, 
	1322, 5, 26, 0, 0, 1322, 75, 1, 0, 0, 0, 1323, 1324, 5, 126, 0, 0, 1324, 
	1327, 5, 25, 0, 0, 1325, 1328, 3, 232, 116, 0, 1326, 1328, 3, 368, 184, 
	0, 1327, 1325, 1, 0, 0, 0, 1327, 1326, 1, 0, 0, 0, 1328, 1329, 1, 0, 0, 
	0, 1329, 1330, 5, 26, 0, 0, 1330, 77, 1, 0, 0, 0, 1331, 1333, 5, 69, 0, 
	0, 1332, 1334, 3, 14, 7, 0, 1333, 1332, 1, 0, 0, 0, 1333, 1334, 1, 0, 0, 
	0, 1334, 1336, 1, 0, 0, 0, 1335, 1337, 3, 140, 70, 0, 1336, 1335, 1, 0, 
	0, 0, 1337, 1338, 1, 0, 0, 0, 1338, 1336, 1, 0, 0, 0, 1338, 1339, 1, 0, 
	0, 0, 1339, 1342, 1, 0, 0, 0, 1340, 1341, 5, 112, 0, 0, 1341, 1343, 3, 
	14, 7, 0, 1342, 1340, 1, 0, 0, 0, 1342, 1343, 1, 0, 0, 0, 1343, 1344, 1, 
	0, 0, 0, 1344, 1345, 5, 116, 0, 0, 1345, 79, 1, 0, 0, 0, 1346, 1358, 3, 
	110, 55, 0, 1347, 1356, 5, 35, 0, 0, 1348, 1349, 5, 25, 0, 0, 1349, 1350, 
	3, 14, 7, 0, 1350, 1351, 5, 26, 0, 0, 1351, 1357, 1, 0, 0, 0, 1352, 1353, 
	5, 31, 0, 0, 1353, 1354, 3, 6, 3, 0, 1354, 1355, 5, 32, 0, 0, 1355, 1357, 
	1, 0, 0, 0, 1356, 1348, 1, 0, 0, 0, 1356, 1352, 1, 0, 0, 0, 1357, 1359, 
	1, 0, 0, 0, 1358, 1347, 1, 0, 0, 0, 1358, 1359, 1, 0, 0, 0, 1359, 81, 1, 
	0, 0, 0, 1360, 1361, 3, 56, 28, 0, 1361, 83, 1, 0, 0, 0, 1362, 1366, 3, 
	98, 49, 0, 1363, 1366, 3, 102, 51, 0, 1364, 1366, 3, 108, 54, 0, 1365, 
	1362, 1, 0, 0, 0, 1365, 1363, 1, 0, 0, 0, 1365, 1364, 1, 0, 0, 0, 1366, 
	85, 1, 0, 0, 0, 1367, 1368, 5, 324, 0, 0, 1368, 87, 1, 0, 0, 0, 1369, 1372, 
	3, 786, 393, 0, 1370, 1372, 5, 324, 0, 0, 1371, 1369, 1, 0, 0, 0, 1371, 
	1370, 1, 0, 0, 0, 1372, 89, 1, 0, 0, 0, 1373, 1374, 3, 14, 7, 0, 1374, 
	1375, 5, 49, 0, 0, 1375, 1376, 3, 88, 44, 0, 1376, 91, 1, 0, 0, 0, 1377, 
	1382, 3, 90, 45, 0, 1378, 1379, 5, 24, 0, 0, 1379, 1381, 3, 90, 45, 0, 
	1380, 1378, 1, 0, 0, 0, 1381, 1384, 1, 0, 0, 0, 1382, 1380, 1, 0, 0, 0, 
	1382, 1383, 1, 0, 0, 0, 1383, 93, 1, 0, 0, 0, 1384, 1382, 1, 0, 0, 0, 1385, 
	1386, 3, 14, 7, 0, 1386, 1387, 5, 24, 0, 0, 1387, 1390, 3, 86, 43, 0, 1388, 
	1389, 5, 218, 0, 0, 1389, 1391, 3, 92, 46, 0, 1390, 1388, 1, 0, 0, 0, 1390, 
	1391, 1, 0, 0, 0, 1391, 95, 1, 0, 0, 0, 1392, 1397, 5, 119, 0, 0, 1393, 
	1397, 5, 200, 0, 0, 1394, 1395, 5, 96, 0, 0, 1395, 1397, 3, 14, 7, 0, 1396, 
	1392, 1, 0, 0, 0, 1396, 1393, 1, 0, 0, 0, 1396, 1394, 1, 0, 0, 0, 1397, 
	97, 1, 0, 0, 0, 1398, 1399, 5, 175, 0, 0, 1399, 1400, 5, 25, 0, 0, 1400, 
	1403, 3, 94, 47, 0, 1401, 1402, 5, 254, 0, 0, 1402, 1404, 3, 156, 78, 0, 
	1403, 1401, 1, 0, 0, 0, 1403, 1404, 1, 0, 0, 0, 1404, 1411, 1, 0, 0, 0, 
	1405, 1406, 3, 96, 48, 0, 1406, 1407, 5, 206, 0, 0, 1407, 1408, 7, 6, 0, 
	0, 1408, 1410, 1, 0, 0, 0, 1409, 1405, 1, 0, 0, 0, 1410, 1413, 1, 0, 0, 
	0, 1411, 1409, 1, 0, 0, 0, 1411, 1412, 1, 0, 0, 0, 1412, 1414, 1, 0, 0, 
	0, 1413, 1411, 1, 0, 0, 0, 1414, 1415, 5, 26, 0, 0, 1415, 99, 1, 0, 0, 
	0, 1416, 1417, 7, 7, 0, 0, 1417, 1418, 5, 206, 0, 0, 1418, 1419, 5, 119, 
	0, 0, 1419, 101, 1, 0, 0, 0, 1420, 1421, 5, 173, 0, 0, 1421, 1422, 5, 25, 
	0, 0, 1422, 1424, 3, 94, 47, 0, 1423, 1425, 3, 100, 50, 0, 1424, 1423, 
	1, 0, 0, 0, 1424, 1425, 1, 0, 0, 0, 1425, 1426, 1, 0, 0, 0, 1426, 1427, 
	5, 26, 0, 0, 1427, 103, 1, 0, 0, 0, 1428, 1430, 5, 321, 0, 0, 1429, 1431, 
	5, 48, 0, 0, 1430, 1429, 1, 0, 0, 0, 1430, 1431, 1, 0, 0, 0, 1431, 1440, 
	1, 0, 0, 0, 1432, 1434, 5, 320, 0, 0, 1433, 1435, 7, 8, 0, 0, 1434, 1433, 
	1, 0, 0, 0, 1434, 1435, 1, 0, 0, 0, 1435, 1437, 1, 0, 0, 0, 1436, 1438, 
	5, 48, 0, 0, 1437, 1436, 1, 0, 0, 0, 1437, 1438, 1, 0, 0, 0, 1438, 1440, 
	1, 0, 0, 0, 1439, 1428, 1, 0, 0, 0, 1439, 1432, 1, 0, 0, 0, 1440, 105, 
	1, 0, 0, 0, 1441, 1448, 5, 119, 0, 0, 1442, 1448, 5, 200, 0, 0, 1443, 1444, 
	5, 113, 0, 0, 1444, 1448, 5, 48, 0, 0, 1445, 1446, 5, 113, 0, 0, 1446, 
	1448, 5, 202, 0, 0, 1447, 1441, 1, 0, 0, 0, 1447, 1442, 1, 0, 0, 0, 1447, 
	1443, 1, 0, 0, 0, 1447, 1445, 1, 0, 0, 0, 1448, 107, 1, 0, 0, 0, 1449, 
	1450, 5, 174, 0, 0, 1450, 1451, 5, 25, 0, 0, 1451, 1455, 3, 94, 47, 0, 
	1452, 1453, 3, 104, 52, 0, 1453, 1454, 5, 322, 0, 0, 1454, 1456, 1, 0, 
	0, 0, 1455, 1452, 1, 0, 0, 0, 1455, 1456, 1, 0, 0, 0, 1456, 1461, 1, 0, 
	0, 0, 1457, 1458, 3, 106, 53, 0, 1458, 1459, 5, 206, 0, 0, 1459, 1460, 
	5, 113, 0, 0, 1460, 1462, 1, 0, 0, 0, 1461, 1457, 1, 0, 0, 0, 1461, 1462, 
	1, 0, 0, 0, 1462, 1467, 1, 0, 0, 0, 1463, 1464, 3, 106, 53, 0, 1464, 1465, 
	5, 206, 0, 0, 1465, 1466, 5, 119, 0, 0, 1466, 1468, 1, 0, 0, 0, 1467, 1463, 
	1, 0, 0, 0, 1467, 1468, 1, 0, 0, 0, 1468, 1469, 1, 0, 0, 0, 1469, 1470, 
	5, 26, 0, 0, 1470, 109, 1, 0, 0, 0, 1471, 1473, 5, 25, 0, 0, 1472, 1474, 
	3, 130, 65, 0, 1473, 1472, 1, 0, 0, 0, 1473, 1474, 1, 0, 0, 0, 1474, 1476, 
	1, 0, 0, 0, 1475, 1477, 5, 24, 0, 0, 1476, 1475, 1, 0, 0, 0, 1476, 1477, 
	1, 0, 0, 0, 1477, 1478, 1, 0, 0, 0, 1478, 1479, 5, 26, 0, 0, 1479, 111, 
	1, 0, 0, 0, 1480, 1485, 3, 14, 7, 0, 1481, 1482, 5, 24, 0, 0, 1482, 1484, 
	3, 14, 7, 0, 1483, 1481, 1, 0, 0, 0, 1484, 1487, 1, 0, 0, 0, 1485, 1483, 
	1, 0, 0, 0, 1485, 1486, 1, 0, 0, 0, 1486, 113, 1, 0, 0, 0, 1487, 1485, 
	1, 0, 0, 0, 1488, 1489, 5, 25, 0, 0, 1489, 1494, 3, 800, 400, 0, 1490, 
	1491, 5, 24, 0, 0, 1491, 1493, 3, 800, 400, 0, 1492, 1490, 1, 0, 0, 0, 
	1493, 1496, 1, 0, 0, 0, 1494, 1492, 1, 0, 0, 0, 1494, 1495, 1, 0, 0, 0, 
	1495, 1497, 1, 0, 0, 0, 1496, 1494, 1, 0, 0, 0, 1497, 1498, 5, 26, 0, 0, 
	1498, 115, 1, 0, 0, 0, 1499, 1502, 3, 144, 72, 0, 1500, 1502, 3, 800, 400, 
	0, 1501, 1499, 1, 0, 0, 0, 1501, 1500, 1, 0, 0, 0, 1502, 117, 1, 0, 0, 
	0, 1503, 1504, 5, 25, 0, 0, 1504, 1509, 3, 116, 58, 0, 1505, 1506, 5, 24, 
	0, 0, 1506, 1508, 3, 116, 58, 0, 1507, 1505, 1, 0, 0, 0, 1508, 1511, 1, 
	0, 0, 0, 1509, 1507, 1, 0, 0, 0, 1509, 1510, 1, 0, 0, 0, 1510, 1512, 1, 
	0, 0, 0, 1511, 1509, 1, 0, 0, 0, 1512, 1513, 5, 26, 0, 0, 1513, 119, 1, 
	0, 0, 0, 1514, 1515, 3, 824, 412, 0, 1515, 1516, 3, 800, 400, 0, 1516, 
	121, 1, 0, 0, 0, 1517, 1518, 3, 800, 400, 0, 1518, 1519, 5, 23, 0, 0, 1519, 
	1520, 3, 800, 400, 0, 1520, 1523, 1, 0, 0, 0, 1521, 1523, 3, 814, 407, 
	0, 1522, 1517, 1, 0, 0, 0, 1522, 1521, 1, 0, 0, 0, 1523, 123, 1, 0, 0, 
	0, 1524, 1529, 3, 120, 60, 0, 1525, 1526, 5, 24, 0, 0, 1526, 1528, 3, 120, 
	60, 0, 1527, 1525, 1, 0, 0, 0, 1528, 1531, 1, 0, 0, 0, 1529, 1527, 1, 0, 
	0, 0, 1529, 1530, 1, 0, 0, 0, 1530, 1533, 1, 0, 0, 0, 1531, 1529, 1, 0, 
	0, 0, 1532, 1534, 5, 24, 0, 0, 1533, 1532, 1, 0, 0, 0, 1533, 1534, 1, 0, 
	0, 0, 1534, 125, 1, 0, 0, 0, 1535, 1540, 3, 122, 61, 0, 1536, 1537, 5, 
	24, 0, 0, 1537, 1539, 3, 122, 61, 0, 1538, 1536, 1, 0, 0, 0, 1539, 1542, 
	1, 0, 0, 0, 1540, 1538, 1, 0, 0, 0, 1540, 1541, 1, 0, 0, 0, 1541, 1544, 
	1, 0, 0, 0, 1542, 1540, 1, 0, 0, 0, 1543, 1545, 5, 24, 0, 0, 1544, 1543, 
	1, 0, 0, 0, 1544, 1545, 1, 0, 0, 0, 1545, 127, 1, 0, 0, 0, 1546, 1549, 
	3, 14, 7, 0, 1547, 1548, 5, 49, 0, 0, 1548, 1550, 3, 802, 401, 0, 1549, 
	1547, 1, 0, 0, 0, 1549, 1550, 1, 0, 0, 0, 1550, 129, 1, 0, 0, 0, 1551, 
	1556, 3, 128, 64, 0, 1552, 1553, 5, 24, 0, 0, 1553, 1555, 3, 128, 64, 0, 
	1554, 1552, 1, 0, 0, 0, 1555, 1558, 1, 0, 0, 0, 1556, 1554, 1, 0, 0, 0, 
	1556, 1557, 1, 0, 0, 0, 1557, 131, 1, 0, 0, 0, 1558, 1556, 1, 0, 0, 0, 
	1559, 1566, 5, 25, 0, 0, 1560, 1561, 3, 252, 126, 0, 1561, 1563, 3, 130, 
	65, 0, 1562, 1564, 5, 24, 0, 0, 1563, 1562, 1, 0, 0, 0, 1563, 1564, 1, 
	0, 0, 0, 1564, 1567, 1, 0, 0, 0, 1565, 1567, 5, 19, 0, 0, 1566, 1560, 1, 
	0, 0, 0, 1566, 1565, 1, 0, 0, 0, 1566, 1567, 1, 0, 0, 0, 1567, 1568, 1, 
	0, 0, 0, 1568, 1569, 5, 26, 0, 0, 1569, 1570, 3, 134, 67, 0, 1570, 133, 
	1, 0, 0, 0, 1571, 1574, 3, 722, 361, 0, 1572, 1574, 3, 724, 362, 0, 1573, 
	1571, 1, 0, 0, 0, 1573, 1572, 1, 0, 0, 0, 1573, 1574, 1, 0, 0, 0, 1574, 
	1577, 1, 0, 0, 0, 1575, 1576, 5, 215, 0, 0, 1576, 1578, 3, 726, 363, 0, 
	1577, 1575, 1, 0, 0, 0, 1577, 1578, 1, 0, 0, 0, 1578, 135, 1, 0, 0, 0, 
	1579, 1580, 3, 802, 401, 0, 1580, 1581, 5, 34, 0, 0, 1581, 1582, 3, 802, 
	401, 0, 1582, 1588, 1, 0, 0, 0, 1583, 1588, 3, 806, 403, 0, 1584, 1588, 
	3, 144, 72, 0, 1585, 1586, 5, 129, 0, 0, 1586, 1588, 5, 142, 0, 0, 1587, 
	1579, 1, 0, 0, 0, 1587, 1583, 1, 0, 0, 0, 1587, 1584, 1, 0, 0, 0, 1587, 
	1585, 1, 0, 0, 0, 1588, 1589, 1, 0, 0, 0, 1589, 1590, 3, 132, 66, 0, 1590, 
	137, 1, 0, 0, 0, 1591, 1592, 5, 37, 0, 0, 1592, 1593, 3, 14, 7, 0, 1593, 
	1594, 5, 36, 0, 0, 1594, 139, 1, 0, 0, 0, 1595, 1596, 5, 317, 0, 0, 1596, 
	1597, 3, 14, 7, 0, 1597, 1598, 5, 292, 0, 0, 1598, 1599, 3, 14, 7, 0, 1599, 
	141, 1, 0, 0, 0, 1600, 1611, 3, 864, 432, 0, 1601, 1611, 3, 862, 431, 0, 
	1602, 1611, 5, 324, 0, 0, 1603, 1611, 5, 330, 0, 0, 1604, 1611, 5, 200, 
	0, 0, 1605, 1611, 5, 90, 0, 0, 1606, 1611, 5, 89, 0, 0, 1607, 1611, 5, 
	91, 0, 0, 1608, 1611, 3, 860, 430, 0, 1609, 1611, 5, 114, 0, 0, 1610, 1600, 
	1, 0, 0, 0, 1610, 1601, 1, 0, 0, 0, 1610, 1602, 1, 0, 0, 0, 1610, 1603, 
	1, 0, 0, 0, 1610, 1604, 1, 0, 0, 0, 1610, 1605, 1, 0, 0, 0, 1610, 1606, 
	1, 0, 0, 0, 1610, 1607, 1, 0, 0, 0, 1610, 1608, 1, 0, 0, 0, 1610, 1609, 
	1, 0, 0, 0, 1611, 143, 1, 0, 0, 0, 1612, 1616, 5, 30, 0, 0, 1613, 1617, 
	3, 802, 401, 0, 1614, 1617, 5, 298, 0, 0, 1615, 1617, 5, 131, 0, 0, 1616, 
	1613, 1, 0, 0, 0, 1616, 1614, 1, 0, 0, 0, 1616, 1615, 1, 0, 0, 0, 1617, 
	145, 1, 0, 0, 0, 1618, 1620, 3, 144, 72, 0, 1619, 1621, 5, 27, 0, 0, 1620, 
	1619, 1, 0, 0, 0, 1620, 1621, 1, 0, 0, 0, 1621, 147, 1, 0, 0, 0, 1622, 
	1627, 3, 144, 72, 0, 1623, 1624, 5, 24, 0, 0, 1624, 1626, 3, 144, 72, 0, 
	1625, 1623, 1, 0, 0, 0, 1626, 1629, 1, 0, 0, 0, 1627, 1625, 1, 0, 0, 0, 
	1627, 1628, 1, 0, 0, 0, 1628, 149, 1, 0, 0, 0, 1629, 1627, 1, 0, 0, 0, 
	1630, 1633, 3, 144, 72, 0, 1631, 1632, 5, 49, 0, 0, 1632, 1634, 3, 144, 
	72, 0, 1633, 1631, 1, 0, 0, 0, 1633, 1634, 1, 0, 0, 0, 1634, 151, 1, 0, 
	0, 0, 1635, 1640, 3, 150, 75, 0, 1636, 1637, 5, 24, 0, 0, 1637, 1639, 3, 
	150, 75, 0, 1638, 1636, 1, 0, 0, 0, 1639, 1642, 1, 0, 0, 0, 1640, 1638, 
	1, 0, 0, 0, 1640, 1641, 1, 0, 0, 0, 1641, 153, 1, 0, 0, 0, 1642, 1640, 
	1, 0, 0, 0, 1643, 1645, 7, 3, 0, 0, 1644, 1643, 1, 0, 0, 0, 1644, 1645, 
	1, 0, 0, 0, 1645, 1648, 1, 0, 0, 0, 1646, 1649, 3, 864, 432, 0, 1647, 1649, 
	3, 862, 431, 0, 1648, 1646, 1, 0, 0, 0, 1648, 1647, 1, 0, 0, 0, 1649, 155, 
	1, 0, 0, 0, 1650, 1651, 3, 818, 409, 0, 1651, 157, 1, 0, 0, 0, 1652, 1655, 
	3, 864, 432, 0, 1653, 1655, 3, 144, 72, 0, 1654, 1652, 1, 0, 0, 0, 1654, 
	1653, 1, 0, 0, 0, 1655, 159, 1, 0, 0, 0, 1656, 1660, 3, 782, 391, 0, 1657, 
	1660, 5, 324, 0, 0, 1658, 1660, 3, 144, 72, 0, 1659, 1656, 1, 0, 0, 0, 
	1659, 1657, 1, 0, 0, 0, 1659, 1658, 1, 0, 0, 0, 1660, 161, 1, 0, 0, 0, 
	1661, 1662, 3, 160, 80, 0, 1662, 1663, 5, 28, 0, 0, 1663, 1664, 3, 204, 
	102, 0, 1664, 163, 1, 0, 0, 0, 1665, 1666, 3, 160, 80, 0, 1666, 1671, 3, 
	204, 102, 0, 1667, 1669, 5, 198, 0, 0, 1668, 1667, 1, 0, 0, 0, 1668, 1669, 
	1, 0, 0, 0, 1669, 1670, 1, 0, 0, 0, 1670, 1672, 5, 200, 0, 0, 1671, 1668, 
	1, 0, 0, 0, 1671, 1672, 1, 0, 0, 0, 1672, 1678, 1, 0, 0, 0, 1673, 1674, 
	3, 204, 102, 0, 1674, 1675, 5, 49, 0, 0, 1675, 1676, 3, 160, 80, 0, 1676, 
	1678, 1, 0, 0, 0, 1677, 1665, 1, 0, 0, 0, 1677, 1673, 1, 0, 0, 0, 1678, 
	165, 1, 0, 0, 0, 1679, 1680, 3, 160, 80, 0, 1680, 1681, 5, 28, 0, 0, 1681, 
	1683, 1, 0, 0, 0, 1682, 1679, 1, 0, 0, 0, 1682, 1683, 1, 0, 0, 0, 1683, 
	1684, 1, 0, 0, 0, 1684, 1685, 3, 204, 102, 0, 1685, 167, 1, 0, 0, 0, 1686, 
	1690, 3, 166, 83, 0, 1687, 1688, 5, 31, 0, 0, 1688, 1689, 5, 58, 0, 0, 
	1689, 1691, 5, 32, 0, 0, 1690, 1687, 1, 0, 0, 0, 1690, 1691, 1, 0, 0, 0, 
	1691, 169, 1, 0, 0, 0, 1692, 1697, 3, 168, 84, 0, 1693, 1694, 5, 24, 0, 
	0, 1694, 1696, 3, 168, 84, 0, 1695, 1693, 1, 0, 0, 0, 1696, 1699, 1, 0, 
	0, 0, 1697, 1695, 1, 0, 0, 0, 1697, 1698, 1, 0, 0, 0, 1698, 171, 1, 0, 
	0, 0, 1699, 1697, 1, 0, 0, 0, 1700, 1701, 5, 94, 0, 0, 1701, 1702, 5, 25, 
	0, 0, 1702, 1703, 3, 158, 79, 0, 1703, 1704, 5, 24, 0, 0, 1704, 1705, 3, 
	158, 79, 0, 1705, 1706, 5, 26, 0, 0, 1706, 173, 1, 0, 0, 0, 1707, 1708, 
	5, 210, 0, 0, 1708, 1709, 5, 5, 0, 0, 1709, 1710, 3, 204, 102, 0, 1710, 
	1711, 5, 7, 0, 0, 1711, 175, 1, 0, 0, 0, 1712, 1729, 5, 299, 0, 0, 1713, 
	1725, 5, 5, 0, 0, 1714, 1719, 3, 204, 102, 0, 1715, 1716, 5, 24, 0, 0, 
	1716, 1718, 3, 204, 102, 0, 1717, 1715, 1, 0, 0, 0, 1718, 1721, 1, 0, 0, 
	0, 1719, 1717, 1, 0, 0, 0, 1719, 1720, 1, 0, 0, 0, 1720, 1723, 1, 0, 0, 
	0, 1721, 1719, 1, 0, 0, 0, 1722, 1724, 5, 24, 0, 0, 1723, 1722, 1, 0, 0, 
	0, 1723, 1724, 1, 0, 0, 0, 1724, 1726, 1, 0, 0, 0, 1725, 1714, 1, 0, 0, 
	0, 1725, 1726, 1, 0, 0, 0, 1726, 1727, 1, 0, 0, 0, 1727, 1730, 5, 7, 0, 
	0, 1728, 1730, 5, 4, 0, 0, 1729, 1713, 1, 0, 0, 0, 1729, 1728, 1, 0, 0, 
	0, 1730, 177, 1, 0, 0, 0, 1731, 1748, 5, 278, 0, 0, 1732, 1744, 5, 5, 0, 
	0, 1733, 1738, 3, 162, 81, 0, 1734, 1735, 5, 24, 0, 0, 1735, 1737, 3, 162, 
	81, 0, 1736, 1734, 1, 0, 0, 0, 1737, 1740, 1, 0, 0, 0, 1738, 1736, 1, 0, 
	0, 0, 1738, 1739, 1, 0, 0, 0, 1739, 1742, 1, 0, 0, 0, 1740, 1738, 1, 0, 
	0, 0, 1741, 1743, 5, 24, 0, 0, 1742, 1741, 1, 0, 0, 0, 1742, 1743, 1, 0, 
	0, 0, 1743, 1745, 1, 0, 0, 0, 1744, 1733, 1, 0, 0, 0, 1744, 1745, 1, 0, 
	0, 0, 1745, 1746, 1, 0, 0, 0, 1746, 1749, 5, 7, 0, 0, 1747, 1749, 5, 4, 
	0, 0, 1748, 1732, 1, 0, 0, 0, 1748, 1747, 1, 0, 0, 0, 1749, 179, 1, 0, 
	0, 0, 1750, 1751, 5, 314, 0, 0, 1751, 1752, 5, 5, 0, 0, 1752, 1757, 3, 
	166, 83, 0, 1753, 1754, 5, 24, 0, 0, 1754, 1756, 3, 166, 83, 0, 1755, 1753, 
	1, 0, 0, 0, 1756, 1759, 1, 0, 0, 0, 1757, 1755, 1, 0, 0, 0, 1757, 1758, 
	1, 0, 0, 0, 1758, 1761, 1, 0, 0, 0, 1759, 1757, 1, 0, 0, 0, 1760, 1762, 
	5, 24, 0, 0, 1761, 1760, 1, 0, 0, 0, 1761, 1762, 1, 0, 0, 0, 1762, 1763, 
	1, 0, 0, 0, 1763, 1764, 5, 7, 0, 0, 1764, 181, 1, 0, 0, 0, 1765, 1766, 
	5, 182, 0, 0, 1766, 1767, 5, 5, 0, 0, 1767, 1768, 3, 204, 102, 0, 1768, 
	1769, 5, 7, 0, 0, 1769, 183, 1, 0, 0, 0, 1770, 1771, 5, 277, 0, 0, 1771, 
	1772, 5, 5, 0, 0, 1772, 1773, 3, 204, 102, 0, 1773, 1774, 5, 7, 0, 0, 1774, 
	185, 1, 0, 0, 0, 1775, 1776, 5, 136, 0, 0, 1776, 1777, 5, 5, 0, 0, 1777, 
	1778, 3, 204, 102, 0, 1778, 1779, 5, 7, 0, 0, 1779, 187, 1, 0, 0, 0, 1780, 
	1781, 5, 104, 0, 0, 1781, 1782, 5, 5, 0, 0, 1782, 1783, 3, 204, 102, 0, 
	1783, 1784, 5, 24, 0, 0, 1784, 1785, 3, 204, 102, 0, 1785, 1786, 5, 7, 
	0, 0, 1786, 189, 1, 0, 0, 0, 1787, 1788, 5, 270, 0, 0, 1788, 1789, 5, 5, 
	0, 0, 1789, 1790, 3, 204, 102, 0, 1790, 1791, 5, 7, 0, 0, 1791, 191, 1, 
	0, 0, 0, 1792, 1793, 5, 117, 0, 0, 1793, 1794, 5, 5, 0, 0, 1794, 1799, 
	3, 160, 80, 0, 1795, 1796, 5, 24, 0, 0, 1796, 1798, 3, 160, 80, 0, 1797, 
	1795, 1, 0, 0, 0, 1798, 1801, 1, 0, 0, 0, 1799, 1797, 1, 0, 0, 0, 1799, 
	1800, 1, 0, 0, 0, 1800, 1803, 1, 0, 0, 0, 1801, 1799, 1, 0, 0, 0, 1802, 
	1804, 5, 24, 0, 0, 1803, 1802, 1, 0, 0, 0, 1803, 1804, 1, 0, 0, 0, 1804, 
	1805, 1, 0, 0, 0, 1805, 1806, 5, 7, 0, 0, 1806, 193, 1, 0, 0, 0, 1807, 
	1808, 5, 247, 0, 0, 1808, 1809, 5, 5, 0, 0, 1809, 1810, 3, 160, 80, 0, 
	1810, 1811, 5, 7, 0, 0, 1811, 195, 1, 0, 0, 0, 1812, 1813, 5, 289, 0, 0, 
	1813, 1814, 5, 5, 0, 0, 1814, 1815, 3, 204, 102, 0, 1815, 1816, 5, 24, 
	0, 0, 1816, 1817, 3, 160, 80, 0, 1817, 1818, 5, 7, 0, 0, 1818, 197, 1, 
	0, 0, 0, 1819, 1820, 5, 67, 0, 0, 1820, 1821, 5, 5, 0, 0, 1821, 1823, 5, 
	25, 0, 0, 1822, 1824, 3, 170, 85, 0, 1823, 1822, 1, 0, 0, 0, 1823, 1824, 
	1, 0, 0, 0, 1824, 1826, 1, 0, 0, 0, 1825, 1827, 5, 24, 0, 0, 1826, 1825, 
	1, 0, 0, 0, 1826, 1827, 1, 0, 0, 0, 1827, 1832, 1, 0, 0, 0, 1828, 1829, 
	5, 37, 0, 0, 1829, 1830, 3, 170, 85, 0, 1830, 1831, 5, 36, 0, 0, 1831, 
	1833, 1, 0, 0, 0, 1832, 1828, 1, 0, 0, 0, 1832, 1833, 1, 0, 0, 0, 1833, 
	1834, 1, 0, 0, 0, 1834, 1835, 5, 26, 0, 0, 1835, 1836, 5, 35, 0, 0, 1836, 
	1837, 3, 204, 102, 0, 1837, 1838, 5, 7, 0, 0, 1838, 199, 1, 0, 0, 0, 1839, 
	1853, 3, 174, 87, 0, 1840, 1853, 3, 176, 88, 0, 1841, 1853, 3, 178, 89, 
	0, 1842, 1853, 3, 180, 90, 0, 1843, 1853, 3, 182, 91, 0, 1844, 1853, 3, 
	184, 92, 0, 1845, 1853, 3, 186, 93, 0, 1846, 1853, 3, 188, 94, 0, 1847, 
	1853, 3, 190, 95, 0, 1848, 1853, 3, 192, 96, 0, 1849, 1853, 3, 194, 97, 
	0, 1850, 1853, 3, 196, 98, 0, 1851, 1853, 3, 198, 99, 0, 1852, 1839, 1, 
	0, 0, 0, 1852, 1840, 1, 0, 0, 0, 1852, 1841, 1, 0, 0, 0, 1852, 1842, 1, 
	0, 0, 0, 1852, 1843, 1, 0, 0, 0, 1852, 1844, 1, 0, 0, 0, 1852, 1845, 1, 
	0, 0, 0, 1852, 1846, 1, 0, 0, 0, 1852, 1847, 1, 0, 0, 0, 1852, 1848, 1, 
	0, 0, 0, 1852, 1849, 1, 0, 0, 0, 1852, 1850, 1, 0, 0, 0, 1852, 1851, 1, 
	0, 0, 0, 1853, 1857, 1, 0, 0, 0, 1854, 1856, 5, 27, 0, 0, 1855, 1854, 1, 
	0, 0, 0, 1856, 1859, 1, 0, 0, 0, 1857, 1855, 1, 0, 0, 0, 1857, 1858, 1, 
	0, 0, 0, 1858, 201, 1, 0, 0, 0, 1859, 1857, 1, 0, 0, 0, 1860, 1872, 3, 
	200, 100, 0, 1861, 1864, 3, 172, 86, 0, 1862, 1864, 3, 156, 78, 0, 1863, 
	1861, 1, 0, 0, 0, 1863, 1862, 1, 0, 0, 0, 1864, 1868, 1, 0, 0, 0, 1865, 
	1867, 5, 27, 0, 0, 1866, 1865, 1, 0, 0, 0, 1867, 1870, 1, 0, 0, 0, 1868, 
	1866, 1, 0, 0, 0, 1868, 1869, 1, 0, 0, 0, 1869, 1872, 1, 0, 0, 0, 1870, 
	1868, 1, 0, 0, 0, 1871, 1860, 1, 0, 0, 0, 1871, 1863, 1, 0, 0, 0, 1872, 
	203, 1, 0, 0, 0, 1873, 1876, 3, 202, 101, 0, 1874, 1876, 3, 144, 72, 0, 
	1875, 1873, 1, 0, 0, 0, 1875, 1874, 1, 0, 0, 0, 1876, 205, 1, 0, 0, 0, 
	1877, 1878, 5, 324, 0, 0, 1878, 207, 1, 0, 0, 0, 1879, 1880, 5, 314, 0, 
	0, 1880, 1881, 5, 25, 0, 0, 1881, 1882, 3, 14, 7, 0, 1882, 1883, 5, 24, 
	0, 0, 1883, 1884, 3, 14, 7, 0, 1884, 1885, 5, 24, 0, 0, 1885, 1886, 3, 
	14, 7, 0, 1886, 1887, 5, 26, 0, 0, 1887, 1903, 1, 0, 0, 0, 1888, 1889, 
	5, 117, 0, 0, 1889, 1890, 5, 25, 0, 0, 1890, 1891, 3, 14, 7, 0, 1891, 1892, 
	5, 24, 0, 0, 1892, 1893, 3, 14, 7, 0, 1893, 1894, 5, 26, 0, 0, 1894, 1903, 
	1, 0, 0, 0, 1895, 1896, 5, 67, 0, 0, 1896, 1897, 5, 25, 0, 0, 1897, 1898, 
	3, 14, 7, 0, 1898, 1899, 5, 24, 0, 0, 1899, 1900, 3, 14, 7, 0, 1900, 1901, 
	5, 26, 0, 0, 1901, 1903, 1, 0, 0, 0, 1902, 1879, 1, 0, 0, 0, 1902, 1888, 
	1, 0, 0, 0, 1902, 1895, 1, 0, 0, 0, 1903, 209, 1, 0, 0, 0, 1904, 1905, 
	5, 95, 0, 0, 1905, 1906, 3, 144, 72, 0, 1906, 1907, 5, 49, 0, 0, 1907, 
	1910, 3, 202, 101, 0, 1908, 1909, 5, 1, 0, 0, 1909, 1911, 3, 142, 71, 0, 
	1910, 1908, 1, 0, 0, 0, 1910, 1911, 1, 0, 0, 0, 1911, 211, 1, 0, 0, 0, 
	1912, 1914, 5, 23, 0, 0, 1913, 1912, 1, 0, 0, 0, 1913, 1914, 1, 0, 0, 0, 
	1914, 1915, 1, 0, 0, 0, 1915, 1920, 3, 800, 400, 0, 1916, 1917, 5, 23, 
	0, 0, 1917, 1919, 3, 800, 400, 0, 1918, 1916, 1, 0, 0, 0, 1919, 1922, 1, 
	0, 0, 0, 1920, 1918, 1, 0, 0, 0, 1920, 1921, 1, 0, 0, 0, 1921, 213, 1, 
	0, 0, 0, 1922, 1920, 1, 0, 0, 0, 1923, 1924, 5, 156, 0, 0, 1924, 1925, 
	3, 212, 106, 0, 1925, 1926, 5, 281, 0, 0, 1926, 1927, 3, 152, 76, 0, 1927, 
	215, 1, 0, 0, 0, 1928, 1929, 5, 128, 0, 0, 1929, 1930, 3, 148, 74, 0, 1930, 
	217, 1, 0, 0, 0, 1931, 1934, 3, 144, 72, 0, 1932, 1934, 5, 114, 0, 0, 1933, 
	1931, 1, 0, 0, 0, 1933, 1932, 1, 0, 0, 0, 1934, 1935, 1, 0, 0, 0, 1935, 
	1937, 5, 25, 0, 0, 1936, 1938, 3, 112, 56, 0, 1937, 1936, 1, 0, 0, 0, 1937, 
	1938, 1, 0, 0, 0, 1938, 1939, 1, 0, 0, 0, 1939, 1940, 5, 26, 0, 0, 1940, 
	219, 1, 0, 0, 0, 1941, 1942, 5, 62, 0, 0, 1942, 1943, 3, 632, 316, 0, 1943, 
	1944, 5, 116, 0, 0, 1944, 1945, 5, 109, 0, 0, 1945, 221, 1, 0, 0, 0, 1946, 
	1949, 5, 109, 0, 0, 1947, 1950, 3, 218, 109, 0, 1948, 1950, 3, 220, 110, 
	0, 1949, 1947, 1, 0, 0, 0, 1949, 1948, 1, 0, 0, 0, 1950, 223, 1, 0, 0, 
	0, 1951, 1952, 5, 226, 0, 0, 1952, 1953, 3, 830, 415, 0, 1953, 1967, 3, 
	800, 400, 0, 1954, 1955, 5, 1, 0, 0, 1955, 1968, 3, 226, 113, 0, 1956, 
	1957, 5, 25, 0, 0, 1957, 1962, 3, 226, 113, 0, 1958, 1959, 5, 24, 0, 0, 
	1959, 1961, 3, 226, 113, 0, 1960, 1958, 1, 0, 0, 0, 1961, 1964, 1, 0, 0, 
	0, 1962, 1960, 1, 0, 0, 0, 1962, 1963, 1, 0, 0, 0, 1963, 1965, 1, 0, 0, 
	0, 1964, 1962, 1, 0, 0, 0, 1965, 1966, 5, 26, 0, 0, 1966, 1968, 1, 0, 0, 
	0, 1967, 1954, 1, 0, 0, 0, 1967, 1956, 1, 0, 0, 0, 1967, 1968, 1, 0, 0, 
	0, 1968, 225, 1, 0, 0, 0, 1969, 1975, 3, 154, 77, 0, 1970, 1975, 3, 782, 
	391, 0, 1971, 1975, 5, 324, 0, 0, 1972, 1975, 3, 860, 430, 0, 1973, 1975, 
	3, 144, 72, 0, 1974, 1969, 1, 0, 0, 0, 1974, 1970, 1, 0, 0, 0, 1974, 1971, 
	1, 0, 0, 0, 1974, 1972, 1, 0, 0, 0, 1974, 1973, 1, 0, 0, 0, 1975, 227, 
	1, 0, 0, 0, 1976, 1978, 3, 14, 7, 0, 1977, 1979, 7, 9, 0, 0, 1978, 1977, 
	1, 0, 0, 0, 1978, 1979, 1, 0, 0, 0, 1979, 229, 1, 0, 0, 0, 1980, 1985, 
	3, 228, 114, 0, 1981, 1982, 5, 24, 0, 0, 1982, 1984, 3, 228, 114, 0, 1983, 
	1981, 1, 0, 0, 0, 1984, 1987, 1, 0, 0, 0, 1985, 1983, 1, 0, 0, 0, 1985, 
	1986, 1, 0, 0, 0, 1986, 231, 1, 0, 0, 0, 1987, 1985, 1, 0, 0, 0, 1988, 
	1994, 3, 236, 118, 0, 1989, 1990, 3, 238, 119, 0, 1990, 1991, 3, 236, 118, 
	0, 1991, 1993, 1, 0, 0, 0, 1992, 1989, 1, 0, 0, 0, 1993, 1996, 1, 0, 0, 
	0, 1994, 1992, 1, 0, 0, 0, 1994, 1995, 1, 0, 0, 0, 1995, 233, 1, 0, 0, 
	0, 1996, 1994, 1, 0, 0, 0, 1997, 2003, 3, 240, 120, 0, 1998, 1999, 3, 238, 
	119, 0, 1999, 2000, 3, 236, 118, 0, 2000, 2002, 1, 0, 0, 0, 2001, 1998, 
	1, 0, 0, 0, 2002, 2005, 1, 0, 0, 0, 2003, 2001, 1, 0, 0, 0, 2003, 2004, 
	1, 0, 0, 0, 2004, 235, 1, 0, 0, 0, 2005, 2003, 1, 0, 0, 0, 2006, 2012, 
	3, 240, 120, 0, 2007, 2008, 5, 25, 0, 0, 2008, 2009, 3, 240, 120, 0, 2009, 
	2010, 5, 26, 0, 0, 2010, 2012, 1, 0, 0, 0, 2011, 2006, 1, 0, 0, 0, 2011, 
	2007, 1, 0, 0, 0, 2012, 237, 1, 0, 0, 0, 2013, 2015, 5, 303, 0, 0, 2014, 
	2016, 5, 42, 0, 0, 2015, 2014, 1, 0, 0, 0, 2015, 2016, 1, 0, 0, 0, 2016, 
	2020, 1, 0, 0, 0, 2017, 2020, 5, 168, 0, 0, 2018, 2020, 5, 122, 0, 0, 2019, 
	2013, 1, 0, 0, 0, 2019, 2017, 1, 0, 0, 0, 2019, 2018, 1, 0, 0, 0, 2020, 
	239, 1, 0, 0, 0, 2021, 2028, 3, 242, 121, 0, 2022, 2023, 5, 181, 0, 0, 
	2023, 2026, 3, 14, 7, 0, 2024, 2025, 7, 10, 0, 0, 2025, 2027, 3, 14, 7, 
	0, 2026, 2024, 1, 0, 0, 0, 2026, 2027, 1, 0, 0, 0, 2027, 2029, 1, 0, 0, 
	0, 2028, 2022, 1, 0, 0, 0, 2028, 2029, 1, 0, 0, 0, 2029, 241, 1, 0, 0, 
	0, 2030, 2032, 5, 107, 0, 0, 2031, 2030, 1, 0, 0, 0, 2031, 2032, 1, 0, 
	0, 0, 2032, 2036, 1, 0, 0, 0, 2033, 2037, 3, 244, 122, 0, 2034, 2037, 3, 
	250, 125, 0, 2035, 2037, 3, 254, 127, 0, 2036, 2033, 1, 0, 0, 0, 2036, 
	2034, 1, 0, 0, 0, 2036, 2035, 1, 0, 0, 0, 2037, 2041, 1, 0, 0, 0, 2038, 
	2039, 5, 169, 0, 0, 2039, 2040, 5, 252, 0, 0, 2040, 2042, 3, 116, 58, 0, 
	2041, 2038, 1, 0, 0, 0, 2041, 2042, 1, 0, 0, 0, 2042, 243, 1, 0, 0, 0, 
	2043, 2045, 5, 231, 0, 0, 2044, 2046, 5, 277, 0, 0, 2045, 2044, 1, 0, 0, 
	0, 2045, 2046, 1, 0, 0, 0, 2046, 2047, 1, 0, 0, 0, 2047, 2052, 3, 346, 
	173, 0, 2048, 2049, 5, 24, 0, 0, 2049, 2051, 3, 346, 173, 0, 2050, 2048, 
	1, 0, 0, 0, 2051, 2054, 1, 0, 0, 0, 2052, 2050, 1, 0, 0, 0, 2052, 2053, 
	1, 0, 0, 0, 2053, 2077, 1, 0, 0, 0, 2054, 2052, 1, 0, 0, 0, 2055, 2056, 
	5, 311, 0, 0, 2056, 2059, 3, 136, 68, 0, 2057, 2058, 5, 49, 0, 0, 2058, 
	2060, 3, 800, 400, 0, 2059, 2057, 1, 0, 0, 0, 2059, 2060, 1, 0, 0, 0, 2060, 
	2063, 1, 0, 0, 0, 2061, 2062, 5, 320, 0, 0, 2062, 2064, 3, 248, 124, 0, 
	2063, 2061, 1, 0, 0, 0, 2063, 2064, 1, 0, 0, 0, 2064, 2067, 1, 0, 0, 0, 
	2065, 2066, 5, 318, 0, 0, 2066, 2068, 3, 14, 7, 0, 2067, 2065, 1, 0, 0, 
	0, 2067, 2068, 1, 0, 0, 0, 2068, 2071, 1, 0, 0, 0, 2069, 2070, 5, 150, 
	0, 0, 2070, 2072, 3, 14, 7, 0, 2071, 2069, 1, 0, 0, 0, 2071, 2072, 1, 0, 
	0, 0, 2072, 2075, 1, 0, 0, 0, 2073, 2074, 5, 51, 0, 0, 2074, 2076, 3, 314, 
	157, 0, 2075, 2073, 1, 0, 0, 0, 2075, 2076, 1, 0, 0, 0, 2076, 2078, 1, 
	0, 0, 0, 2077, 2055, 1, 0, 0, 0, 2077, 2078, 1, 0, 0, 0, 2078, 245, 1, 
	0, 0, 0, 2079, 2080, 3, 800, 400, 0, 2080, 2081, 5, 1, 0, 0, 2081, 2082, 
	3, 14, 7, 0, 2082, 247, 1, 0, 0, 0, 2083, 2088, 3, 246, 123, 0, 2084, 2085, 
	5, 24, 0, 0, 2085, 2087, 3, 246, 123, 0, 2086, 2084, 1, 0, 0, 0, 2087, 
	2090, 1, 0, 0, 0, 2088, 2086, 1, 0, 0, 0, 2088, 2089, 1, 0, 0, 0, 2089, 
	249, 1, 0, 0, 0, 2090, 2088, 1, 0, 0, 0, 2091, 2092, 5, 236, 0, 0, 2092, 
	2097, 3, 346, 173, 0, 2093, 2094, 5, 24, 0, 0, 2094, 2096, 3, 346, 173, 
	0, 2095, 2093, 1, 0, 0, 0, 2096, 2099, 1, 0, 0, 0, 2097, 2095, 1, 0, 0, 
	0, 2097, 2098, 1, 0, 0, 0, 2098, 2102, 1, 0, 0, 0, 2099, 2097, 1, 0, 0, 
	0, 2100, 2101, 5, 228, 0, 0, 2101, 2103, 3, 230, 115, 0, 2102, 2100, 1, 
	0, 0, 0, 2102, 2103, 1, 0, 0, 0, 2103, 2104, 1, 0, 0, 0, 2104, 2105, 5, 
	206, 0, 0, 2105, 2106, 3, 124, 62, 0, 2106, 2108, 5, 311, 0, 0, 2107, 2109, 
	5, 42, 0, 0, 2108, 2107, 1, 0, 0, 0, 2108, 2109, 1, 0, 0, 0, 2109, 2110, 
	1, 0, 0, 0, 2110, 2113, 3, 136, 68, 0, 2111, 2112, 5, 49, 0, 0, 2112, 2114, 
	3, 800, 400, 0, 2113, 2111, 1, 0, 0, 0, 2113, 2114, 1, 0, 0, 0, 2114, 2117, 
	1, 0, 0, 0, 2115, 2116, 5, 318, 0, 0, 2116, 2118, 3, 14, 7, 0, 2117, 2115, 
	1, 0, 0, 0, 2117, 2118, 1, 0, 0, 0, 2118, 2121, 1, 0, 0, 0, 2119, 2120, 
	5, 150, 0, 0, 2120, 2122, 3, 14, 7, 0, 2121, 2119, 1, 0, 0, 0, 2121, 2122, 
	1, 0, 0, 0, 2122, 2125, 1, 0, 0, 0, 2123, 2124, 5, 51, 0, 0, 2124, 2126, 
	3, 314, 157, 0, 2125, 2123, 1, 0, 0, 0, 2125, 2126, 1, 0, 0, 0, 2126, 251, 
	1, 0, 0, 0, 2127, 2129, 7, 11, 0, 0, 2128, 2127, 1, 0, 0, 0, 2128, 2129, 
	1, 0, 0, 0, 2129, 253, 1, 0, 0, 0, 2130, 2131, 5, 140, 0, 0, 2131, 2133, 
	3, 338, 169, 0, 2132, 2130, 1, 0, 0, 0, 2132, 2133, 1, 0, 0, 0, 2133, 2134, 
	1, 0, 0, 0, 2134, 2136, 5, 268, 0, 0, 2135, 2137, 5, 277, 0, 0, 2136, 2135, 
	1, 0, 0, 0, 2136, 2137, 1, 0, 0, 0, 2137, 2138, 1, 0, 0, 0, 2138, 2139, 
	3, 252, 126, 0, 2139, 2144, 3, 336, 168, 0, 2140, 2141, 5, 24, 0, 0, 2141, 
	2143, 3, 336, 168, 0, 2142, 2140, 1, 0, 0, 0, 2143, 2146, 1, 0, 0, 0, 2144, 
	2142, 1, 0, 0, 0, 2144, 2145, 1, 0, 0, 0, 2145, 2148, 1, 0, 0, 0, 2146, 
	2144, 1, 0, 0, 0, 2147, 2149, 5, 24, 0, 0, 2148, 2147, 1, 0, 0, 0, 2148, 
	2149, 1, 0, 0, 0, 2149, 2152, 1, 0, 0, 0, 2150, 2151, 5, 321, 0, 0, 2151, 
	2153, 3, 126, 63, 0, 2152, 2150, 1, 0, 0, 0, 2152, 2153, 1, 0, 0, 0, 2153, 
	2156, 1, 0, 0, 0, 2154, 2155, 5, 140, 0, 0, 2155, 2157, 3, 338, 169, 0, 
	2156, 2154, 1, 0, 0, 0, 2156, 2157, 1, 0, 0, 0, 2157, 2160, 1, 0, 0, 0, 
	2158, 2159, 5, 318, 0, 0, 2159, 2161, 3, 14, 7, 0, 2160, 2158, 1, 0, 0, 
	0, 2160, 2161, 1, 0, 0, 0, 2161, 2163, 1, 0, 0, 0, 2162, 2164, 3, 318, 
	159, 0, 2163, 2162, 1, 0, 0, 0, 2163, 2164, 1, 0, 0, 0, 2164, 2167, 1, 
	0, 0, 0, 2165, 2166, 5, 150, 0, 0, 2166, 2168, 3, 14, 7, 0, 2167, 2165, 
	1, 0, 0, 0, 2167, 2168, 1, 0, 0, 0, 2168, 2170, 1, 0, 0, 0, 2169, 2171, 
	3, 730, 365, 0, 2170, 2169, 1, 0, 0, 0, 2170, 2171, 1, 0, 0, 0, 2171, 2173, 
	1, 0, 0, 0, 2172, 2174, 3, 316, 158, 0, 2173, 2172, 1, 0, 0, 0, 2173, 2174, 
	1, 0, 0, 0, 2174, 255, 1, 0, 0, 0, 2175, 2176, 5, 188, 0, 0, 2176, 2178, 
	5, 25, 0, 0, 2177, 2179, 3, 744, 372, 0, 2178, 2177, 1, 0, 0, 0, 2178, 
	2179, 1, 0, 0, 0, 2179, 2181, 1, 0, 0, 0, 2180, 2182, 3, 314, 157, 0, 2181, 
	2180, 1, 0, 0, 0, 2181, 2182, 1, 0, 0, 0, 2182, 2184, 1, 0, 0, 0, 2183, 
	2185, 3, 262, 131, 0, 2184, 2183, 1, 0, 0, 0, 2184, 2185, 1, 0, 0, 0, 2185, 
	2187, 1, 0, 0, 0, 2186, 2188, 3, 258, 129, 0, 2187, 2186, 1, 0, 0, 0, 2187, 
	2188, 1, 0, 0, 0, 2188, 2189, 1, 0, 0, 0, 2189, 2190, 3, 268, 134, 0, 2190, 
	2191, 5, 26, 0, 0, 2191, 257, 1, 0, 0, 0, 2192, 2193, 5, 207, 0, 0, 2193, 
	2194, 5, 261, 0, 0, 2194, 2195, 5, 222, 0, 0, 2195, 2204, 5, 186, 0, 0, 
	2196, 2197, 5, 42, 0, 0, 2197, 2198, 5, 262, 0, 0, 2198, 2199, 5, 222, 
	0, 0, 2199, 2201, 5, 186, 0, 0, 2200, 2202, 3, 260, 130, 0, 2201, 2200, 
	1, 0, 0, 0, 2201, 2202, 1, 0, 0, 0, 2202, 2204, 1, 0, 0, 0, 2203, 2192, 
	1, 0, 0, 0, 2203, 2196, 1, 0, 0, 0, 2204, 259, 1, 0, 0, 0, 2205, 2206, 
	5, 272, 0, 0, 2206, 2207, 5, 113, 0, 0, 2207, 2215, 5, 187, 0, 0, 2208, 
	2209, 5, 205, 0, 0, 2209, 2210, 5, 113, 0, 0, 2210, 2215, 5, 187, 0, 0, 
	2211, 2212, 5, 320, 0, 0, 2212, 2213, 5, 306, 0, 0, 2213, 2215, 5, 262, 
	0, 0, 2214, 2205, 1, 0, 0, 0, 2214, 2208, 1, 0, 0, 0, 2214, 2211, 1, 0, 
	0, 0, 2215, 261, 1, 0, 0, 0, 2216, 2217, 5, 189, 0, 0, 2217, 2218, 3, 264, 
	132, 0, 2218, 263, 1, 0, 0, 0, 2219, 2224, 3, 266, 133, 0, 2220, 2221, 
	5, 24, 0, 0, 2221, 2223, 3, 266, 133, 0, 2222, 2220, 1, 0, 0, 0, 2223, 
	2226, 1, 0, 0, 0, 2224, 2222, 1, 0, 0, 0, 2224, 2225, 1, 0, 0, 0, 2225, 
	265, 1, 0, 0, 0, 2226, 2224, 1, 0, 0, 0, 2227, 2228, 3, 14, 7, 0, 2228, 
	2229, 5, 49, 0, 0, 2229, 2230, 3, 800, 400, 0, 2230, 267, 1, 0, 0, 0, 2231, 
	2232, 5, 41, 0, 0, 2232, 2233, 5, 186, 0, 0, 2233, 2235, 3, 270, 135, 0, 
	2234, 2231, 1, 0, 0, 0, 2234, 2235, 1, 0, 0, 0, 2235, 2237, 1, 0, 0, 0, 
	2236, 2238, 3, 274, 137, 0, 2237, 2236, 1, 0, 0, 0, 2237, 2238, 1, 0, 0, 
	0, 2238, 2239, 1, 0, 0, 0, 2239, 2240, 5, 221, 0, 0, 2240, 2241, 5, 25, 
	0, 0, 2241, 2242, 3, 276, 138, 0, 2242, 2244, 5, 26, 0, 0, 2243, 2245, 
	3, 290, 145, 0, 2244, 2243, 1, 0, 0, 0, 2244, 2245, 1, 0, 0, 0, 2245, 2246, 
	1, 0, 0, 0, 2246, 2247, 5, 99, 0, 0, 2247, 2248, 3, 302, 151, 0, 2248, 
	269, 1, 0, 0, 0, 2249, 2250, 5, 273, 0, 0, 2250, 2251, 5, 294, 0, 0, 2251, 
	2252, 5, 195, 0, 0, 2252, 2269, 5, 261, 0, 0, 2253, 2254, 5, 273, 0, 0, 
	2254, 2255, 5, 220, 0, 0, 2255, 2256, 5, 177, 0, 0, 2256, 2269, 5, 261, 
	0, 0, 2257, 2258, 5, 273, 0, 0, 2258, 2259, 5, 294, 0, 0, 2259, 2260, 5, 
	134, 0, 0, 2260, 2269, 3, 272, 136, 0, 2261, 2262, 5, 273, 0, 0, 2262, 
	2263, 5, 294, 0, 0, 2263, 2264, 5, 177, 0, 0, 2264, 2269, 3, 272, 136, 
	0, 2265, 2266, 5, 273, 0, 0, 2266, 2267, 5, 294, 0, 0, 2267, 2269, 3, 272, 
	136, 0, 2268, 2249, 1, 0, 0, 0, 2268, 2253, 1, 0, 0, 0, 2268, 2257, 1, 
	0, 0, 0, 2268, 2261, 1, 0, 0, 0, 2268, 2265, 1, 0, 0, 0, 2269, 271, 1, 
	0, 0, 0, 2270, 2271, 3, 312, 156, 0, 2271, 273, 1, 0, 0, 0, 2272, 2273, 
	7, 12, 0, 0, 2273, 275, 1, 0, 0, 0, 2274, 2279, 3, 278, 139, 0, 2275, 2276, 
	5, 12, 0, 0, 2276, 2278, 3, 278, 139, 0, 2277, 2275, 1, 0, 0, 0, 2278, 
	2281, 1, 0, 0, 0, 2279, 2277, 1, 0, 0, 0, 2279, 2280, 1, 0, 0, 0, 2280, 
	277, 1, 0, 0, 0, 2281, 2279, 1, 0, 0, 0, 2282, 2284, 3, 280, 140, 0, 2283, 
	2282, 1, 0, 0, 0, 2284, 2285, 1, 0, 0, 0, 2285, 2283, 1, 0, 0, 0, 2285, 
	2286, 1, 0, 0, 0, 2286, 279, 1, 0, 0, 0, 2287, 2289, 3, 284, 142, 0, 2288, 
	2290, 3, 282, 141, 0, 2289, 2288, 1, 0, 0, 0, 2289, 2290, 1, 0, 0, 0, 2290, 
	281, 1, 0, 0, 0, 2291, 2293, 5, 19, 0, 0, 2292, 2294, 5, 27, 0, 0, 2293, 
	2292, 1, 0, 0, 0, 2293, 2294, 1, 0, 0, 0, 2294, 2320, 1, 0, 0, 0, 2295, 
	2297, 5, 16, 0, 0, 2296, 2298, 5, 27, 0, 0, 2297, 2296, 1, 0, 0, 0, 2297, 
	2298, 1, 0, 0, 0, 2298, 2320, 1, 0, 0, 0, 2299, 2301, 5, 27, 0, 0, 2300, 
	2302, 5, 27, 0, 0, 2301, 2300, 1, 0, 0, 0, 2301, 2302, 1, 0, 0, 0, 2302, 
	2320, 1, 0, 0, 0, 2303, 2305, 5, 31, 0, 0, 2304, 2306, 3, 864, 432, 0, 
	2305, 2304, 1, 0, 0, 0, 2305, 2306, 1, 0, 0, 0, 2306, 2307, 1, 0, 0, 0, 
	2307, 2309, 5, 24, 0, 0, 2308, 2310, 3, 864, 432, 0, 2309, 2308, 1, 0, 
	0, 0, 2309, 2310, 1, 0, 0, 0, 2310, 2311, 1, 0, 0, 0, 2311, 2313, 5, 32, 
	0, 0, 2312, 2314, 5, 27, 0, 0, 2313, 2312, 1, 0, 0, 0, 2313, 2314, 1, 0, 
	0, 0, 2314, 2320, 1, 0, 0, 0, 2315, 2316, 5, 31, 0, 0, 2316, 2317, 3, 864, 
	432, 0, 2317, 2318, 5, 32, 0, 0, 2318, 2320, 1, 0, 0, 0, 2319, 2291, 1, 
	0, 0, 0, 2319, 2295, 1, 0, 0, 0, 2319, 2299, 1, 0, 0, 0, 2319, 2303, 1, 
	0, 0, 0, 2319, 2315, 1, 0, 0, 0, 2320, 283, 1, 0, 0, 0, 2321, 2337, 3, 
	286, 143, 0, 2322, 2337, 5, 30, 0, 0, 2323, 2337, 5, 33, 0, 0, 2324, 2326, 
	5, 25, 0, 0, 2325, 2327, 3, 276, 138, 0, 2326, 2325, 1, 0, 0, 0, 2326, 
	2327, 1, 0, 0, 0, 2327, 2328, 1, 0, 0, 0, 2328, 2337, 5, 26, 0, 0, 2329, 
	2330, 5, 31, 0, 0, 2330, 2331, 5, 17, 0, 0, 2331, 2332, 3, 276, 138, 0, 
	2332, 2333, 5, 17, 0, 0, 2333, 2334, 5, 32, 0, 0, 2334, 2337, 1, 0, 0, 
	0, 2335, 2337, 3, 288, 144, 0, 2336, 2321, 1, 0, 0, 0, 2336, 2322, 1, 0, 
	0, 0, 2336, 2323, 1, 0, 0, 0, 2336, 2324, 1, 0, 0, 0, 2336, 2329, 1, 0, 
	0, 0, 2336, 2335, 1, 0, 0, 0, 2337, 285, 1, 0, 0, 0, 2338, 2339, 3, 312, 
	156, 0, 2339, 287, 1, 0, 0, 0, 2340, 2341, 5, 223, 0, 0, 2341, 2342, 5, 
	25, 0, 0, 2342, 2347, 3, 276, 138, 0, 2343, 2344, 5, 24, 0, 0, 2344, 2346, 
	3, 276, 138, 0, 2345, 2343, 1, 0, 0, 0, 2346, 2349, 1, 0, 0, 0, 2347, 2345, 
	1, 0, 0, 0, 2347, 2348, 1, 0, 0, 0, 2348, 2350, 1, 0, 0, 0, 2349, 2347, 
	1, 0, 0, 0, 2350, 2351, 5, 26, 0, 0, 2351, 289, 1, 0, 0, 0, 2352, 2353, 
	5, 280, 0, 0, 2353, 2354, 3, 292, 146, 0, 2354, 291, 1, 0, 0, 0, 2355, 
	2360, 3, 294, 147, 0, 2356, 2357, 5, 24, 0, 0, 2357, 2359, 3, 294, 147, 
	0, 2358, 2356, 1, 0, 0, 0, 2359, 2362, 1, 0, 0, 0, 2360, 2358, 1, 0, 0, 
	0, 2360, 2361, 1, 0, 0, 0, 2361, 293, 1, 0, 0, 0, 2362, 2360, 1, 0, 0, 
	0, 2363, 2364, 3, 296, 148, 0, 2364, 2365, 5, 1, 0, 0, 2365, 2366, 5, 25, 
	0, 0, 2366, 2367, 3, 298, 149, 0, 2367, 2368, 5, 26, 0, 0, 2368, 295, 1, 
	0, 0, 0, 2369, 2370, 3, 312, 156, 0, 2370, 297, 1, 0, 0, 0, 2371, 2376, 
	3, 300, 150, 0, 2372, 2373, 5, 24, 0, 0, 2373, 2375, 3, 300, 150, 0, 2374, 
	2372, 1, 0, 0, 0, 2375, 2378, 1, 0, 0, 0, 2376, 2374, 1, 0, 0, 0, 2376, 
	2377, 1, 0, 0, 0, 2377, 299, 1, 0, 0, 0, 2378, 2376, 1, 0, 0, 0, 2379, 
	2380, 3, 312, 156, 0, 2380, 301, 1, 0, 0, 0, 2381, 2386, 3, 304, 152, 0, 
	2382, 2383, 5, 24, 0, 0, 2383, 2385, 3, 304, 152, 0, 2384, 2382, 1, 0, 
	0, 0, 2385, 2388, 1, 0, 0, 0, 2386, 2384, 1, 0, 0, 0, 2386, 2387, 1, 0, 
	0, 0, 2387, 303, 1, 0, 0, 0, 2388, 2386, 1, 0, 0, 0, 2389, 2390, 3, 306, 
	153, 0, 2390, 2391, 5, 49, 0, 0, 2391, 2392, 3, 308, 154, 0, 2392, 305, 
	1, 0, 0, 0, 2393, 2394, 3, 312, 156, 0, 2394, 307, 1, 0, 0, 0, 2395, 2396, 
	3, 310, 155, 0, 2396, 309, 1, 0, 0, 0, 2397, 2398, 3, 14, 7, 0, 2398, 311, 
	1, 0, 0, 0, 2399, 2400, 3, 780, 390, 0, 2400, 313, 1, 0, 0, 0, 2401, 2402, 
	5, 212, 0, 0, 2402, 2403, 5, 66, 0, 0, 2403, 2404, 3, 230, 115, 0, 2404, 
	315, 1, 0, 0, 0, 2405, 2407, 5, 51, 0, 0, 2406, 2405, 1, 0, 0, 0, 2406, 
	2407, 1, 0, 0, 0, 2407, 2408, 1, 0, 0, 0, 2408, 2409, 3, 314, 157, 0, 2409, 
	317, 1, 0, 0, 0, 2410, 2412, 5, 146, 0, 0, 2411, 2413, 5, 78, 0, 0, 2412, 
	2411, 1, 0, 0, 0, 2412, 2413, 1, 0, 0, 0, 2413, 2414, 1, 0, 0, 0, 2414, 
	2415, 5, 66, 0, 0, 2415, 2416, 3, 252, 126, 0, 2416, 2419, 3, 320, 160, 
	0, 2417, 2418, 5, 320, 0, 0, 2418, 2420, 3, 800, 400, 0, 2419, 2417, 1, 
	0, 0, 0, 2419, 2420, 1, 0, 0, 0, 2420, 319, 1, 0, 0, 0, 2421, 2426, 3, 
	322, 161, 0, 2422, 2423, 5, 24, 0, 0, 2423, 2425, 3, 322, 161, 0, 2424, 
	2422, 1, 0, 0, 0, 2425, 2428, 1, 0, 0, 0, 2426, 2424, 1, 0, 0, 0, 2426, 
	2427, 1, 0, 0, 0, 2427, 321, 1, 0, 0, 0, 2428, 2426, 1, 0, 0, 0, 2429, 
	2435, 3, 324, 162, 0, 2430, 2435, 3, 328, 164, 0, 2431, 2435, 3, 330, 165, 
	0, 2432, 2435, 3, 332, 166, 0, 2433, 2435, 3, 334, 167, 0, 2434, 2429, 
	1, 0, 0, 0, 2434, 2430, 1, 0, 0, 0, 2434, 2431, 1, 0, 0, 0, 2434, 2432, 
	1, 0, 0, 0, 2434, 2433, 1, 0, 0, 0, 2435, 323, 1, 0, 0, 0, 2436, 2437, 
	3, 128, 64, 0, 2437, 325, 1, 0, 0, 0, 2438, 2443, 3, 324, 162, 0, 2439, 
	2440, 5, 24, 0, 0, 2440, 2442, 3, 324, 162, 0, 2441, 2439, 1, 0, 0, 0, 
	2442, 2445, 1, 0, 0, 0, 2443, 2441, 1, 0, 0, 0, 2443, 2444, 1, 0, 0, 0, 
	2444, 327, 1, 0, 0, 0, 2445, 2443, 1, 0, 0, 0, 2446, 2447, 5, 260, 0, 0, 
	2447, 2448, 5, 25, 0, 0, 2448, 2449, 3, 326, 163, 0, 2449, 2450, 5, 26, 
	0, 0, 2450, 329, 1, 0, 0, 0, 2451, 2452, 5, 87, 0, 0, 2452, 2453, 5, 25, 
	0, 0, 2453, 2454, 3, 326, 163, 0, 2454, 2455, 5, 26, 0, 0, 2455, 331, 1, 
	0, 0, 0, 2456, 2457, 5, 147, 0, 0, 2457, 2458, 5, 271, 0, 0, 2458, 2459, 
	5, 25, 0, 0, 2459, 2460, 3, 320, 160, 0, 2460, 2461, 5, 26, 0, 0, 2461, 
	333, 1, 0, 0, 0, 2462, 2463, 5, 151, 0, 0, 2463, 2464, 5, 25, 0, 0, 2464, 
	2465, 3, 14, 7, 0, 2465, 2466, 5, 24, 0, 0, 2466, 2467, 3, 14, 7, 0, 2467, 
	2468, 5, 24, 0, 0, 2468, 2469, 3, 14, 7, 0, 2469, 2470, 5, 24, 0, 0, 2470, 
	2471, 3, 14, 7, 0, 2471, 2472, 5, 26, 0, 0, 2472, 335, 1, 0, 0, 0, 2473, 
	2474, 3, 824, 412, 0, 2474, 2475, 5, 19, 0, 0, 2475, 2483, 1, 0, 0, 0, 
	2476, 2480, 3, 14, 7, 0, 2477, 2478, 5, 49, 0, 0, 2478, 2481, 3, 802, 401, 
	0, 2479, 2481, 3, 820, 410, 0, 2480, 2477, 1, 0, 0, 0, 2480, 2479, 1, 0, 
	0, 0, 2480, 2481, 1, 0, 0, 0, 2481, 2483, 1, 0, 0, 0, 2482, 2473, 1, 0, 
	0, 0, 2482, 2476, 1, 0, 0, 0, 2483, 337, 1, 0, 0, 0, 2484, 2486, 5, 47, 
	0, 0, 2485, 2484, 1, 0, 0, 0, 2485, 2486, 1, 0, 0, 0, 2486, 2487, 1, 0, 
	0, 0, 2487, 2498, 3, 344, 172, 0, 2488, 2490, 3, 358, 179, 0, 2489, 2491, 
	5, 47, 0, 0, 2490, 2489, 1, 0, 0, 0, 2490, 2491, 1, 0, 0, 0, 2491, 2492, 
	1, 0, 0, 0, 2492, 2494, 3, 344, 172, 0, 2493, 2495, 3, 360, 180, 0, 2494, 
	2493, 1, 0, 0, 0, 2494, 2495, 1, 0, 0, 0, 2495, 2497, 1, 0, 0, 0, 2496, 
	2488, 1, 0, 0, 0, 2497, 2500, 1, 0, 0, 0, 2498, 2496, 1, 0, 0, 0, 2498, 
	2499, 1, 0, 0, 0, 2499, 339, 1, 0, 0, 0, 2500, 2498, 1, 0, 0, 0, 2501, 
	2504, 3, 120, 60, 0, 2502, 2503, 5, 49, 0, 0, 2503, 2505, 3, 800, 400, 
	0, 2504, 2502, 1, 0, 0, 0, 2504, 2505, 1, 0, 0, 0, 2505, 341, 1, 0, 0, 
	0, 2506, 2515, 3, 340, 170, 0, 2507, 2508, 5, 25, 0, 0, 2508, 2510, 3, 
	130, 65, 0, 2509, 2511, 5, 24, 0, 0, 2510, 2509, 1, 0, 0, 0, 2510, 2511, 
	1, 0, 0, 0, 2511, 2512, 1, 0, 0, 0, 2512, 2513, 5, 26, 0, 0, 2513, 2515, 
	1, 0, 0, 0, 2514, 2506, 1, 0, 0, 0, 2514, 2507, 1, 0, 0, 0, 2515, 343, 
	1, 0, 0, 0, 2516, 2526, 3, 346, 173, 0, 2517, 2524, 5, 135, 0, 0, 2518, 
	2520, 7, 13, 0, 0, 2519, 2518, 1, 0, 0, 0, 2519, 2520, 1, 0, 0, 0, 2520, 
	2521, 1, 0, 0, 0, 2521, 2522, 5, 66, 0, 0, 2522, 2525, 3, 342, 171, 0, 
	2523, 2525, 5, 76, 0, 0, 2524, 2519, 1, 0, 0, 0, 2524, 2523, 1, 0, 0, 0, 
	2525, 2527, 1, 0, 0, 0, 2526, 2517, 1, 0, 0, 0, 2526, 2527, 1, 0, 0, 0, 
	2527, 345, 1, 0, 0, 0, 2528, 2530, 3, 348, 174, 0, 2529, 2531, 3, 256, 
	128, 0, 2530, 2529, 1, 0, 0, 0, 2530, 2531, 1, 0, 0, 0, 2531, 2540, 1, 
	0, 0, 0, 2532, 2533, 5, 49, 0, 0, 2533, 2536, 3, 800, 400, 0, 2534, 2536, 
	3, 820, 410, 0, 2535, 2532, 1, 0, 0, 0, 2535, 2534, 1, 0, 0, 0, 2536, 2538, 
	1, 0, 0, 0, 2537, 2539, 3, 114, 57, 0, 2538, 2537, 1, 0, 0, 0, 2538, 2539, 
	1, 0, 0, 0, 2539, 2541, 1, 0, 0, 0, 2540, 2535, 1, 0, 0, 0, 2540, 2541, 
	1, 0, 0, 0, 2541, 2544, 1, 0, 0, 0, 2542, 2545, 3, 350, 175, 0, 2543, 2545, 
	3, 352, 176, 0, 2544, 2542, 1, 0, 0, 0, 2544, 2543, 1, 0, 0, 0, 2544, 2545, 
	1, 0, 0, 0, 2545, 347, 1, 0, 0, 0, 2546, 2556, 3, 638, 319, 0, 2547, 2548, 
	5, 25, 0, 0, 2548, 2549, 3, 232, 116, 0, 2549, 2550, 5, 26, 0, 0, 2550, 
	2556, 1, 0, 0, 0, 2551, 2552, 5, 25, 0, 0, 2552, 2553, 3, 368, 184, 0, 
	2553, 2554, 5, 26, 0, 0, 2554, 2556, 1, 0, 0, 0, 2555, 2546, 1, 0, 0, 0, 
	2555, 2547, 1, 0, 0, 0, 2555, 2551, 1, 0, 0, 0, 2556, 349, 1, 0, 0, 0, 
	2557, 2558, 5, 263, 0, 0, 2558, 2559, 3, 14, 7, 0, 2559, 351, 1, 0, 0, 
	0, 2560, 2561, 5, 287, 0, 0, 2561, 2562, 3, 354, 177, 0, 2562, 2563, 5, 
	25, 0, 0, 2563, 2564, 3, 14, 7, 0, 2564, 2566, 5, 26, 0, 0, 2565, 2567, 
	3, 356, 178, 0, 2566, 2565, 1, 0, 0, 0, 2566, 2567, 1, 0, 0, 0, 2567, 353, 
	1, 0, 0, 0, 2568, 2569, 7, 14, 0, 0, 2569, 355, 1, 0, 0, 0, 2570, 2571, 
	5, 243, 0, 0, 2571, 2572, 5, 25, 0, 0, 2572, 2573, 3, 14, 7, 0, 2573, 2574, 
	5, 26, 0, 0, 2574, 357, 1, 0, 0, 0, 2575, 2600, 5, 24, 0, 0, 2576, 2578, 
	5, 194, 0, 0, 2577, 2576, 1, 0, 0, 0, 2577, 2578, 1, 0, 0, 0, 2578, 2596, 
	1, 0, 0, 0, 2579, 2581, 5, 178, 0, 0, 2580, 2582, 7, 15, 0, 0, 2581, 2580, 
	1, 0, 0, 0, 2581, 2582, 1, 0, 0, 0, 2582, 2590, 1, 0, 0, 0, 2583, 2585, 
	5, 257, 0, 0, 2584, 2586, 7, 15, 0, 0, 2585, 2584, 1, 0, 0, 0, 2585, 2586, 
	1, 0, 0, 0, 2586, 2590, 1, 0, 0, 0, 2587, 2590, 5, 124, 0, 0, 2588, 2590, 
	5, 141, 0, 0, 2589, 2579, 1, 0, 0, 0, 2589, 2583, 1, 0, 0, 0, 2589, 2587, 
	1, 0, 0, 0, 2589, 2588, 1, 0, 0, 0, 2589, 2590, 1, 0, 0, 0, 2590, 2592, 
	1, 0, 0, 0, 2591, 2593, 5, 214, 0, 0, 2592, 2591, 1, 0, 0, 0, 2592, 2593, 
	1, 0, 0, 0, 2593, 2597, 1, 0, 0, 0, 2594, 2597, 5, 165, 0, 0, 2595, 2597, 
	5, 86, 0, 0, 2596, 2589, 1, 0, 0, 0, 2596, 2594, 1, 0, 0, 0, 2596, 2595, 
	1, 0, 0, 0, 2597, 2598, 1, 0, 0, 0, 2598, 2600, 5, 172, 0, 0, 2599, 2575, 
	1, 0, 0, 0, 2599, 2577, 1, 0, 0, 0, 2600, 359, 1, 0, 0, 0, 2601, 2602, 
	5, 206, 0, 0, 2602, 2606, 3, 14, 7, 0, 2603, 2604, 5, 311, 0, 0, 2604, 
	2606, 3, 118, 59, 0, 2605, 2601, 1, 0, 0, 0, 2605, 2603, 1, 0, 0, 0, 2606, 
	361, 1, 0, 0, 0, 2607, 2617, 5, 254, 0, 0, 2608, 2618, 5, 19, 0, 0, 2609, 
	2614, 3, 800, 400, 0, 2610, 2611, 5, 24, 0, 0, 2611, 2613, 3, 800, 400, 
	0, 2612, 2610, 1, 0, 0, 0, 2613, 2616, 1, 0, 0, 0, 2614, 2612, 1, 0, 0, 
	0, 2614, 2615, 1, 0, 0, 0, 2615, 2618, 1, 0, 0, 0, 2616, 2614, 1, 0, 0, 
	0, 2617, 2608, 1, 0, 0, 0, 2617, 2609, 1, 0, 0, 0, 2618, 363, 1, 0, 0, 
	0, 2619, 2632, 5, 166, 0, 0, 2620, 2621, 5, 166, 0, 0, 2621, 2622, 5, 211, 
	0, 0, 2622, 2632, 5, 38, 0, 0, 2623, 2624, 5, 166, 0, 0, 2624, 2625, 5, 
	211, 0, 0, 2625, 2632, 5, 255, 0, 0, 2626, 2627, 5, 166, 0, 0, 2627, 2628, 
	5, 211, 0, 0, 2628, 2632, 5, 153, 0, 0, 2629, 2632, 5, 308, 0, 0, 2630, 
	2632, 5, 244, 0, 0, 2631, 2619, 1, 0, 0, 0, 2631, 2620, 1, 0, 0, 0, 2631, 
	2623, 1, 0, 0, 0, 2631, 2626, 1, 0, 0, 0, 2631, 2629, 1, 0, 0, 0, 2631, 
	2630, 1, 0, 0, 0, 2632, 2633, 1, 0, 0, 0, 2633, 2634, 5, 169, 0, 0, 2634, 
	2635, 3, 654, 327, 0, 2635, 2637, 3, 366, 183, 0, 2636, 2638, 3, 362, 181, 
	0, 2637, 2636, 1, 0, 0, 0, 2637, 2638, 1, 0, 0, 0, 2638, 365, 1, 0, 0, 
	0, 2639, 2641, 3, 114, 57, 0, 2640, 2639, 1, 0, 0, 0, 2640, 2641, 1, 0, 
	0, 0, 2641, 2642, 1, 0, 0, 0, 2642, 2646, 3, 370, 185, 0, 2643, 2644, 5, 
	96, 0, 0, 2644, 2646, 5, 313, 0, 0, 2645, 2640, 1, 0, 0, 0, 2645, 2643, 
	1, 0, 0, 0, 2646, 367, 1, 0, 0, 0, 2647, 2648, 5, 313, 0, 0, 2648, 2649, 
	3, 372, 186, 0, 2649, 369, 1, 0, 0, 0, 2650, 2653, 3, 368, 184, 0, 2651, 
	2653, 3, 232, 116, 0, 2652, 2650, 1, 0, 0, 0, 2652, 2651, 1, 0, 0, 0, 2653, 
	371, 1, 0, 0, 0, 2654, 2659, 3, 374, 187, 0, 2655, 2656, 5, 24, 0, 0, 2656, 
	2658, 3, 374, 187, 0, 2657, 2655, 1, 0, 0, 0, 2658, 2661, 1, 0, 0, 0, 2659, 
	2657, 1, 0, 0, 0, 2659, 2660, 1, 0, 0, 0, 2660, 373, 1, 0, 0, 0, 2661, 
	2659, 1, 0, 0, 0, 2662, 2663, 5, 25, 0, 0, 2663, 2664, 3, 112, 56, 0, 2664, 
	2665, 5, 26, 0, 0, 2665, 375, 1, 0, 0, 0, 2666, 2669, 3, 112, 56, 0, 2667, 
	2669, 3, 232, 116, 0, 2668, 2666, 1, 0, 0, 0, 2668, 2667, 1, 0, 0, 0, 2669, 
	377, 1, 0, 0, 0, 2670, 2673, 5, 85, 0, 0, 2671, 2672, 5, 211, 0, 0, 2672, 
	2674, 5, 244, 0, 0, 2673, 2671, 1, 0, 0, 0, 2673, 2674, 1, 0, 0, 0, 2674, 
	2675, 1, 0, 0, 0, 2675, 2676, 5, 129, 0, 0, 2676, 2677, 5, 92, 0, 0, 2677, 
	2681, 5, 275, 0, 0, 2678, 2679, 5, 152, 0, 0, 2679, 2680, 5, 198, 0, 0, 
	2680, 2682, 5, 126, 0, 0, 2681, 2678, 1, 0, 0, 0, 2681, 2682, 1, 0, 0, 
	0, 2682, 2683, 1, 0, 0, 0, 2683, 2684, 3, 648, 324, 0, 2684, 2685, 3, 454, 
	227, 0, 2685, 379, 1, 0, 0, 0, 2686, 2687, 5, 43, 0, 0, 2687, 2688, 5, 
	129, 0, 0, 2688, 2689, 5, 92, 0, 0, 2689, 2690, 5, 275, 0, 0, 2690, 2691, 
	3, 648, 324, 0, 2691, 2696, 3, 382, 191, 0, 2692, 2693, 5, 24, 0, 0, 2693, 
	2695, 3, 382, 191, 0, 2694, 2692, 1, 0, 0, 0, 2695, 2698, 1, 0, 0, 0, 2696, 
	2694, 1, 0, 0, 0, 2696, 2697, 1, 0, 0, 0, 2697, 381, 1, 0, 0, 0, 2698, 
	2696, 1, 0, 0, 0, 2699, 2703, 3, 486, 243, 0, 2700, 2703, 3, 488, 244, 
	0, 2701, 2703, 3, 490, 245, 0, 2702, 2699, 1, 0, 0, 0, 2702, 2700, 1, 0, 
	0, 0, 2702, 2701, 1, 0, 0, 0, 2703, 383, 1, 0, 0, 0, 2704, 2705, 5, 110, 
	0, 0, 2705, 2706, 5, 129, 0, 0, 2706, 2707, 5, 92, 0, 0, 2707, 2710, 5, 
	275, 0, 0, 2708, 2709, 5, 152, 0, 0, 2709, 2711, 5, 126, 0, 0, 2710, 2708, 
	1, 0, 0, 0, 2710, 2711, 1, 0, 0, 0, 2711, 2712, 1, 0, 0, 0, 2712, 2713, 
	3, 648, 324, 0, 2713, 385, 1, 0, 0, 0, 2714, 2715, 5, 85, 0, 0, 2715, 2719, 
	5, 315, 0, 0, 2716, 2717, 5, 152, 0, 0, 2717, 2718, 5, 198, 0, 0, 2718, 
	2720, 5, 126, 0, 0, 2719, 2716, 1, 0, 0, 0, 2719, 2720, 1, 0, 0, 0, 2720, 
	2721, 1, 0, 0, 0, 2721, 2723, 3, 648, 324, 0, 2722, 2724, 3, 394, 197, 
	0, 2723, 2722, 1, 0, 0, 0, 2723, 2724, 1, 0, 0, 0, 2724, 2725, 1, 0, 0, 
	0, 2725, 2726, 5, 49, 0, 0, 2726, 2727, 3, 232, 116, 0, 2727, 387, 1, 0, 
	0, 0, 2728, 2729, 5, 110, 0, 0, 2729, 2732, 5, 315, 0, 0, 2730, 2731, 5, 
	152, 0, 0, 2731, 2733, 5, 126, 0, 0, 2732, 2730, 1, 0, 0, 0, 2732, 2733, 
	1, 0, 0, 0, 2733, 2734, 1, 0, 0, 0, 2734, 2735, 3, 648, 324, 0, 2735, 389, 
	1, 0, 0, 0, 2736, 2737, 5, 308, 0, 0, 2737, 2738, 5, 202, 0, 0, 2738, 2739, 
	3, 648, 324, 0, 2739, 2740, 5, 25, 0, 0, 2740, 2741, 5, 300, 0, 0, 2741, 
	2742, 3, 414, 207, 0, 2742, 2744, 5, 26, 0, 0, 2743, 2745, 3, 394, 197, 
	0, 2744, 2743, 1, 0, 0, 0, 2744, 2745, 1, 0, 0, 0, 2745, 391, 1, 0, 0, 
	0, 2746, 2747, 5, 85, 0, 0, 2747, 2751, 5, 202, 0, 0, 2748, 2749, 5, 152, 
	0, 0, 2749, 2750, 5, 198, 0, 0, 2750, 2752, 5, 126, 0, 0, 2751, 2748, 1, 
	0, 0, 0, 2751, 2752, 1, 0, 0, 0, 2752, 2753, 1, 0, 0, 0, 2753, 2754, 3, 
	648, 324, 0, 2754, 2755, 5, 25, 0, 0, 2755, 2756, 5, 300, 0, 0, 2756, 2757, 
	3, 414, 207, 0, 2757, 2759, 5, 26, 0, 0, 2758, 2760, 3, 394, 197, 0, 2759, 
	2758, 1, 0, 0, 0, 2759, 2760, 1, 0, 0, 0, 2760, 393, 1, 0, 0, 0, 2761, 
	2762, 5, 320, 0, 0, 2762, 2763, 3, 412, 206, 0, 2763, 395, 1, 0, 0, 0, 
	2764, 2765, 5, 43, 0, 0, 2765, 2766, 5, 202, 0, 0, 2766, 2767, 3, 648, 
	324, 0, 2767, 2768, 5, 25, 0, 0, 2768, 2769, 5, 300, 0, 0, 2769, 2770, 
	3, 414, 207, 0, 2770, 2771, 5, 26, 0, 0, 2771, 2772, 3, 398, 199, 0, 2772, 
	397, 1, 0, 0, 0, 2773, 2774, 5, 270, 0, 0, 2774, 2775, 3, 412, 206, 0, 
	2775, 399, 1, 0, 0, 0, 2776, 2777, 5, 110, 0, 0, 2777, 2780, 5, 202, 0, 
	0, 2778, 2779, 5, 152, 0, 0, 2779, 2781, 5, 126, 0, 0, 2780, 2778, 1, 0, 
	0, 0, 2780, 2781, 1, 0, 0, 0, 2781, 2782, 1, 0, 0, 0, 2782, 2783, 3, 648, 
	324, 0, 2783, 2784, 5, 25, 0, 0, 2784, 2785, 5, 300, 0, 0, 2785, 2786, 
	3, 414, 207, 0, 2786, 2788, 5, 26, 0, 0, 2787, 2789, 3, 402, 201, 0, 2788, 
	2787, 1, 0, 0, 0, 2788, 2789, 1, 0, 0, 0, 2789, 401, 1, 0, 0, 0, 2790, 
	2791, 5, 320, 0, 0, 2791, 2792, 3, 412, 206, 0, 2792, 403, 1, 0, 0, 0, 
	2793, 2798, 3, 828, 414, 0, 2794, 2798, 3, 144, 72, 0, 2795, 2798, 5, 324, 
	0, 0, 2796, 2798, 3, 860, 430, 0, 2797, 2793, 1, 0, 0, 0, 2797, 2794, 1, 
	0, 0, 0, 2797, 2795, 1, 0, 0, 0, 2797, 2796, 1, 0, 0, 0, 2798, 405, 1, 
	0, 0, 0, 2799, 2800, 3, 802, 401, 0, 2800, 2801, 5, 1, 0, 0, 2801, 2802, 
	3, 404, 202, 0, 2802, 407, 1, 0, 0, 0, 2803, 2804, 3, 802, 401, 0, 2804, 
	409, 1, 0, 0, 0, 2805, 2808, 3, 406, 203, 0, 2806, 2808, 3, 408, 204, 0, 
	2807, 2805, 1, 0, 0, 0, 2807, 2806, 1, 0, 0, 0, 2808, 411, 1, 0, 0, 0, 
	2809, 2822, 3, 410, 205, 0, 2810, 2811, 5, 25, 0, 0, 2811, 2816, 3, 410, 
	205, 0, 2812, 2813, 5, 24, 0, 0, 2813, 2815, 3, 410, 205, 0, 2814, 2812, 
	1, 0, 0, 0, 2815, 2818, 1, 0, 0, 0, 2816, 2814, 1, 0, 0, 0, 2816, 2817, 
	1, 0, 0, 0, 2817, 2819, 1, 0, 0, 0, 2818, 2816, 1, 0, 0, 0, 2819, 2820, 
	5, 26, 0, 0, 2820, 2822, 1, 0, 0, 0, 2821, 2809, 1, 0, 0, 0, 2821, 2810, 
	1, 0, 0, 0, 2822, 413, 1, 0, 0, 0, 2823, 2824, 3, 802, 401, 0, 2824, 415, 
	1, 0, 0, 0, 2825, 2828, 5, 85, 0, 0, 2826, 2827, 5, 211, 0, 0, 2827, 2829, 
	5, 244, 0, 0, 2828, 2826, 1, 0, 0, 0, 2828, 2829, 1, 0, 0, 0, 2829, 2838, 
	1, 0, 0, 0, 2830, 2839, 5, 285, 0, 0, 2831, 2839, 5, 288, 0, 0, 2832, 2833, 
	5, 129, 0, 0, 2833, 2839, 5, 285, 0, 0, 2834, 2835, 5, 290, 0, 0, 2835, 
	2839, 5, 285, 0, 0, 2836, 2837, 5, 291, 0, 0, 2837, 2839, 5, 285, 0, 0, 
	2838, 2830, 1, 0, 0, 0, 2838, 2831, 1, 0, 0, 0, 2838, 2832, 1, 0, 0, 0, 
	2838, 2834, 1, 0, 0, 0, 2838, 2836, 1, 0, 0, 0, 2839, 2843, 1, 0, 0, 0, 
	2840, 2841, 5, 152, 0, 0, 2841, 2842, 5, 198, 0, 0, 2842, 2844, 5, 126, 
	0, 0, 2843, 2840, 1, 0, 0, 0, 2843, 2844, 1, 0, 0, 0, 2844, 2845, 1, 0, 
	0, 0, 2845, 2846, 3, 652, 326, 0, 2846, 2847, 5, 25, 0, 0, 2847, 2852, 
	3, 418, 209, 0, 2848, 2849, 5, 24, 0, 0, 2849, 2851, 3, 418, 209, 0, 2850, 
	2848, 1, 0, 0, 0, 2851, 2854, 1, 0, 0, 0, 2852, 2850, 1, 0, 0, 0, 2852, 
	2853, 1, 0, 0, 0, 2853, 2856, 1, 0, 0, 0, 2854, 2852, 1, 0, 0, 0, 2855, 
	2857, 5, 24, 0, 0, 2856, 2855, 1, 0, 0, 0, 2856, 2857, 1, 0, 0, 0, 2857, 
	2858, 1, 0, 0, 0, 2858, 2860, 5, 26, 0, 0, 2859, 2861, 3, 450, 225, 0, 
	2860, 2859, 1, 0, 0, 0, 2860, 2861, 1, 0, 0, 0, 2861, 2863, 1, 0, 0, 0, 
	2862, 2864, 3, 452, 226, 0, 2863, 2862, 1, 0, 0, 0, 2863, 2864, 1, 0, 0, 
	0, 2864, 2866, 1, 0, 0, 0, 2865, 2867, 3, 454, 227, 0, 2866, 2865, 1, 0, 
	0, 0, 2866, 2867, 1, 0, 0, 0, 2867, 2869, 1, 0, 0, 0, 2868, 2870, 3, 456, 
	228, 0, 2869, 2868, 1, 0, 0, 0, 2869, 2870, 1, 0, 0, 0, 2870, 2872, 1, 
	0, 0, 0, 2871, 2873, 3, 460, 230, 0, 2872, 2871, 1, 0, 0, 0, 2872, 2873, 
	1, 0, 0, 0, 2873, 417, 1, 0, 0, 0, 2874, 2881, 3, 508, 254, 0, 2875, 2881, 
	3, 516, 258, 0, 2876, 2881, 3, 518, 259, 0, 2877, 2881, 3, 552, 276, 0, 
	2878, 2881, 3, 534, 267, 0, 2879, 2881, 3, 804, 402, 0, 2880, 2874, 1, 
	0, 0, 0, 2880, 2875, 1, 0, 0, 0, 2880, 2876, 1, 0, 0, 0, 2880, 2877, 1, 
	0, 0, 0, 2880, 2878, 1, 0, 0, 0, 2880, 2879, 1, 0, 0, 0, 2881, 419, 1, 
	0, 0, 0, 2882, 2883, 5, 85, 0, 0, 2883, 2885, 3, 440, 220, 0, 2884, 2886, 
	3, 426, 213, 0, 2885, 2884, 1, 0, 0, 0, 2885, 2886, 1, 0, 0, 0, 2886, 2887, 
	1, 0, 0, 0, 2887, 2888, 5, 320, 0, 0, 2888, 2889, 5, 25, 0, 0, 2889, 2890, 
	3, 442, 221, 0, 2890, 2891, 5, 26, 0, 0, 2891, 421, 1, 0, 0, 0, 2892, 2893, 
	5, 43, 0, 0, 2893, 2896, 3, 440, 220, 0, 2894, 2897, 3, 432, 216, 0, 2895, 
	2897, 3, 436, 218, 0, 2896, 2894, 1, 0, 0, 0, 2896, 2895, 1, 0, 0, 0, 2897, 
	423, 1, 0, 0, 0, 2898, 2899, 5, 110, 0, 0, 2899, 2900, 3, 440, 220, 0, 
	2900, 425, 1, 0, 0, 0, 2901, 2904, 5, 93, 0, 0, 2902, 2904, 3, 428, 214, 
	0, 2903, 2901, 1, 0, 0, 0, 2903, 2902, 1, 0, 0, 0, 2904, 427, 1, 0, 0, 
	0, 2905, 2906, 5, 25, 0, 0, 2906, 2907, 3, 430, 215, 0, 2907, 2908, 5, 
	26, 0, 0, 2908, 429, 1, 0, 0, 0, 2909, 2910, 5, 285, 0, 0, 2910, 2916, 
	3, 812, 406, 0, 2911, 2912, 5, 24, 0, 0, 2912, 2913, 5, 285, 0, 0, 2913, 
	2915, 3, 812, 406, 0, 2914, 2911, 1, 0, 0, 0, 2915, 2918, 1, 0, 0, 0, 2916, 
	2914, 1, 0, 0, 0, 2916, 2917, 1, 0, 0, 0, 2917, 431, 1, 0, 0, 0, 2918, 
	2916, 1, 0, 0, 0, 2919, 2924, 3, 434, 217, 0, 2920, 2921, 5, 24, 0, 0, 
	2921, 2923, 3, 434, 217, 0, 2922, 2920, 1, 0, 0, 0, 2923, 2926, 1, 0, 0, 
	0, 2924, 2922, 1, 0, 0, 0, 2924, 2925, 1, 0, 0, 0, 2925, 433, 1, 0, 0, 
	0, 2926, 2924, 1, 0, 0, 0, 2927, 2930, 3, 488, 244, 0, 2928, 2930, 3, 490, 
	245, 0, 2929, 2927, 1, 0, 0, 0, 2929, 2928, 1, 0, 0, 0, 2930, 435, 1, 0, 
	0, 0, 2931, 2936, 3, 438, 219, 0, 2932, 2933, 5, 24, 0, 0, 2933, 2935, 
	3, 438, 219, 0, 2934, 2932, 1, 0, 0, 0, 2935, 2938, 1, 0, 0, 0, 2936, 2934, 
	1, 0, 0, 0, 2936, 2937, 1, 0, 0, 0, 2937, 437, 1, 0, 0, 0, 2938, 2936, 
	1, 0, 0, 0, 2939, 2940, 5, 40, 0, 0, 2940, 2950, 5, 93, 0, 0, 2941, 2942, 
	5, 110, 0, 0, 2942, 2950, 5, 93, 0, 0, 2943, 2944, 5, 40, 0, 0, 2944, 2945, 
	5, 285, 0, 0, 2945, 2950, 3, 812, 406, 0, 2946, 2947, 5, 110, 0, 0, 2947, 
	2948, 5, 285, 0, 0, 2948, 2950, 3, 812, 406, 0, 2949, 2939, 1, 0, 0, 0, 
	2949, 2941, 1, 0, 0, 0, 2949, 2943, 1, 0, 0, 0, 2949, 2946, 1, 0, 0, 0, 
	2950, 439, 1, 0, 0, 0, 2951, 2952, 5, 59, 0, 0, 2952, 2953, 5, 60, 0, 0, 
	2953, 2954, 3, 648, 324, 0, 2954, 441, 1, 0, 0, 0, 2955, 2960, 3, 444, 
	222, 0, 2956, 2957, 5, 24, 0, 0, 2957, 2959, 3, 444, 222, 0, 2958, 2956, 
	1, 0, 0, 0, 2959, 2962, 1, 0, 0, 0, 2960, 2958, 1, 0, 0, 0, 2960, 2961, 
	1, 0, 0, 0, 2961, 443, 1, 0, 0, 0, 2962, 2960, 1, 0, 0, 0, 2963, 2964, 
	3, 800, 400, 0, 2964, 2965, 5, 1, 0, 0, 2965, 2966, 3, 546, 273, 0, 2966, 
	445, 1, 0, 0, 0, 2967, 2968, 5, 59, 0, 0, 2968, 2970, 3, 648, 324, 0, 2969, 
	2971, 5, 159, 0, 0, 2970, 2969, 1, 0, 0, 0, 2970, 2971, 1, 0, 0, 0, 2971, 
	447, 1, 0, 0, 0, 2972, 2973, 5, 250, 0, 0, 2973, 2976, 3, 648, 324, 0, 
	2974, 2975, 5, 54, 0, 0, 2975, 2977, 5, 324, 0, 0, 2976, 2974, 1, 0, 0, 
	0, 2976, 2977, 1, 0, 0, 0, 2977, 449, 1, 0, 0, 0, 2978, 2979, 5, 162, 0, 
	0, 2979, 2980, 5, 25, 0, 0, 2980, 2985, 3, 650, 325, 0, 2981, 2982, 5, 
	24, 0, 0, 2982, 2984, 3, 650, 325, 0, 2983, 2981, 1, 0, 0, 0, 2984, 2987, 
	1, 0, 0, 0, 2985, 2983, 1, 0, 0, 0, 2985, 2986, 1, 0, 0, 0, 2986, 2988, 
	1, 0, 0, 0, 2987, 2985, 1, 0, 0, 0, 2988, 2989, 5, 26, 0, 0, 2989, 451, 
	1, 0, 0, 0, 2990, 2991, 5, 217, 0, 0, 2991, 2992, 5, 66, 0, 0, 2992, 2993, 
	5, 149, 0, 0, 2993, 2994, 3, 114, 57, 0, 2994, 453, 1, 0, 0, 0, 2995, 2996, 
	5, 320, 0, 0, 2996, 2997, 5, 25, 0, 0, 2997, 3002, 3, 458, 229, 0, 2998, 
	2999, 5, 24, 0, 0, 2999, 3001, 3, 458, 229, 0, 3000, 2998, 1, 0, 0, 0, 
	3001, 3004, 1, 0, 0, 0, 3002, 3000, 1, 0, 0, 0, 3002, 3003, 1, 0, 0, 0, 
	3003, 3005, 1, 0, 0, 0, 3004, 3002, 1, 0, 0, 0, 3005, 3006, 5, 26, 0, 0, 
	3006, 455, 1, 0, 0, 0, 3007, 3008, 5, 288, 0, 0, 3008, 3009, 3, 650, 325, 
	0, 3009, 457, 1, 0, 0, 0, 3010, 3011, 3, 800, 400, 0, 3011, 3012, 5, 1, 
	0, 0, 3012, 3013, 3, 546, 273, 0, 3013, 459, 1, 0, 0, 0, 3014, 3015, 5, 
	49, 0, 0, 3015, 3016, 3, 370, 185, 0, 3016, 461, 1, 0, 0, 0, 3017, 3018, 
	5, 43, 0, 0, 3018, 3019, 5, 285, 0, 0, 3019, 3020, 3, 652, 326, 0, 3020, 
	3025, 3, 464, 232, 0, 3021, 3022, 5, 24, 0, 0, 3022, 3024, 3, 464, 232, 
	0, 3023, 3021, 1, 0, 0, 0, 3024, 3027, 1, 0, 0, 0, 3025, 3023, 1, 0, 0, 
	0, 3025, 3026, 1, 0, 0, 0, 3026, 463, 1, 0, 0, 0, 3027, 3025, 1, 0, 0, 
	0, 3028, 3046, 3, 474, 237, 0, 3029, 3046, 3, 476, 238, 0, 3030, 3046, 
	3, 478, 239, 0, 3031, 3046, 3, 482, 241, 0, 3032, 3046, 3, 484, 242, 0, 
	3033, 3046, 3, 486, 243, 0, 3034, 3046, 3, 488, 244, 0, 3035, 3046, 3, 
	490, 245, 0, 3036, 3046, 3, 492, 246, 0, 3037, 3046, 3, 494, 247, 0, 3038, 
	3046, 3, 496, 248, 0, 3039, 3046, 3, 500, 250, 0, 3040, 3046, 3, 502, 251, 
	0, 3041, 3046, 3, 504, 252, 0, 3042, 3046, 3, 498, 249, 0, 3043, 3046, 
	3, 506, 253, 0, 3044, 3046, 3, 480, 240, 0, 3045, 3028, 1, 0, 0, 0, 3045, 
	3029, 1, 0, 0, 0, 3045, 3030, 1, 0, 0, 0, 3045, 3031, 1, 0, 0, 0, 3045, 
	3032, 1, 0, 0, 0, 3045, 3033, 1, 0, 0, 0, 3045, 3034, 1, 0, 0, 0, 3045, 
	3035, 1, 0, 0, 0, 3045, 3036, 1, 0, 0, 0, 3045, 3037, 1, 0, 0, 0, 3045, 
	3038, 1, 0, 0, 0, 3045, 3039, 1, 0, 0, 0, 3045, 3040, 1, 0, 0, 0, 3045, 
	3041, 1, 0, 0, 0, 3045, 3042, 1, 0, 0, 0, 3045, 3043, 1, 0, 0, 0, 3045, 
	3044, 1, 0, 0, 0, 3046, 465, 1, 0, 0, 0, 3047, 3048, 5, 43, 0, 0, 3048, 
	3049, 5, 129, 0, 0, 3049, 3050, 5, 285, 0, 0, 3050, 3051, 3, 652, 326, 
	0, 3051, 3056, 3, 468, 234, 0, 3052, 3053, 5, 24, 0, 0, 3053, 3055, 3, 
	468, 234, 0, 3054, 3052, 1, 0, 0, 0, 3055, 3058, 1, 0, 0, 0, 3056, 3054, 
	1, 0, 0, 0, 3056, 3057, 1, 0, 0, 0, 3057, 467, 1, 0, 0, 0, 3058, 3056, 
	1, 0, 0, 0, 3059, 3065, 3, 474, 237, 0, 3060, 3065, 3, 476, 238, 0, 3061, 
	3065, 3, 486, 243, 0, 3062, 3065, 3, 488, 244, 0, 3063, 3065, 3, 490, 245, 
	0, 3064, 3059, 1, 0, 0, 0, 3064, 3060, 1, 0, 0, 0, 3064, 3061, 1, 0, 0, 
	0, 3064, 3062, 1, 0, 0, 0, 3064, 3063, 1, 0, 0, 0, 3065, 469, 1, 0, 0, 
	0, 3066, 3067, 5, 43, 0, 0, 3067, 3068, 5, 288, 0, 0, 3068, 3069, 3, 648, 
	324, 0, 3069, 3074, 3, 472, 236, 0, 3070, 3071, 5, 24, 0, 0, 3071, 3073, 
	3, 472, 236, 0, 3072, 3070, 1, 0, 0, 0, 3073, 3076, 1, 0, 0, 0, 3074, 3072, 
	1, 0, 0, 0, 3074, 3075, 1, 0, 0, 0, 3075, 471, 1, 0, 0, 0, 3076, 3074, 
	1, 0, 0, 0, 3077, 3080, 3, 474, 237, 0, 3078, 3080, 3, 476, 238, 0, 3079, 
	3077, 1, 0, 0, 0, 3079, 3078, 1, 0, 0, 0, 3080, 473, 1, 0, 0, 0, 3081, 
	3083, 5, 40, 0, 0, 3082, 3084, 5, 75, 0, 0, 3083, 3082, 1, 0, 0, 0, 3083, 
	3084, 1, 0, 0, 0, 3084, 3085, 1, 0, 0, 0, 3085, 3086, 3, 508, 254, 0, 3086, 
	475, 1, 0, 0, 0, 3087, 3089, 5, 110, 0, 0, 3088, 3090, 5, 75, 0, 0, 3089, 
	3088, 1, 0, 0, 0, 3089, 3090, 1, 0, 0, 0, 3090, 3091, 1, 0, 0, 0, 3091, 
	3092, 3, 800, 400, 0, 3092, 477, 1, 0, 0, 0, 3093, 3094, 5, 43, 0, 0, 3094, 
	3095, 5, 75, 0, 0, 3095, 3096, 3, 800, 400, 0, 3096, 3097, 5, 270, 0, 0, 
	3097, 3098, 3, 510, 255, 0, 3098, 479, 1, 0, 0, 0, 3099, 3100, 5, 43, 0, 
	0, 3100, 3101, 5, 75, 0, 0, 3101, 3102, 3, 800, 400, 0, 3102, 3103, 5, 
	110, 0, 0, 3103, 3104, 5, 198, 0, 0, 3104, 3105, 5, 200, 0, 0, 3105, 481, 
	1, 0, 0, 0, 3106, 3107, 5, 40, 0, 0, 3107, 3108, 3, 552, 276, 0, 3108, 
	483, 1, 0, 0, 0, 3109, 3110, 5, 43, 0, 0, 3110, 3111, 5, 132, 0, 0, 3111, 
	3112, 3, 800, 400, 0, 3112, 3113, 5, 270, 0, 0, 3113, 3114, 3, 800, 400, 
	0, 3114, 3115, 3, 558, 279, 0, 3115, 485, 1, 0, 0, 0, 3116, 3117, 5, 270, 
	0, 0, 3117, 3118, 3, 800, 400, 0, 3118, 3119, 3, 546, 273, 0, 3119, 487, 
	1, 0, 0, 0, 3120, 3121, 5, 270, 0, 0, 3121, 3122, 5, 25, 0, 0, 3122, 3127, 
	3, 544, 272, 0, 3123, 3124, 5, 24, 0, 0, 3124, 3126, 3, 544, 272, 0, 3125, 
	3123, 1, 0, 0, 0, 3126, 3129, 1, 0, 0, 0, 3127, 3125, 1, 0, 0, 0, 3127, 
	3128, 1, 0, 0, 0, 3128, 3130, 1, 0, 0, 0, 3129, 3127, 1, 0, 0, 0, 3130, 
	3131, 5, 26, 0, 0, 3131, 489, 1, 0, 0, 0, 3132, 3133, 5, 246, 0, 0, 3133, 
	3134, 5, 25, 0, 0, 3134, 3139, 3, 800, 400, 0, 3135, 3136, 5, 24, 0, 0, 
	3136, 3138, 3, 800, 400, 0, 3137, 3135, 1, 0, 0, 0, 3138, 3141, 1, 0, 0, 
	0, 3139, 3137, 1, 0, 0, 0, 3139, 3140, 1, 0, 0, 0, 3140, 3142, 1, 0, 0, 
	0, 3141, 3139, 1, 0, 0, 0, 3142, 3143, 5, 26, 0, 0, 3143, 491, 1, 0, 0, 
	0, 3144, 3145, 5, 40, 0, 0, 3145, 3146, 3, 518, 259, 0, 3146, 493, 1, 0, 
	0, 0, 3147, 3148, 5, 110, 0, 0, 3148, 3149, 5, 160, 0, 0, 3149, 3150, 3, 
	800, 400, 0, 3150, 495, 1, 0, 0, 0, 3151, 3152, 5, 242, 0, 0, 3152, 3153, 
	5, 294, 0, 0, 3153, 3154, 3, 812, 406, 0, 3154, 497, 1, 0, 0, 0, 3155, 
	3156, 5, 242, 0, 0, 3156, 3157, 5, 160, 0, 0, 3157, 3158, 3, 800, 400, 
	0, 3158, 3159, 5, 294, 0, 0, 3159, 3160, 3, 800, 400, 0, 3160, 499, 1, 
	0, 0, 0, 3161, 3162, 5, 40, 0, 0, 3162, 3163, 3, 534, 267, 0, 3163, 501, 
	1, 0, 0, 0, 3164, 3165, 5, 43, 0, 0, 3165, 3166, 5, 71, 0, 0, 3166, 3167, 
	3, 800, 400, 0, 3167, 3168, 3, 542, 271, 0, 3168, 503, 1, 0, 0, 0, 3169, 
	3170, 5, 110, 0, 0, 3170, 3171, 5, 71, 0, 0, 3171, 3172, 3, 800, 400, 0, 
	3172, 505, 1, 0, 0, 0, 3173, 3174, 5, 43, 0, 0, 3174, 3175, 5, 160, 0, 
	0, 3175, 3176, 3, 800, 400, 0, 3176, 3177, 3, 564, 282, 0, 3177, 507, 1, 
	0, 0, 0, 3178, 3179, 3, 804, 402, 0, 3179, 3181, 3, 204, 102, 0, 3180, 
	3182, 3, 510, 255, 0, 3181, 3180, 1, 0, 0, 0, 3181, 3182, 1, 0, 0, 0, 3182, 
	3183, 1, 0, 0, 0, 3183, 3184, 3, 512, 256, 0, 3184, 509, 1, 0, 0, 0, 3185, 
	3186, 5, 132, 0, 0, 3186, 3187, 3, 800, 400, 0, 3187, 511, 1, 0, 0, 0, 
	3188, 3190, 5, 198, 0, 0, 3189, 3188, 1, 0, 0, 0, 3189, 3190, 1, 0, 0, 
	0, 3190, 3191, 1, 0, 0, 0, 3191, 3193, 5, 200, 0, 0, 3192, 3189, 1, 0, 
	0, 0, 3192, 3193, 1, 0, 0, 0, 3193, 3196, 1, 0, 0, 0, 3194, 3195, 5, 96, 
	0, 0, 3195, 3197, 3, 14, 7, 0, 3196, 3194, 1, 0, 0, 0, 3196, 3197, 1, 0, 
	0, 0, 3197, 513, 1, 0, 0, 0, 3198, 3200, 3, 800, 400, 0, 3199, 3201, 7, 
	9, 0, 0, 3200, 3199, 1, 0, 0, 0, 3200, 3201, 1, 0, 0, 0, 3201, 515, 1, 
	0, 0, 0, 3202, 3203, 5, 229, 0, 0, 3203, 3204, 5, 176, 0, 0, 3204, 3205, 
	5, 25, 0, 0, 3205, 3210, 3, 800, 400, 0, 3206, 3207, 5, 24, 0, 0, 3207, 
	3209, 3, 800, 400, 0, 3208, 3206, 1, 0, 0, 0, 3209, 3212, 1, 0, 0, 0, 3210, 
	3208, 1, 0, 0, 0, 3210, 3211, 1, 0, 0, 0, 3211, 3213, 1, 0, 0, 0, 3212, 
	3210, 1, 0, 0, 0, 3213, 3214, 5, 26, 0, 0, 3214, 3242, 1, 0, 0, 0, 3215, 
	3216, 5, 217, 0, 0, 3216, 3217, 5, 66, 0, 0, 3217, 3218, 5, 25, 0, 0, 3218, 
	3223, 3, 800, 400, 0, 3219, 3220, 5, 24, 0, 0, 3220, 3222, 3, 800, 400, 
	0, 3221, 3219, 1, 0, 0, 0, 3222, 3225, 1, 0, 0, 0, 3223, 3221, 1, 0, 0, 
	0, 3223, 3224, 1, 0, 0, 0, 3224, 3226, 1, 0, 0, 0, 3225, 3223, 1, 0, 0, 
	0, 3226, 3227, 5, 26, 0, 0, 3227, 3242, 1, 0, 0, 0, 3228, 3229, 5, 212, 
	0, 0, 3229, 3230, 5, 66, 0, 0, 3230, 3231, 5, 25, 0, 0, 3231, 3236, 3, 
	514, 257, 0, 3232, 3233, 5, 24, 0, 0, 3233, 3235, 3, 514, 257, 0, 3234, 
	3232, 1, 0, 0, 0, 3235, 3238, 1, 0, 0, 0, 3236, 3234, 1, 0, 0, 0, 3236, 
	3237, 1, 0, 0, 0, 3237, 3239, 1, 0, 0, 0, 3238, 3236, 1, 0, 0, 0, 3239, 
	3240, 5, 26, 0, 0, 3240, 3242, 1, 0, 0, 0, 3241, 3202, 1, 0, 0, 0, 3241, 
	3215, 1, 0, 0, 0, 3241, 3228, 1, 0, 0, 0, 3242, 517, 1, 0, 0, 0, 3243, 
	3244, 5, 160, 0, 0, 3244, 3245, 3, 800, 400, 0, 3245, 3246, 3, 520, 260, 
	0, 3246, 3247, 5, 206, 0, 0, 3247, 3248, 5, 25, 0, 0, 3248, 3253, 3, 804, 
	402, 0, 3249, 3250, 5, 24, 0, 0, 3250, 3252, 3, 804, 402, 0, 3251, 3249, 
	1, 0, 0, 0, 3252, 3255, 1, 0, 0, 0, 3253, 3251, 1, 0, 0, 0, 3253, 3254, 
	1, 0, 0, 0, 3254, 3256, 1, 0, 0, 0, 3255, 3253, 1, 0, 0, 0, 3256, 3269, 
	5, 26, 0, 0, 3257, 3258, 5, 84, 0, 0, 3258, 3259, 5, 25, 0, 0, 3259, 3264, 
	3, 804, 402, 0, 3260, 3261, 5, 24, 0, 0, 3261, 3263, 3, 804, 402, 0, 3262, 
	3260, 1, 0, 0, 0, 3263, 3266, 1, 0, 0, 0, 3264, 3262, 1, 0, 0, 0, 3264, 
	3265, 1, 0, 0, 0, 3265, 3267, 1, 0, 0, 0, 3266, 3264, 1, 0, 0, 0, 3267, 
	3268, 5, 26, 0, 0, 3268, 3270, 1, 0, 0, 0, 3269, 3257, 1, 0, 0, 0, 3269, 
	3270, 1, 0, 0, 0, 3270, 3272, 1, 0, 0, 0, 3271, 3273, 3, 528, 264, 0, 3272, 
	3271, 1, 0, 0, 0, 3272, 3273, 1, 0, 0, 0, 3273, 519, 1, 0, 0, 0, 3274, 
	3277, 3, 522, 261, 0, 3275, 3277, 3, 524, 262, 0, 3276, 3274, 1, 0, 0, 
	0, 3276, 3275, 1, 0, 0, 0, 3277, 3280, 1, 0, 0, 0, 3278, 3279, 5, 311, 
	0, 0, 3279, 3281, 3, 526, 263, 0, 3280, 3278, 1, 0, 0, 0, 3280, 3281, 1, 
	0, 0, 0, 3281, 521, 1, 0, 0, 0, 3282, 3284, 5, 144, 0, 0, 3283, 3285, 5, 
	304, 0, 0, 3284, 3283, 1, 0, 0, 0, 3284, 3285, 1, 0, 0, 0, 3285, 3287, 
	1, 0, 0, 0, 3286, 3288, 7, 16, 0, 0, 3287, 3286, 1, 0, 0, 0, 3287, 3288, 
	1, 0, 0, 0, 3288, 523, 1, 0, 0, 0, 3289, 3290, 5, 183, 0, 0, 3290, 525, 
	1, 0, 0, 0, 3291, 3292, 3, 800, 400, 0, 3292, 527, 1, 0, 0, 0, 3293, 3294, 
	5, 320, 0, 0, 3294, 3295, 5, 25, 0, 0, 3295, 3300, 3, 530, 265, 0, 3296, 
	3297, 5, 24, 0, 0, 3297, 3299, 3, 530, 265, 0, 3298, 3296, 1, 0, 0, 0, 
	3299, 3302, 1, 0, 0, 0, 3300, 3298, 1, 0, 0, 0, 3300, 3301, 1, 0, 0, 0, 
	3301, 3304, 1, 0, 0, 0, 3302, 3300, 1, 0, 0, 0, 3303, 3305, 5, 24, 0, 0, 
	3304, 3303, 1, 0, 0, 0, 3304, 3305, 1, 0, 0, 0, 3305, 3306, 1, 0, 0, 0, 
	3306, 3307, 5, 26, 0, 0, 3307, 529, 1, 0, 0, 0, 3308, 3309, 3, 800, 400, 
	0, 3309, 3310, 5, 1, 0, 0, 3310, 3311, 3, 532, 266, 0, 3311, 531, 1, 0, 
	0, 0, 3312, 3317, 3, 828, 414, 0, 3313, 3317, 5, 324, 0, 0, 3314, 3317, 
	3, 864, 432, 0, 3315, 3317, 3, 860, 430, 0, 3316, 3312, 1, 0, 0, 0, 3316, 
	3313, 1, 0, 0, 0, 3316, 3314, 1, 0, 0, 0, 3316, 3315, 1, 0, 0, 0, 3317, 
	533, 1, 0, 0, 0, 3318, 3319, 5, 71, 0, 0, 3319, 3320, 3, 800, 400, 0, 3320, 
	3321, 5, 320, 0, 0, 3321, 3322, 5, 25, 0, 0, 3322, 3323, 3, 536, 268, 0, 
	3323, 3324, 5, 26, 0, 0, 3324, 535, 1, 0, 0, 0, 3325, 3330, 3, 538, 269, 
	0, 3326, 3327, 5, 24, 0, 0, 3327, 3329, 3, 538, 269, 0, 3328, 3326, 1, 
	0, 0, 0, 3329, 3332, 1, 0, 0, 0, 3330, 3328, 1, 0, 0, 0, 3330, 3331, 1, 
	0, 0, 0, 3331, 537, 1, 0, 0, 0, 3332, 3330, 1, 0, 0, 0, 3333, 3334, 3, 
	800, 400, 0, 3334, 3335, 5, 1, 0, 0, 3335, 3336, 3, 540, 270, 0, 3336, 
	539, 1, 0, 0, 0, 3337, 3338, 3, 14, 7, 0, 3338, 541, 1, 0, 0, 0, 3339, 
	3346, 5, 106, 0, 0, 3340, 3341, 5, 270, 0, 0, 3341, 3342, 5, 25, 0, 0, 
	3342, 3343, 3, 536, 268, 0, 3343, 3344, 5, 26, 0, 0, 3344, 3346, 1, 0, 
	0, 0, 3345, 3339, 1, 0, 0, 0, 3345, 3340, 1, 0, 0, 0, 3346, 543, 1, 0, 
	0, 0, 3347, 3348, 3, 800, 400, 0, 3348, 3349, 5, 1, 0, 0, 3349, 3350, 3, 
	546, 273, 0, 3350, 545, 1, 0, 0, 0, 3351, 3364, 3, 782, 391, 0, 3352, 3364, 
	5, 324, 0, 0, 3353, 3364, 3, 864, 432, 0, 3354, 3364, 3, 560, 280, 0, 3355, 
	3356, 3, 548, 274, 0, 3356, 3357, 5, 206, 0, 0, 3357, 3360, 3, 800, 400, 
	0, 3358, 3359, 5, 49, 0, 0, 3359, 3361, 7, 17, 0, 0, 3360, 3358, 1, 0, 
	0, 0, 3360, 3361, 1, 0, 0, 0, 3361, 3364, 1, 0, 0, 0, 3362, 3364, 3, 860, 
	430, 0, 3363, 3351, 1, 0, 0, 0, 3363, 3352, 1, 0, 0, 0, 3363, 3353, 1, 
	0, 0, 0, 3363, 3354, 1, 0, 0, 0, 3363, 3355, 1, 0, 0, 0, 3363, 3362, 1, 
	0, 0, 0, 3364, 547, 1, 0, 0, 0, 3365, 3376, 3, 14, 7, 0, 3366, 3373, 3, 
	550, 275, 0, 3367, 3368, 5, 24, 0, 0, 3368, 3369, 3, 14, 7, 0, 3369, 3370, 
	3, 550, 275, 0, 3370, 3372, 1, 0, 0, 0, 3371, 3367, 1, 0, 0, 0, 3372, 3375, 
	1, 0, 0, 0, 3373, 3371, 1, 0, 0, 0, 3373, 3374, 1, 0, 0, 0, 3374, 3377, 
	1, 0, 0, 0, 3375, 3373, 1, 0, 0, 0, 3376, 3366, 1, 0, 0, 0, 3376, 3377, 
	1, 0, 0, 0, 3377, 549, 1, 0, 0, 0, 3378, 3379, 5, 294, 0, 0, 3379, 3380, 
	5, 129, 0, 0, 3380, 3381, 5, 92, 0, 0, 3381, 3382, 5, 275, 0, 0, 3382, 
	3385, 3, 800, 400, 0, 3383, 3385, 5, 100, 0, 0, 3384, 3378, 1, 0, 0, 0, 
	3384, 3383, 1, 0, 0, 0, 3385, 551, 1, 0, 0, 0, 3386, 3387, 5, 132, 0, 0, 
	3387, 3388, 3, 800, 400, 0, 3388, 3389, 3, 554, 277, 0, 3389, 553, 1, 0, 
	0, 0, 3390, 3399, 5, 25, 0, 0, 3391, 3396, 3, 556, 278, 0, 3392, 3393, 
	5, 24, 0, 0, 3393, 3395, 3, 556, 278, 0, 3394, 3392, 1, 0, 0, 0, 3395, 
	3398, 1, 0, 0, 0, 3396, 3394, 1, 0, 0, 0, 3396, 3397, 1, 0, 0, 0, 3397, 
	3400, 1, 0, 0, 0, 3398, 3396, 1, 0, 0, 0, 3399, 3391, 1, 0, 0, 0, 3399, 
	3400, 1, 0, 0, 0, 3400, 3401, 1, 0, 0, 0, 3401, 3402, 5, 26, 0, 0, 3402, 
	555, 1, 0, 0, 0, 3403, 3404, 3, 800, 400, 0, 3404, 3405, 5, 1, 0, 0, 3405, 
	3406, 3, 558, 279, 0, 3406, 557, 1, 0, 0, 0, 3407, 3410, 5, 324, 0, 0, 
	3408, 3410, 3, 864, 432, 0, 3409, 3407, 1, 0, 0, 0, 3409, 3408, 1, 0, 0, 
	0, 3410, 559, 1, 0, 0, 0, 3411, 3412, 5, 25, 0, 0, 3412, 3417, 3, 562, 
	281, 0, 3413, 3414, 5, 24, 0, 0, 3414, 3416, 3, 562, 281, 0, 3415, 3413, 
	1, 0, 0, 0, 3416, 3419, 1, 0, 0, 0, 3417, 3415, 1, 0, 0, 0, 3417, 3418, 
	1, 0, 0, 0, 3418, 3420, 1, 0, 0, 0, 3419, 3417, 1, 0, 0, 0, 3420, 3421, 
	5, 26, 0, 0, 3421, 3424, 1, 0, 0, 0, 3422, 3424, 3, 562, 281, 0, 3423, 
	3411, 1, 0, 0, 0, 3423, 3422, 1, 0, 0, 0, 3424, 561, 1, 0, 0, 0, 3425, 
	3426, 5, 25, 0, 0, 3426, 3431, 3, 142, 71, 0, 3427, 3428, 5, 24, 0, 0, 
	3428, 3430, 3, 142, 71, 0, 3429, 3427, 1, 0, 0, 0, 3430, 3433, 1, 0, 0, 
	0, 3431, 3429, 1, 0, 0, 0, 3431, 3432, 1, 0, 0, 0, 3432, 3434, 1, 0, 0, 
	0, 3433, 3431, 1, 0, 0, 0, 3434, 3435, 5, 26, 0, 0, 3435, 563, 1, 0, 0, 
	0, 3436, 3440, 3, 486, 243, 0, 3437, 3440, 3, 488, 244, 0, 3438, 3440, 
	3, 490, 245, 0, 3439, 3436, 1, 0, 0, 0, 3439, 3437, 1, 0, 0, 0, 3439, 3438, 
	1, 0, 0, 0, 3440, 565, 1, 0, 0, 0, 3441, 3446, 5, 110, 0, 0, 3442, 3447, 
	5, 285, 0, 0, 3443, 3447, 5, 288, 0, 0, 3444, 3445, 5, 129, 0, 0, 3445, 
	3447, 5, 285, 0, 0, 3446, 3442, 1, 0, 0, 0, 3446, 3443, 1, 0, 0, 0, 3446, 
	3444, 1, 0, 0, 0, 3447, 3450, 1, 0, 0, 0, 3448, 3449, 5, 152, 0, 0, 3449, 
	3451, 5, 126, 0, 0, 3450, 3448, 1, 0, 0, 0, 3450, 3451, 1, 0, 0, 0, 3451, 
	3452, 1, 0, 0, 0, 3452, 3453, 3, 652, 326, 0, 3453, 567, 1, 0, 0, 0, 3454, 
	3455, 5, 85, 0, 0, 3455, 3456, 5, 310, 0, 0, 3456, 3460, 3, 578, 289, 0, 
	3457, 3459, 3, 580, 290, 0, 3458, 3457, 1, 0, 0, 0, 3459, 3462, 1, 0, 0, 
	0, 3460, 3458, 1, 0, 0, 0, 3460, 3461, 1, 0, 0, 0, 3461, 569, 1, 0, 0, 
	0, 3462, 3460, 1, 0, 0, 0, 3463, 3464, 5, 43, 0, 0, 3464, 3465, 5, 310, 
	0, 0, 3465, 3477, 3, 578, 289, 0, 3466, 3468, 5, 320, 0, 0, 3467, 3466, 
	1, 0, 0, 0, 3467, 3468, 1, 0, 0, 0, 3468, 3470, 1, 0, 0, 0, 3469, 3471, 
	3, 580, 290, 0, 3470, 3469, 1, 0, 0, 0, 3471, 3472, 1, 0, 0, 0, 3472, 3470, 
	1, 0, 0, 0, 3472, 3473, 1, 0, 0, 0, 3473, 3478, 1, 0, 0, 0, 3474, 3475, 
	5, 242, 0, 0, 3475, 3476, 5, 294, 0, 0, 3476, 3478, 3, 578, 289, 0, 3477, 
	3467, 1, 0, 0, 0, 3477, 3474, 1, 0, 0, 0, 3478, 571, 1, 0, 0, 0, 3479, 
	3480, 5, 85, 0, 0, 3480, 3481, 5, 146, 0, 0, 3481, 3495, 3, 578, 289, 0, 
	3482, 3483, 5, 320, 0, 0, 3483, 3484, 5, 310, 0, 0, 3484, 3489, 3, 578, 
	289, 0, 3485, 3486, 5, 24, 0, 0, 3486, 3488, 3, 578, 289, 0, 3487, 3485, 
	1, 0, 0, 0, 3488, 3491, 1, 0, 0, 0, 3489, 3487, 1, 0, 0, 0, 3489, 3490, 
	1, 0, 0, 0, 3490, 3493, 1, 0, 0, 0, 3491, 3489, 1, 0, 0, 0, 3492, 3494, 
	5, 24, 0, 0, 3493, 3492, 1, 0, 0, 0, 3493, 3494, 1, 0, 0, 0, 3494, 3496, 
	1, 0, 0, 0, 3495, 3482, 1, 0, 0, 0, 3495, 3496, 1, 0, 0, 0, 3496, 573, 
	1, 0, 0, 0, 3497, 3498, 5, 43, 0, 0, 3498, 3499, 5, 146, 0, 0, 3499, 3516, 
	3, 578, 289, 0, 3500, 3501, 7, 18, 0, 0, 3501, 3502, 5, 310, 0, 0, 3502, 
	3507, 3, 578, 289, 0, 3503, 3504, 5, 24, 0, 0, 3504, 3506, 3, 578, 289, 
	0, 3505, 3503, 1, 0, 0, 0, 3506, 3509, 1, 0, 0, 0, 3507, 3505, 1, 0, 0, 
	0, 3507, 3508, 1, 0, 0, 0, 3508, 3511, 1, 0, 0, 0, 3509, 3507, 1, 0, 0, 
	0, 3510, 3512, 5, 24, 0, 0, 3511, 3510, 1, 0, 0, 0, 3511, 3512, 1, 0, 0, 
	0, 3512, 3517, 1, 0, 0, 0, 3513, 3514, 5, 242, 0, 0, 3514, 3515, 5, 294, 
	0, 0, 3515, 3517, 3, 578, 289, 0, 3516, 3500, 1, 0, 0, 0, 3516, 3513, 1, 
	0, 0, 0, 3517, 575, 1, 0, 0, 0, 3518, 3519, 5, 110, 0, 0, 3519, 3522, 7, 
	19, 0, 0, 3520, 3521, 5, 152, 0, 0, 3521, 3523, 5, 126, 0, 0, 3522, 3520, 
	1, 0, 0, 0, 3522, 3523, 1, 0, 0, 0, 3523, 3524, 1, 0, 0, 0, 3524, 3529, 
	3, 578, 289, 0, 3525, 3526, 5, 24, 0, 0, 3526, 3528, 3, 578, 289, 0, 3527, 
	3525, 1, 0, 0, 0, 3528, 3531, 1, 0, 0, 0, 3529, 3527, 1, 0, 0, 0, 3529, 
	3530, 1, 0, 0, 0, 3530, 3533, 1, 0, 0, 0, 3531, 3529, 1, 0, 0, 0, 3532, 
	3534, 5, 24, 0, 0, 3533, 3532, 1, 0, 0, 0, 3533, 3534, 1, 0, 0, 0, 3534, 
	577, 1, 0, 0, 0, 3535, 3538, 3, 802, 401, 0, 3536, 3538, 3, 144, 72, 0, 
	3537, 3535, 1, 0, 0, 0, 3537, 3536, 1, 0, 0, 0, 3538, 579, 1, 0, 0, 0, 
	3539, 3542, 3, 582, 291, 0, 3540, 3542, 3, 584, 292, 0, 3541, 3539, 1, 
	0, 0, 0, 3541, 3540, 1, 0, 0, 0, 3542, 581, 1, 0, 0, 0, 3543, 3545, 5, 
	115, 0, 0, 3544, 3543, 1, 0, 0, 0, 3544, 3545, 1, 0, 0, 0, 3545, 3546, 
	1, 0, 0, 0, 3546, 3547, 5, 219, 0, 0, 3547, 3548, 3, 14, 7, 0, 3548, 583, 
	1, 0, 0, 0, 3549, 3550, 7, 20, 0, 0, 3550, 585, 1, 0, 0, 0, 3551, 3552, 
	5, 145, 0, 0, 3552, 3553, 3, 594, 297, 0, 3553, 3554, 5, 206, 0, 0, 3554, 
	3559, 3, 804, 402, 0, 3555, 3556, 5, 24, 0, 0, 3556, 3558, 3, 804, 402, 
	0, 3557, 3555, 1, 0, 0, 0, 3558, 3561, 1, 0, 0, 0, 3559, 3557, 1, 0, 0, 
	0, 3559, 3560, 1, 0, 0, 0, 3560, 3562, 1, 0, 0, 0, 3561, 3559, 1, 0, 0, 
	0, 3562, 3563, 5, 294, 0, 0, 3563, 3568, 3, 578, 289, 0, 3564, 3565, 5, 
	24, 0, 0, 3565, 3567, 3, 578, 289, 0, 3566, 3564, 1, 0, 0, 0, 3567, 3570, 
	1, 0, 0, 0, 3568, 3566, 1, 0, 0, 0, 3568, 3569, 1, 0, 0, 0, 3569, 3572, 
	1, 0, 0, 0, 3570, 3568, 1, 0, 0, 0, 3571, 3573, 5, 24, 0, 0, 3572, 3571, 
	1, 0, 0, 0, 3572, 3573, 1, 0, 0, 0, 3573, 3577, 1, 0, 0, 0, 3574, 3575, 
	5, 320, 0, 0, 3575, 3576, 5, 145, 0, 0, 3576, 3578, 5, 209, 0, 0, 3577, 
	3574, 1, 0, 0, 0, 3577, 3578, 1, 0, 0, 0, 3578, 587, 1, 0, 0, 0, 3579, 
	3583, 5, 256, 0, 0, 3580, 3581, 5, 145, 0, 0, 3581, 3582, 5, 209, 0, 0, 
	3582, 3584, 5, 138, 0, 0, 3583, 3580, 1, 0, 0, 0, 3583, 3584, 1, 0, 0, 
	0, 3584, 3585, 1, 0, 0, 0, 3585, 3586, 3, 594, 297, 0, 3586, 3587, 5, 206, 
	0, 0, 3587, 3592, 3, 804, 402, 0, 3588, 3589, 5, 24, 0, 0, 3589, 3591, 
	3, 804, 402, 0, 3590, 3588, 1, 0, 0, 0, 3591, 3594, 1, 0, 0, 0, 3592, 3590, 
	1, 0, 0, 0, 3592, 3593, 1, 0, 0, 0, 3593, 3595, 1, 0, 0, 0, 3594, 3592, 
	1, 0, 0, 0, 3595, 3596, 5, 140, 0, 0, 3596, 3601, 3, 578, 289, 0, 3597, 
	3598, 5, 24, 0, 0, 3598, 3600, 3, 578, 289, 0, 3599, 3597, 1, 0, 0, 0, 
	3600, 3603, 1, 0, 0, 0, 3601, 3599, 1, 0, 0, 0, 3601, 3602, 1, 0, 0, 0, 
	3602, 589, 1, 0, 0, 0, 3603, 3601, 1, 0, 0, 0, 3604, 3629, 5, 81, 0, 0, 
	3605, 3629, 5, 182, 0, 0, 3606, 3629, 5, 166, 0, 0, 3607, 3629, 5, 185, 
	0, 0, 3608, 3629, 5, 110, 0, 0, 3609, 3629, 5, 145, 0, 0, 3610, 3611, 5, 
	192, 0, 0, 3611, 3629, 7, 21, 0, 0, 3612, 3613, 7, 22, 0, 0, 3613, 3629, 
	5, 261, 0, 0, 3614, 3615, 7, 23, 0, 0, 3615, 3629, 5, 265, 0, 0, 3616, 
	3618, 5, 268, 0, 0, 3617, 3619, 7, 24, 0, 0, 3618, 3617, 1, 0, 0, 0, 3618, 
	3619, 1, 0, 0, 0, 3619, 3629, 1, 0, 0, 0, 3620, 3622, 7, 25, 0, 0, 3621, 
	3623, 5, 179, 0, 0, 3622, 3621, 1, 0, 0, 0, 3622, 3623, 1, 0, 0, 0, 3623, 
	3629, 1, 0, 0, 0, 3624, 3626, 5, 85, 0, 0, 3625, 3627, 7, 26, 0, 0, 3626, 
	3625, 1, 0, 0, 0, 3626, 3627, 1, 0, 0, 0, 3627, 3629, 1, 0, 0, 0, 3628, 
	3604, 1, 0, 0, 0, 3628, 3605, 1, 0, 0, 0, 3628, 3606, 1, 0, 0, 0, 3628, 
	3607, 1, 0, 0, 0, 3628, 3608, 1, 0, 0, 0, 3628, 3609, 1, 0, 0, 0, 3628, 
	3610, 1, 0, 0, 0, 3628, 3612, 1, 0, 0, 0, 3628, 3614, 1, 0, 0, 0, 3628, 
	3616, 1, 0, 0, 0, 3628, 3620, 1, 0, 0, 0, 3628, 3624, 1, 0, 0, 0, 3629, 
	591, 1, 0, 0, 0, 3630, 3633, 3, 590, 295, 0, 3631, 3633, 5, 324, 0, 0, 
	3632, 3630, 1, 0, 0, 0, 3632, 3631, 1, 0, 0, 0, 3633, 593, 1, 0, 0, 0, 
	3634, 3639, 3, 592, 296, 0, 3635, 3636, 5, 24, 0, 0, 3636, 3638, 3, 592, 
	296, 0, 3637, 3635, 1, 0, 0, 0, 3638, 3641, 1, 0, 0, 0, 3639, 3637, 1, 
	0, 0, 0, 3639, 3640, 1, 0, 0, 0, 3640, 3643, 1, 0, 0, 0, 3641, 3639, 1, 
	0, 0, 0, 3642, 3644, 5, 24, 0, 0, 3643, 3642, 1, 0, 0, 0, 3643, 3644, 1, 
	0, 0, 0, 3644, 3650, 1, 0, 0, 0, 3645, 3647, 5, 42, 0, 0, 3646, 3648, 5, 
	230, 0, 0, 3647, 3646, 1, 0, 0, 0, 3647, 3648, 1, 0, 0, 0, 3648, 3650, 
	1, 0, 0, 0, 3649, 3634, 1, 0, 0, 0, 3649, 3645, 1, 0, 0, 0, 3650, 595, 
	1, 0, 0, 0, 3651, 3652, 5, 85, 0, 0, 3652, 3653, 5, 247, 0, 0, 3653, 3654, 
	5, 225, 0, 0, 3654, 3655, 3, 648, 324, 0, 3655, 3656, 3, 454, 227, 0, 3656, 
	597, 1, 0, 0, 0, 3657, 3658, 5, 43, 0, 0, 3658, 3659, 5, 247, 0, 0, 3659, 
	3660, 5, 225, 0, 0, 3660, 3661, 3, 648, 324, 0, 3661, 3666, 3, 600, 300, 
	0, 3662, 3663, 5, 24, 0, 0, 3663, 3665, 3, 600, 300, 0, 3664, 3662, 1, 
	0, 0, 0, 3665, 3668, 1, 0, 0, 0, 3666, 3664, 1, 0, 0, 0, 3666, 3667, 1, 
	0, 0, 0, 3667, 599, 1, 0, 0, 0, 3668, 3666, 1, 0, 0, 0, 3669, 3672, 3, 
	488, 244, 0, 3670, 3672, 3, 490, 245, 0, 3671, 3669, 1, 0, 0, 0, 3671, 
	3670, 1, 0, 0, 0, 3672, 601, 1, 0, 0, 0, 3673, 3674, 5, 110, 0, 0, 3674, 
	3675, 5, 247, 0, 0, 3675, 3676, 5, 225, 0, 0, 3676, 3677, 3, 648, 324, 
	0, 3677, 603, 1, 0, 0, 0, 3678, 3679, 5, 85, 0, 0, 3679, 3680, 5, 247, 
	0, 0, 3680, 3681, 5, 225, 0, 0, 3681, 3682, 5, 73, 0, 0, 3682, 3683, 3, 
	648, 324, 0, 3683, 3684, 3, 454, 227, 0, 3684, 605, 1, 0, 0, 0, 3685, 3686, 
	5, 43, 0, 0, 3686, 3687, 5, 247, 0, 0, 3687, 3688, 5, 225, 0, 0, 3688, 
	3689, 5, 73, 0, 0, 3689, 3690, 3, 648, 324, 0, 3690, 3695, 3, 608, 304, 
	0, 3691, 3692, 5, 24, 0, 0, 3692, 3694, 3, 608, 304, 0, 3693, 3691, 1, 
	0, 0, 0, 3694, 3697, 1, 0, 0, 0, 3695, 3693, 1, 0, 0, 0, 3695, 3696, 1, 
	0, 0, 0, 3696, 607, 1, 0, 0, 0, 3697, 3695, 1, 0, 0, 0, 3698, 3701, 3, 
	488, 244, 0, 3699, 3701, 3, 490, 245, 0, 3700, 3698, 1, 0, 0, 0, 3700, 
	3699, 1, 0, 0, 0, 3701, 609, 1, 0, 0, 0, 3702, 3703, 5, 110, 0, 0, 3703, 
	3704, 5, 247, 0, 0, 3704, 3705, 5, 225, 0, 0, 3705, 3706, 5, 73, 0, 0, 
	3706, 3707, 3, 648, 324, 0, 3707, 611, 1, 0, 0, 0, 3708, 3709, 5, 85, 0, 
	0, 3709, 3710, 5, 53, 0, 0, 3710, 3711, 5, 245, 0, 0, 3711, 3712, 3, 648, 
	324, 0, 3712, 3713, 5, 138, 0, 0, 3713, 3718, 3, 614, 307, 0, 3714, 3715, 
	5, 24, 0, 0, 3715, 3717, 3, 614, 307, 0, 3716, 3714, 1, 0, 0, 0, 3717, 
	3720, 1, 0, 0, 0, 3718, 3716, 1, 0, 0, 0, 3718, 3719, 1, 0, 0, 0, 3719, 
	3721, 1, 0, 0, 0, 3720, 3718, 1, 0, 0, 0, 3721, 3722, 5, 320, 0, 0, 3722, 
	3723, 5, 25, 0, 0, 3723, 3724, 3, 616, 308, 0, 3724, 3725, 5, 26, 0, 0, 
	3725, 613, 1, 0, 0, 0, 3726, 3727, 3, 648, 324, 0, 3727, 3728, 5, 49, 0, 
	0, 3728, 3729, 3, 648, 324, 0, 3729, 615, 1, 0, 0, 0, 3730, 3735, 3, 618, 
	309, 0, 3731, 3732, 5, 24, 0, 0, 3732, 3734, 3, 618, 309, 0, 3733, 3731, 
	1, 0, 0, 0, 3734, 3737, 1, 0, 0, 0, 3735, 3733, 1, 0, 0, 0, 3735, 3736, 
	1, 0, 0, 0, 3736, 617, 1, 0, 0, 0, 3737, 3735, 1, 0, 0, 0, 3738, 3739, 
	3, 800, 400, 0, 3739, 3740, 5, 1, 0, 0, 3740, 3741, 3, 14, 7, 0, 3741, 
	619, 1, 0, 0, 0, 3742, 3743, 5, 43, 0, 0, 3743, 3744, 5, 53, 0, 0, 3744, 
	3745, 5, 245, 0, 0, 3745, 3746, 3, 648, 324, 0, 3746, 3751, 3, 622, 311, 
	0, 3747, 3748, 5, 24, 0, 0, 3748, 3750, 3, 622, 311, 0, 3749, 3747, 1, 
	0, 0, 0, 3750, 3753, 1, 0, 0, 0, 3751, 3749, 1, 0, 0, 0, 3751, 3752, 1, 
	0, 0, 0, 3752, 621, 1, 0, 0, 0, 3753, 3751, 1, 0, 0, 0, 3754, 3755, 3, 
	624, 312, 0, 3755, 623, 1, 0, 0, 0, 3756, 3757, 5, 270, 0, 0, 3757, 3758, 
	5, 25, 0, 0, 3758, 3759, 3, 616, 308, 0, 3759, 3760, 5, 26, 0, 0, 3760, 
	625, 1, 0, 0, 0, 3761, 3762, 5, 110, 0, 0, 3762, 3763, 5, 53, 0, 0, 3763, 
	3764, 5, 245, 0, 0, 3764, 3766, 3, 648, 324, 0, 3765, 3767, 5, 68, 0, 0, 
	3766, 3765, 1, 0, 0, 0, 3766, 3767, 1, 0, 0, 0, 3767, 627, 1, 0, 0, 0, 
	3768, 3773, 3, 146, 73, 0, 3769, 3770, 5, 24, 0, 0, 3770, 3772, 3, 146, 
	73, 0, 3771, 3769, 1, 0, 0, 0, 3772, 3775, 1, 0, 0, 0, 3773, 3771, 1, 0, 
	0, 0, 3773, 3774, 1, 0, 0, 0, 3774, 629, 1, 0, 0, 0, 3775, 3773, 1, 0, 
	0, 0, 3776, 3777, 5, 99, 0, 0, 3777, 3778, 7, 27, 0, 0, 3778, 3779, 3, 
	144, 72, 0, 3779, 3781, 5, 25, 0, 0, 3780, 3782, 3, 628, 314, 0, 3781, 
	3780, 1, 0, 0, 0, 3781, 3782, 1, 0, 0, 0, 3782, 3783, 1, 0, 0, 0, 3783, 
	3784, 5, 26, 0, 0, 3784, 3785, 5, 49, 0, 0, 3785, 3786, 3, 632, 316, 0, 
	3786, 3787, 5, 116, 0, 0, 3787, 3788, 5, 99, 0, 0, 3788, 631, 1, 0, 0, 
	0, 3789, 3791, 5, 22, 0, 0, 3790, 3789, 1, 0, 0, 0, 3791, 3794, 1, 0, 0, 
	0, 3792, 3790, 1, 0, 0, 0, 3792, 3793, 1, 0, 0, 0, 3793, 3813, 1, 0, 0, 
	0, 3794, 3792, 1, 0, 0, 0, 3795, 3804, 3, 12, 6, 0, 3796, 3798, 5, 22, 
	0, 0, 3797, 3796, 1, 0, 0, 0, 3798, 3799, 1, 0, 0, 0, 3799, 3797, 1, 0, 
	0, 0, 3799, 3800, 1, 0, 0, 0, 3800, 3801, 1, 0, 0, 0, 3801, 3803, 3, 12, 
	6, 0, 3802, 3797, 1, 0, 0, 0, 3803, 3806, 1, 0, 0, 0, 3804, 3802, 1, 0, 
	0, 0, 3804, 3805, 1, 0, 0, 0, 3805, 3810, 1, 0, 0, 0, 3806, 3804, 1, 0, 
	0, 0, 3807, 3809, 5, 22, 0, 0, 3808, 3807, 1, 0, 0, 0, 3809, 3812, 1, 0, 
	0, 0, 3810, 3808, 1, 0, 0, 0, 3810, 3811, 1, 0, 0, 0, 3811, 3814, 1, 0, 
	0, 0, 3812, 3810, 1, 0, 0, 0, 3813, 3795, 1, 0, 0, 0, 3813, 3814, 1, 0, 
	0, 0, 3814, 633, 1, 0, 0, 0, 3815, 3817, 5, 121, 0, 0, 3816, 3815, 1, 0, 
	0, 0, 3816, 3817, 1, 0, 0, 0, 3817, 3818, 1, 0, 0, 0, 3818, 3819, 5, 152, 
	0, 0, 3819, 3820, 3, 14, 7, 0, 3820, 3823, 3, 222, 111, 0, 3821, 3822, 
	5, 112, 0, 0, 3822, 3824, 3, 222, 111, 0, 3823, 3821, 1, 0, 0, 0, 3823, 
	3824, 1, 0, 0, 0, 3824, 635, 1, 0, 0, 0, 3825, 3827, 5, 121, 0, 0, 3826, 
	3825, 1, 0, 0, 0, 3826, 3827, 1, 0, 0, 0, 3827, 3829, 1, 0, 0, 0, 3828, 
	3830, 5, 216, 0, 0, 3829, 3828, 1, 0, 0, 0, 3829, 3830, 1, 0, 0, 0, 3830, 
	3831, 1, 0, 0, 0, 3831, 3832, 5, 138, 0, 0, 3832, 3833, 3, 144, 72, 0, 
	3833, 3834, 5, 157, 0, 0, 3834, 3835, 3, 14, 7, 0, 3835, 3838, 3, 222, 
	111, 0, 3836, 3837, 5, 112, 0, 0, 3837, 3839, 3, 222, 111, 0, 3838, 3836, 
	1, 0, 0, 0, 3838, 3839, 1, 0, 0, 0, 3839, 637, 1, 0, 0, 0, 3840, 3841, 
	3, 826, 413, 0, 3841, 3842, 5, 23, 0, 0, 3842, 3844, 1, 0, 0, 0, 3843, 
	3840, 1, 0, 0, 0, 3843, 3844, 1, 0, 0, 0, 3844, 3846, 1, 0, 0, 0, 3845, 
	3847, 5, 29, 0, 0, 3846, 3845, 1, 0, 0, 0, 3846, 3847, 1, 0, 0, 0, 3847, 
	3878, 1, 0, 0, 0, 3848, 3879, 3, 640, 320, 0, 3849, 3850, 3, 806, 403, 
	0, 3850, 3862, 5, 25, 0, 0, 3851, 3856, 3, 642, 321, 0, 3852, 3853, 5, 
	24, 0, 0, 3853, 3855, 3, 642, 321, 0, 3854, 3852, 1, 0, 0, 0, 3855, 3858, 
	1, 0, 0, 0, 3856, 3854, 1, 0, 0, 0, 3856, 3857, 1, 0, 0, 0, 3857, 3860, 
	1, 0, 0, 0, 3858, 3856, 1, 0, 0, 0, 3859, 3861, 5, 24, 0, 0, 3860, 3859, 
	1, 0, 0, 0, 3860, 3861, 1, 0, 0, 0, 3861, 3863, 1, 0, 0, 0, 3862, 3851, 
	1, 0, 0, 0, 3862, 3863, 1, 0, 0, 0, 3863, 3864, 1, 0, 0, 0, 3864, 3865, 
	5, 26, 0, 0, 3865, 3879, 1, 0, 0, 0, 3866, 3872, 3, 144, 72, 0, 3867, 3869, 
	5, 25, 0, 0, 3868, 3870, 3, 112, 56, 0, 3869, 3868, 1, 0, 0, 0, 3869, 3870, 
	1, 0, 0, 0, 3870, 3871, 1, 0, 0, 0, 3871, 3873, 5, 26, 0, 0, 3872, 3867, 
	1, 0, 0, 0, 3872, 3873, 1, 0, 0, 0, 3873, 3876, 1, 0, 0, 0, 3874, 3875, 
	5, 315, 0, 0, 3875, 3877, 3, 822, 411, 0, 3876, 3874, 1, 0, 0, 0, 3876, 
	3877, 1, 0, 0, 0, 3877, 3879, 1, 0, 0, 0, 3878, 3848, 1, 0, 0, 0, 3878, 
	3849, 1, 0, 0, 0, 3878, 3866, 1, 0, 0, 0, 3879, 3881, 1, 0, 0, 0, 3880, 
	3882, 3, 644, 322, 0, 3881, 3880, 1, 0, 0, 0, 3881, 3882, 1, 0, 0, 0, 3882, 
	639, 1, 0, 0, 0, 3883, 3886, 3, 834, 417, 0, 3884, 3885, 5, 315, 0, 0, 
	3885, 3887, 3, 822, 411, 0, 3886, 3884, 1, 0, 0, 0, 3886, 3887, 1, 0, 0, 
	0, 3887, 641, 1, 0, 0, 0, 3888, 3890, 5, 29, 0, 0, 3889, 3888, 1, 0, 0, 
	0, 3889, 3890, 1, 0, 0, 0, 3890, 3891, 1, 0, 0, 0, 3891, 3894, 3, 128, 
	64, 0, 3892, 3893, 5, 315, 0, 0, 3893, 3895, 3, 822, 411, 0, 3894, 3892, 
	1, 0, 0, 0, 3894, 3895, 1, 0, 0, 0, 3895, 643, 1, 0, 0, 0, 3896, 3909, 
	5, 320, 0, 0, 3897, 3910, 3, 646, 323, 0, 3898, 3899, 5, 25, 0, 0, 3899, 
	3904, 3, 646, 323, 0, 3900, 3901, 5, 24, 0, 0, 3901, 3903, 3, 646, 323, 
	0, 3902, 3900, 1, 0, 0, 0, 3903, 3906, 1, 0, 0, 0, 3904, 3902, 1, 0, 0, 
	0, 3904, 3905, 1, 0, 0, 0, 3905, 3907, 1, 0, 0, 0, 3906, 3904, 1, 0, 0, 
	0, 3907, 3908, 5, 26, 0, 0, 3908, 3910, 1, 0, 0, 0, 3909, 3897, 1, 0, 0, 
	0, 3909, 3898, 1, 0, 0, 0, 3910, 645, 1, 0, 0, 0, 3911, 3930, 3, 816, 408, 
	0, 3912, 3928, 5, 1, 0, 0, 3913, 3929, 3, 160, 80, 0, 3914, 3915, 5, 25, 
	0, 0, 3915, 3920, 3, 160, 80, 0, 3916, 3917, 5, 24, 0, 0, 3917, 3919, 3, 
	160, 80, 0, 3918, 3916, 1, 0, 0, 0, 3919, 3922, 1, 0, 0, 0, 3920, 3918, 
	1, 0, 0, 0, 3920, 3921, 1, 0, 0, 0, 3921, 3924, 1, 0, 0, 0, 3922, 3920, 
	1, 0, 0, 0, 3923, 3925, 5, 24, 0, 0, 3924, 3923, 1, 0, 0, 0, 3924, 3925, 
	1, 0, 0, 0, 3925, 3926, 1, 0, 0, 0, 3926, 3927, 5, 26, 0, 0, 3927, 3929, 
	1, 0, 0, 0, 3928, 3913, 1, 0, 0, 0, 3928, 3914, 1, 0, 0, 0, 3929, 3931, 
	1, 0, 0, 0, 3930, 3912, 1, 0, 0, 0, 3930, 3931, 1, 0, 0, 0, 3931, 3957, 
	1, 0, 0, 0, 3932, 3934, 7, 28, 0, 0, 3933, 3935, 5, 1, 0, 0, 3934, 3933, 
	1, 0, 0, 0, 3934, 3935, 1, 0, 0, 0, 3935, 3936, 1, 0, 0, 0, 3936, 3957, 
	3, 204, 102, 0, 3937, 3939, 5, 265, 0, 0, 3938, 3940, 5, 1, 0, 0, 3939, 
	3938, 1, 0, 0, 0, 3939, 3940, 1, 0, 0, 0, 3940, 3941, 1, 0, 0, 0, 3941, 
	3950, 5, 25, 0, 0, 3942, 3947, 3, 164, 82, 0, 3943, 3944, 5, 24, 0, 0, 
	3944, 3946, 3, 164, 82, 0, 3945, 3943, 1, 0, 0, 0, 3946, 3949, 1, 0, 0, 
	0, 3947, 3945, 1, 0, 0, 0, 3947, 3948, 1, 0, 0, 0, 3948, 3951, 1, 0, 0, 
	0, 3949, 3947, 1, 0, 0, 0, 3950, 3942, 1, 0, 0, 0, 3950, 3951, 1, 0, 0, 
	0, 3951, 3953, 1, 0, 0, 0, 3952, 3954, 5, 24, 0, 0, 3953, 3952, 1, 0, 0, 
	0, 3953, 3954, 1, 0, 0, 0, 3954, 3955, 1, 0, 0, 0, 3955, 3957, 5, 26, 0, 
	0, 3956, 3911, 1, 0, 0, 0, 3956, 3932, 1, 0, 0, 0, 3956, 3937, 1, 0, 0, 
	0, 3957, 647, 1, 0, 0, 0, 3958, 3959, 3, 826, 413, 0, 3959, 3960, 5, 23, 
	0, 0, 3960, 3962, 1, 0, 0, 0, 3961, 3958, 1, 0, 0, 0, 3961, 3962, 1, 0, 
	0, 0, 3962, 3963, 1, 0, 0, 0, 3963, 3964, 3, 832, 416, 0, 3964, 649, 1, 
	0, 0, 0, 3965, 3971, 3, 648, 324, 0, 3966, 3968, 5, 29, 0, 0, 3967, 3966, 
	1, 0, 0, 0, 3967, 3968, 1, 0, 0, 0, 3968, 3969, 1, 0, 0, 0, 3969, 3971, 
	3, 144, 72, 0, 3970, 3965, 1, 0, 0, 0, 3970, 3967, 1, 0, 0, 0, 3971, 651, 
	1, 0, 0, 0, 3972, 3974, 3, 650, 325, 0, 3973, 3975, 3, 644, 322, 0, 3974, 
	3973, 1, 0, 0, 0, 3974, 3975, 1, 0, 0, 0, 3975, 653, 1, 0, 0, 0, 3976, 
	3980, 3, 652, 326, 0, 3977, 3978, 5, 118, 0, 0, 3978, 3979, 5, 66, 0, 0, 
	3979, 3981, 3, 114, 57, 0, 3980, 3977, 1, 0, 0, 0, 3980, 3981, 1, 0, 0, 
	0, 3981, 655, 1, 0, 0, 0, 3982, 3983, 5, 100, 0, 0, 3983, 3984, 5, 140, 
	0, 0, 3984, 3989, 3, 652, 326, 0, 3985, 3986, 5, 318, 0, 0, 3986, 3990, 
	3, 14, 7, 0, 3987, 3988, 5, 206, 0, 0, 3988, 3990, 3, 366, 183, 0, 3989, 
	3985, 1, 0, 0, 0, 3989, 3987, 1, 0, 0, 0, 3989, 3990, 1, 0, 0, 0, 3990, 
	3992, 1, 0, 0, 0, 3991, 3993, 3, 362, 181, 0, 3992, 3991, 1, 0, 0, 0, 3992, 
	3993, 1, 0, 0, 0, 3993, 657, 1, 0, 0, 0, 3994, 3995, 5, 307, 0, 0, 3995, 
	4004, 3, 652, 326, 0, 3996, 3997, 5, 270, 0, 0, 3997, 4000, 3, 660, 330, 
	0, 3998, 3999, 5, 318, 0, 0, 3999, 4001, 3, 14, 7, 0, 4000, 3998, 1, 0, 
	0, 0, 4000, 4001, 1, 0, 0, 0, 4001, 4005, 1, 0, 0, 0, 4002, 4003, 5, 206, 
	0, 0, 4003, 4005, 3, 366, 183, 0, 4004, 3996, 1, 0, 0, 0, 4004, 4002, 1, 
	0, 0, 0, 4005, 4007, 1, 0, 0, 0, 4006, 4008, 3, 362, 181, 0, 4007, 4006, 
	1, 0, 0, 0, 4007, 4008, 1, 0, 0, 0, 4008, 659, 1, 0, 0, 0, 4009, 4012, 
	3, 662, 331, 0, 4010, 4012, 3, 668, 334, 0, 4011, 4009, 1, 0, 0, 0, 4011, 
	4010, 1, 0, 0, 0, 4012, 661, 1, 0, 0, 0, 4013, 4018, 3, 664, 332, 0, 4014, 
	4015, 5, 24, 0, 0, 4015, 4017, 3, 664, 332, 0, 4016, 4014, 1, 0, 0, 0, 
	4017, 4020, 1, 0, 0, 0, 4018, 4016, 1, 0, 0, 0, 4018, 4019, 1, 0, 0, 0, 
	4019, 663, 1, 0, 0, 0, 4020, 4018, 1, 0, 0, 0, 4021, 4022, 3, 666, 333, 
	0, 4022, 4023, 5, 1, 0, 0, 4023, 4024, 3, 14, 7, 0, 4024, 665, 1, 0, 0, 
	0, 4025, 4026, 3, 120, 60, 0, 4026, 667, 1, 0, 0, 0, 4027, 4028, 3, 670, 
	335, 0, 4028, 4029, 5, 1, 0, 0, 4029, 4030, 5, 25, 0, 0, 4030, 4031, 3, 
	376, 188, 0, 4031, 4032, 5, 26, 0, 0, 4032, 669, 1, 0, 0, 0, 4033, 4034, 
	5, 25, 0, 0, 4034, 4039, 3, 666, 333, 0, 4035, 4036, 5, 24, 0, 0, 4036, 
	4038, 3, 666, 333, 0, 4037, 4035, 1, 0, 0, 0, 4038, 4041, 1, 0, 0, 0, 4039, 
	4037, 1, 0, 0, 0, 4039, 4040, 1, 0, 0, 0, 4040, 4042, 1, 0, 0, 0, 4041, 
	4039, 1, 0, 0, 0, 4042, 4043, 5, 26, 0, 0, 4043, 671, 1, 0, 0, 0, 4044, 
	4045, 5, 85, 0, 0, 4045, 4049, 5, 295, 0, 0, 4046, 4047, 5, 152, 0, 0, 
	4047, 4048, 5, 198, 0, 0, 4048, 4050, 5, 126, 0, 0, 4049, 4046, 1, 0, 0, 
	0, 4049, 4050, 1, 0, 0, 0, 4050, 4051, 1, 0, 0, 0, 4051, 4053, 3, 718, 
	359, 0, 4052, 4054, 3, 674, 337, 0, 4053, 4052, 1, 0, 0, 0, 4053, 4054, 
	1, 0, 0, 0, 4054, 4056, 1, 0, 0, 0, 4055, 4057, 3, 678, 339, 0, 4056, 4055, 
	1, 0, 0, 0, 4056, 4057, 1, 0, 0, 0, 4057, 673, 1, 0, 0, 0, 4058, 4059, 
	5, 25, 0, 0, 4059, 4064, 3, 676, 338, 0, 4060, 4061, 5, 24, 0, 0, 4061, 
	4063, 3, 676, 338, 0, 4062, 4060, 1, 0, 0, 0, 4063, 4066, 1, 0, 0, 0, 4064, 
	4062, 1, 0, 0, 0, 4064, 4065, 1, 0, 0, 0, 4065, 4067, 1, 0, 0, 0, 4066, 
	4064, 1, 0, 0, 0, 4067, 4068, 5, 26, 0, 0, 4068, 675, 1, 0, 0, 0, 4069, 
	4070, 3, 686, 343, 0, 4070, 677, 1, 0, 0, 0, 4071, 4072, 5, 320, 0, 0, 
	4072, 4073, 5, 25, 0, 0, 4073, 4074, 3, 704, 352, 0, 4074, 4075, 5, 26, 
	0, 0, 4075, 679, 1, 0, 0, 0, 4076, 4077, 5, 43, 0, 0, 4077, 4080, 5, 295, 
	0, 0, 4078, 4079, 5, 152, 0, 0, 4079, 4081, 5, 126, 0, 0, 4080, 4078, 1, 
	0, 0, 0, 4080, 4081, 1, 0, 0, 0, 4081, 4082, 1, 0, 0, 0, 4082, 4083, 3, 
	718, 359, 0, 4083, 4088, 3, 682, 341, 0, 4084, 4085, 5, 24, 0, 0, 4085, 
	4087, 3, 682, 341, 0, 4086, 4084, 1, 0, 0, 0, 4087, 4090, 1, 0, 0, 0, 4088, 
	4086, 1, 0, 0, 0, 4088, 4089, 1, 0, 0, 0, 4089, 681, 1, 0, 0, 0, 4090, 
	4088, 1, 0, 0, 0, 4091, 4097, 3, 684, 342, 0, 4092, 4097, 3, 688, 344, 
	0, 4093, 4097, 3, 692, 346, 0, 4094, 4097, 3, 698, 349, 0, 4095, 4097, 
	3, 700, 350, 0, 4096, 4091, 1, 0, 0, 0, 4096, 4092, 1, 0, 0, 0, 4096, 4093, 
	1, 0, 0, 0, 4096, 4094, 1, 0, 0, 0, 4096, 4095, 1, 0, 0, 0, 4097, 683, 
	1, 0, 0, 0, 4098, 4099, 5, 40, 0, 0, 4099, 4100, 3, 686, 343, 0, 4100, 
	685, 1, 0, 0, 0, 4101, 4102, 5, 83, 0, 0, 4102, 4104, 3, 800, 400, 0, 4103, 
	4105, 3, 710, 355, 0, 4104, 4103, 1, 0, 0, 0, 4104, 4105, 1, 0, 0, 0, 4105, 
	687, 1, 0, 0, 0, 4106, 4107, 5, 43, 0, 0, 4107, 4108, 5, 83, 0, 0, 4108, 
	4109, 3, 720, 360, 0, 4109, 4110, 3, 690, 345, 0, 4110, 689, 1, 0, 0, 0, 
	4111, 4114, 3, 694, 347, 0, 4112, 4114, 3, 696, 348, 0, 4113, 4111, 1, 
	0, 0, 0, 4113, 4112, 1, 0, 0, 0, 4114, 691, 1, 0, 0, 0, 4115, 4116, 5, 
	110, 0, 0, 4116, 4117, 5, 83, 0, 0, 4117, 4118, 3, 720, 360, 0, 4118, 693, 
	1, 0, 0, 0, 4119, 4120, 5, 270, 0, 0, 4120, 4121, 5, 25, 0, 0, 4121, 4122, 
	3, 712, 356, 0, 4122, 4123, 5, 26, 0, 0, 4123, 695, 1, 0, 0, 0, 4124, 4125, 
	5, 246, 0, 0, 4125, 4126, 5, 25, 0, 0, 4126, 4131, 3, 800, 400, 0, 4127, 
	4128, 5, 24, 0, 0, 4128, 4130, 3, 800, 400, 0, 4129, 4127, 1, 0, 0, 0, 
	4130, 4133, 1, 0, 0, 0, 4131, 4129, 1, 0, 0, 0, 4131, 4132, 1, 0, 0, 0, 
	4132, 4134, 1, 0, 0, 0, 4133, 4131, 1, 0, 0, 0, 4134, 4135, 5, 26, 0, 0, 
	4135, 697, 1, 0, 0, 0, 4136, 4137, 5, 270, 0, 0, 4137, 4138, 5, 25, 0, 
	0, 4138, 4139, 3, 704, 352, 0, 4139, 4140, 5, 26, 0, 0, 4140, 699, 1, 0, 
	0, 0, 4141, 4142, 5, 246, 0, 0, 4142, 4143, 5, 25, 0, 0, 4143, 4148, 3, 
	800, 400, 0, 4144, 4145, 5, 24, 0, 0, 4145, 4147, 3, 818, 409, 0, 4146, 
	4144, 1, 0, 0, 0, 4147, 4150, 1, 0, 0, 0, 4148, 4146, 1, 0, 0, 0, 4148, 
	4149, 1, 0, 0, 0, 4149, 4151, 1, 0, 0, 0, 4150, 4148, 1, 0, 0, 0, 4151, 
	4152, 5, 26, 0, 0, 4152, 701, 1, 0, 0, 0, 4153, 4154, 5, 110, 0, 0, 4154, 
	4157, 5, 295, 0, 0, 4155, 4156, 5, 152, 0, 0, 4156, 4158, 5, 126, 0, 0, 
	4157, 4155, 1, 0, 0, 0, 4157, 4158, 1, 0, 0, 0, 4158, 4159, 1, 0, 0, 0, 
	4159, 4160, 3, 718, 359, 0, 4160, 703, 1, 0, 0, 0, 4161, 4166, 3, 706, 
	353, 0, 4162, 4163, 5, 24, 0, 0, 4163, 4165, 3, 706, 353, 0, 4164, 4162, 
	1, 0, 0, 0, 4165, 4168, 1, 0, 0, 0, 4166, 4164, 1, 0, 0, 0, 4166, 4167, 
	1, 0, 0, 0, 4167, 705, 1, 0, 0, 0, 4168, 4166, 1, 0, 0, 0, 4169, 4170, 
	3, 800, 400, 0, 4170, 4171, 5, 1, 0, 0, 4171, 4172, 3, 708, 354, 0, 4172, 
	707, 1, 0, 0, 0, 4173, 4174, 3, 14, 7, 0, 4174, 709, 1, 0, 0, 0, 4175, 
	4176, 5, 320, 0, 0, 4176, 4177, 5, 25, 0, 0, 4177, 4178, 3, 712, 356, 0, 
	4178, 4179, 5, 26, 0, 0, 4179, 711, 1, 0, 0, 0, 4180, 4185, 3, 714, 357, 
	0, 4181, 4182, 5, 24, 0, 0, 4182, 4184, 3, 714, 357, 0, 4183, 4181, 1, 
	0, 0, 0, 4184, 4187, 1, 0, 0, 0, 4185, 4183, 1, 0, 0, 0, 4185, 4186, 1, 
	0, 0, 0, 4186, 713, 1, 0, 0, 0, 4187, 4185, 1, 0, 0, 0, 4188, 4189, 3, 
	800, 400, 0, 4189, 4190, 5, 1, 0, 0, 4190, 4191, 3, 716, 358, 0, 4191, 
	715, 1, 0, 0, 0, 4192, 4193, 3, 14, 7, 0, 4193, 717, 1, 0, 0, 0, 4194, 
	4195, 3, 826, 413, 0, 4195, 4196, 5, 23, 0, 0, 4196, 4198, 1, 0, 0, 0, 
	4197, 4194, 1, 0, 0, 0, 4197, 4198, 1, 0, 0, 0, 4198, 4199, 1, 0, 0, 0, 
	4199, 4200, 3, 800, 400, 0, 4200, 719, 1, 0, 0, 0, 4201, 4202, 3, 818, 
	409, 0, 4202, 721, 1, 0, 0, 0, 4203, 4204, 5, 248, 0, 0, 4204, 4208, 5, 
	201, 0, 0, 4205, 4206, 5, 153, 0, 0, 4206, 4208, 5, 201, 0, 0, 4207, 4203, 
	1, 0, 0, 0, 4207, 4205, 1, 0, 0, 0, 4208, 723, 1, 0, 0, 0, 4209, 4210, 
	5, 133, 0, 0, 4210, 4211, 5, 25, 0, 0, 4211, 4212, 5, 318, 0, 0, 4212, 
	4213, 3, 14, 7, 0, 4213, 4214, 5, 26, 0, 0, 4214, 725, 1, 0, 0, 0, 4215, 
	4218, 3, 728, 364, 0, 4216, 4218, 3, 738, 369, 0, 4217, 4215, 1, 0, 0, 
	0, 4217, 4216, 1, 0, 0, 0, 4218, 727, 1, 0, 0, 0, 4219, 4220, 3, 810, 405, 
	0, 4220, 729, 1, 0, 0, 0, 4221, 4222, 5, 319, 0, 0, 4222, 4223, 3, 732, 
	366, 0, 4223, 731, 1, 0, 0, 0, 4224, 4229, 3, 734, 367, 0, 4225, 4226, 
	5, 24, 0, 0, 4226, 4228, 3, 734, 367, 0, 4227, 4225, 1, 0, 0, 0, 4228, 
	4231, 1, 0, 0, 0, 4229, 4227, 1, 0, 0, 0, 4229, 4230, 1, 0, 0, 0, 4230, 
	733, 1, 0, 0, 0, 4231, 4229, 1, 0, 0, 0, 4232, 4233, 3, 736, 368, 0, 4233, 
	4234, 5, 49, 0, 0, 4234, 4235, 3, 738, 369, 0, 4235, 735, 1, 0, 0, 0, 4236, 
	4237, 3, 728, 364, 0, 4237, 737, 1, 0, 0, 0, 4238, 4239, 5, 25, 0, 0, 4239, 
	4240, 3, 740, 370, 0, 4240, 4241, 5, 26, 0, 0, 4241, 739, 1, 0, 0, 0, 4242, 
	4244, 3, 742, 371, 0, 4243, 4242, 1, 0, 0, 0, 4243, 4244, 1, 0, 0, 0, 4244, 
	4246, 1, 0, 0, 0, 4245, 4247, 3, 744, 372, 0, 4246, 4245, 1, 0, 0, 0, 4246, 
	4247, 1, 0, 0, 0, 4247, 4249, 1, 0, 0, 0, 4248, 4250, 3, 746, 373, 0, 4249, 
	4248, 1, 0, 0, 0, 4249, 4250, 1, 0, 0, 0, 4250, 4252, 1, 0, 0, 0, 4251, 
	4253, 3, 748, 374, 0, 4252, 4251, 1, 0, 0, 0, 4252, 4253, 1, 0, 0, 0, 4253, 
	741, 1, 0, 0, 0, 4254, 4255, 3, 728, 364, 0, 4255, 743, 1, 0, 0, 0, 4256, 
	4258, 5, 217, 0, 0, 4257, 4259, 5, 78, 0, 0, 4258, 4257, 1, 0, 0, 0, 4258, 
	4259, 1, 0, 0, 0, 4259, 4260, 1, 0, 0, 0, 4260, 4261, 5, 66, 0, 0, 4261, 
	4262, 3, 130, 65, 0, 4262, 745, 1, 0, 0, 0, 4263, 4264, 3, 314, 157, 0, 
	4264, 747, 1, 0, 0, 0, 4265, 4266, 3, 750, 375, 0, 4266, 4268, 3, 752, 
	376, 0, 4267, 4269, 3, 758, 379, 0, 4268, 4267, 1, 0, 0, 0, 4268, 4269, 
	1, 0, 0, 0, 4269, 749, 1, 0, 0, 0, 4270, 4271, 7, 29, 0, 0, 4271, 751, 
	1, 0, 0, 0, 4272, 4275, 3, 756, 378, 0, 4273, 4275, 3, 754, 377, 0, 4274, 
	4272, 1, 0, 0, 0, 4274, 4273, 1, 0, 0, 0, 4275, 753, 1, 0, 0, 0, 4276, 
	4277, 5, 64, 0, 0, 4277, 4278, 3, 756, 378, 0, 4278, 4279, 5, 45, 0, 0, 
	4279, 4280, 3, 756, 378, 0, 4280, 755, 1, 0, 0, 0, 4281, 4282, 5, 88, 0, 
	0, 4282, 4289, 5, 261, 0, 0, 4283, 4286, 3, 14, 7, 0, 4284, 4286, 5, 301, 
	0, 0, 4285, 4283, 1, 0, 0, 0, 4285, 4284, 1, 0, 0, 0, 4286, 4287, 1, 0, 
	0, 0, 4287, 4289, 7, 30, 0, 0, 4288, 4281, 1, 0, 0, 0, 4288, 4285, 1, 0, 
	0, 0, 4289, 757, 1, 0, 0, 0, 4290, 4291, 5, 123, 0, 0, 4291, 4292, 5, 88, 
	0, 0, 4292, 4301, 5, 261, 0, 0, 4293, 4294, 5, 123, 0, 0, 4294, 4301, 5, 
	146, 0, 0, 4295, 4296, 5, 123, 0, 0, 4296, 4301, 5, 293, 0, 0, 4297, 4298, 
	5, 123, 0, 0, 4298, 4299, 5, 196, 0, 0, 4299, 4301, 5, 213, 0, 0, 4300, 
	4290, 1, 0, 0, 0, 4300, 4293, 1, 0, 0, 0, 4300, 4295, 1, 0, 0, 0, 4300, 
	4297, 1, 0, 0, 0, 4301, 759, 1, 0, 0, 0, 4302, 4303, 5, 309, 0, 0, 4303, 
	4304, 3, 826, 413, 0, 4304, 761, 1, 0, 0, 0, 4305, 4306, 5, 25, 0, 0, 4306, 
	4307, 3, 232, 116, 0, 4307, 4308, 5, 26, 0, 0, 4308, 4311, 1, 0, 0, 0, 
	4309, 4311, 3, 234, 117, 0, 4310, 4305, 1, 0, 0, 0, 4310, 4309, 1, 0, 0, 
	0, 4311, 763, 1, 0, 0, 0, 4312, 4313, 3, 148, 74, 0, 4313, 4316, 5, 1, 
	0, 0, 4314, 4317, 3, 14, 7, 0, 4315, 4317, 3, 762, 381, 0, 4316, 4314, 
	1, 0, 0, 0, 4316, 4315, 1, 0, 0, 0, 4317, 765, 1, 0, 0, 0, 4318, 4319, 
	5, 77, 0, 0, 4319, 767, 1, 0, 0, 0, 4320, 4321, 5, 259, 0, 0, 4321, 769, 
	1, 0, 0, 0, 4322, 4327, 3, 652, 326, 0, 4323, 4324, 5, 25, 0, 0, 4324, 
	4325, 3, 124, 62, 0, 4325, 4326, 5, 26, 0, 0, 4326, 4328, 1, 0, 0, 0, 4327, 
	4323, 1, 0, 0, 0, 4327, 4328, 1, 0, 0, 0, 4328, 771, 1, 0, 0, 0, 4329, 
	4334, 3, 770, 385, 0, 4330, 4331, 5, 24, 0, 0, 4331, 4333, 3, 770, 385, 
	0, 4332, 4330, 1, 0, 0, 0, 4333, 4336, 1, 0, 0, 0, 4334, 4332, 1, 0, 0, 
	0, 4334, 4335, 1, 0, 0, 0, 4335, 4338, 1, 0, 0, 0, 4336, 4334, 1, 0, 0, 
	0, 4337, 4339, 5, 24, 0, 0, 4338, 4337, 1, 0, 0, 0, 4338, 4339, 1, 0, 0, 
	0, 4339, 773, 1, 0, 0, 0, 4340, 4341, 5, 44, 0, 0, 4341, 4342, 3, 772, 
	386, 0, 4342, 775, 1, 0, 0, 0, 4343, 4344, 5, 43, 0, 0, 4344, 4347, 5, 
	274, 0, 0, 4345, 4346, 5, 152, 0, 0, 4346, 4348, 5, 126, 0, 0, 4347, 4345, 
	1, 0, 0, 0, 4347, 4348, 1, 0, 0, 0, 4348, 4349, 1, 0, 0, 0, 4349, 4351, 
	3, 648, 324, 0, 4350, 4352, 3, 778, 389, 0, 4351, 4350, 1, 0, 0, 0, 4352, 
	4353, 1, 0, 0, 0, 4353, 4351, 1, 0, 0, 0, 4353, 4354, 1, 0, 0, 0, 4354, 
	777, 1, 0, 0, 0, 4355, 4357, 5, 276, 0, 0, 4356, 4358, 5, 320, 0, 0, 4357, 
	4356, 1, 0, 0, 0, 4357, 4358, 1, 0, 0, 0, 4358, 4359, 1, 0, 0, 0, 4359, 
	4372, 3, 864, 432, 0, 4360, 4362, 5, 249, 0, 0, 4361, 4363, 5, 320, 0, 
	0, 4362, 4361, 1, 0, 0, 0, 4362, 4363, 1, 0, 0, 0, 4363, 4364, 1, 0, 0, 
	0, 4364, 4372, 3, 864, 432, 0, 4365, 4372, 5, 249, 0, 0, 4366, 4368, 5, 
	158, 0, 0, 4367, 4369, 5, 66, 0, 0, 4368, 4367, 1, 0, 0, 0, 4368, 4369, 
	1, 0, 0, 0, 4369, 4370, 1, 0, 0, 0, 4370, 4372, 3, 864, 432, 0, 4371, 4355, 
	1, 0, 0, 0, 4371, 4360, 1, 0, 0, 0, 4371, 4365, 1, 0, 0, 0, 4371, 4366, 
	1, 0, 0, 0, 4372, 779, 1, 0, 0, 0, 4373, 4374, 7, 31, 0, 0, 4374, 781, 
	1, 0, 0, 0, 4375, 4378, 3, 780, 390, 0, 4376, 4378, 3, 838, 419, 0, 4377, 
	4375, 1, 0, 0, 0, 4377, 4376, 1, 0, 0, 0, 4378, 783, 1, 0, 0, 0, 4379, 
	4387, 3, 780, 390, 0, 4380, 4387, 3, 856, 428, 0, 4381, 4387, 3, 840, 420, 
	0, 4382, 4387, 3, 844, 422, 0, 4383, 4387, 3, 848, 424, 0, 4384, 4387, 
	3, 850, 425, 0, 4385, 4387, 3, 852, 426, 0, 4386, 4379, 1, 0, 0, 0, 4386, 
	4380, 1, 0, 0, 0, 4386, 4381, 1, 0, 0, 0, 4386, 4382, 1, 0, 0, 0, 4386, 
	4383, 1, 0, 0, 0, 4386, 4384, 1, 0, 0, 0, 4386, 4385, 1, 0, 0, 0, 4387, 
	785, 1, 0, 0, 0, 4388, 4395, 3, 780, 390, 0, 4389, 4395, 3, 856, 428, 0, 
	4390, 4395, 3, 846, 423, 0, 4391, 4395, 3, 848, 424, 0, 4392, 4395, 3, 
	850, 425, 0, 4393, 4395, 3, 852, 426, 0, 4394, 4388, 1, 0, 0, 0, 4394, 
	4389, 1, 0, 0, 0, 4394, 4390, 1, 0, 0, 0, 4394, 4391, 1, 0, 0, 0, 4394, 
	4392, 1, 0, 0, 0, 4394, 4393, 1, 0, 0, 0, 4395, 787, 1, 0, 0, 0, 4396, 
	4402, 3, 780, 390, 0, 4397, 4402, 3, 856, 428, 0, 4398, 4402, 3, 846, 423, 
	0, 4399, 4402, 3, 850, 425, 0, 4400, 4402, 3, 852, 426, 0, 4401, 4396, 
	1, 0, 0, 0, 4401, 4397, 1, 0, 0, 0, 4401, 4398, 1, 0, 0, 0, 4401, 4399, 
	1, 0, 0, 0, 4401, 4400, 1, 0, 0, 0, 4402, 789, 1, 0, 0, 0, 4403, 4412, 
	3, 780, 390, 0, 4404, 4412, 3, 856, 428, 0, 4405, 4412, 3, 840, 420, 0, 
	4406, 4412, 3, 842, 421, 0, 4407, 4412, 3, 844, 422, 0, 4408, 4412, 3, 
	846, 423, 0, 4409, 4412, 3, 848, 424, 0, 4410, 4412, 3, 852, 426, 0, 4411, 
	4403, 1, 0, 0, 0, 4411, 4404, 1, 0, 0, 0, 4411, 4405, 1, 0, 0, 0, 4411, 
	4406, 1, 0, 0, 0, 4411, 4407, 1, 0, 0, 0, 4411, 4408, 1, 0, 0, 0, 4411, 
	4409, 1, 0, 0, 0, 4411, 4410, 1, 0, 0, 0, 4412, 791, 1, 0, 0, 0, 4413, 
	4421, 3, 780, 390, 0, 4414, 4421, 3, 856, 428, 0, 4415, 4421, 3, 840, 420, 
	0, 4416, 4421, 3, 844, 422, 0, 4417, 4421, 3, 848, 424, 0, 4418, 4421, 
	3, 850, 425, 0, 4419, 4421, 3, 852, 426, 0, 4420, 4413, 1, 0, 0, 0, 4420, 
	4414, 1, 0, 0, 0, 4420, 4415, 1, 0, 0, 0, 4420, 4416, 1, 0, 0, 0, 4420, 
	4417, 1, 0, 0, 0, 4420, 4418, 1, 0, 0, 0, 4420, 4419, 1, 0, 0, 0, 4421, 
	793, 1, 0, 0, 0, 4422, 4430, 3, 780, 390, 0, 4423, 4430, 3, 856, 428, 0, 
	4424, 4430, 3, 842, 421, 0, 4425, 4430, 3, 846, 423, 0, 4426, 4430, 3, 
	848, 424, 0, 4427, 4430, 3, 850, 425, 0, 4428, 4430, 3, 852, 426, 0, 4429, 
	4422, 1, 0, 0, 0, 4429, 4423, 1, 0, 0, 0, 4429, 4424, 1, 0, 0, 0, 4429, 
	4425, 1, 0, 0, 0, 4429, 4426, 1, 0, 0, 0, 4429, 4427, 1, 0, 0, 0, 4429, 
	4428, 1, 0, 0, 0, 4430, 795, 1, 0, 0, 0, 4431, 4440, 3, 780, 390, 0, 4432, 
	4440, 3, 856, 428, 0, 4433, 4440, 3, 840, 420, 0, 4434, 4440, 3, 842, 421, 
	0, 4435, 4440, 3, 844, 422, 0, 4436, 4440, 3, 846, 423, 0, 4437, 4440, 
	3, 848, 424, 0, 4438, 4440, 3, 850, 425, 0, 4439, 4431, 1, 0, 0, 0, 4439, 
	4432, 1, 0, 0, 0, 4439, 4433, 1, 0, 0, 0, 4439, 4434, 1, 0, 0, 0, 4439, 
	4435, 1, 0, 0, 0, 4439, 4436, 1, 0, 0, 0, 4439, 4437, 1, 0, 0, 0, 4439, 
	4438, 1, 0, 0, 0, 4440, 797, 1, 0, 0, 0, 4441, 4444, 3, 780, 390, 0, 4442, 
	4444, 3, 854, 427, 0, 4443, 4441, 1, 0, 0, 0, 4443, 4442, 1, 0, 0, 0, 4444, 
	799, 1, 0, 0, 0, 4445, 4448, 3, 782, 391, 0, 4446, 4448, 5, 324, 0, 0, 
	4447, 4445, 1, 0, 0, 0, 4447, 4446, 1, 0, 0, 0, 4448, 801, 1, 0, 0, 0, 
	4449, 4452, 3, 828, 414, 0, 4450, 4452, 5, 324, 0, 0, 4451, 4449, 1, 0, 
	0, 0, 4451, 4450, 1, 0, 0, 0, 4452, 803, 1, 0, 0, 0, 4453, 4456, 3, 784, 
	392, 0, 4454, 4456, 5, 324, 0, 0, 4455, 4453, 1, 0, 0, 0, 4455, 4454, 1, 
	0, 0, 0, 4456, 805, 1, 0, 0, 0, 4457, 4460, 3, 786, 393, 0, 4458, 4460, 
	5, 324, 0, 0, 4459, 4457, 1, 0, 0, 0, 4459, 4458, 1, 0, 0, 0, 4460, 807, 
	1, 0, 0, 0, 4461, 4464, 3, 788, 394, 0, 4462, 4464, 5, 324, 0, 0, 4463, 
	4461, 1, 0, 0, 0, 4463, 4462, 1, 0, 0, 0, 4464, 809, 1, 0, 0, 0, 4465, 
	4468, 3, 790, 395, 0, 4466, 4468, 5, 324, 0, 0, 4467, 4465, 1, 0, 0, 0, 
	4467, 4466, 1, 0, 0, 0, 4468, 811, 1, 0, 0, 0, 4469, 4472, 3, 792, 396, 
	0, 4470, 4472, 5, 324, 0, 0, 4471, 4469, 1, 0, 0, 0, 4471, 4470, 1, 0, 
	0, 0, 4472, 813, 1, 0, 0, 0, 4473, 4476, 3, 794, 397, 0, 4474, 4476, 5, 
	324, 0, 0, 4475, 4473, 1, 0, 0, 0, 4475, 4474, 1, 0, 0, 0, 4476, 815, 1, 
	0, 0, 0, 4477, 4480, 3, 796, 398, 0, 4478, 4480, 5, 324, 0, 0, 4479, 4477, 
	1, 0, 0, 0, 4479, 4478, 1, 0, 0, 0, 4480, 817, 1, 0, 0, 0, 4481, 4484, 
	3, 780, 390, 0, 4482, 4484, 5, 324, 0, 0, 4483, 4481, 1, 0, 0, 0, 4483, 
	4482, 1, 0, 0, 0, 4484, 819, 1, 0, 0, 0, 4485, 4488, 3, 798, 399, 0, 4486, 
	4488, 5, 324, 0, 0, 4487, 4485, 1, 0, 0, 0, 4487, 4486, 1, 0, 0, 0, 4488, 
	821, 1, 0, 0, 0, 4489, 4493, 3, 800, 400, 0, 4490, 4491, 5, 229, 0, 0, 
	4491, 4493, 5, 176, 0, 0, 4492, 4489, 1, 0, 0, 0, 4492, 4490, 1, 0, 0, 
	0, 4493, 823, 1, 0, 0, 0, 4494, 4495, 3, 800, 400, 0, 4495, 4496, 5, 23, 
	0, 0, 4496, 4498, 1, 0, 0, 0, 4497, 4494, 1, 0, 0, 0, 4497, 4498, 1, 0, 
	0, 0, 4498, 825, 1, 0, 0, 0, 4499, 4500, 3, 800, 400, 0, 4500, 4501, 5, 
	28, 0, 0, 4501, 4503, 1, 0, 0, 0, 4502, 4499, 1, 0, 0, 0, 4502, 4503, 1, 
	0, 0, 0, 4503, 4506, 1, 0, 0, 0, 4504, 4507, 3, 116, 58, 0, 4505, 4507, 
	5, 19, 0, 0, 4506, 4504, 1, 0, 0, 0, 4506, 4505, 1, 0, 0, 0, 4507, 827, 
	1, 0, 0, 0, 4508, 4511, 3, 782, 391, 0, 4509, 4511, 3, 858, 429, 0, 4510, 
	4508, 1, 0, 0, 0, 4510, 4509, 1, 0, 0, 0, 4511, 829, 1, 0, 0, 0, 4512, 
	4513, 3, 802, 401, 0, 4513, 4514, 5, 23, 0, 0, 4514, 4516, 1, 0, 0, 0, 
	4515, 4512, 1, 0, 0, 0, 4515, 4516, 1, 0, 0, 0, 4516, 831, 1, 0, 0, 0, 
	4517, 4519, 5, 29, 0, 0, 4518, 4517, 1, 0, 0, 0, 4518, 4519, 1, 0, 0, 0, 
	4519, 4520, 1, 0, 0, 0, 4520, 4521, 3, 802, 401, 0, 4521, 833, 1, 0, 0, 
	0, 4522, 4525, 3, 812, 406, 0, 4523, 4525, 3, 858, 429, 0, 4524, 4522, 
	1, 0, 0, 0, 4524, 4523, 1, 0, 0, 0, 4525, 835, 1, 0, 0, 0, 4526, 4528, 
	5, 29, 0, 0, 4527, 4526, 1, 0, 0, 0, 4527, 4528, 1, 0, 0, 0, 4528, 4529, 
	1, 0, 0, 0, 4529, 4530, 3, 834, 417, 0, 4530, 837, 1, 0, 0, 0, 4531, 4540, 
	3, 856, 428, 0, 4532, 4540, 3, 840, 420, 0, 4533, 4540, 3, 842, 421, 0, 
	4534, 4540, 3, 844, 422, 0, 4535, 4540, 3, 846, 423, 0, 4536, 4540, 3, 
	848, 424, 0, 4537, 4540, 3, 850, 425, 0, 4538, 4540, 3, 852, 426, 0, 4539, 
	4531, 1, 0, 0, 0, 4539, 4532, 1, 0, 0, 0, 4539, 4533, 1, 0, 0, 0, 4539, 
	4534, 1, 0, 0, 0, 4539, 4535, 1, 0, 0, 0, 4539, 4536, 1, 0, 0, 0, 4539, 
	4537, 1, 0, 0, 0, 4539, 4538, 1, 0, 0, 0, 4540, 839, 1, 0, 0, 0, 4541, 
	4542, 7, 32, 0, 0, 4542, 841, 1, 0, 0, 0, 4543, 4544, 7, 33, 0, 0, 4544, 
	843, 1, 0, 0, 0, 4545, 4546, 7, 34, 0, 0, 4546, 845, 1, 0, 0, 0, 4547, 
	4548, 5, 75, 0, 0, 4548, 847, 1, 0, 0, 0, 4549, 4550, 5, 78, 0, 0, 4550, 
	849, 1, 0, 0, 0, 4551, 4552, 7, 29, 0, 0, 4552, 851, 1, 0, 0, 0, 4553, 
	4554, 7, 28, 0, 0, 4554, 853, 1, 0, 0, 0, 4555, 4556, 7, 35, 0, 0, 4556, 
	855, 1, 0, 0, 0, 4557, 4558, 7, 36, 0, 0, 4558, 857, 1, 0, 0, 0, 4559, 
	4560, 7, 37, 0, 0, 4560, 859, 1, 0, 0, 0, 4561, 4562, 7, 38, 0, 0, 4562, 
	861, 1, 0, 0, 0, 4563, 4564, 5, 329, 0, 0, 4564, 863, 1, 0, 0, 0, 4565, 
	4566, 7, 39, 0, 0, 4566, 865, 1, 0, 0, 0, 505, 871, 876, 883, 888, 894, 
	902, 910, 917, 921, 929, 934, 939, 941, 1002, 1009, 1013, 1020, 1028, 1033, 
	1037, 1043, 1049, 1052, 1056, 1064, 1068, 1071, 1075, 1086, 1091, 1093, 
	1102, 1123, 1128, 1137, 1139, 1146, 1154, 1162, 1169, 1179, 1181, 1185, 
	1190, 1194, 1200, 1206, 1210, 1214, 1217, 1224, 1230, 1234, 1239, 1242, 
	1256, 1261, 1264, 1278, 1285, 1296, 1307, 1327, 1333, 1338, 1342, 1356, 
	1358, 1365, 1371, 1382, 1390, 1396, 1403, 1411, 1424, 1430, 1434, 1437, 
	1439, 1447, 1455, 1461, 1467, 1473, 1476, 1485, 1494, 1501, 1509, 1522, 
	1529, 1533, 1540, 1544, 1549, 1556, 1563, 1566, 1573, 1577, 1587, 1610, 
	1616, 1620, 1627, 1633, 1640, 1644, 1648, 1654, 1659, 1668, 1671, 1677, 
	1682, 1690, 1697, 1719, 1723, 1725, 1729, 1738, 1742, 1744, 1748, 1757, 
	1761, 1799, 1803, 1823, 1826, 1832, 1852, 1857, 1863, 1868, 1871, 1875, 
	1902, 1910, 1913, 1920, 1933, 1937, 1949, 1962, 1967, 1974, 1978, 1985, 
	1994, 2003, 2011, 2015, 2019, 2026, 2028, 2031, 2036, 2041, 2045, 2052, 
	2059, 2063, 2067, 2071, 2075, 2077, 2088, 2097, 2102, 2108, 2113, 2117, 
	2121, 2125, 2128, 2132, 2136, 2144, 2148, 2152, 2156, 2160, 2163, 2167, 
	2170, 2173, 2178, 2181, 2184, 2187, 2201, 2203, 2214, 2224, 2234, 2237, 
	2244, 2268, 2279, 2285, 2289, 2293, 2297, 2301, 2305, 2309, 2313, 2319, 
	2326, 2336, 2347, 2360, 2376, 2386, 2406, 2412, 2419, 2426, 2434, 2443, 
	2480, 2482, 2485, 2490, 2494, 2498, 2504, 2510, 2514, 2519, 2524, 2526, 
	2530, 2535, 2538, 2540, 2544, 2555, 2566, 2577, 2581, 2585, 2589, 2592, 
	2596, 2599, 2605, 2614, 2617, 2631, 2637, 2640, 2645, 2652, 2659, 2668, 
	2673, 2681, 2696, 2702, 2710, 2719, 2723, 2732, 2744, 2751, 2759, 2780, 
	2788, 2797, 2807, 2816, 2821, 2828, 2838, 2843, 2852, 2856, 2860, 2863, 
	2866, 2869, 2872, 2880, 2885, 2896, 2903, 2916, 2924, 2929, 2936, 2949, 
	2960, 2970, 2976, 2985, 3002, 3025, 3045, 3056, 3064, 3074, 3079, 3083, 
	3089, 3127, 3139, 3181, 3189, 3192, 3196, 3200, 3210, 3223, 3236, 3241, 
	3253, 3264, 3269, 3272, 3276, 3280, 3284, 3287, 3300, 3304, 3316, 3330, 
	3345, 3360, 3363, 3373, 3376, 3384, 3396, 3399, 3409, 3417, 3423, 3431, 
	3439, 3446, 3450, 3460, 3467, 3472, 3477, 3489, 3493, 3495, 3507, 3511, 
	3516, 3522, 3529, 3533, 3537, 3541, 3544, 3559, 3568, 3572, 3577, 3583, 
	3592, 3601, 3618, 3622, 3626, 3628, 3632, 3639, 3643, 3647, 3649, 3666, 
	3671, 3695, 3700, 3718, 3735, 3751, 3766, 3773, 3781, 3792, 3799, 3804, 
	3810, 3813, 3816, 3823, 3826, 3829, 3838, 3843, 3846, 3856, 3860, 3862, 
	3869, 3872, 3876, 3878, 3881, 3886, 3889, 3894, 3904, 3909, 3920, 3924, 
	3928, 3930, 3934, 3939, 3947, 3950, 3953, 3956, 3961, 3967, 3970, 3974, 
	3980, 3989, 3992, 4000, 4004, 4007, 4011, 4018, 4039, 4049, 4053, 4056, 
	4064, 4080, 4088, 4096, 4104, 4113, 4131, 4148, 4157, 4166, 4185, 4197, 
	4207, 4217, 4229, 4243, 4246, 4249, 4252, 4258, 4268, 4274, 4285, 4288, 
	4300, 4310, 4316, 4327, 4334, 4338, 4347, 4353, 4357, 4362, 4368, 4371, 
	4377, 4386, 4394, 4401, 4411, 4420, 4429, 4439, 4443, 4447, 4451, 4455, 
	4459, 4463, 4467, 4471, 4475, 4479, 4483, 4487, 4492, 4497, 4502, 4506, 
	4510, 4515, 4518, 4524, 4527, 4539,
}
  deserializer := antlr.NewATNDeserializer(nil)
  staticData.atn = deserializer.Deserialize(staticData.serializedATN)
  atn := staticData.atn
  staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
  decisionToDFA := staticData.decisionToDFA
  for index, state := range atn.DecisionToState {
    decisionToDFA[index] = antlr.NewDFA(state, index)
  }
}

// YQLParserInit initializes any static state used to implement YQLParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewYQLParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func YQLParserInit() {
  staticData := &YQLParserStaticData
  staticData.once.Do(yqlParserInit)
}

// NewYQLParser produces a new parser instance for the optional input antlr.TokenStream.
func NewYQLParser(input antlr.TokenStream) *YQLParser {
	YQLParserInit()
	this := new(YQLParser)
	this.BaseParser = antlr.NewBaseParser(input)
  staticData := &YQLParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "YQL.g4"

	return this
}


// YQLParser tokens.
const (
	YQLParserEOF = antlr.TokenEOF
	YQLParserEQUALS = 1
	YQLParserEQUALS2 = 2
	YQLParserNOT_EQUALS = 3
	YQLParserNOT_EQUALS2 = 4
	YQLParserLESS = 5
	YQLParserLESS_OR_EQ = 6
	YQLParserGREATER = 7
	YQLParserGREATER_OR_EQ = 8
	YQLParserSHIFT_LEFT = 9
	YQLParserROT_LEFT = 10
	YQLParserAMPERSAND = 11
	YQLParserPIPE = 12
	YQLParserDOUBLE_PIPE = 13
	YQLParserSTRUCT_OPEN = 14
	YQLParserSTRUCT_CLOSE = 15
	YQLParserPLUS = 16
	YQLParserMINUS = 17
	YQLParserTILDA = 18
	YQLParserASTERISK = 19
	YQLParserSLASH = 20
	YQLParserPERCENT = 21
	YQLParserSEMICOLON = 22
	YQLParserDOT = 23
	YQLParserCOMMA = 24
	YQLParserLPAREN = 25
	YQLParserRPAREN = 26
	YQLParserQUESTION = 27
	YQLParserCOLON = 28
	YQLParserCOMMAT = 29
	YQLParserDOLLAR = 30
	YQLParserLBRACE_CURLY = 31
	YQLParserRBRACE_CURLY = 32
	YQLParserCARET = 33
	YQLParserNAMESPACE = 34
	YQLParserARROW = 35
	YQLParserRBRACE_SQUARE = 36
	YQLParserLBRACE_SQUARE = 37
	YQLParserABORT = 38
	YQLParserACTION = 39
	YQLParserADD = 40
	YQLParserAFTER = 41
	YQLParserALL = 42
	YQLParserALTER = 43
	YQLParserANALYZE = 44
	YQLParserAND = 45
	YQLParserANSI = 46
	YQLParserANY = 47
	YQLParserARRAY = 48
	YQLParserAS = 49
	YQLParserASC = 50
	YQLParserASSUME = 51
	YQLParserASYMMETRIC = 52
	YQLParserASYNC = 53
	YQLParserAT = 54
	YQLParserATTACH = 55
	YQLParserATTRIBUTES = 56
	YQLParserAUTOINCREMENT = 57
	YQLParserAUTOMAP = 58
	YQLParserBACKUP = 59
	YQLParserCOLLECTION = 60
	YQLParserBEFORE = 61
	YQLParserBEGIN = 62
	YQLParserBERNOULLI = 63
	YQLParserBETWEEN = 64
	YQLParserBITCAST = 65
	YQLParserBY = 66
	YQLParserCALLABLE = 67
	YQLParserCASCADE = 68
	YQLParserCASE = 69
	YQLParserCAST = 70
	YQLParserCHANGEFEED = 71
	YQLParserCHECK = 72
	YQLParserCLASSIFIER = 73
	YQLParserCOLLATE = 74
	YQLParserCOLUMN = 75
	YQLParserCOLUMNS = 76
	YQLParserCOMMIT = 77
	YQLParserCOMPACT = 78
	YQLParserCONDITIONAL = 79
	YQLParserCONFLICT = 80
	YQLParserCONNECT = 81
	YQLParserCONSTRAINT = 82
	YQLParserCONSUMER = 83
	YQLParserCOVER = 84
	YQLParserCREATE = 85
	YQLParserCROSS = 86
	YQLParserCUBE = 87
	YQLParserCURRENT = 88
	YQLParserCURRENT_DATE = 89
	YQLParserCURRENT_TIME = 90
	YQLParserCURRENT_TIMESTAMP = 91
	YQLParserDATA = 92
	YQLParserDATABASE = 93
	YQLParserDECIMAL = 94
	YQLParserDECLARE = 95
	YQLParserDEFAULT = 96
	YQLParserDEFERRABLE = 97
	YQLParserDEFERRED = 98
	YQLParserDEFINE = 99
	YQLParserDELETE = 100
	YQLParserDESC = 101
	YQLParserDESCRIBE = 102
	YQLParserDETACH = 103
	YQLParserDICT = 104
	YQLParserDIRECTORY = 105
	YQLParserDISABLE = 106
	YQLParserDISCARD = 107
	YQLParserDISTINCT = 108
	YQLParserDO = 109
	YQLParserDROP = 110
	YQLParserEACH = 111
	YQLParserELSE = 112
	YQLParserEMPTY = 113
	YQLParserEMPTY_ACTION = 114
	YQLParserENCRYPTED = 115
	YQLParserEND = 116
	YQLParserENUM = 117
	YQLParserERASE = 118
	YQLParserERROR = 119
	YQLParserESCAPE = 120
	YQLParserEVALUATE = 121
	YQLParserEXCEPT = 122
	YQLParserEXCLUDE = 123
	YQLParserEXCLUSION = 124
	YQLParserEXCLUSIVE = 125
	YQLParserEXISTS = 126
	YQLParserEXPLAIN = 127
	YQLParserEXPORT = 128
	YQLParserEXTERNAL = 129
	YQLParserFAIL = 130
	YQLParserFALSE = 131
	YQLParserFAMILY = 132
	YQLParserFILTER = 133
	YQLParserFIRST = 134
	YQLParserFLATTEN = 135
	YQLParserFLOW = 136
	YQLParserFOLLOWING = 137
	YQLParserFOR = 138
	YQLParserFOREIGN = 139
	YQLParserFROM = 140
	YQLParserFULL = 141
	YQLParserFUNCTION = 142
	YQLParserGLOB = 143
	YQLParserGLOBAL = 144
	YQLParserGRANT = 145
	YQLParserGROUP = 146
	YQLParserGROUPING = 147
	YQLParserGROUPS = 148
	YQLParserHASH = 149
	YQLParserHAVING = 150
	YQLParserHOP = 151
	YQLParserIF = 152
	YQLParserIGNORE = 153
	YQLParserILIKE = 154
	YQLParserIMMEDIATE = 155
	YQLParserIMPORT = 156
	YQLParserIN = 157
	YQLParserINCREMENT = 158
	YQLParserINCREMENTAL = 159
	YQLParserINDEX = 160
	YQLParserINDEXED = 161
	YQLParserINHERITS = 162
	YQLParserINITIAL = 163
	YQLParserINITIALLY = 164
	YQLParserINNER = 165
	YQLParserINSERT = 166
	YQLParserINSTEAD = 167
	YQLParserINTERSECT = 168
	YQLParserINTO = 169
	YQLParserIS = 170
	YQLParserISNULL = 171
	YQLParserJOIN = 172
	YQLParserJSON_EXISTS = 173
	YQLParserJSON_QUERY = 174
	YQLParserJSON_VALUE = 175
	YQLParserKEY = 176
	YQLParserLAST = 177
	YQLParserLEFT = 178
	YQLParserLEGACY = 179
	YQLParserLIKE = 180
	YQLParserLIMIT = 181
	YQLParserLIST = 182
	YQLParserLOCAL = 183
	YQLParserLOGIN = 184
	YQLParserMANAGE = 185
	YQLParserMATCH = 186
	YQLParserMATCHES = 187
	YQLParserMATCH_RECOGNIZE = 188
	YQLParserMEASURES = 189
	YQLParserMICROSECONDS = 190
	YQLParserMILLISECONDS = 191
	YQLParserMODIFY = 192
	YQLParserNANOSECONDS = 193
	YQLParserNATURAL = 194
	YQLParserNEXT = 195
	YQLParserNO = 196
	YQLParserNOLOGIN = 197
	YQLParserNOT = 198
	YQLParserNOTNULL = 199
	YQLParserNULL = 200
	YQLParserNULLS = 201
	YQLParserOBJECT = 202
	YQLParserOF = 203
	YQLParserOFFSET = 204
	YQLParserOMIT = 205
	YQLParserON = 206
	YQLParserONE = 207
	YQLParserONLY = 208
	YQLParserOPTION = 209
	YQLParserOPTIONAL = 210
	YQLParserOR = 211
	YQLParserORDER = 212
	YQLParserOTHERS = 213
	YQLParserOUTER = 214
	YQLParserOVER = 215
	YQLParserPARALLEL = 216
	YQLParserPARTITION = 217
	YQLParserPASSING = 218
	YQLParserPASSWORD = 219
	YQLParserPAST = 220
	YQLParserPATTERN = 221
	YQLParserPER = 222
	YQLParserPERMUTE = 223
	YQLParserPLAN = 224
	YQLParserPOOL = 225
	YQLParserPRAGMA = 226
	YQLParserPRECEDING = 227
	YQLParserPRESORT = 228
	YQLParserPRIMARY = 229
	YQLParserPRIVILEGES = 230
	YQLParserPROCESS = 231
	YQLParserQUERY = 232
	YQLParserQUEUE = 233
	YQLParserRAISE = 234
	YQLParserRANGE = 235
	YQLParserREDUCE = 236
	YQLParserREFERENCES = 237
	YQLParserREGEXP = 238
	YQLParserREINDEX = 239
	YQLParserRELEASE = 240
	YQLParserREMOVE = 241
	YQLParserRENAME = 242
	YQLParserREPEATABLE = 243
	YQLParserREPLACE = 244
	YQLParserREPLICATION = 245
	YQLParserRESET = 246
	YQLParserRESOURCE = 247
	YQLParserRESPECT = 248
	YQLParserRESTART = 249
	YQLParserRESTORE = 250
	YQLParserRESTRICT = 251
	YQLParserRESULT = 252
	YQLParserRETURN = 253
	YQLParserRETURNING = 254
	YQLParserREVERT = 255
	YQLParserREVOKE = 256
	YQLParserRIGHT = 257
	YQLParserRLIKE = 258
	YQLParserROLLBACK = 259
	YQLParserROLLUP = 260
	YQLParserROW = 261
	YQLParserROWS = 262
	YQLParserSAMPLE = 263
	YQLParserSAVEPOINT = 264
	YQLParserSCHEMA = 265
	YQLParserSECONDS = 266
	YQLParserSEEK = 267
	YQLParserSELECT = 268
	YQLParserSEMI = 269
	YQLParserSET = 270
	YQLParserSETS = 271
	YQLParserSHOW = 272
	YQLParserTSKIP = 273
	YQLParserSEQUENCE = 274
	YQLParserSOURCE = 275
	YQLParserSTART = 276
	YQLParserSTREAM = 277
	YQLParserSTRUCT = 278
	YQLParserSUBQUERY = 279
	YQLParserSUBSET = 280
	YQLParserSYMBOLS = 281
	YQLParserSYMMETRIC = 282
	YQLParserSYNC = 283
	YQLParserSYSTEM = 284
	YQLParserTABLE = 285
	YQLParserTABLES = 286
	YQLParserTABLESAMPLE = 287
	YQLParserTABLESTORE = 288
	YQLParserTAGGED = 289
	YQLParserTEMP = 290
	YQLParserTEMPORARY = 291
	YQLParserTHEN = 292
	YQLParserTIES = 293
	YQLParserTO = 294
	YQLParserTOPIC = 295
	YQLParserTRANSACTION = 296
	YQLParserTRIGGER = 297
	YQLParserTRUE = 298
	YQLParserTUPLE = 299
	YQLParserTYPE = 300
	YQLParserUNBOUNDED = 301
	YQLParserUNCONDITIONAL = 302
	YQLParserUNION = 303
	YQLParserUNIQUE = 304
	YQLParserUNKNOWN = 305
	YQLParserUNMATCHED = 306
	YQLParserUPDATE = 307
	YQLParserUPSERT = 308
	YQLParserUSE = 309
	YQLParserUSER = 310
	YQLParserUSING = 311
	YQLParserVACUUM = 312
	YQLParserVALUES = 313
	YQLParserVARIANT = 314
	YQLParserVIEW = 315
	YQLParserVIRTUAL = 316
	YQLParserWHEN = 317
	YQLParserWHERE = 318
	YQLParserWINDOW = 319
	YQLParserWITH = 320
	YQLParserWITHOUT = 321
	YQLParserWRAPPER = 322
	YQLParserXOR = 323
	YQLParserSTRING_VALUE = 324
	YQLParserID_PLAIN = 325
	YQLParserID_QUOTED = 326
	YQLParserDIGITS = 327
	YQLParserINTEGER_VALUE = 328
	YQLParserREAL = 329
	YQLParserBLOB = 330
	YQLParserWS = 331
	YQLParserCOMMENT = 332
)

// YQLParser rules.
const (
	YQLParserRULE_sql_query = 0
	YQLParserRULE_sql_stmt_list = 1
	YQLParserRULE_ansi_sql_stmt_list = 2
	YQLParserRULE_lambda_body = 3
	YQLParserRULE_lambda_stmt = 4
	YQLParserRULE_sql_stmt = 5
	YQLParserRULE_sql_stmt_core = 6
	YQLParserRULE_expr = 7
	YQLParserRULE_or_subexpr = 8
	YQLParserRULE_and_subexpr = 9
	YQLParserRULE_xor_subexpr = 10
	YQLParserRULE_distinct_from_op = 11
	YQLParserRULE_cond_expr = 12
	YQLParserRULE_match_op = 13
	YQLParserRULE_eq_subexpr = 14
	YQLParserRULE_shift_right = 15
	YQLParserRULE_rot_right = 16
	YQLParserRULE_double_question = 17
	YQLParserRULE_neq_subexpr = 18
	YQLParserRULE_bit_subexpr = 19
	YQLParserRULE_add_subexpr = 20
	YQLParserRULE_mul_subexpr = 21
	YQLParserRULE_con_subexpr = 22
	YQLParserRULE_unary_op = 23
	YQLParserRULE_unary_subexpr_suffix = 24
	YQLParserRULE_unary_casual_subexpr = 25
	YQLParserRULE_in_unary_casual_subexpr = 26
	YQLParserRULE_unary_subexpr = 27
	YQLParserRULE_in_unary_subexpr = 28
	YQLParserRULE_list_literal = 29
	YQLParserRULE_expr_dict_list = 30
	YQLParserRULE_dict_literal = 31
	YQLParserRULE_expr_struct_list = 32
	YQLParserRULE_struct_literal = 33
	YQLParserRULE_atom_expr = 34
	YQLParserRULE_in_atom_expr = 35
	YQLParserRULE_cast_expr = 36
	YQLParserRULE_bitcast_expr = 37
	YQLParserRULE_exists_expr = 38
	YQLParserRULE_case_expr = 39
	YQLParserRULE_lambda = 40
	YQLParserRULE_in_expr = 41
	YQLParserRULE_json_api_expr = 42
	YQLParserRULE_jsonpath_spec = 43
	YQLParserRULE_json_variable_name = 44
	YQLParserRULE_json_variable = 45
	YQLParserRULE_json_variables = 46
	YQLParserRULE_json_common_args = 47
	YQLParserRULE_json_case_handler = 48
	YQLParserRULE_json_value = 49
	YQLParserRULE_json_exists_handler = 50
	YQLParserRULE_json_exists = 51
	YQLParserRULE_json_query_wrapper = 52
	YQLParserRULE_json_query_handler = 53
	YQLParserRULE_json_query = 54
	YQLParserRULE_smart_parenthesis = 55
	YQLParserRULE_expr_list = 56
	YQLParserRULE_pure_column_list = 57
	YQLParserRULE_pure_column_or_named = 58
	YQLParserRULE_pure_column_or_named_list = 59
	YQLParserRULE_column_name = 60
	YQLParserRULE_without_column_name = 61
	YQLParserRULE_column_list = 62
	YQLParserRULE_without_column_list = 63
	YQLParserRULE_named_expr = 64
	YQLParserRULE_named_expr_list = 65
	YQLParserRULE_invoke_expr = 66
	YQLParserRULE_invoke_expr_tail = 67
	YQLParserRULE_using_call_expr = 68
	YQLParserRULE_key_expr = 69
	YQLParserRULE_when_expr = 70
	YQLParserRULE_literal_value = 71
	YQLParserRULE_bind_parameter = 72
	YQLParserRULE_opt_bind_parameter = 73
	YQLParserRULE_bind_parameter_list = 74
	YQLParserRULE_named_bind_parameter = 75
	YQLParserRULE_named_bind_parameter_list = 76
	YQLParserRULE_signed_number = 77
	YQLParserRULE_type_name_simple = 78
	YQLParserRULE_integer_or_bind = 79
	YQLParserRULE_type_name_tag = 80
	YQLParserRULE_struct_arg = 81
	YQLParserRULE_struct_arg_positional = 82
	YQLParserRULE_variant_arg = 83
	YQLParserRULE_callable_arg = 84
	YQLParserRULE_callable_arg_list = 85
	YQLParserRULE_type_name_decimal = 86
	YQLParserRULE_type_name_optional = 87
	YQLParserRULE_type_name_tuple = 88
	YQLParserRULE_type_name_struct = 89
	YQLParserRULE_type_name_variant = 90
	YQLParserRULE_type_name_list = 91
	YQLParserRULE_type_name_stream = 92
	YQLParserRULE_type_name_flow = 93
	YQLParserRULE_type_name_dict = 94
	YQLParserRULE_type_name_set = 95
	YQLParserRULE_type_name_enum = 96
	YQLParserRULE_type_name_resource = 97
	YQLParserRULE_type_name_tagged = 98
	YQLParserRULE_type_name_callable = 99
	YQLParserRULE_type_name_composite = 100
	YQLParserRULE_type_name = 101
	YQLParserRULE_type_name_or_bind = 102
	YQLParserRULE_value_constructor_literal = 103
	YQLParserRULE_value_constructor = 104
	YQLParserRULE_declare_stmt = 105
	YQLParserRULE_module_path = 106
	YQLParserRULE_import_stmt = 107
	YQLParserRULE_export_stmt = 108
	YQLParserRULE_call_action = 109
	YQLParserRULE_inline_action = 110
	YQLParserRULE_do_stmt = 111
	YQLParserRULE_pragma_stmt = 112
	YQLParserRULE_pragma_value = 113
	YQLParserRULE_sort_specification = 114
	YQLParserRULE_sort_specification_list = 115
	YQLParserRULE_select_stmt = 116
	YQLParserRULE_select_unparenthesized_stmt = 117
	YQLParserRULE_select_kind_parenthesis = 118
	YQLParserRULE_select_op = 119
	YQLParserRULE_select_kind_partial = 120
	YQLParserRULE_select_kind = 121
	YQLParserRULE_process_core = 122
	YQLParserRULE_external_call_param = 123
	YQLParserRULE_external_call_settings = 124
	YQLParserRULE_reduce_core = 125
	YQLParserRULE_opt_set_quantifier = 126
	YQLParserRULE_select_core = 127
	YQLParserRULE_row_pattern_recognition_clause = 128
	YQLParserRULE_row_pattern_rows_per_match = 129
	YQLParserRULE_row_pattern_empty_match_handling = 130
	YQLParserRULE_row_pattern_measures = 131
	YQLParserRULE_row_pattern_measure_list = 132
	YQLParserRULE_row_pattern_measure_definition = 133
	YQLParserRULE_row_pattern_common_syntax = 134
	YQLParserRULE_row_pattern_skip_to = 135
	YQLParserRULE_row_pattern_skip_to_variable_name = 136
	YQLParserRULE_row_pattern_initial_or_seek = 137
	YQLParserRULE_row_pattern = 138
	YQLParserRULE_row_pattern_term = 139
	YQLParserRULE_row_pattern_factor = 140
	YQLParserRULE_row_pattern_quantifier = 141
	YQLParserRULE_row_pattern_primary = 142
	YQLParserRULE_row_pattern_primary_variable_name = 143
	YQLParserRULE_row_pattern_permute = 144
	YQLParserRULE_row_pattern_subset_clause = 145
	YQLParserRULE_row_pattern_subset_list = 146
	YQLParserRULE_row_pattern_subset_item = 147
	YQLParserRULE_row_pattern_subset_item_variable_name = 148
	YQLParserRULE_row_pattern_subset_rhs = 149
	YQLParserRULE_row_pattern_subset_rhs_variable_name = 150
	YQLParserRULE_row_pattern_definition_list = 151
	YQLParserRULE_row_pattern_definition = 152
	YQLParserRULE_row_pattern_definition_variable_name = 153
	YQLParserRULE_row_pattern_definition_search_condition = 154
	YQLParserRULE_search_condition = 155
	YQLParserRULE_row_pattern_variable_name = 156
	YQLParserRULE_order_by_clause = 157
	YQLParserRULE_ext_order_by_clause = 158
	YQLParserRULE_group_by_clause = 159
	YQLParserRULE_grouping_element_list = 160
	YQLParserRULE_grouping_element = 161
	YQLParserRULE_ordinary_grouping_set = 162
	YQLParserRULE_ordinary_grouping_set_list = 163
	YQLParserRULE_rollup_list = 164
	YQLParserRULE_cube_list = 165
	YQLParserRULE_grouping_sets_specification = 166
	YQLParserRULE_hopping_window_specification = 167
	YQLParserRULE_result_column = 168
	YQLParserRULE_join_source = 169
	YQLParserRULE_named_column = 170
	YQLParserRULE_flatten_by_arg = 171
	YQLParserRULE_flatten_source = 172
	YQLParserRULE_named_single_source = 173
	YQLParserRULE_single_source = 174
	YQLParserRULE_sample_clause = 175
	YQLParserRULE_tablesample_clause = 176
	YQLParserRULE_sampling_mode = 177
	YQLParserRULE_repeatable_clause = 178
	YQLParserRULE_join_op = 179
	YQLParserRULE_join_constraint = 180
	YQLParserRULE_returning_columns_list = 181
	YQLParserRULE_into_table_stmt = 182
	YQLParserRULE_into_values_source = 183
	YQLParserRULE_values_stmt = 184
	YQLParserRULE_values_source = 185
	YQLParserRULE_values_source_row_list = 186
	YQLParserRULE_values_source_row = 187
	YQLParserRULE_simple_values_source = 188
	YQLParserRULE_create_external_data_source_stmt = 189
	YQLParserRULE_alter_external_data_source_stmt = 190
	YQLParserRULE_alter_external_data_source_action = 191
	YQLParserRULE_drop_external_data_source_stmt = 192
	YQLParserRULE_create_view_stmt = 193
	YQLParserRULE_drop_view_stmt = 194
	YQLParserRULE_upsert_object_stmt = 195
	YQLParserRULE_create_object_stmt = 196
	YQLParserRULE_create_object_features = 197
	YQLParserRULE_alter_object_stmt = 198
	YQLParserRULE_alter_object_features = 199
	YQLParserRULE_drop_object_stmt = 200
	YQLParserRULE_drop_object_features = 201
	YQLParserRULE_object_feature_value = 202
	YQLParserRULE_object_feature_kv = 203
	YQLParserRULE_object_feature_flag = 204
	YQLParserRULE_object_feature = 205
	YQLParserRULE_object_features = 206
	YQLParserRULE_object_type_ref = 207
	YQLParserRULE_create_table_stmt = 208
	YQLParserRULE_create_table_entry = 209
	YQLParserRULE_create_backup_collection_stmt = 210
	YQLParserRULE_alter_backup_collection_stmt = 211
	YQLParserRULE_drop_backup_collection_stmt = 212
	YQLParserRULE_create_backup_collection_entries = 213
	YQLParserRULE_create_backup_collection_entries_many = 214
	YQLParserRULE_table_list = 215
	YQLParserRULE_alter_backup_collection_actions = 216
	YQLParserRULE_alter_backup_collection_action = 217
	YQLParserRULE_alter_backup_collection_entries = 218
	YQLParserRULE_alter_backup_collection_entry = 219
	YQLParserRULE_backup_collection = 220
	YQLParserRULE_backup_collection_settings = 221
	YQLParserRULE_backup_collection_settings_entry = 222
	YQLParserRULE_backup_stmt = 223
	YQLParserRULE_restore_stmt = 224
	YQLParserRULE_table_inherits = 225
	YQLParserRULE_table_partition_by = 226
	YQLParserRULE_with_table_settings = 227
	YQLParserRULE_table_tablestore = 228
	YQLParserRULE_table_settings_entry = 229
	YQLParserRULE_table_as_source = 230
	YQLParserRULE_alter_table_stmt = 231
	YQLParserRULE_alter_table_action = 232
	YQLParserRULE_alter_external_table_stmt = 233
	YQLParserRULE_alter_external_table_action = 234
	YQLParserRULE_alter_table_store_stmt = 235
	YQLParserRULE_alter_table_store_action = 236
	YQLParserRULE_alter_table_add_column = 237
	YQLParserRULE_alter_table_drop_column = 238
	YQLParserRULE_alter_table_alter_column = 239
	YQLParserRULE_alter_table_alter_column_drop_not_null = 240
	YQLParserRULE_alter_table_add_column_family = 241
	YQLParserRULE_alter_table_alter_column_family = 242
	YQLParserRULE_alter_table_set_table_setting_uncompat = 243
	YQLParserRULE_alter_table_set_table_setting_compat = 244
	YQLParserRULE_alter_table_reset_table_setting = 245
	YQLParserRULE_alter_table_add_index = 246
	YQLParserRULE_alter_table_drop_index = 247
	YQLParserRULE_alter_table_rename_to = 248
	YQLParserRULE_alter_table_rename_index_to = 249
	YQLParserRULE_alter_table_add_changefeed = 250
	YQLParserRULE_alter_table_alter_changefeed = 251
	YQLParserRULE_alter_table_drop_changefeed = 252
	YQLParserRULE_alter_table_alter_index = 253
	YQLParserRULE_column_schema = 254
	YQLParserRULE_family_relation = 255
	YQLParserRULE_opt_column_constraints = 256
	YQLParserRULE_column_order_by_specification = 257
	YQLParserRULE_table_constraint = 258
	YQLParserRULE_table_index = 259
	YQLParserRULE_table_index_type = 260
	YQLParserRULE_global_index = 261
	YQLParserRULE_local_index = 262
	YQLParserRULE_index_subtype = 263
	YQLParserRULE_with_index_settings = 264
	YQLParserRULE_index_setting_entry = 265
	YQLParserRULE_index_setting_value = 266
	YQLParserRULE_changefeed = 267
	YQLParserRULE_changefeed_settings = 268
	YQLParserRULE_changefeed_settings_entry = 269
	YQLParserRULE_changefeed_setting_value = 270
	YQLParserRULE_changefeed_alter_settings = 271
	YQLParserRULE_alter_table_setting_entry = 272
	YQLParserRULE_table_setting_value = 273
	YQLParserRULE_ttl_tier_list = 274
	YQLParserRULE_ttl_tier_action = 275
	YQLParserRULE_family_entry = 276
	YQLParserRULE_family_settings = 277
	YQLParserRULE_family_settings_entry = 278
	YQLParserRULE_family_setting_value = 279
	YQLParserRULE_split_boundaries = 280
	YQLParserRULE_literal_value_list = 281
	YQLParserRULE_alter_table_alter_index_action = 282
	YQLParserRULE_drop_table_stmt = 283
	YQLParserRULE_create_user_stmt = 284
	YQLParserRULE_alter_user_stmt = 285
	YQLParserRULE_create_group_stmt = 286
	YQLParserRULE_alter_group_stmt = 287
	YQLParserRULE_drop_role_stmt = 288
	YQLParserRULE_role_name = 289
	YQLParserRULE_create_user_option = 290
	YQLParserRULE_password_option = 291
	YQLParserRULE_login_option = 292
	YQLParserRULE_grant_permissions_stmt = 293
	YQLParserRULE_revoke_permissions_stmt = 294
	YQLParserRULE_permission_id = 295
	YQLParserRULE_permission_name = 296
	YQLParserRULE_permission_name_target = 297
	YQLParserRULE_create_resource_pool_stmt = 298
	YQLParserRULE_alter_resource_pool_stmt = 299
	YQLParserRULE_alter_resource_pool_action = 300
	YQLParserRULE_drop_resource_pool_stmt = 301
	YQLParserRULE_create_resource_pool_classifier_stmt = 302
	YQLParserRULE_alter_resource_pool_classifier_stmt = 303
	YQLParserRULE_alter_resource_pool_classifier_action = 304
	YQLParserRULE_drop_resource_pool_classifier_stmt = 305
	YQLParserRULE_create_replication_stmt = 306
	YQLParserRULE_replication_target = 307
	YQLParserRULE_replication_settings = 308
	YQLParserRULE_replication_settings_entry = 309
	YQLParserRULE_alter_replication_stmt = 310
	YQLParserRULE_alter_replication_action = 311
	YQLParserRULE_alter_replication_set_setting = 312
	YQLParserRULE_drop_replication_stmt = 313
	YQLParserRULE_action_or_subquery_args = 314
	YQLParserRULE_define_action_or_subquery_stmt = 315
	YQLParserRULE_define_action_or_subquery_body = 316
	YQLParserRULE_if_stmt = 317
	YQLParserRULE_for_stmt = 318
	YQLParserRULE_table_ref = 319
	YQLParserRULE_table_key = 320
	YQLParserRULE_table_arg = 321
	YQLParserRULE_table_hints = 322
	YQLParserRULE_table_hint = 323
	YQLParserRULE_object_ref = 324
	YQLParserRULE_simple_table_ref_core = 325
	YQLParserRULE_simple_table_ref = 326
	YQLParserRULE_into_simple_table_ref = 327
	YQLParserRULE_delete_stmt = 328
	YQLParserRULE_update_stmt = 329
	YQLParserRULE_set_clause_choice = 330
	YQLParserRULE_set_clause_list = 331
	YQLParserRULE_set_clause = 332
	YQLParserRULE_set_target = 333
	YQLParserRULE_multiple_column_assignment = 334
	YQLParserRULE_set_target_list = 335
	YQLParserRULE_create_topic_stmt = 336
	YQLParserRULE_create_topic_entries = 337
	YQLParserRULE_create_topic_entry = 338
	YQLParserRULE_with_topic_settings = 339
	YQLParserRULE_alter_topic_stmt = 340
	YQLParserRULE_alter_topic_action = 341
	YQLParserRULE_alter_topic_add_consumer = 342
	YQLParserRULE_topic_create_consumer_entry = 343
	YQLParserRULE_alter_topic_alter_consumer = 344
	YQLParserRULE_alter_topic_alter_consumer_entry = 345
	YQLParserRULE_alter_topic_drop_consumer = 346
	YQLParserRULE_topic_alter_consumer_set = 347
	YQLParserRULE_topic_alter_consumer_reset = 348
	YQLParserRULE_alter_topic_set_settings = 349
	YQLParserRULE_alter_topic_reset_settings = 350
	YQLParserRULE_drop_topic_stmt = 351
	YQLParserRULE_topic_settings = 352
	YQLParserRULE_topic_settings_entry = 353
	YQLParserRULE_topic_setting_value = 354
	YQLParserRULE_topic_consumer_with_settings = 355
	YQLParserRULE_topic_consumer_settings = 356
	YQLParserRULE_topic_consumer_settings_entry = 357
	YQLParserRULE_topic_consumer_setting_value = 358
	YQLParserRULE_topic_ref = 359
	YQLParserRULE_topic_consumer_ref = 360
	YQLParserRULE_null_treatment = 361
	YQLParserRULE_filter_clause = 362
	YQLParserRULE_window_name_or_specification = 363
	YQLParserRULE_window_name = 364
	YQLParserRULE_window_clause = 365
	YQLParserRULE_window_definition_list = 366
	YQLParserRULE_window_definition = 367
	YQLParserRULE_new_window_name = 368
	YQLParserRULE_window_specification = 369
	YQLParserRULE_window_specification_details = 370
	YQLParserRULE_existing_window_name = 371
	YQLParserRULE_window_partition_clause = 372
	YQLParserRULE_window_order_clause = 373
	YQLParserRULE_window_frame_clause = 374
	YQLParserRULE_window_frame_units = 375
	YQLParserRULE_window_frame_extent = 376
	YQLParserRULE_window_frame_between = 377
	YQLParserRULE_window_frame_bound = 378
	YQLParserRULE_window_frame_exclusion = 379
	YQLParserRULE_use_stmt = 380
	YQLParserRULE_subselect_stmt = 381
	YQLParserRULE_named_nodes_stmt = 382
	YQLParserRULE_commit_stmt = 383
	YQLParserRULE_rollback_stmt = 384
	YQLParserRULE_analyze_table = 385
	YQLParserRULE_analyze_table_list = 386
	YQLParserRULE_analyze_stmt = 387
	YQLParserRULE_alter_sequence_stmt = 388
	YQLParserRULE_alter_sequence_action = 389
	YQLParserRULE_identifier = 390
	YQLParserRULE_id = 391
	YQLParserRULE_id_schema = 392
	YQLParserRULE_id_expr = 393
	YQLParserRULE_id_expr_in = 394
	YQLParserRULE_id_window = 395
	YQLParserRULE_id_table = 396
	YQLParserRULE_id_without = 397
	YQLParserRULE_id_hint = 398
	YQLParserRULE_id_as_compat = 399
	YQLParserRULE_an_id = 400
	YQLParserRULE_an_id_or_type = 401
	YQLParserRULE_an_id_schema = 402
	YQLParserRULE_an_id_expr = 403
	YQLParserRULE_an_id_expr_in = 404
	YQLParserRULE_an_id_window = 405
	YQLParserRULE_an_id_table = 406
	YQLParserRULE_an_id_without = 407
	YQLParserRULE_an_id_hint = 408
	YQLParserRULE_an_id_pure = 409
	YQLParserRULE_an_id_as_compat = 410
	YQLParserRULE_view_name = 411
	YQLParserRULE_opt_id_prefix = 412
	YQLParserRULE_cluster_expr = 413
	YQLParserRULE_id_or_type = 414
	YQLParserRULE_opt_id_prefix_or_type = 415
	YQLParserRULE_id_or_at = 416
	YQLParserRULE_id_table_or_type = 417
	YQLParserRULE_id_table_or_at = 418
	YQLParserRULE_keyword = 419
	YQLParserRULE_keyword_expr_uncompat = 420
	YQLParserRULE_keyword_table_uncompat = 421
	YQLParserRULE_keyword_select_uncompat = 422
	YQLParserRULE_keyword_alter_uncompat = 423
	YQLParserRULE_keyword_in_uncompat = 424
	YQLParserRULE_keyword_window_uncompat = 425
	YQLParserRULE_keyword_hint_uncompat = 426
	YQLParserRULE_keyword_as_compat = 427
	YQLParserRULE_keyword_compat = 428
	YQLParserRULE_type_id = 429
	YQLParserRULE_bool_value = 430
	YQLParserRULE_real = 431
	YQLParserRULE_integer = 432
)

// ISql_queryContext is an interface to support dynamic dispatch.
type ISql_queryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Sql_stmt_list() ISql_stmt_listContext
	PRAGMA() antlr.TerminalNode
	ANSI() antlr.TerminalNode
	DIGITS() antlr.TerminalNode
	Ansi_sql_stmt_list() IAnsi_sql_stmt_listContext

	// IsSql_queryContext differentiates from other interfaces.
	IsSql_queryContext()
}

type Sql_queryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySql_queryContext() *Sql_queryContext {
	var p = new(Sql_queryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_sql_query
	return p
}

func InitEmptySql_queryContext(p *Sql_queryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_sql_query
}

func (*Sql_queryContext) IsSql_queryContext() {}

func NewSql_queryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sql_queryContext {
	var p = new(Sql_queryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_sql_query

	return p
}

func (s *Sql_queryContext) GetParser() antlr.Parser { return s.parser }

func (s *Sql_queryContext) Sql_stmt_list() ISql_stmt_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_stmt_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_stmt_listContext)
}

func (s *Sql_queryContext) PRAGMA() antlr.TerminalNode {
	return s.GetToken(YQLParserPRAGMA, 0)
}

func (s *Sql_queryContext) ANSI() antlr.TerminalNode {
	return s.GetToken(YQLParserANSI, 0)
}

func (s *Sql_queryContext) DIGITS() antlr.TerminalNode {
	return s.GetToken(YQLParserDIGITS, 0)
}

func (s *Sql_queryContext) Ansi_sql_stmt_list() IAnsi_sql_stmt_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnsi_sql_stmt_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnsi_sql_stmt_listContext)
}

func (s *Sql_queryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sql_queryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Sql_queryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterSql_query(s)
	}
}

func (s *Sql_queryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitSql_query(s)
	}
}




func (p *YQLParser) Sql_query() (localctx ISql_queryContext) {
	localctx = NewSql_queryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, YQLParserRULE_sql_query)
	p.SetState(871)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(866)
			p.Sql_stmt_list()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(867)
			p.Match(YQLParserPRAGMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(868)
			p.Match(YQLParserANSI)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(869)
			p.Match(YQLParserDIGITS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(870)
			p.Ansi_sql_stmt_list()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISql_stmt_listContext is an interface to support dynamic dispatch.
type ISql_stmt_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSql_stmt() []ISql_stmtContext
	Sql_stmt(i int) ISql_stmtContext
	EOF() antlr.TerminalNode
	AllSEMICOLON() []antlr.TerminalNode
	SEMICOLON(i int) antlr.TerminalNode

	// IsSql_stmt_listContext differentiates from other interfaces.
	IsSql_stmt_listContext()
}

type Sql_stmt_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySql_stmt_listContext() *Sql_stmt_listContext {
	var p = new(Sql_stmt_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_sql_stmt_list
	return p
}

func InitEmptySql_stmt_listContext(p *Sql_stmt_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_sql_stmt_list
}

func (*Sql_stmt_listContext) IsSql_stmt_listContext() {}

func NewSql_stmt_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sql_stmt_listContext {
	var p = new(Sql_stmt_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_sql_stmt_list

	return p
}

func (s *Sql_stmt_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Sql_stmt_listContext) AllSql_stmt() []ISql_stmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISql_stmtContext); ok {
			len++
		}
	}

	tst := make([]ISql_stmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISql_stmtContext); ok {
			tst[i] = t.(ISql_stmtContext)
			i++
		}
	}

	return tst
}

func (s *Sql_stmt_listContext) Sql_stmt(i int) ISql_stmtContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_stmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_stmtContext)
}

func (s *Sql_stmt_listContext) EOF() antlr.TerminalNode {
	return s.GetToken(YQLParserEOF, 0)
}

func (s *Sql_stmt_listContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(YQLParserSEMICOLON)
}

func (s *Sql_stmt_listContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserSEMICOLON, i)
}

func (s *Sql_stmt_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sql_stmt_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Sql_stmt_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterSql_stmt_list(s)
	}
}

func (s *Sql_stmt_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitSql_stmt_list(s)
	}
}




func (p *YQLParser) Sql_stmt_list() (localctx ISql_stmt_listContext) {
	localctx = NewSql_stmt_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, YQLParserRULE_sql_stmt_list)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(876)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserSEMICOLON {
		{
			p.SetState(873)
			p.Match(YQLParserSEMICOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


		p.SetState(878)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(879)
		p.Sql_stmt()
	}
	p.SetState(888)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(881)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			for ok := true; ok; ok = _la == YQLParserSEMICOLON {
				{
					p.SetState(880)
					p.Match(YQLParserSEMICOLON)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}


				p.SetState(883)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
			    	goto errorExit
			    }
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(885)
				p.Sql_stmt()
			}


		}
		p.SetState(890)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(894)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserSEMICOLON {
		{
			p.SetState(891)
			p.Match(YQLParserSEMICOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


		p.SetState(896)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(897)
		p.Match(YQLParserEOF)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAnsi_sql_stmt_listContext is an interface to support dynamic dispatch.
type IAnsi_sql_stmt_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllSEMICOLON() []antlr.TerminalNode
	SEMICOLON(i int) antlr.TerminalNode

	// IsAnsi_sql_stmt_listContext differentiates from other interfaces.
	IsAnsi_sql_stmt_listContext()
}

type Ansi_sql_stmt_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnsi_sql_stmt_listContext() *Ansi_sql_stmt_listContext {
	var p = new(Ansi_sql_stmt_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_ansi_sql_stmt_list
	return p
}

func InitEmptyAnsi_sql_stmt_listContext(p *Ansi_sql_stmt_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_ansi_sql_stmt_list
}

func (*Ansi_sql_stmt_listContext) IsAnsi_sql_stmt_listContext() {}

func NewAnsi_sql_stmt_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ansi_sql_stmt_listContext {
	var p = new(Ansi_sql_stmt_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_ansi_sql_stmt_list

	return p
}

func (s *Ansi_sql_stmt_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Ansi_sql_stmt_listContext) EOF() antlr.TerminalNode {
	return s.GetToken(YQLParserEOF, 0)
}

func (s *Ansi_sql_stmt_listContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(YQLParserSEMICOLON)
}

func (s *Ansi_sql_stmt_listContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserSEMICOLON, i)
}

func (s *Ansi_sql_stmt_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ansi_sql_stmt_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Ansi_sql_stmt_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAnsi_sql_stmt_list(s)
	}
}

func (s *Ansi_sql_stmt_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAnsi_sql_stmt_list(s)
	}
}




func (p *YQLParser) Ansi_sql_stmt_list() (localctx IAnsi_sql_stmt_listContext) {
	localctx = NewAnsi_sql_stmt_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, YQLParserRULE_ansi_sql_stmt_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(902)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserSEMICOLON {
		{
			p.SetState(899)
			p.Match(YQLParserSEMICOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


		p.SetState(904)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(905)
		p.Match(YQLParserEOF)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILambda_bodyContext is an interface to support dynamic dispatch.
type ILambda_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETURN() antlr.TerminalNode
	Expr() IExprContext
	AllSEMICOLON() []antlr.TerminalNode
	SEMICOLON(i int) antlr.TerminalNode
	AllLambda_stmt() []ILambda_stmtContext
	Lambda_stmt(i int) ILambda_stmtContext

	// IsLambda_bodyContext differentiates from other interfaces.
	IsLambda_bodyContext()
}

type Lambda_bodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambda_bodyContext() *Lambda_bodyContext {
	var p = new(Lambda_bodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_lambda_body
	return p
}

func InitEmptyLambda_bodyContext(p *Lambda_bodyContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_lambda_body
}

func (*Lambda_bodyContext) IsLambda_bodyContext() {}

func NewLambda_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lambda_bodyContext {
	var p = new(Lambda_bodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_lambda_body

	return p
}

func (s *Lambda_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Lambda_bodyContext) RETURN() antlr.TerminalNode {
	return s.GetToken(YQLParserRETURN, 0)
}

func (s *Lambda_bodyContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Lambda_bodyContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(YQLParserSEMICOLON)
}

func (s *Lambda_bodyContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserSEMICOLON, i)
}

func (s *Lambda_bodyContext) AllLambda_stmt() []ILambda_stmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILambda_stmtContext); ok {
			len++
		}
	}

	tst := make([]ILambda_stmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILambda_stmtContext); ok {
			tst[i] = t.(ILambda_stmtContext)
			i++
		}
	}

	return tst
}

func (s *Lambda_bodyContext) Lambda_stmt(i int) ILambda_stmtContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambda_stmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambda_stmtContext)
}

func (s *Lambda_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lambda_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Lambda_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterLambda_body(s)
	}
}

func (s *Lambda_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitLambda_body(s)
	}
}




func (p *YQLParser) Lambda_body() (localctx ILambda_bodyContext) {
	localctx = NewLambda_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, YQLParserRULE_lambda_body)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(910)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserSEMICOLON {
		{
			p.SetState(907)
			p.Match(YQLParserSEMICOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


		p.SetState(912)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(921)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserDOLLAR || _la == YQLParserIMPORT {
		{
			p.SetState(913)
			p.Lambda_stmt()
		}
		p.SetState(915)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = _la == YQLParserSEMICOLON {
			{
				p.SetState(914)
				p.Match(YQLParserSEMICOLON)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


			p.SetState(917)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}


		p.SetState(923)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(924)
		p.Match(YQLParserRETURN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(925)
		p.Expr()
	}
	p.SetState(929)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserSEMICOLON {
		{
			p.SetState(926)
			p.Match(YQLParserSEMICOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


		p.SetState(931)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILambda_stmtContext is an interface to support dynamic dispatch.
type ILambda_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Named_nodes_stmt() INamed_nodes_stmtContext
	Import_stmt() IImport_stmtContext

	// IsLambda_stmtContext differentiates from other interfaces.
	IsLambda_stmtContext()
}

type Lambda_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambda_stmtContext() *Lambda_stmtContext {
	var p = new(Lambda_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_lambda_stmt
	return p
}

func InitEmptyLambda_stmtContext(p *Lambda_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_lambda_stmt
}

func (*Lambda_stmtContext) IsLambda_stmtContext() {}

func NewLambda_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lambda_stmtContext {
	var p = new(Lambda_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_lambda_stmt

	return p
}

func (s *Lambda_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Lambda_stmtContext) Named_nodes_stmt() INamed_nodes_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_nodes_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_nodes_stmtContext)
}

func (s *Lambda_stmtContext) Import_stmt() IImport_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImport_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImport_stmtContext)
}

func (s *Lambda_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lambda_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Lambda_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterLambda_stmt(s)
	}
}

func (s *Lambda_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitLambda_stmt(s)
	}
}




func (p *YQLParser) Lambda_stmt() (localctx ILambda_stmtContext) {
	localctx = NewLambda_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, YQLParserRULE_lambda_stmt)
	p.SetState(934)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserDOLLAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(932)
			p.Named_nodes_stmt()
		}


	case YQLParserIMPORT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(933)
			p.Import_stmt()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISql_stmtContext is an interface to support dynamic dispatch.
type ISql_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Sql_stmt_core() ISql_stmt_coreContext
	EXPLAIN() antlr.TerminalNode
	QUERY() antlr.TerminalNode
	PLAN() antlr.TerminalNode

	// IsSql_stmtContext differentiates from other interfaces.
	IsSql_stmtContext()
}

type Sql_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySql_stmtContext() *Sql_stmtContext {
	var p = new(Sql_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_sql_stmt
	return p
}

func InitEmptySql_stmtContext(p *Sql_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_sql_stmt
}

func (*Sql_stmtContext) IsSql_stmtContext() {}

func NewSql_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sql_stmtContext {
	var p = new(Sql_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_sql_stmt

	return p
}

func (s *Sql_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Sql_stmtContext) Sql_stmt_core() ISql_stmt_coreContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_stmt_coreContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_stmt_coreContext)
}

func (s *Sql_stmtContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(YQLParserEXPLAIN, 0)
}

func (s *Sql_stmtContext) QUERY() antlr.TerminalNode {
	return s.GetToken(YQLParserQUERY, 0)
}

func (s *Sql_stmtContext) PLAN() antlr.TerminalNode {
	return s.GetToken(YQLParserPLAN, 0)
}

func (s *Sql_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sql_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Sql_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterSql_stmt(s)
	}
}

func (s *Sql_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitSql_stmt(s)
	}
}




func (p *YQLParser) Sql_stmt() (localctx ISql_stmtContext) {
	localctx = NewSql_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, YQLParserRULE_sql_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(941)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserEXPLAIN {
		{
			p.SetState(936)
			p.Match(YQLParserEXPLAIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(939)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserQUERY {
			{
				p.SetState(937)
				p.Match(YQLParserQUERY)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(938)
				p.Match(YQLParserPLAN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}

	}
	{
		p.SetState(943)
		p.Sql_stmt_core()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISql_stmt_coreContext is an interface to support dynamic dispatch.
type ISql_stmt_coreContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Pragma_stmt() IPragma_stmtContext
	Select_stmt() ISelect_stmtContext
	Named_nodes_stmt() INamed_nodes_stmtContext
	Create_table_stmt() ICreate_table_stmtContext
	Drop_table_stmt() IDrop_table_stmtContext
	Use_stmt() IUse_stmtContext
	Into_table_stmt() IInto_table_stmtContext
	Commit_stmt() ICommit_stmtContext
	Update_stmt() IUpdate_stmtContext
	Delete_stmt() IDelete_stmtContext
	Rollback_stmt() IRollback_stmtContext
	Declare_stmt() IDeclare_stmtContext
	Import_stmt() IImport_stmtContext
	Export_stmt() IExport_stmtContext
	Alter_table_stmt() IAlter_table_stmtContext
	Alter_external_table_stmt() IAlter_external_table_stmtContext
	Do_stmt() IDo_stmtContext
	Define_action_or_subquery_stmt() IDefine_action_or_subquery_stmtContext
	If_stmt() IIf_stmtContext
	For_stmt() IFor_stmtContext
	Values_stmt() IValues_stmtContext
	Create_user_stmt() ICreate_user_stmtContext
	Alter_user_stmt() IAlter_user_stmtContext
	Create_group_stmt() ICreate_group_stmtContext
	Alter_group_stmt() IAlter_group_stmtContext
	Drop_role_stmt() IDrop_role_stmtContext
	Create_object_stmt() ICreate_object_stmtContext
	Alter_object_stmt() IAlter_object_stmtContext
	Drop_object_stmt() IDrop_object_stmtContext
	Create_external_data_source_stmt() ICreate_external_data_source_stmtContext
	Alter_external_data_source_stmt() IAlter_external_data_source_stmtContext
	Drop_external_data_source_stmt() IDrop_external_data_source_stmtContext
	Create_replication_stmt() ICreate_replication_stmtContext
	Drop_replication_stmt() IDrop_replication_stmtContext
	Create_topic_stmt() ICreate_topic_stmtContext
	Alter_topic_stmt() IAlter_topic_stmtContext
	Drop_topic_stmt() IDrop_topic_stmtContext
	Grant_permissions_stmt() IGrant_permissions_stmtContext
	Revoke_permissions_stmt() IRevoke_permissions_stmtContext
	Alter_table_store_stmt() IAlter_table_store_stmtContext
	Upsert_object_stmt() IUpsert_object_stmtContext
	Create_view_stmt() ICreate_view_stmtContext
	Drop_view_stmt() IDrop_view_stmtContext
	Alter_replication_stmt() IAlter_replication_stmtContext
	Create_resource_pool_stmt() ICreate_resource_pool_stmtContext
	Alter_resource_pool_stmt() IAlter_resource_pool_stmtContext
	Drop_resource_pool_stmt() IDrop_resource_pool_stmtContext
	Create_backup_collection_stmt() ICreate_backup_collection_stmtContext
	Alter_backup_collection_stmt() IAlter_backup_collection_stmtContext
	Drop_backup_collection_stmt() IDrop_backup_collection_stmtContext
	Analyze_stmt() IAnalyze_stmtContext
	Create_resource_pool_classifier_stmt() ICreate_resource_pool_classifier_stmtContext
	Alter_resource_pool_classifier_stmt() IAlter_resource_pool_classifier_stmtContext
	Drop_resource_pool_classifier_stmt() IDrop_resource_pool_classifier_stmtContext
	Backup_stmt() IBackup_stmtContext
	Restore_stmt() IRestore_stmtContext
	Alter_sequence_stmt() IAlter_sequence_stmtContext

	// IsSql_stmt_coreContext differentiates from other interfaces.
	IsSql_stmt_coreContext()
}

type Sql_stmt_coreContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySql_stmt_coreContext() *Sql_stmt_coreContext {
	var p = new(Sql_stmt_coreContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_sql_stmt_core
	return p
}

func InitEmptySql_stmt_coreContext(p *Sql_stmt_coreContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_sql_stmt_core
}

func (*Sql_stmt_coreContext) IsSql_stmt_coreContext() {}

func NewSql_stmt_coreContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sql_stmt_coreContext {
	var p = new(Sql_stmt_coreContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_sql_stmt_core

	return p
}

func (s *Sql_stmt_coreContext) GetParser() antlr.Parser { return s.parser }

func (s *Sql_stmt_coreContext) Pragma_stmt() IPragma_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPragma_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPragma_stmtContext)
}

func (s *Sql_stmt_coreContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Sql_stmt_coreContext) Named_nodes_stmt() INamed_nodes_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_nodes_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_nodes_stmtContext)
}

func (s *Sql_stmt_coreContext) Create_table_stmt() ICreate_table_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_stmtContext)
}

func (s *Sql_stmt_coreContext) Drop_table_stmt() IDrop_table_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_table_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_table_stmtContext)
}

func (s *Sql_stmt_coreContext) Use_stmt() IUse_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUse_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUse_stmtContext)
}

func (s *Sql_stmt_coreContext) Into_table_stmt() IInto_table_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInto_table_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInto_table_stmtContext)
}

func (s *Sql_stmt_coreContext) Commit_stmt() ICommit_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommit_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommit_stmtContext)
}

func (s *Sql_stmt_coreContext) Update_stmt() IUpdate_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdate_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdate_stmtContext)
}

func (s *Sql_stmt_coreContext) Delete_stmt() IDelete_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelete_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelete_stmtContext)
}

func (s *Sql_stmt_coreContext) Rollback_stmt() IRollback_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollback_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollback_stmtContext)
}

func (s *Sql_stmt_coreContext) Declare_stmt() IDeclare_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_stmtContext)
}

func (s *Sql_stmt_coreContext) Import_stmt() IImport_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImport_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImport_stmtContext)
}

func (s *Sql_stmt_coreContext) Export_stmt() IExport_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExport_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExport_stmtContext)
}

func (s *Sql_stmt_coreContext) Alter_table_stmt() IAlter_table_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_stmtContext)
}

func (s *Sql_stmt_coreContext) Alter_external_table_stmt() IAlter_external_table_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_external_table_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_external_table_stmtContext)
}

func (s *Sql_stmt_coreContext) Do_stmt() IDo_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDo_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDo_stmtContext)
}

func (s *Sql_stmt_coreContext) Define_action_or_subquery_stmt() IDefine_action_or_subquery_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefine_action_or_subquery_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefine_action_or_subquery_stmtContext)
}

func (s *Sql_stmt_coreContext) If_stmt() IIf_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIf_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIf_stmtContext)
}

func (s *Sql_stmt_coreContext) For_stmt() IFor_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFor_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFor_stmtContext)
}

func (s *Sql_stmt_coreContext) Values_stmt() IValues_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValues_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValues_stmtContext)
}

func (s *Sql_stmt_coreContext) Create_user_stmt() ICreate_user_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_user_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_user_stmtContext)
}

func (s *Sql_stmt_coreContext) Alter_user_stmt() IAlter_user_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_user_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_user_stmtContext)
}

func (s *Sql_stmt_coreContext) Create_group_stmt() ICreate_group_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_group_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_group_stmtContext)
}

func (s *Sql_stmt_coreContext) Alter_group_stmt() IAlter_group_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_group_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_group_stmtContext)
}

func (s *Sql_stmt_coreContext) Drop_role_stmt() IDrop_role_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_role_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_role_stmtContext)
}

func (s *Sql_stmt_coreContext) Create_object_stmt() ICreate_object_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_object_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_object_stmtContext)
}

func (s *Sql_stmt_coreContext) Alter_object_stmt() IAlter_object_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_object_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_object_stmtContext)
}

func (s *Sql_stmt_coreContext) Drop_object_stmt() IDrop_object_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_object_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_object_stmtContext)
}

func (s *Sql_stmt_coreContext) Create_external_data_source_stmt() ICreate_external_data_source_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_external_data_source_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_external_data_source_stmtContext)
}

func (s *Sql_stmt_coreContext) Alter_external_data_source_stmt() IAlter_external_data_source_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_external_data_source_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_external_data_source_stmtContext)
}

func (s *Sql_stmt_coreContext) Drop_external_data_source_stmt() IDrop_external_data_source_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_external_data_source_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_external_data_source_stmtContext)
}

func (s *Sql_stmt_coreContext) Create_replication_stmt() ICreate_replication_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_replication_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_replication_stmtContext)
}

func (s *Sql_stmt_coreContext) Drop_replication_stmt() IDrop_replication_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_replication_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_replication_stmtContext)
}

func (s *Sql_stmt_coreContext) Create_topic_stmt() ICreate_topic_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_topic_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_topic_stmtContext)
}

func (s *Sql_stmt_coreContext) Alter_topic_stmt() IAlter_topic_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_topic_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_topic_stmtContext)
}

func (s *Sql_stmt_coreContext) Drop_topic_stmt() IDrop_topic_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_topic_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_topic_stmtContext)
}

func (s *Sql_stmt_coreContext) Grant_permissions_stmt() IGrant_permissions_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrant_permissions_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrant_permissions_stmtContext)
}

func (s *Sql_stmt_coreContext) Revoke_permissions_stmt() IRevoke_permissions_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRevoke_permissions_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRevoke_permissions_stmtContext)
}

func (s *Sql_stmt_coreContext) Alter_table_store_stmt() IAlter_table_store_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_store_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_store_stmtContext)
}

func (s *Sql_stmt_coreContext) Upsert_object_stmt() IUpsert_object_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpsert_object_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpsert_object_stmtContext)
}

func (s *Sql_stmt_coreContext) Create_view_stmt() ICreate_view_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_view_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_view_stmtContext)
}

func (s *Sql_stmt_coreContext) Drop_view_stmt() IDrop_view_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_view_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_view_stmtContext)
}

func (s *Sql_stmt_coreContext) Alter_replication_stmt() IAlter_replication_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_replication_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_replication_stmtContext)
}

func (s *Sql_stmt_coreContext) Create_resource_pool_stmt() ICreate_resource_pool_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_resource_pool_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_resource_pool_stmtContext)
}

func (s *Sql_stmt_coreContext) Alter_resource_pool_stmt() IAlter_resource_pool_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_resource_pool_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_resource_pool_stmtContext)
}

func (s *Sql_stmt_coreContext) Drop_resource_pool_stmt() IDrop_resource_pool_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_resource_pool_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_resource_pool_stmtContext)
}

func (s *Sql_stmt_coreContext) Create_backup_collection_stmt() ICreate_backup_collection_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_backup_collection_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_backup_collection_stmtContext)
}

func (s *Sql_stmt_coreContext) Alter_backup_collection_stmt() IAlter_backup_collection_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_backup_collection_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_backup_collection_stmtContext)
}

func (s *Sql_stmt_coreContext) Drop_backup_collection_stmt() IDrop_backup_collection_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_backup_collection_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_backup_collection_stmtContext)
}

func (s *Sql_stmt_coreContext) Analyze_stmt() IAnalyze_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyze_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyze_stmtContext)
}

func (s *Sql_stmt_coreContext) Create_resource_pool_classifier_stmt() ICreate_resource_pool_classifier_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_resource_pool_classifier_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_resource_pool_classifier_stmtContext)
}

func (s *Sql_stmt_coreContext) Alter_resource_pool_classifier_stmt() IAlter_resource_pool_classifier_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_resource_pool_classifier_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_resource_pool_classifier_stmtContext)
}

func (s *Sql_stmt_coreContext) Drop_resource_pool_classifier_stmt() IDrop_resource_pool_classifier_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_resource_pool_classifier_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_resource_pool_classifier_stmtContext)
}

func (s *Sql_stmt_coreContext) Backup_stmt() IBackup_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBackup_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBackup_stmtContext)
}

func (s *Sql_stmt_coreContext) Restore_stmt() IRestore_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRestore_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRestore_stmtContext)
}

func (s *Sql_stmt_coreContext) Alter_sequence_stmt() IAlter_sequence_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_sequence_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_sequence_stmtContext)
}

func (s *Sql_stmt_coreContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sql_stmt_coreContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Sql_stmt_coreContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterSql_stmt_core(s)
	}
}

func (s *Sql_stmt_coreContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitSql_stmt_core(s)
	}
}




func (p *YQLParser) Sql_stmt_core() (localctx ISql_stmt_coreContext) {
	localctx = NewSql_stmt_coreContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, YQLParserRULE_sql_stmt_core)
	p.SetState(1002)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(945)
			p.Pragma_stmt()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(946)
			p.Select_stmt()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(947)
			p.Named_nodes_stmt()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(948)
			p.Create_table_stmt()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(949)
			p.Drop_table_stmt()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(950)
			p.Use_stmt()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(951)
			p.Into_table_stmt()
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(952)
			p.Commit_stmt()
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(953)
			p.Update_stmt()
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(954)
			p.Delete_stmt()
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(955)
			p.Rollback_stmt()
		}


	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(956)
			p.Declare_stmt()
		}


	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(957)
			p.Import_stmt()
		}


	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(958)
			p.Export_stmt()
		}


	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(959)
			p.Alter_table_stmt()
		}


	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(960)
			p.Alter_external_table_stmt()
		}


	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(961)
			p.Do_stmt()
		}


	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(962)
			p.Define_action_or_subquery_stmt()
		}


	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(963)
			p.If_stmt()
		}


	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(964)
			p.For_stmt()
		}


	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(965)
			p.Values_stmt()
		}


	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(966)
			p.Create_user_stmt()
		}


	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(967)
			p.Alter_user_stmt()
		}


	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(968)
			p.Create_group_stmt()
		}


	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(969)
			p.Alter_group_stmt()
		}


	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(970)
			p.Drop_role_stmt()
		}


	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(971)
			p.Create_object_stmt()
		}


	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(972)
			p.Alter_object_stmt()
		}


	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(973)
			p.Drop_object_stmt()
		}


	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(974)
			p.Create_external_data_source_stmt()
		}


	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(975)
			p.Alter_external_data_source_stmt()
		}


	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(976)
			p.Drop_external_data_source_stmt()
		}


	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(977)
			p.Create_replication_stmt()
		}


	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(978)
			p.Drop_replication_stmt()
		}


	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(979)
			p.Create_topic_stmt()
		}


	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(980)
			p.Alter_topic_stmt()
		}


	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(981)
			p.Drop_topic_stmt()
		}


	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(982)
			p.Grant_permissions_stmt()
		}


	case 39:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(983)
			p.Revoke_permissions_stmt()
		}


	case 40:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(984)
			p.Alter_table_store_stmt()
		}


	case 41:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(985)
			p.Upsert_object_stmt()
		}


	case 42:
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(986)
			p.Create_view_stmt()
		}


	case 43:
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(987)
			p.Drop_view_stmt()
		}


	case 44:
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(988)
			p.Alter_replication_stmt()
		}


	case 45:
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(989)
			p.Create_resource_pool_stmt()
		}


	case 46:
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(990)
			p.Alter_resource_pool_stmt()
		}


	case 47:
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(991)
			p.Drop_resource_pool_stmt()
		}


	case 48:
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(992)
			p.Create_backup_collection_stmt()
		}


	case 49:
		p.EnterOuterAlt(localctx, 49)
		{
			p.SetState(993)
			p.Alter_backup_collection_stmt()
		}


	case 50:
		p.EnterOuterAlt(localctx, 50)
		{
			p.SetState(994)
			p.Drop_backup_collection_stmt()
		}


	case 51:
		p.EnterOuterAlt(localctx, 51)
		{
			p.SetState(995)
			p.Analyze_stmt()
		}


	case 52:
		p.EnterOuterAlt(localctx, 52)
		{
			p.SetState(996)
			p.Create_resource_pool_classifier_stmt()
		}


	case 53:
		p.EnterOuterAlt(localctx, 53)
		{
			p.SetState(997)
			p.Alter_resource_pool_classifier_stmt()
		}


	case 54:
		p.EnterOuterAlt(localctx, 54)
		{
			p.SetState(998)
			p.Drop_resource_pool_classifier_stmt()
		}


	case 55:
		p.EnterOuterAlt(localctx, 55)
		{
			p.SetState(999)
			p.Backup_stmt()
		}


	case 56:
		p.EnterOuterAlt(localctx, 56)
		{
			p.SetState(1000)
			p.Restore_stmt()
		}


	case 57:
		p.EnterOuterAlt(localctx, 57)
		{
			p.SetState(1001)
			p.Alter_sequence_stmt()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllOr_subexpr() []IOr_subexprContext
	Or_subexpr(i int) IOr_subexprContext
	AllOR() []antlr.TerminalNode
	OR(i int) antlr.TerminalNode
	Type_name_composite() IType_name_compositeContext

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_expr
	return p
}

func InitEmptyExprContext(p *ExprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_expr
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) AllOr_subexpr() []IOr_subexprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOr_subexprContext); ok {
			len++
		}
	}

	tst := make([]IOr_subexprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOr_subexprContext); ok {
			tst[i] = t.(IOr_subexprContext)
			i++
		}
	}

	return tst
}

func (s *ExprContext) Or_subexpr(i int) IOr_subexprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOr_subexprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOr_subexprContext)
}

func (s *ExprContext) AllOR() []antlr.TerminalNode {
	return s.GetTokens(YQLParserOR)
}

func (s *ExprContext) OR(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserOR, i)
}

func (s *ExprContext) Type_name_composite() IType_name_compositeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_compositeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_compositeContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitExpr(s)
	}
}




func (p *YQLParser) Expr() (localctx IExprContext) {
	localctx = NewExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, YQLParserRULE_expr)
	var _alt int

	p.SetState(1013)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1004)
			p.Or_subexpr()
		}
		p.SetState(1009)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1005)
					p.Match(YQLParserOR)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(1006)
					p.Or_subexpr()
				}


			}
			p.SetState(1011)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1012)
			p.Type_name_composite()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOr_subexprContext is an interface to support dynamic dispatch.
type IOr_subexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAnd_subexpr() []IAnd_subexprContext
	And_subexpr(i int) IAnd_subexprContext
	AllAND() []antlr.TerminalNode
	AND(i int) antlr.TerminalNode

	// IsOr_subexprContext differentiates from other interfaces.
	IsOr_subexprContext()
}

type Or_subexprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOr_subexprContext() *Or_subexprContext {
	var p = new(Or_subexprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_or_subexpr
	return p
}

func InitEmptyOr_subexprContext(p *Or_subexprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_or_subexpr
}

func (*Or_subexprContext) IsOr_subexprContext() {}

func NewOr_subexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Or_subexprContext {
	var p = new(Or_subexprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_or_subexpr

	return p
}

func (s *Or_subexprContext) GetParser() antlr.Parser { return s.parser }

func (s *Or_subexprContext) AllAnd_subexpr() []IAnd_subexprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnd_subexprContext); ok {
			len++
		}
	}

	tst := make([]IAnd_subexprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnd_subexprContext); ok {
			tst[i] = t.(IAnd_subexprContext)
			i++
		}
	}

	return tst
}

func (s *Or_subexprContext) And_subexpr(i int) IAnd_subexprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnd_subexprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnd_subexprContext)
}

func (s *Or_subexprContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(YQLParserAND)
}

func (s *Or_subexprContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserAND, i)
}

func (s *Or_subexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Or_subexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Or_subexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterOr_subexpr(s)
	}
}

func (s *Or_subexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitOr_subexpr(s)
	}
}




func (p *YQLParser) Or_subexpr() (localctx IOr_subexprContext) {
	localctx = NewOr_subexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, YQLParserRULE_or_subexpr)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1015)
		p.And_subexpr()
	}
	p.SetState(1020)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1016)
				p.Match(YQLParserAND)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1017)
				p.And_subexpr()
			}


		}
		p.SetState(1022)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAnd_subexprContext is an interface to support dynamic dispatch.
type IAnd_subexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllXor_subexpr() []IXor_subexprContext
	Xor_subexpr(i int) IXor_subexprContext
	AllXOR() []antlr.TerminalNode
	XOR(i int) antlr.TerminalNode

	// IsAnd_subexprContext differentiates from other interfaces.
	IsAnd_subexprContext()
}

type And_subexprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnd_subexprContext() *And_subexprContext {
	var p = new(And_subexprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_and_subexpr
	return p
}

func InitEmptyAnd_subexprContext(p *And_subexprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_and_subexpr
}

func (*And_subexprContext) IsAnd_subexprContext() {}

func NewAnd_subexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *And_subexprContext {
	var p = new(And_subexprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_and_subexpr

	return p
}

func (s *And_subexprContext) GetParser() antlr.Parser { return s.parser }

func (s *And_subexprContext) AllXor_subexpr() []IXor_subexprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IXor_subexprContext); ok {
			len++
		}
	}

	tst := make([]IXor_subexprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IXor_subexprContext); ok {
			tst[i] = t.(IXor_subexprContext)
			i++
		}
	}

	return tst
}

func (s *And_subexprContext) Xor_subexpr(i int) IXor_subexprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXor_subexprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXor_subexprContext)
}

func (s *And_subexprContext) AllXOR() []antlr.TerminalNode {
	return s.GetTokens(YQLParserXOR)
}

func (s *And_subexprContext) XOR(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserXOR, i)
}

func (s *And_subexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *And_subexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *And_subexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAnd_subexpr(s)
	}
}

func (s *And_subexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAnd_subexpr(s)
	}
}




func (p *YQLParser) And_subexpr() (localctx IAnd_subexprContext) {
	localctx = NewAnd_subexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, YQLParserRULE_and_subexpr)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1023)
		p.Xor_subexpr()
	}
	p.SetState(1028)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1024)
				p.Match(YQLParserXOR)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1025)
				p.Xor_subexpr()
			}


		}
		p.SetState(1030)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IXor_subexprContext is an interface to support dynamic dispatch.
type IXor_subexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Eq_subexpr() IEq_subexprContext
	Cond_expr() ICond_exprContext

	// IsXor_subexprContext differentiates from other interfaces.
	IsXor_subexprContext()
}

type Xor_subexprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXor_subexprContext() *Xor_subexprContext {
	var p = new(Xor_subexprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_xor_subexpr
	return p
}

func InitEmptyXor_subexprContext(p *Xor_subexprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_xor_subexpr
}

func (*Xor_subexprContext) IsXor_subexprContext() {}

func NewXor_subexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Xor_subexprContext {
	var p = new(Xor_subexprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_xor_subexpr

	return p
}

func (s *Xor_subexprContext) GetParser() antlr.Parser { return s.parser }

func (s *Xor_subexprContext) Eq_subexpr() IEq_subexprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEq_subexprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEq_subexprContext)
}

func (s *Xor_subexprContext) Cond_expr() ICond_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICond_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICond_exprContext)
}

func (s *Xor_subexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Xor_subexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Xor_subexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterXor_subexpr(s)
	}
}

func (s *Xor_subexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitXor_subexpr(s)
	}
}




func (p *YQLParser) Xor_subexpr() (localctx IXor_subexprContext) {
	localctx = NewXor_subexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, YQLParserRULE_xor_subexpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1031)
		p.Eq_subexpr()
	}
	p.SetState(1033)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1032)
			p.Cond_expr()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDistinct_from_opContext is an interface to support dynamic dispatch.
type IDistinct_from_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IS() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode
	FROM() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsDistinct_from_opContext differentiates from other interfaces.
	IsDistinct_from_opContext()
}

type Distinct_from_opContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDistinct_from_opContext() *Distinct_from_opContext {
	var p = new(Distinct_from_opContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_distinct_from_op
	return p
}

func InitEmptyDistinct_from_opContext(p *Distinct_from_opContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_distinct_from_op
}

func (*Distinct_from_opContext) IsDistinct_from_opContext() {}

func NewDistinct_from_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Distinct_from_opContext {
	var p = new(Distinct_from_opContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_distinct_from_op

	return p
}

func (s *Distinct_from_opContext) GetParser() antlr.Parser { return s.parser }

func (s *Distinct_from_opContext) IS() antlr.TerminalNode {
	return s.GetToken(YQLParserIS, 0)
}

func (s *Distinct_from_opContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(YQLParserDISTINCT, 0)
}

func (s *Distinct_from_opContext) FROM() antlr.TerminalNode {
	return s.GetToken(YQLParserFROM, 0)
}

func (s *Distinct_from_opContext) NOT() antlr.TerminalNode {
	return s.GetToken(YQLParserNOT, 0)
}

func (s *Distinct_from_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Distinct_from_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Distinct_from_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterDistinct_from_op(s)
	}
}

func (s *Distinct_from_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitDistinct_from_op(s)
	}
}




func (p *YQLParser) Distinct_from_op() (localctx IDistinct_from_opContext) {
	localctx = NewDistinct_from_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, YQLParserRULE_distinct_from_op)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1035)
		p.Match(YQLParserIS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1037)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserNOT {
		{
			p.SetState(1036)
			p.Match(YQLParserNOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(1039)
		p.Match(YQLParserDISTINCT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1040)
		p.Match(YQLParserFROM)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICond_exprContext is an interface to support dynamic dispatch.
type ICond_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Match_op() IMatch_opContext
	AllEq_subexpr() []IEq_subexprContext
	Eq_subexpr(i int) IEq_subexprContext
	NOT() antlr.TerminalNode
	ESCAPE() antlr.TerminalNode
	IN() antlr.TerminalNode
	In_expr() IIn_exprContext
	COMPACT() antlr.TerminalNode
	ISNULL() antlr.TerminalNode
	NOTNULL() antlr.TerminalNode
	IS() antlr.TerminalNode
	NULL() antlr.TerminalNode
	BETWEEN() antlr.TerminalNode
	AND() antlr.TerminalNode
	SYMMETRIC() antlr.TerminalNode
	ASYMMETRIC() antlr.TerminalNode
	AllEQUALS() []antlr.TerminalNode
	EQUALS(i int) antlr.TerminalNode
	AllEQUALS2() []antlr.TerminalNode
	EQUALS2(i int) antlr.TerminalNode
	AllNOT_EQUALS() []antlr.TerminalNode
	NOT_EQUALS(i int) antlr.TerminalNode
	AllNOT_EQUALS2() []antlr.TerminalNode
	NOT_EQUALS2(i int) antlr.TerminalNode
	AllDistinct_from_op() []IDistinct_from_opContext
	Distinct_from_op(i int) IDistinct_from_opContext

	// IsCond_exprContext differentiates from other interfaces.
	IsCond_exprContext()
}

type Cond_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCond_exprContext() *Cond_exprContext {
	var p = new(Cond_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_cond_expr
	return p
}

func InitEmptyCond_exprContext(p *Cond_exprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_cond_expr
}

func (*Cond_exprContext) IsCond_exprContext() {}

func NewCond_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cond_exprContext {
	var p = new(Cond_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_cond_expr

	return p
}

func (s *Cond_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Cond_exprContext) Match_op() IMatch_opContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatch_opContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatch_opContext)
}

func (s *Cond_exprContext) AllEq_subexpr() []IEq_subexprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEq_subexprContext); ok {
			len++
		}
	}

	tst := make([]IEq_subexprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEq_subexprContext); ok {
			tst[i] = t.(IEq_subexprContext)
			i++
		}
	}

	return tst
}

func (s *Cond_exprContext) Eq_subexpr(i int) IEq_subexprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEq_subexprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEq_subexprContext)
}

func (s *Cond_exprContext) NOT() antlr.TerminalNode {
	return s.GetToken(YQLParserNOT, 0)
}

func (s *Cond_exprContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(YQLParserESCAPE, 0)
}

func (s *Cond_exprContext) IN() antlr.TerminalNode {
	return s.GetToken(YQLParserIN, 0)
}

func (s *Cond_exprContext) In_expr() IIn_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIn_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIn_exprContext)
}

func (s *Cond_exprContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(YQLParserCOMPACT, 0)
}

func (s *Cond_exprContext) ISNULL() antlr.TerminalNode {
	return s.GetToken(YQLParserISNULL, 0)
}

func (s *Cond_exprContext) NOTNULL() antlr.TerminalNode {
	return s.GetToken(YQLParserNOTNULL, 0)
}

func (s *Cond_exprContext) IS() antlr.TerminalNode {
	return s.GetToken(YQLParserIS, 0)
}

func (s *Cond_exprContext) NULL() antlr.TerminalNode {
	return s.GetToken(YQLParserNULL, 0)
}

func (s *Cond_exprContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(YQLParserBETWEEN, 0)
}

func (s *Cond_exprContext) AND() antlr.TerminalNode {
	return s.GetToken(YQLParserAND, 0)
}

func (s *Cond_exprContext) SYMMETRIC() antlr.TerminalNode {
	return s.GetToken(YQLParserSYMMETRIC, 0)
}

func (s *Cond_exprContext) ASYMMETRIC() antlr.TerminalNode {
	return s.GetToken(YQLParserASYMMETRIC, 0)
}

func (s *Cond_exprContext) AllEQUALS() []antlr.TerminalNode {
	return s.GetTokens(YQLParserEQUALS)
}

func (s *Cond_exprContext) EQUALS(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserEQUALS, i)
}

func (s *Cond_exprContext) AllEQUALS2() []antlr.TerminalNode {
	return s.GetTokens(YQLParserEQUALS2)
}

func (s *Cond_exprContext) EQUALS2(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserEQUALS2, i)
}

func (s *Cond_exprContext) AllNOT_EQUALS() []antlr.TerminalNode {
	return s.GetTokens(YQLParserNOT_EQUALS)
}

func (s *Cond_exprContext) NOT_EQUALS(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserNOT_EQUALS, i)
}

func (s *Cond_exprContext) AllNOT_EQUALS2() []antlr.TerminalNode {
	return s.GetTokens(YQLParserNOT_EQUALS2)
}

func (s *Cond_exprContext) NOT_EQUALS2(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserNOT_EQUALS2, i)
}

func (s *Cond_exprContext) AllDistinct_from_op() []IDistinct_from_opContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDistinct_from_opContext); ok {
			len++
		}
	}

	tst := make([]IDistinct_from_opContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDistinct_from_opContext); ok {
			tst[i] = t.(IDistinct_from_opContext)
			i++
		}
	}

	return tst
}

func (s *Cond_exprContext) Distinct_from_op(i int) IDistinct_from_opContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistinct_from_opContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistinct_from_opContext)
}

func (s *Cond_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cond_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Cond_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterCond_expr(s)
	}
}

func (s *Cond_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitCond_expr(s)
	}
}




func (p *YQLParser) Cond_expr() (localctx ICond_exprContext) {
	localctx = NewCond_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, YQLParserRULE_cond_expr)
	var _la int

	var _alt int

	p.SetState(1093)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1043)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserNOT {
			{
				p.SetState(1042)
				p.Match(YQLParserNOT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1045)
			p.Match_op()
		}
		{
			p.SetState(1046)
			p.Eq_subexpr()
		}
		p.SetState(1049)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 21, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1047)
				p.Match(YQLParserESCAPE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1048)
				p.Eq_subexpr()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1052)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserNOT {
			{
				p.SetState(1051)
				p.Match(YQLParserNOT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1054)
			p.Match(YQLParserIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1056)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 23, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1055)
				p.Match(YQLParserCOMPACT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(1058)
			p.In_expr()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1068)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1059)
				p.Match(YQLParserISNULL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case 2:
			{
				p.SetState(1060)
				p.Match(YQLParserNOTNULL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case 3:
			{
				p.SetState(1061)
				p.Match(YQLParserIS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1062)
				p.Match(YQLParserNULL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case 4:
			p.SetState(1064)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == YQLParserIS {
				{
					p.SetState(1063)
					p.Match(YQLParserIS)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			}
			{
				p.SetState(1066)
				p.Match(YQLParserNOT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1067)
				p.Match(YQLParserNULL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1071)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserNOT {
			{
				p.SetState(1070)
				p.Match(YQLParserNOT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1073)
			p.Match(YQLParserBETWEEN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1075)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 27, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1074)
				_la = p.GetTokenStream().LA(1)

				if !(_la == YQLParserASYMMETRIC || _la == YQLParserSYMMETRIC) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(1077)
			p.Eq_subexpr()
		}
		{
			p.SetState(1078)
			p.Match(YQLParserAND)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1079)
			p.Eq_subexpr()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(1089)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
					p.SetState(1086)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}

					switch p.GetTokenStream().LA(1) {
					case YQLParserEQUALS:
						{
							p.SetState(1081)
							p.Match(YQLParserEQUALS)
							if p.HasError() {
									// Recognition error - abort rule
									goto errorExit
							}
						}


					case YQLParserEQUALS2:
						{
							p.SetState(1082)
							p.Match(YQLParserEQUALS2)
							if p.HasError() {
									// Recognition error - abort rule
									goto errorExit
							}
						}


					case YQLParserNOT_EQUALS:
						{
							p.SetState(1083)
							p.Match(YQLParserNOT_EQUALS)
							if p.HasError() {
									// Recognition error - abort rule
									goto errorExit
							}
						}


					case YQLParserNOT_EQUALS2:
						{
							p.SetState(1084)
							p.Match(YQLParserNOT_EQUALS2)
							if p.HasError() {
									// Recognition error - abort rule
									goto errorExit
							}
						}


					case YQLParserIS:
						{
							p.SetState(1085)
							p.Distinct_from_op()
						}



					default:
						p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
						goto errorExit
					}
					{
						p.SetState(1088)
						p.Eq_subexpr()
					}




			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(1091)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IMatch_opContext is an interface to support dynamic dispatch.
type IMatch_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIKE() antlr.TerminalNode
	ILIKE() antlr.TerminalNode
	GLOB() antlr.TerminalNode
	REGEXP() antlr.TerminalNode
	RLIKE() antlr.TerminalNode
	MATCH() antlr.TerminalNode

	// IsMatch_opContext differentiates from other interfaces.
	IsMatch_opContext()
}

type Match_opContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatch_opContext() *Match_opContext {
	var p = new(Match_opContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_match_op
	return p
}

func InitEmptyMatch_opContext(p *Match_opContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_match_op
}

func (*Match_opContext) IsMatch_opContext() {}

func NewMatch_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Match_opContext {
	var p = new(Match_opContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_match_op

	return p
}

func (s *Match_opContext) GetParser() antlr.Parser { return s.parser }

func (s *Match_opContext) LIKE() antlr.TerminalNode {
	return s.GetToken(YQLParserLIKE, 0)
}

func (s *Match_opContext) ILIKE() antlr.TerminalNode {
	return s.GetToken(YQLParserILIKE, 0)
}

func (s *Match_opContext) GLOB() antlr.TerminalNode {
	return s.GetToken(YQLParserGLOB, 0)
}

func (s *Match_opContext) REGEXP() antlr.TerminalNode {
	return s.GetToken(YQLParserREGEXP, 0)
}

func (s *Match_opContext) RLIKE() antlr.TerminalNode {
	return s.GetToken(YQLParserRLIKE, 0)
}

func (s *Match_opContext) MATCH() antlr.TerminalNode {
	return s.GetToken(YQLParserMATCH, 0)
}

func (s *Match_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Match_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Match_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterMatch_op(s)
	}
}

func (s *Match_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitMatch_op(s)
	}
}




func (p *YQLParser) Match_op() (localctx IMatch_opContext) {
	localctx = NewMatch_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, YQLParserRULE_match_op)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1095)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la - 143)) & ^0x3f) == 0 && ((int64(1) << (_la - 143)) & 8933531977729) != 0) || _la == YQLParserREGEXP || _la == YQLParserRLIKE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IEq_subexprContext is an interface to support dynamic dispatch.
type IEq_subexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNeq_subexpr() []INeq_subexprContext
	Neq_subexpr(i int) INeq_subexprContext
	AllLESS() []antlr.TerminalNode
	LESS(i int) antlr.TerminalNode
	AllLESS_OR_EQ() []antlr.TerminalNode
	LESS_OR_EQ(i int) antlr.TerminalNode
	AllGREATER() []antlr.TerminalNode
	GREATER(i int) antlr.TerminalNode
	AllGREATER_OR_EQ() []antlr.TerminalNode
	GREATER_OR_EQ(i int) antlr.TerminalNode

	// IsEq_subexprContext differentiates from other interfaces.
	IsEq_subexprContext()
}

type Eq_subexprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEq_subexprContext() *Eq_subexprContext {
	var p = new(Eq_subexprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_eq_subexpr
	return p
}

func InitEmptyEq_subexprContext(p *Eq_subexprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_eq_subexpr
}

func (*Eq_subexprContext) IsEq_subexprContext() {}

func NewEq_subexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Eq_subexprContext {
	var p = new(Eq_subexprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_eq_subexpr

	return p
}

func (s *Eq_subexprContext) GetParser() antlr.Parser { return s.parser }

func (s *Eq_subexprContext) AllNeq_subexpr() []INeq_subexprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INeq_subexprContext); ok {
			len++
		}
	}

	tst := make([]INeq_subexprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INeq_subexprContext); ok {
			tst[i] = t.(INeq_subexprContext)
			i++
		}
	}

	return tst
}

func (s *Eq_subexprContext) Neq_subexpr(i int) INeq_subexprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INeq_subexprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INeq_subexprContext)
}

func (s *Eq_subexprContext) AllLESS() []antlr.TerminalNode {
	return s.GetTokens(YQLParserLESS)
}

func (s *Eq_subexprContext) LESS(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserLESS, i)
}

func (s *Eq_subexprContext) AllLESS_OR_EQ() []antlr.TerminalNode {
	return s.GetTokens(YQLParserLESS_OR_EQ)
}

func (s *Eq_subexprContext) LESS_OR_EQ(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserLESS_OR_EQ, i)
}

func (s *Eq_subexprContext) AllGREATER() []antlr.TerminalNode {
	return s.GetTokens(YQLParserGREATER)
}

func (s *Eq_subexprContext) GREATER(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserGREATER, i)
}

func (s *Eq_subexprContext) AllGREATER_OR_EQ() []antlr.TerminalNode {
	return s.GetTokens(YQLParserGREATER_OR_EQ)
}

func (s *Eq_subexprContext) GREATER_OR_EQ(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserGREATER_OR_EQ, i)
}

func (s *Eq_subexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Eq_subexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Eq_subexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterEq_subexpr(s)
	}
}

func (s *Eq_subexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitEq_subexpr(s)
	}
}




func (p *YQLParser) Eq_subexpr() (localctx IEq_subexprContext) {
	localctx = NewEq_subexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, YQLParserRULE_eq_subexpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1097)
		p.Neq_subexpr()
	}
	p.SetState(1102)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 480) != 0) {
		{
			p.SetState(1098)
			_la = p.GetTokenStream().LA(1)

			if !(((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 480) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1099)
			p.Neq_subexpr()
		}


		p.SetState(1104)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IShift_rightContext is an interface to support dynamic dispatch.
type IShift_rightContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllGREATER() []antlr.TerminalNode
	GREATER(i int) antlr.TerminalNode

	// IsShift_rightContext differentiates from other interfaces.
	IsShift_rightContext()
}

type Shift_rightContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShift_rightContext() *Shift_rightContext {
	var p = new(Shift_rightContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_shift_right
	return p
}

func InitEmptyShift_rightContext(p *Shift_rightContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_shift_right
}

func (*Shift_rightContext) IsShift_rightContext() {}

func NewShift_rightContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Shift_rightContext {
	var p = new(Shift_rightContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_shift_right

	return p
}

func (s *Shift_rightContext) GetParser() antlr.Parser { return s.parser }

func (s *Shift_rightContext) AllGREATER() []antlr.TerminalNode {
	return s.GetTokens(YQLParserGREATER)
}

func (s *Shift_rightContext) GREATER(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserGREATER, i)
}

func (s *Shift_rightContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Shift_rightContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Shift_rightContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterShift_right(s)
	}
}

func (s *Shift_rightContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitShift_right(s)
	}
}




func (p *YQLParser) Shift_right() (localctx IShift_rightContext) {
	localctx = NewShift_rightContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, YQLParserRULE_shift_right)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1105)
		p.Match(YQLParserGREATER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1106)
		p.Match(YQLParserGREATER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRot_rightContext is an interface to support dynamic dispatch.
type IRot_rightContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllGREATER() []antlr.TerminalNode
	GREATER(i int) antlr.TerminalNode
	PIPE() antlr.TerminalNode

	// IsRot_rightContext differentiates from other interfaces.
	IsRot_rightContext()
}

type Rot_rightContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRot_rightContext() *Rot_rightContext {
	var p = new(Rot_rightContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_rot_right
	return p
}

func InitEmptyRot_rightContext(p *Rot_rightContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_rot_right
}

func (*Rot_rightContext) IsRot_rightContext() {}

func NewRot_rightContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rot_rightContext {
	var p = new(Rot_rightContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_rot_right

	return p
}

func (s *Rot_rightContext) GetParser() antlr.Parser { return s.parser }

func (s *Rot_rightContext) AllGREATER() []antlr.TerminalNode {
	return s.GetTokens(YQLParserGREATER)
}

func (s *Rot_rightContext) GREATER(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserGREATER, i)
}

func (s *Rot_rightContext) PIPE() antlr.TerminalNode {
	return s.GetToken(YQLParserPIPE, 0)
}

func (s *Rot_rightContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rot_rightContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Rot_rightContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterRot_right(s)
	}
}

func (s *Rot_rightContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitRot_right(s)
	}
}




func (p *YQLParser) Rot_right() (localctx IRot_rightContext) {
	localctx = NewRot_rightContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, YQLParserRULE_rot_right)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1108)
		p.Match(YQLParserGREATER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1109)
		p.Match(YQLParserGREATER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1110)
		p.Match(YQLParserPIPE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDouble_questionContext is an interface to support dynamic dispatch.
type IDouble_questionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllQUESTION() []antlr.TerminalNode
	QUESTION(i int) antlr.TerminalNode

	// IsDouble_questionContext differentiates from other interfaces.
	IsDouble_questionContext()
}

type Double_questionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDouble_questionContext() *Double_questionContext {
	var p = new(Double_questionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_double_question
	return p
}

func InitEmptyDouble_questionContext(p *Double_questionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_double_question
}

func (*Double_questionContext) IsDouble_questionContext() {}

func NewDouble_questionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Double_questionContext {
	var p = new(Double_questionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_double_question

	return p
}

func (s *Double_questionContext) GetParser() antlr.Parser { return s.parser }

func (s *Double_questionContext) AllQUESTION() []antlr.TerminalNode {
	return s.GetTokens(YQLParserQUESTION)
}

func (s *Double_questionContext) QUESTION(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserQUESTION, i)
}

func (s *Double_questionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Double_questionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Double_questionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterDouble_question(s)
	}
}

func (s *Double_questionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitDouble_question(s)
	}
}




func (p *YQLParser) Double_question() (localctx IDouble_questionContext) {
	localctx = NewDouble_questionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, YQLParserRULE_double_question)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1112)
		p.Match(YQLParserQUESTION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1113)
		p.Match(YQLParserQUESTION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// INeq_subexprContext is an interface to support dynamic dispatch.
type INeq_subexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllBit_subexpr() []IBit_subexprContext
	Bit_subexpr(i int) IBit_subexprContext
	Double_question() IDouble_questionContext
	Neq_subexpr() INeq_subexprContext
	AllSHIFT_LEFT() []antlr.TerminalNode
	SHIFT_LEFT(i int) antlr.TerminalNode
	AllShift_right() []IShift_rightContext
	Shift_right(i int) IShift_rightContext
	AllROT_LEFT() []antlr.TerminalNode
	ROT_LEFT(i int) antlr.TerminalNode
	AllRot_right() []IRot_rightContext
	Rot_right(i int) IRot_rightContext
	AllAMPERSAND() []antlr.TerminalNode
	AMPERSAND(i int) antlr.TerminalNode
	AllPIPE() []antlr.TerminalNode
	PIPE(i int) antlr.TerminalNode
	AllCARET() []antlr.TerminalNode
	CARET(i int) antlr.TerminalNode
	AllQUESTION() []antlr.TerminalNode
	QUESTION(i int) antlr.TerminalNode

	// IsNeq_subexprContext differentiates from other interfaces.
	IsNeq_subexprContext()
}

type Neq_subexprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNeq_subexprContext() *Neq_subexprContext {
	var p = new(Neq_subexprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_neq_subexpr
	return p
}

func InitEmptyNeq_subexprContext(p *Neq_subexprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_neq_subexpr
}

func (*Neq_subexprContext) IsNeq_subexprContext() {}

func NewNeq_subexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Neq_subexprContext {
	var p = new(Neq_subexprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_neq_subexpr

	return p
}

func (s *Neq_subexprContext) GetParser() antlr.Parser { return s.parser }

func (s *Neq_subexprContext) AllBit_subexpr() []IBit_subexprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBit_subexprContext); ok {
			len++
		}
	}

	tst := make([]IBit_subexprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBit_subexprContext); ok {
			tst[i] = t.(IBit_subexprContext)
			i++
		}
	}

	return tst
}

func (s *Neq_subexprContext) Bit_subexpr(i int) IBit_subexprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBit_subexprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBit_subexprContext)
}

func (s *Neq_subexprContext) Double_question() IDouble_questionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDouble_questionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDouble_questionContext)
}

func (s *Neq_subexprContext) Neq_subexpr() INeq_subexprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INeq_subexprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INeq_subexprContext)
}

func (s *Neq_subexprContext) AllSHIFT_LEFT() []antlr.TerminalNode {
	return s.GetTokens(YQLParserSHIFT_LEFT)
}

func (s *Neq_subexprContext) SHIFT_LEFT(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserSHIFT_LEFT, i)
}

func (s *Neq_subexprContext) AllShift_right() []IShift_rightContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IShift_rightContext); ok {
			len++
		}
	}

	tst := make([]IShift_rightContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IShift_rightContext); ok {
			tst[i] = t.(IShift_rightContext)
			i++
		}
	}

	return tst
}

func (s *Neq_subexprContext) Shift_right(i int) IShift_rightContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShift_rightContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShift_rightContext)
}

func (s *Neq_subexprContext) AllROT_LEFT() []antlr.TerminalNode {
	return s.GetTokens(YQLParserROT_LEFT)
}

func (s *Neq_subexprContext) ROT_LEFT(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserROT_LEFT, i)
}

func (s *Neq_subexprContext) AllRot_right() []IRot_rightContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRot_rightContext); ok {
			len++
		}
	}

	tst := make([]IRot_rightContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRot_rightContext); ok {
			tst[i] = t.(IRot_rightContext)
			i++
		}
	}

	return tst
}

func (s *Neq_subexprContext) Rot_right(i int) IRot_rightContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRot_rightContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRot_rightContext)
}

func (s *Neq_subexprContext) AllAMPERSAND() []antlr.TerminalNode {
	return s.GetTokens(YQLParserAMPERSAND)
}

func (s *Neq_subexprContext) AMPERSAND(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserAMPERSAND, i)
}

func (s *Neq_subexprContext) AllPIPE() []antlr.TerminalNode {
	return s.GetTokens(YQLParserPIPE)
}

func (s *Neq_subexprContext) PIPE(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserPIPE, i)
}

func (s *Neq_subexprContext) AllCARET() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCARET)
}

func (s *Neq_subexprContext) CARET(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCARET, i)
}

func (s *Neq_subexprContext) AllQUESTION() []antlr.TerminalNode {
	return s.GetTokens(YQLParserQUESTION)
}

func (s *Neq_subexprContext) QUESTION(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserQUESTION, i)
}

func (s *Neq_subexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Neq_subexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Neq_subexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterNeq_subexpr(s)
	}
}

func (s *Neq_subexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitNeq_subexpr(s)
	}
}




func (p *YQLParser) Neq_subexpr() (localctx INeq_subexprContext) {
	localctx = NewNeq_subexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, YQLParserRULE_neq_subexpr)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1115)
		p.Bit_subexpr()
	}
	p.SetState(1128)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1123)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 32, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(1116)
					p.Match(YQLParserSHIFT_LEFT)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}


			case 2:
				{
					p.SetState(1117)
					p.Shift_right()
				}


			case 3:
				{
					p.SetState(1118)
					p.Match(YQLParserROT_LEFT)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}


			case 4:
				{
					p.SetState(1119)
					p.Rot_right()
				}


			case 5:
				{
					p.SetState(1120)
					p.Match(YQLParserAMPERSAND)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}


			case 6:
				{
					p.SetState(1121)
					p.Match(YQLParserPIPE)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}


			case 7:
				{
					p.SetState(1122)
					p.Match(YQLParserCARET)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}
			{
				p.SetState(1125)
				p.Bit_subexpr()
			}


		}
		p.SetState(1130)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1139)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1131)
			p.Double_question()
		}
		{
			p.SetState(1132)
			p.Neq_subexpr()
		}

		} else if p.HasError() { // JIM
			goto errorExit} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) == 2 {
		p.SetState(1135)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = _la == YQLParserQUESTION {
			{
				p.SetState(1134)
				p.Match(YQLParserQUESTION)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


			p.SetState(1137)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBit_subexprContext is an interface to support dynamic dispatch.
type IBit_subexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAdd_subexpr() []IAdd_subexprContext
	Add_subexpr(i int) IAdd_subexprContext
	AllPLUS() []antlr.TerminalNode
	PLUS(i int) antlr.TerminalNode
	AllMINUS() []antlr.TerminalNode
	MINUS(i int) antlr.TerminalNode

	// IsBit_subexprContext differentiates from other interfaces.
	IsBit_subexprContext()
}

type Bit_subexprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBit_subexprContext() *Bit_subexprContext {
	var p = new(Bit_subexprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_bit_subexpr
	return p
}

func InitEmptyBit_subexprContext(p *Bit_subexprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_bit_subexpr
}

func (*Bit_subexprContext) IsBit_subexprContext() {}

func NewBit_subexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bit_subexprContext {
	var p = new(Bit_subexprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_bit_subexpr

	return p
}

func (s *Bit_subexprContext) GetParser() antlr.Parser { return s.parser }

func (s *Bit_subexprContext) AllAdd_subexpr() []IAdd_subexprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAdd_subexprContext); ok {
			len++
		}
	}

	tst := make([]IAdd_subexprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAdd_subexprContext); ok {
			tst[i] = t.(IAdd_subexprContext)
			i++
		}
	}

	return tst
}

func (s *Bit_subexprContext) Add_subexpr(i int) IAdd_subexprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdd_subexprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdd_subexprContext)
}

func (s *Bit_subexprContext) AllPLUS() []antlr.TerminalNode {
	return s.GetTokens(YQLParserPLUS)
}

func (s *Bit_subexprContext) PLUS(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserPLUS, i)
}

func (s *Bit_subexprContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(YQLParserMINUS)
}

func (s *Bit_subexprContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserMINUS, i)
}

func (s *Bit_subexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bit_subexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Bit_subexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterBit_subexpr(s)
	}
}

func (s *Bit_subexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitBit_subexpr(s)
	}
}




func (p *YQLParser) Bit_subexpr() (localctx IBit_subexprContext) {
	localctx = NewBit_subexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, YQLParserRULE_bit_subexpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1141)
		p.Add_subexpr()
	}
	p.SetState(1146)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserPLUS || _la == YQLParserMINUS {
		{
			p.SetState(1142)
			_la = p.GetTokenStream().LA(1)

			if !(_la == YQLParserPLUS || _la == YQLParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1143)
			p.Add_subexpr()
		}


		p.SetState(1148)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAdd_subexprContext is an interface to support dynamic dispatch.
type IAdd_subexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMul_subexpr() []IMul_subexprContext
	Mul_subexpr(i int) IMul_subexprContext
	AllASTERISK() []antlr.TerminalNode
	ASTERISK(i int) antlr.TerminalNode
	AllSLASH() []antlr.TerminalNode
	SLASH(i int) antlr.TerminalNode
	AllPERCENT() []antlr.TerminalNode
	PERCENT(i int) antlr.TerminalNode

	// IsAdd_subexprContext differentiates from other interfaces.
	IsAdd_subexprContext()
}

type Add_subexprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdd_subexprContext() *Add_subexprContext {
	var p = new(Add_subexprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_add_subexpr
	return p
}

func InitEmptyAdd_subexprContext(p *Add_subexprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_add_subexpr
}

func (*Add_subexprContext) IsAdd_subexprContext() {}

func NewAdd_subexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Add_subexprContext {
	var p = new(Add_subexprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_add_subexpr

	return p
}

func (s *Add_subexprContext) GetParser() antlr.Parser { return s.parser }

func (s *Add_subexprContext) AllMul_subexpr() []IMul_subexprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMul_subexprContext); ok {
			len++
		}
	}

	tst := make([]IMul_subexprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMul_subexprContext); ok {
			tst[i] = t.(IMul_subexprContext)
			i++
		}
	}

	return tst
}

func (s *Add_subexprContext) Mul_subexpr(i int) IMul_subexprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMul_subexprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMul_subexprContext)
}

func (s *Add_subexprContext) AllASTERISK() []antlr.TerminalNode {
	return s.GetTokens(YQLParserASTERISK)
}

func (s *Add_subexprContext) ASTERISK(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserASTERISK, i)
}

func (s *Add_subexprContext) AllSLASH() []antlr.TerminalNode {
	return s.GetTokens(YQLParserSLASH)
}

func (s *Add_subexprContext) SLASH(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserSLASH, i)
}

func (s *Add_subexprContext) AllPERCENT() []antlr.TerminalNode {
	return s.GetTokens(YQLParserPERCENT)
}

func (s *Add_subexprContext) PERCENT(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserPERCENT, i)
}

func (s *Add_subexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Add_subexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Add_subexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAdd_subexpr(s)
	}
}

func (s *Add_subexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAdd_subexpr(s)
	}
}




func (p *YQLParser) Add_subexpr() (localctx IAdd_subexprContext) {
	localctx = NewAdd_subexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, YQLParserRULE_add_subexpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1149)
		p.Mul_subexpr()
	}
	p.SetState(1154)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 3670016) != 0) {
		{
			p.SetState(1150)
			_la = p.GetTokenStream().LA(1)

			if !(((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 3670016) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1151)
			p.Mul_subexpr()
		}


		p.SetState(1156)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IMul_subexprContext is an interface to support dynamic dispatch.
type IMul_subexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCon_subexpr() []ICon_subexprContext
	Con_subexpr(i int) ICon_subexprContext
	AllDOUBLE_PIPE() []antlr.TerminalNode
	DOUBLE_PIPE(i int) antlr.TerminalNode

	// IsMul_subexprContext differentiates from other interfaces.
	IsMul_subexprContext()
}

type Mul_subexprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMul_subexprContext() *Mul_subexprContext {
	var p = new(Mul_subexprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_mul_subexpr
	return p
}

func InitEmptyMul_subexprContext(p *Mul_subexprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_mul_subexpr
}

func (*Mul_subexprContext) IsMul_subexprContext() {}

func NewMul_subexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mul_subexprContext {
	var p = new(Mul_subexprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_mul_subexpr

	return p
}

func (s *Mul_subexprContext) GetParser() antlr.Parser { return s.parser }

func (s *Mul_subexprContext) AllCon_subexpr() []ICon_subexprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICon_subexprContext); ok {
			len++
		}
	}

	tst := make([]ICon_subexprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICon_subexprContext); ok {
			tst[i] = t.(ICon_subexprContext)
			i++
		}
	}

	return tst
}

func (s *Mul_subexprContext) Con_subexpr(i int) ICon_subexprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICon_subexprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICon_subexprContext)
}

func (s *Mul_subexprContext) AllDOUBLE_PIPE() []antlr.TerminalNode {
	return s.GetTokens(YQLParserDOUBLE_PIPE)
}

func (s *Mul_subexprContext) DOUBLE_PIPE(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserDOUBLE_PIPE, i)
}

func (s *Mul_subexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mul_subexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Mul_subexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterMul_subexpr(s)
	}
}

func (s *Mul_subexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitMul_subexpr(s)
	}
}




func (p *YQLParser) Mul_subexpr() (localctx IMul_subexprContext) {
	localctx = NewMul_subexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, YQLParserRULE_mul_subexpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1157)
		p.Con_subexpr()
	}
	p.SetState(1162)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserDOUBLE_PIPE {
		{
			p.SetState(1158)
			p.Match(YQLParserDOUBLE_PIPE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1159)
			p.Con_subexpr()
		}


		p.SetState(1164)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICon_subexprContext is an interface to support dynamic dispatch.
type ICon_subexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Unary_subexpr() IUnary_subexprContext
	Unary_op() IUnary_opContext

	// IsCon_subexprContext differentiates from other interfaces.
	IsCon_subexprContext()
}

type Con_subexprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCon_subexprContext() *Con_subexprContext {
	var p = new(Con_subexprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_con_subexpr
	return p
}

func InitEmptyCon_subexprContext(p *Con_subexprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_con_subexpr
}

func (*Con_subexprContext) IsCon_subexprContext() {}

func NewCon_subexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Con_subexprContext {
	var p = new(Con_subexprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_con_subexpr

	return p
}

func (s *Con_subexprContext) GetParser() antlr.Parser { return s.parser }

func (s *Con_subexprContext) Unary_subexpr() IUnary_subexprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnary_subexprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnary_subexprContext)
}

func (s *Con_subexprContext) Unary_op() IUnary_opContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnary_opContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnary_opContext)
}

func (s *Con_subexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Con_subexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Con_subexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterCon_subexpr(s)
	}
}

func (s *Con_subexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitCon_subexpr(s)
	}
}




func (p *YQLParser) Con_subexpr() (localctx ICon_subexprContext) {
	localctx = NewCon_subexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, YQLParserRULE_con_subexpr)
	p.SetState(1169)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1165)
			p.Unary_subexpr()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1166)
			p.Unary_op()
		}
		{
			p.SetState(1167)
			p.Unary_subexpr()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUnary_opContext is an interface to support dynamic dispatch.
type IUnary_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	TILDA() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsUnary_opContext differentiates from other interfaces.
	IsUnary_opContext()
}

type Unary_opContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_opContext() *Unary_opContext {
	var p = new(Unary_opContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_unary_op
	return p
}

func InitEmptyUnary_opContext(p *Unary_opContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_unary_op
}

func (*Unary_opContext) IsUnary_opContext() {}

func NewUnary_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_opContext {
	var p = new(Unary_opContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_unary_op

	return p
}

func (s *Unary_opContext) GetParser() antlr.Parser { return s.parser }

func (s *Unary_opContext) PLUS() antlr.TerminalNode {
	return s.GetToken(YQLParserPLUS, 0)
}

func (s *Unary_opContext) MINUS() antlr.TerminalNode {
	return s.GetToken(YQLParserMINUS, 0)
}

func (s *Unary_opContext) TILDA() antlr.TerminalNode {
	return s.GetToken(YQLParserTILDA, 0)
}

func (s *Unary_opContext) NOT() antlr.TerminalNode {
	return s.GetToken(YQLParserNOT, 0)
}

func (s *Unary_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Unary_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterUnary_op(s)
	}
}

func (s *Unary_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitUnary_op(s)
	}
}




func (p *YQLParser) Unary_op() (localctx IUnary_opContext) {
	localctx = NewUnary_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, YQLParserRULE_unary_op)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1171)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 458752) != 0) || _la == YQLParserNOT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUnary_subexpr_suffixContext is an interface to support dynamic dispatch.
type IUnary_subexpr_suffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLLATE() antlr.TerminalNode
	An_id() IAn_idContext
	AllKey_expr() []IKey_exprContext
	Key_expr(i int) IKey_exprContext
	AllInvoke_expr() []IInvoke_exprContext
	Invoke_expr(i int) IInvoke_exprContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	AllBind_parameter() []IBind_parameterContext
	Bind_parameter(i int) IBind_parameterContext
	AllDIGITS() []antlr.TerminalNode
	DIGITS(i int) antlr.TerminalNode
	AllAn_id_or_type() []IAn_id_or_typeContext
	An_id_or_type(i int) IAn_id_or_typeContext

	// IsUnary_subexpr_suffixContext differentiates from other interfaces.
	IsUnary_subexpr_suffixContext()
}

type Unary_subexpr_suffixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_subexpr_suffixContext() *Unary_subexpr_suffixContext {
	var p = new(Unary_subexpr_suffixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_unary_subexpr_suffix
	return p
}

func InitEmptyUnary_subexpr_suffixContext(p *Unary_subexpr_suffixContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_unary_subexpr_suffix
}

func (*Unary_subexpr_suffixContext) IsUnary_subexpr_suffixContext() {}

func NewUnary_subexpr_suffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_subexpr_suffixContext {
	var p = new(Unary_subexpr_suffixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_unary_subexpr_suffix

	return p
}

func (s *Unary_subexpr_suffixContext) GetParser() antlr.Parser { return s.parser }

func (s *Unary_subexpr_suffixContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(YQLParserCOLLATE, 0)
}

func (s *Unary_subexpr_suffixContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Unary_subexpr_suffixContext) AllKey_expr() []IKey_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKey_exprContext); ok {
			len++
		}
	}

	tst := make([]IKey_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKey_exprContext); ok {
			tst[i] = t.(IKey_exprContext)
			i++
		}
	}

	return tst
}

func (s *Unary_subexpr_suffixContext) Key_expr(i int) IKey_exprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKey_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKey_exprContext)
}

func (s *Unary_subexpr_suffixContext) AllInvoke_expr() []IInvoke_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInvoke_exprContext); ok {
			len++
		}
	}

	tst := make([]IInvoke_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInvoke_exprContext); ok {
			tst[i] = t.(IInvoke_exprContext)
			i++
		}
	}

	return tst
}

func (s *Unary_subexpr_suffixContext) Invoke_expr(i int) IInvoke_exprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInvoke_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInvoke_exprContext)
}

func (s *Unary_subexpr_suffixContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(YQLParserDOT)
}

func (s *Unary_subexpr_suffixContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserDOT, i)
}

func (s *Unary_subexpr_suffixContext) AllBind_parameter() []IBind_parameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBind_parameterContext); ok {
			len++
		}
	}

	tst := make([]IBind_parameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBind_parameterContext); ok {
			tst[i] = t.(IBind_parameterContext)
			i++
		}
	}

	return tst
}

func (s *Unary_subexpr_suffixContext) Bind_parameter(i int) IBind_parameterContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *Unary_subexpr_suffixContext) AllDIGITS() []antlr.TerminalNode {
	return s.GetTokens(YQLParserDIGITS)
}

func (s *Unary_subexpr_suffixContext) DIGITS(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserDIGITS, i)
}

func (s *Unary_subexpr_suffixContext) AllAn_id_or_type() []IAn_id_or_typeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAn_id_or_typeContext); ok {
			len++
		}
	}

	tst := make([]IAn_id_or_typeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAn_id_or_typeContext); ok {
			tst[i] = t.(IAn_id_or_typeContext)
			i++
		}
	}

	return tst
}

func (s *Unary_subexpr_suffixContext) An_id_or_type(i int) IAn_id_or_typeContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_or_typeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_or_typeContext)
}

func (s *Unary_subexpr_suffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_subexpr_suffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Unary_subexpr_suffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterUnary_subexpr_suffix(s)
	}
}

func (s *Unary_subexpr_suffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitUnary_subexpr_suffix(s)
	}
}




func (p *YQLParser) Unary_subexpr_suffix() (localctx IUnary_subexpr_suffixContext) {
	localctx = NewUnary_subexpr_suffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, YQLParserRULE_unary_subexpr_suffix)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1185)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 137480896512) != 0) {
		p.SetState(1181)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case YQLParserLBRACE_SQUARE:
			{
				p.SetState(1173)
				p.Key_expr()
			}


		case YQLParserLPAREN:
			{
				p.SetState(1174)
				p.Invoke_expr()
			}


		case YQLParserDOT:
			{
				p.SetState(1175)
				p.Match(YQLParserDOT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(1179)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case YQLParserDOLLAR:
				{
					p.SetState(1176)
					p.Bind_parameter()
				}


			case YQLParserDIGITS:
				{
					p.SetState(1177)
					p.Match(YQLParserDIGITS)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}


			case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALL, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserANY, YQLParserARRAY, YQLParserAS, YQLParserASC, YQLParserASSUME, YQLParserASYMMETRIC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBETWEEN, YQLParserBITCAST, YQLParserBY, YQLParserCALLABLE, YQLParserCASCADE, YQLParserCASE, YQLParserCAST, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOLUMN, YQLParserCOLUMNS, YQLParserCOMMIT, YQLParserCOMPACT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCUBE, YQLParserCURRENT, YQLParserCURRENT_DATE, YQLParserCURRENT_TIME, YQLParserCURRENT_TIMESTAMP, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDICT, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDISTINCT, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserEMPTY_ACTION, YQLParserENCRYPTED, YQLParserEND, YQLParserENUM, YQLParserERASE, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCEPT, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXISTS, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFLOW, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFROM, YQLParserFULL, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserGROUPS, YQLParserHASH, YQLParserHAVING, YQLParserHOP, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTERSECT, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserJSON_EXISTS, YQLParserJSON_QUERY, YQLParserJSON_VALUE, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLIMIT, YQLParserLIST, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOT, YQLParserNOTNULL, YQLParserNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOPTIONAL, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserPROCESS, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserRANGE, YQLParserREDUCE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESOURCE, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserRETURN, YQLParserRETURNING, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROLLUP, YQLParserROW, YQLParserROWS, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSCHEMA, YQLParserSECONDS, YQLParserSEEK, YQLParserSELECT, YQLParserSEMI, YQLParserSET, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSTREAM, YQLParserSTRUCT, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYMMETRIC, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTAGGED, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTUPLE, YQLParserTYPE, YQLParserUNBOUNDED, YQLParserUNCONDITIONAL, YQLParserUNION, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVARIANT, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWHEN, YQLParserWHERE, YQLParserWINDOW, YQLParserWITH, YQLParserWITHOUT, YQLParserWRAPPER, YQLParserXOR, YQLParserSTRING_VALUE, YQLParserID_PLAIN, YQLParserID_QUOTED:
				{
					p.SetState(1178)
					p.An_id_or_type()
				}



			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}


		p.SetState(1187)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1190)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserCOLLATE {
		{
			p.SetState(1188)
			p.Match(YQLParserCOLLATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1189)
			p.An_id()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUnary_casual_subexprContext is an interface to support dynamic dispatch.
type IUnary_casual_subexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Unary_subexpr_suffix() IUnary_subexpr_suffixContext
	Id_expr() IId_exprContext
	Atom_expr() IAtom_exprContext

	// IsUnary_casual_subexprContext differentiates from other interfaces.
	IsUnary_casual_subexprContext()
}

type Unary_casual_subexprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_casual_subexprContext() *Unary_casual_subexprContext {
	var p = new(Unary_casual_subexprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_unary_casual_subexpr
	return p
}

func InitEmptyUnary_casual_subexprContext(p *Unary_casual_subexprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_unary_casual_subexpr
}

func (*Unary_casual_subexprContext) IsUnary_casual_subexprContext() {}

func NewUnary_casual_subexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_casual_subexprContext {
	var p = new(Unary_casual_subexprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_unary_casual_subexpr

	return p
}

func (s *Unary_casual_subexprContext) GetParser() antlr.Parser { return s.parser }

func (s *Unary_casual_subexprContext) Unary_subexpr_suffix() IUnary_subexpr_suffixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnary_subexpr_suffixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnary_subexpr_suffixContext)
}

func (s *Unary_casual_subexprContext) Id_expr() IId_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_exprContext)
}

func (s *Unary_casual_subexprContext) Atom_expr() IAtom_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAtom_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAtom_exprContext)
}

func (s *Unary_casual_subexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_casual_subexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Unary_casual_subexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterUnary_casual_subexpr(s)
	}
}

func (s *Unary_casual_subexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitUnary_casual_subexpr(s)
	}
}




func (p *YQLParser) Unary_casual_subexpr() (localctx IUnary_casual_subexprContext) {
	localctx = NewUnary_casual_subexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, YQLParserRULE_unary_casual_subexpr)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1194)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1192)
			p.Id_expr()
		}


	case 2:
		{
			p.SetState(1193)
			p.Atom_expr()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(1196)
		p.Unary_subexpr_suffix()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIn_unary_casual_subexprContext is an interface to support dynamic dispatch.
type IIn_unary_casual_subexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Unary_subexpr_suffix() IUnary_subexpr_suffixContext
	Id_expr_in() IId_expr_inContext
	In_atom_expr() IIn_atom_exprContext

	// IsIn_unary_casual_subexprContext differentiates from other interfaces.
	IsIn_unary_casual_subexprContext()
}

type In_unary_casual_subexprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIn_unary_casual_subexprContext() *In_unary_casual_subexprContext {
	var p = new(In_unary_casual_subexprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_in_unary_casual_subexpr
	return p
}

func InitEmptyIn_unary_casual_subexprContext(p *In_unary_casual_subexprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_in_unary_casual_subexpr
}

func (*In_unary_casual_subexprContext) IsIn_unary_casual_subexprContext() {}

func NewIn_unary_casual_subexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *In_unary_casual_subexprContext {
	var p = new(In_unary_casual_subexprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_in_unary_casual_subexpr

	return p
}

func (s *In_unary_casual_subexprContext) GetParser() antlr.Parser { return s.parser }

func (s *In_unary_casual_subexprContext) Unary_subexpr_suffix() IUnary_subexpr_suffixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnary_subexpr_suffixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnary_subexpr_suffixContext)
}

func (s *In_unary_casual_subexprContext) Id_expr_in() IId_expr_inContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_expr_inContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_expr_inContext)
}

func (s *In_unary_casual_subexprContext) In_atom_expr() IIn_atom_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIn_atom_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIn_atom_exprContext)
}

func (s *In_unary_casual_subexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *In_unary_casual_subexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *In_unary_casual_subexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterIn_unary_casual_subexpr(s)
	}
}

func (s *In_unary_casual_subexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitIn_unary_casual_subexpr(s)
	}
}




func (p *YQLParser) In_unary_casual_subexpr() (localctx IIn_unary_casual_subexprContext) {
	localctx = NewIn_unary_casual_subexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, YQLParserRULE_in_unary_casual_subexpr)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1200)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1198)
			p.Id_expr_in()
		}


	case 2:
		{
			p.SetState(1199)
			p.In_atom_expr()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(1202)
		p.Unary_subexpr_suffix()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUnary_subexprContext is an interface to support dynamic dispatch.
type IUnary_subexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Unary_casual_subexpr() IUnary_casual_subexprContext
	Json_api_expr() IJson_api_exprContext

	// IsUnary_subexprContext differentiates from other interfaces.
	IsUnary_subexprContext()
}

type Unary_subexprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_subexprContext() *Unary_subexprContext {
	var p = new(Unary_subexprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_unary_subexpr
	return p
}

func InitEmptyUnary_subexprContext(p *Unary_subexprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_unary_subexpr
}

func (*Unary_subexprContext) IsUnary_subexprContext() {}

func NewUnary_subexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_subexprContext {
	var p = new(Unary_subexprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_unary_subexpr

	return p
}

func (s *Unary_subexprContext) GetParser() antlr.Parser { return s.parser }

func (s *Unary_subexprContext) Unary_casual_subexpr() IUnary_casual_subexprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnary_casual_subexprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnary_casual_subexprContext)
}

func (s *Unary_subexprContext) Json_api_expr() IJson_api_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJson_api_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJson_api_exprContext)
}

func (s *Unary_subexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_subexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Unary_subexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterUnary_subexpr(s)
	}
}

func (s *Unary_subexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitUnary_subexpr(s)
	}
}




func (p *YQLParser) Unary_subexpr() (localctx IUnary_subexprContext) {
	localctx = NewUnary_subexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, YQLParserRULE_unary_subexpr)
	p.SetState(1206)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1204)
			p.Unary_casual_subexpr()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1205)
			p.Json_api_expr()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIn_unary_subexprContext is an interface to support dynamic dispatch.
type IIn_unary_subexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	In_unary_casual_subexpr() IIn_unary_casual_subexprContext
	Json_api_expr() IJson_api_exprContext

	// IsIn_unary_subexprContext differentiates from other interfaces.
	IsIn_unary_subexprContext()
}

type In_unary_subexprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIn_unary_subexprContext() *In_unary_subexprContext {
	var p = new(In_unary_subexprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_in_unary_subexpr
	return p
}

func InitEmptyIn_unary_subexprContext(p *In_unary_subexprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_in_unary_subexpr
}

func (*In_unary_subexprContext) IsIn_unary_subexprContext() {}

func NewIn_unary_subexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *In_unary_subexprContext {
	var p = new(In_unary_subexprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_in_unary_subexpr

	return p
}

func (s *In_unary_subexprContext) GetParser() antlr.Parser { return s.parser }

func (s *In_unary_subexprContext) In_unary_casual_subexpr() IIn_unary_casual_subexprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIn_unary_casual_subexprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIn_unary_casual_subexprContext)
}

func (s *In_unary_subexprContext) Json_api_expr() IJson_api_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJson_api_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJson_api_exprContext)
}

func (s *In_unary_subexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *In_unary_subexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *In_unary_subexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterIn_unary_subexpr(s)
	}
}

func (s *In_unary_subexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitIn_unary_subexpr(s)
	}
}




func (p *YQLParser) In_unary_subexpr() (localctx IIn_unary_subexprContext) {
	localctx = NewIn_unary_subexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, YQLParserRULE_in_unary_subexpr)
	p.SetState(1210)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1208)
			p.In_unary_casual_subexpr()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1209)
			p.Json_api_expr()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IList_literalContext is an interface to support dynamic dispatch.
type IList_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE_SQUARE() antlr.TerminalNode
	RBRACE_SQUARE() antlr.TerminalNode
	Expr_list() IExpr_listContext
	COMMA() antlr.TerminalNode

	// IsList_literalContext differentiates from other interfaces.
	IsList_literalContext()
}

type List_literalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_literalContext() *List_literalContext {
	var p = new(List_literalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_list_literal
	return p
}

func InitEmptyList_literalContext(p *List_literalContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_list_literal
}

func (*List_literalContext) IsList_literalContext() {}

func NewList_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_literalContext {
	var p = new(List_literalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_list_literal

	return p
}

func (s *List_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *List_literalContext) LBRACE_SQUARE() antlr.TerminalNode {
	return s.GetToken(YQLParserLBRACE_SQUARE, 0)
}

func (s *List_literalContext) RBRACE_SQUARE() antlr.TerminalNode {
	return s.GetToken(YQLParserRBRACE_SQUARE, 0)
}

func (s *List_literalContext) Expr_list() IExpr_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_listContext)
}

func (s *List_literalContext) COMMA() antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, 0)
}

func (s *List_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *List_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterList_literal(s)
	}
}

func (s *List_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitList_literal(s)
	}
}




func (p *YQLParser) List_literal() (localctx IList_literalContext) {
	localctx = NewList_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, YQLParserRULE_list_literal)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1212)
		p.Match(YQLParserLBRACE_SQUARE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1214)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64((_la - 14)) & ^0x3f) == 0 && ((int64(1) << (_la - 14)) & -17592194234339) != 0) || ((int64((_la - 78)) & ^0x3f) == 0 && ((int64(1) << (_la - 78)) & -1) != 0) || ((int64((_la - 142)) & ^0x3f) == 0 && ((int64(1) << (_la - 142)) & -1) != 0) || ((int64((_la - 206)) & ^0x3f) == 0 && ((int64(1) << (_la - 206)) & -137438953473) != 0) || ((int64((_la - 270)) & ^0x3f) == 0 && ((int64(1) << (_la - 270)) & 2305843009213693951) != 0) {
		{
			p.SetState(1213)
			p.Expr_list()
		}

	}
	p.SetState(1217)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserCOMMA {
		{
			p.SetState(1216)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(1219)
		p.Match(YQLParserRBRACE_SQUARE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpr_dict_listContext is an interface to support dynamic dispatch.
type IExpr_dict_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllCOLON() []antlr.TerminalNode
	COLON(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExpr_dict_listContext differentiates from other interfaces.
	IsExpr_dict_listContext()
}

type Expr_dict_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_dict_listContext() *Expr_dict_listContext {
	var p = new(Expr_dict_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_expr_dict_list
	return p
}

func InitEmptyExpr_dict_listContext(p *Expr_dict_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_expr_dict_list
}

func (*Expr_dict_listContext) IsExpr_dict_listContext() {}

func NewExpr_dict_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_dict_listContext {
	var p = new(Expr_dict_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_expr_dict_list

	return p
}

func (s *Expr_dict_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_dict_listContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Expr_dict_listContext) Expr(i int) IExprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_dict_listContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOLON)
}

func (s *Expr_dict_listContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOLON, i)
}

func (s *Expr_dict_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Expr_dict_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Expr_dict_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_dict_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Expr_dict_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterExpr_dict_list(s)
	}
}

func (s *Expr_dict_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitExpr_dict_list(s)
	}
}




func (p *YQLParser) Expr_dict_list() (localctx IExpr_dict_listContext) {
	localctx = NewExpr_dict_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, YQLParserRULE_expr_dict_list)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1221)
		p.Expr()
	}
	p.SetState(1224)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserCOLON {
		{
			p.SetState(1222)
			p.Match(YQLParserCOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1223)
			p.Expr()
		}

	}
	p.SetState(1234)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1226)
				p.Match(YQLParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1227)
				p.Expr()
			}
			p.SetState(1230)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == YQLParserCOLON {
				{
					p.SetState(1228)
					p.Match(YQLParserCOLON)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(1229)
					p.Expr()
				}

			}


		}
		p.SetState(1236)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDict_literalContext is an interface to support dynamic dispatch.
type IDict_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE_CURLY() antlr.TerminalNode
	RBRACE_CURLY() antlr.TerminalNode
	Expr_dict_list() IExpr_dict_listContext
	COMMA() antlr.TerminalNode

	// IsDict_literalContext differentiates from other interfaces.
	IsDict_literalContext()
}

type Dict_literalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDict_literalContext() *Dict_literalContext {
	var p = new(Dict_literalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_dict_literal
	return p
}

func InitEmptyDict_literalContext(p *Dict_literalContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_dict_literal
}

func (*Dict_literalContext) IsDict_literalContext() {}

func NewDict_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dict_literalContext {
	var p = new(Dict_literalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_dict_literal

	return p
}

func (s *Dict_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Dict_literalContext) LBRACE_CURLY() antlr.TerminalNode {
	return s.GetToken(YQLParserLBRACE_CURLY, 0)
}

func (s *Dict_literalContext) RBRACE_CURLY() antlr.TerminalNode {
	return s.GetToken(YQLParserRBRACE_CURLY, 0)
}

func (s *Dict_literalContext) Expr_dict_list() IExpr_dict_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_dict_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_dict_listContext)
}

func (s *Dict_literalContext) COMMA() antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, 0)
}

func (s *Dict_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dict_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Dict_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterDict_literal(s)
	}
}

func (s *Dict_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitDict_literal(s)
	}
}




func (p *YQLParser) Dict_literal() (localctx IDict_literalContext) {
	localctx = NewDict_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, YQLParserRULE_dict_literal)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1237)
		p.Match(YQLParserLBRACE_CURLY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1239)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64((_la - 14)) & ^0x3f) == 0 && ((int64(1) << (_la - 14)) & -17592194234339) != 0) || ((int64((_la - 78)) & ^0x3f) == 0 && ((int64(1) << (_la - 78)) & -1) != 0) || ((int64((_la - 142)) & ^0x3f) == 0 && ((int64(1) << (_la - 142)) & -1) != 0) || ((int64((_la - 206)) & ^0x3f) == 0 && ((int64(1) << (_la - 206)) & -137438953473) != 0) || ((int64((_la - 270)) & ^0x3f) == 0 && ((int64(1) << (_la - 270)) & 2305843009213693951) != 0) {
		{
			p.SetState(1238)
			p.Expr_dict_list()
		}

	}
	p.SetState(1242)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserCOMMA {
		{
			p.SetState(1241)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(1244)
		p.Match(YQLParserRBRACE_CURLY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpr_struct_listContext is an interface to support dynamic dispatch.
type IExpr_struct_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllCOLON() []antlr.TerminalNode
	COLON(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExpr_struct_listContext differentiates from other interfaces.
	IsExpr_struct_listContext()
}

type Expr_struct_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_struct_listContext() *Expr_struct_listContext {
	var p = new(Expr_struct_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_expr_struct_list
	return p
}

func InitEmptyExpr_struct_listContext(p *Expr_struct_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_expr_struct_list
}

func (*Expr_struct_listContext) IsExpr_struct_listContext() {}

func NewExpr_struct_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_struct_listContext {
	var p = new(Expr_struct_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_expr_struct_list

	return p
}

func (s *Expr_struct_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_struct_listContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Expr_struct_listContext) Expr(i int) IExprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_struct_listContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOLON)
}

func (s *Expr_struct_listContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOLON, i)
}

func (s *Expr_struct_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Expr_struct_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Expr_struct_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_struct_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Expr_struct_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterExpr_struct_list(s)
	}
}

func (s *Expr_struct_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitExpr_struct_list(s)
	}
}




func (p *YQLParser) Expr_struct_list() (localctx IExpr_struct_listContext) {
	localctx = NewExpr_struct_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, YQLParserRULE_expr_struct_list)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1246)
		p.Expr()
	}
	{
		p.SetState(1247)
		p.Match(YQLParserCOLON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1248)
		p.Expr()
	}
	p.SetState(1256)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 55, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1249)
				p.Match(YQLParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1250)
				p.Expr()
			}
			{
				p.SetState(1251)
				p.Match(YQLParserCOLON)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1252)
				p.Expr()
			}


		}
		p.SetState(1258)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 55, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IStruct_literalContext is an interface to support dynamic dispatch.
type IStruct_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRUCT_OPEN() antlr.TerminalNode
	STRUCT_CLOSE() antlr.TerminalNode
	Expr_struct_list() IExpr_struct_listContext
	COMMA() antlr.TerminalNode

	// IsStruct_literalContext differentiates from other interfaces.
	IsStruct_literalContext()
}

type Struct_literalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_literalContext() *Struct_literalContext {
	var p = new(Struct_literalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_struct_literal
	return p
}

func InitEmptyStruct_literalContext(p *Struct_literalContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_struct_literal
}

func (*Struct_literalContext) IsStruct_literalContext() {}

func NewStruct_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_literalContext {
	var p = new(Struct_literalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_struct_literal

	return p
}

func (s *Struct_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_literalContext) STRUCT_OPEN() antlr.TerminalNode {
	return s.GetToken(YQLParserSTRUCT_OPEN, 0)
}

func (s *Struct_literalContext) STRUCT_CLOSE() antlr.TerminalNode {
	return s.GetToken(YQLParserSTRUCT_CLOSE, 0)
}

func (s *Struct_literalContext) Expr_struct_list() IExpr_struct_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_struct_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_struct_listContext)
}

func (s *Struct_literalContext) COMMA() antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, 0)
}

func (s *Struct_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Struct_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterStruct_literal(s)
	}
}

func (s *Struct_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitStruct_literal(s)
	}
}




func (p *YQLParser) Struct_literal() (localctx IStruct_literalContext) {
	localctx = NewStruct_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, YQLParserRULE_struct_literal)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1259)
		p.Match(YQLParserSTRUCT_OPEN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1261)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64((_la - 14)) & ^0x3f) == 0 && ((int64(1) << (_la - 14)) & -17592194234339) != 0) || ((int64((_la - 78)) & ^0x3f) == 0 && ((int64(1) << (_la - 78)) & -1) != 0) || ((int64((_la - 142)) & ^0x3f) == 0 && ((int64(1) << (_la - 142)) & -1) != 0) || ((int64((_la - 206)) & ^0x3f) == 0 && ((int64(1) << (_la - 206)) & -137438953473) != 0) || ((int64((_la - 270)) & ^0x3f) == 0 && ((int64(1) << (_la - 270)) & 2305843009213693951) != 0) {
		{
			p.SetState(1260)
			p.Expr_struct_list()
		}

	}
	p.SetState(1264)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserCOMMA {
		{
			p.SetState(1263)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(1266)
		p.Match(YQLParserSTRUCT_CLOSE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAtom_exprContext is an interface to support dynamic dispatch.
type IAtom_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Literal_value() ILiteral_valueContext
	Bind_parameter() IBind_parameterContext
	Lambda() ILambdaContext
	Cast_expr() ICast_exprContext
	Exists_expr() IExists_exprContext
	Case_expr() ICase_exprContext
	An_id_or_type() IAn_id_or_typeContext
	NAMESPACE() antlr.TerminalNode
	Id_or_type() IId_or_typeContext
	STRING_VALUE() antlr.TerminalNode
	Value_constructor() IValue_constructorContext
	Bitcast_expr() IBitcast_exprContext
	List_literal() IList_literalContext
	Dict_literal() IDict_literalContext
	Struct_literal() IStruct_literalContext

	// IsAtom_exprContext differentiates from other interfaces.
	IsAtom_exprContext()
}

type Atom_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtom_exprContext() *Atom_exprContext {
	var p = new(Atom_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_atom_expr
	return p
}

func InitEmptyAtom_exprContext(p *Atom_exprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_atom_expr
}

func (*Atom_exprContext) IsAtom_exprContext() {}

func NewAtom_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Atom_exprContext {
	var p = new(Atom_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_atom_expr

	return p
}

func (s *Atom_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Atom_exprContext) Literal_value() ILiteral_valueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteral_valueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteral_valueContext)
}

func (s *Atom_exprContext) Bind_parameter() IBind_parameterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *Atom_exprContext) Lambda() ILambdaContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaContext)
}

func (s *Atom_exprContext) Cast_expr() ICast_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICast_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICast_exprContext)
}

func (s *Atom_exprContext) Exists_expr() IExists_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExists_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExists_exprContext)
}

func (s *Atom_exprContext) Case_expr() ICase_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICase_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICase_exprContext)
}

func (s *Atom_exprContext) An_id_or_type() IAn_id_or_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_or_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_or_typeContext)
}

func (s *Atom_exprContext) NAMESPACE() antlr.TerminalNode {
	return s.GetToken(YQLParserNAMESPACE, 0)
}

func (s *Atom_exprContext) Id_or_type() IId_or_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_or_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_or_typeContext)
}

func (s *Atom_exprContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(YQLParserSTRING_VALUE, 0)
}

func (s *Atom_exprContext) Value_constructor() IValue_constructorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValue_constructorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValue_constructorContext)
}

func (s *Atom_exprContext) Bitcast_expr() IBitcast_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitcast_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitcast_exprContext)
}

func (s *Atom_exprContext) List_literal() IList_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IList_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IList_literalContext)
}

func (s *Atom_exprContext) Dict_literal() IDict_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDict_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDict_literalContext)
}

func (s *Atom_exprContext) Struct_literal() IStruct_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStruct_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStruct_literalContext)
}

func (s *Atom_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Atom_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Atom_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAtom_expr(s)
	}
}

func (s *Atom_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAtom_expr(s)
	}
}




func (p *YQLParser) Atom_expr() (localctx IAtom_exprContext) {
	localctx = NewAtom_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, YQLParserRULE_atom_expr)
	p.SetState(1285)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 59, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1268)
			p.Literal_value()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1269)
			p.Bind_parameter()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1270)
			p.Lambda()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1271)
			p.Cast_expr()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1272)
			p.Exists_expr()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1273)
			p.Case_expr()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1274)
			p.An_id_or_type()
		}
		{
			p.SetState(1275)
			p.Match(YQLParserNAMESPACE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1278)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALL, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserANY, YQLParserARRAY, YQLParserAS, YQLParserASC, YQLParserASSUME, YQLParserASYMMETRIC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBETWEEN, YQLParserBITCAST, YQLParserBY, YQLParserCALLABLE, YQLParserCASCADE, YQLParserCASE, YQLParserCAST, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOLUMN, YQLParserCOLUMNS, YQLParserCOMMIT, YQLParserCOMPACT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCUBE, YQLParserCURRENT, YQLParserCURRENT_DATE, YQLParserCURRENT_TIME, YQLParserCURRENT_TIMESTAMP, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDICT, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDISTINCT, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserEMPTY_ACTION, YQLParserENCRYPTED, YQLParserEND, YQLParserENUM, YQLParserERASE, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCEPT, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXISTS, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFLOW, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFROM, YQLParserFULL, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserGROUPS, YQLParserHASH, YQLParserHAVING, YQLParserHOP, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTERSECT, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserJSON_EXISTS, YQLParserJSON_QUERY, YQLParserJSON_VALUE, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLIMIT, YQLParserLIST, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOT, YQLParserNOTNULL, YQLParserNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOPTIONAL, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserPROCESS, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserRANGE, YQLParserREDUCE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESOURCE, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserRETURN, YQLParserRETURNING, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROLLUP, YQLParserROW, YQLParserROWS, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSCHEMA, YQLParserSECONDS, YQLParserSEEK, YQLParserSELECT, YQLParserSEMI, YQLParserSET, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSTREAM, YQLParserSTRUCT, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYMMETRIC, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTAGGED, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTUPLE, YQLParserTYPE, YQLParserUNBOUNDED, YQLParserUNCONDITIONAL, YQLParserUNION, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVARIANT, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWHEN, YQLParserWHERE, YQLParserWINDOW, YQLParserWITH, YQLParserWITHOUT, YQLParserWRAPPER, YQLParserXOR, YQLParserID_PLAIN, YQLParserID_QUOTED:
			{
				p.SetState(1276)
				p.Id_or_type()
			}


		case YQLParserSTRING_VALUE:
			{
				p.SetState(1277)
				p.Match(YQLParserSTRING_VALUE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1280)
			p.Value_constructor()
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1281)
			p.Bitcast_expr()
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1282)
			p.List_literal()
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1283)
			p.Dict_literal()
		}


	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1284)
			p.Struct_literal()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIn_atom_exprContext is an interface to support dynamic dispatch.
type IIn_atom_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Literal_value() ILiteral_valueContext
	Bind_parameter() IBind_parameterContext
	Lambda() ILambdaContext
	Cast_expr() ICast_exprContext
	Case_expr() ICase_exprContext
	An_id_or_type() IAn_id_or_typeContext
	NAMESPACE() antlr.TerminalNode
	Id_or_type() IId_or_typeContext
	STRING_VALUE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	RPAREN() antlr.TerminalNode
	Value_constructor() IValue_constructorContext
	Bitcast_expr() IBitcast_exprContext
	List_literal() IList_literalContext
	Dict_literal() IDict_literalContext
	Struct_literal() IStruct_literalContext

	// IsIn_atom_exprContext differentiates from other interfaces.
	IsIn_atom_exprContext()
}

type In_atom_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIn_atom_exprContext() *In_atom_exprContext {
	var p = new(In_atom_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_in_atom_expr
	return p
}

func InitEmptyIn_atom_exprContext(p *In_atom_exprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_in_atom_expr
}

func (*In_atom_exprContext) IsIn_atom_exprContext() {}

func NewIn_atom_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *In_atom_exprContext {
	var p = new(In_atom_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_in_atom_expr

	return p
}

func (s *In_atom_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *In_atom_exprContext) Literal_value() ILiteral_valueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteral_valueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteral_valueContext)
}

func (s *In_atom_exprContext) Bind_parameter() IBind_parameterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *In_atom_exprContext) Lambda() ILambdaContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaContext)
}

func (s *In_atom_exprContext) Cast_expr() ICast_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICast_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICast_exprContext)
}

func (s *In_atom_exprContext) Case_expr() ICase_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICase_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICase_exprContext)
}

func (s *In_atom_exprContext) An_id_or_type() IAn_id_or_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_or_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_or_typeContext)
}

func (s *In_atom_exprContext) NAMESPACE() antlr.TerminalNode {
	return s.GetToken(YQLParserNAMESPACE, 0)
}

func (s *In_atom_exprContext) Id_or_type() IId_or_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_or_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_or_typeContext)
}

func (s *In_atom_exprContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(YQLParserSTRING_VALUE, 0)
}

func (s *In_atom_exprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *In_atom_exprContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *In_atom_exprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *In_atom_exprContext) Value_constructor() IValue_constructorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValue_constructorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValue_constructorContext)
}

func (s *In_atom_exprContext) Bitcast_expr() IBitcast_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitcast_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitcast_exprContext)
}

func (s *In_atom_exprContext) List_literal() IList_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IList_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IList_literalContext)
}

func (s *In_atom_exprContext) Dict_literal() IDict_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDict_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDict_literalContext)
}

func (s *In_atom_exprContext) Struct_literal() IStruct_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStruct_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStruct_literalContext)
}

func (s *In_atom_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *In_atom_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *In_atom_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterIn_atom_expr(s)
	}
}

func (s *In_atom_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitIn_atom_expr(s)
	}
}




func (p *YQLParser) In_atom_expr() (localctx IIn_atom_exprContext) {
	localctx = NewIn_atom_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, YQLParserRULE_in_atom_expr)
	p.SetState(1307)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1287)
			p.Literal_value()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1288)
			p.Bind_parameter()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1289)
			p.Lambda()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1290)
			p.Cast_expr()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1291)
			p.Case_expr()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1292)
			p.An_id_or_type()
		}
		{
			p.SetState(1293)
			p.Match(YQLParserNAMESPACE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1296)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALL, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserANY, YQLParserARRAY, YQLParserAS, YQLParserASC, YQLParserASSUME, YQLParserASYMMETRIC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBETWEEN, YQLParserBITCAST, YQLParserBY, YQLParserCALLABLE, YQLParserCASCADE, YQLParserCASE, YQLParserCAST, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOLUMN, YQLParserCOLUMNS, YQLParserCOMMIT, YQLParserCOMPACT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCUBE, YQLParserCURRENT, YQLParserCURRENT_DATE, YQLParserCURRENT_TIME, YQLParserCURRENT_TIMESTAMP, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDICT, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDISTINCT, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserEMPTY_ACTION, YQLParserENCRYPTED, YQLParserEND, YQLParserENUM, YQLParserERASE, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCEPT, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXISTS, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFLOW, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFROM, YQLParserFULL, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserGROUPS, YQLParserHASH, YQLParserHAVING, YQLParserHOP, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTERSECT, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserJSON_EXISTS, YQLParserJSON_QUERY, YQLParserJSON_VALUE, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLIMIT, YQLParserLIST, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOT, YQLParserNOTNULL, YQLParserNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOPTIONAL, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserPROCESS, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserRANGE, YQLParserREDUCE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESOURCE, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserRETURN, YQLParserRETURNING, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROLLUP, YQLParserROW, YQLParserROWS, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSCHEMA, YQLParserSECONDS, YQLParserSEEK, YQLParserSELECT, YQLParserSEMI, YQLParserSET, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSTREAM, YQLParserSTRUCT, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYMMETRIC, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTAGGED, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTUPLE, YQLParserTYPE, YQLParserUNBOUNDED, YQLParserUNCONDITIONAL, YQLParserUNION, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVARIANT, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWHEN, YQLParserWHERE, YQLParserWINDOW, YQLParserWITH, YQLParserWITHOUT, YQLParserWRAPPER, YQLParserXOR, YQLParserID_PLAIN, YQLParserID_QUOTED:
			{
				p.SetState(1294)
				p.Id_or_type()
			}


		case YQLParserSTRING_VALUE:
			{
				p.SetState(1295)
				p.Match(YQLParserSTRING_VALUE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1298)
			p.Match(YQLParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1299)
			p.Select_stmt()
		}
		{
			p.SetState(1300)
			p.Match(YQLParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1302)
			p.Value_constructor()
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1303)
			p.Bitcast_expr()
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1304)
			p.List_literal()
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1305)
			p.Dict_literal()
		}


	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1306)
			p.Struct_literal()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICast_exprContext is an interface to support dynamic dispatch.
type ICast_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CAST() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expr() IExprContext
	AS() antlr.TerminalNode
	Type_name_or_bind() IType_name_or_bindContext
	RPAREN() antlr.TerminalNode

	// IsCast_exprContext differentiates from other interfaces.
	IsCast_exprContext()
}

type Cast_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCast_exprContext() *Cast_exprContext {
	var p = new(Cast_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_cast_expr
	return p
}

func InitEmptyCast_exprContext(p *Cast_exprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_cast_expr
}

func (*Cast_exprContext) IsCast_exprContext() {}

func NewCast_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cast_exprContext {
	var p = new(Cast_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_cast_expr

	return p
}

func (s *Cast_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Cast_exprContext) CAST() antlr.TerminalNode {
	return s.GetToken(YQLParserCAST, 0)
}

func (s *Cast_exprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Cast_exprContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Cast_exprContext) AS() antlr.TerminalNode {
	return s.GetToken(YQLParserAS, 0)
}

func (s *Cast_exprContext) Type_name_or_bind() IType_name_or_bindContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_or_bindContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_or_bindContext)
}

func (s *Cast_exprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Cast_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cast_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Cast_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterCast_expr(s)
	}
}

func (s *Cast_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitCast_expr(s)
	}
}




func (p *YQLParser) Cast_expr() (localctx ICast_exprContext) {
	localctx = NewCast_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, YQLParserRULE_cast_expr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1309)
		p.Match(YQLParserCAST)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1310)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1311)
		p.Expr()
	}
	{
		p.SetState(1312)
		p.Match(YQLParserAS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1313)
		p.Type_name_or_bind()
	}
	{
		p.SetState(1314)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBitcast_exprContext is an interface to support dynamic dispatch.
type IBitcast_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BITCAST() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expr() IExprContext
	AS() antlr.TerminalNode
	Type_name_simple() IType_name_simpleContext
	RPAREN() antlr.TerminalNode

	// IsBitcast_exprContext differentiates from other interfaces.
	IsBitcast_exprContext()
}

type Bitcast_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitcast_exprContext() *Bitcast_exprContext {
	var p = new(Bitcast_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_bitcast_expr
	return p
}

func InitEmptyBitcast_exprContext(p *Bitcast_exprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_bitcast_expr
}

func (*Bitcast_exprContext) IsBitcast_exprContext() {}

func NewBitcast_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bitcast_exprContext {
	var p = new(Bitcast_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_bitcast_expr

	return p
}

func (s *Bitcast_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Bitcast_exprContext) BITCAST() antlr.TerminalNode {
	return s.GetToken(YQLParserBITCAST, 0)
}

func (s *Bitcast_exprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Bitcast_exprContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Bitcast_exprContext) AS() antlr.TerminalNode {
	return s.GetToken(YQLParserAS, 0)
}

func (s *Bitcast_exprContext) Type_name_simple() IType_name_simpleContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_simpleContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_simpleContext)
}

func (s *Bitcast_exprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Bitcast_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bitcast_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Bitcast_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterBitcast_expr(s)
	}
}

func (s *Bitcast_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitBitcast_expr(s)
	}
}




func (p *YQLParser) Bitcast_expr() (localctx IBitcast_exprContext) {
	localctx = NewBitcast_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, YQLParserRULE_bitcast_expr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1316)
		p.Match(YQLParserBITCAST)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1317)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1318)
		p.Expr()
	}
	{
		p.SetState(1319)
		p.Match(YQLParserAS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1320)
		p.Type_name_simple()
	}
	{
		p.SetState(1321)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExists_exprContext is an interface to support dynamic dispatch.
type IExists_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXISTS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	Values_stmt() IValues_stmtContext

	// IsExists_exprContext differentiates from other interfaces.
	IsExists_exprContext()
}

type Exists_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExists_exprContext() *Exists_exprContext {
	var p = new(Exists_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_exists_expr
	return p
}

func InitEmptyExists_exprContext(p *Exists_exprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_exists_expr
}

func (*Exists_exprContext) IsExists_exprContext() {}

func NewExists_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Exists_exprContext {
	var p = new(Exists_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_exists_expr

	return p
}

func (s *Exists_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Exists_exprContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(YQLParserEXISTS, 0)
}

func (s *Exists_exprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Exists_exprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Exists_exprContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Exists_exprContext) Values_stmt() IValues_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValues_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValues_stmtContext)
}

func (s *Exists_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Exists_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Exists_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterExists_expr(s)
	}
}

func (s *Exists_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitExists_expr(s)
	}
}




func (p *YQLParser) Exists_expr() (localctx IExists_exprContext) {
	localctx = NewExists_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, YQLParserRULE_exists_expr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1323)
		p.Match(YQLParserEXISTS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1324)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1327)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserLPAREN, YQLParserDISCARD, YQLParserFROM, YQLParserPROCESS, YQLParserREDUCE, YQLParserSELECT:
		{
			p.SetState(1325)
			p.Select_stmt()
		}


	case YQLParserVALUES:
		{
			p.SetState(1326)
			p.Values_stmt()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(1329)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICase_exprContext is an interface to support dynamic dispatch.
type ICase_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASE() antlr.TerminalNode
	END() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllWhen_expr() []IWhen_exprContext
	When_expr(i int) IWhen_exprContext
	ELSE() antlr.TerminalNode

	// IsCase_exprContext differentiates from other interfaces.
	IsCase_exprContext()
}

type Case_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_exprContext() *Case_exprContext {
	var p = new(Case_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_case_expr
	return p
}

func InitEmptyCase_exprContext(p *Case_exprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_case_expr
}

func (*Case_exprContext) IsCase_exprContext() {}

func NewCase_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_exprContext {
	var p = new(Case_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_case_expr

	return p
}

func (s *Case_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_exprContext) CASE() antlr.TerminalNode {
	return s.GetToken(YQLParserCASE, 0)
}

func (s *Case_exprContext) END() antlr.TerminalNode {
	return s.GetToken(YQLParserEND, 0)
}

func (s *Case_exprContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Case_exprContext) Expr(i int) IExprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Case_exprContext) AllWhen_expr() []IWhen_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhen_exprContext); ok {
			len++
		}
	}

	tst := make([]IWhen_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhen_exprContext); ok {
			tst[i] = t.(IWhen_exprContext)
			i++
		}
	}

	return tst
}

func (s *Case_exprContext) When_expr(i int) IWhen_exprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhen_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhen_exprContext)
}

func (s *Case_exprContext) ELSE() antlr.TerminalNode {
	return s.GetToken(YQLParserELSE, 0)
}

func (s *Case_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Case_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterCase_expr(s)
	}
}

func (s *Case_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitCase_expr(s)
	}
}




func (p *YQLParser) Case_expr() (localctx ICase_exprContext) {
	localctx = NewCase_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, YQLParserRULE_case_expr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1331)
		p.Match(YQLParserCASE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1333)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 63, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1332)
			p.Expr()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(1336)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = _la == YQLParserWHEN {
		{
			p.SetState(1335)
			p.When_expr()
		}


		p.SetState(1338)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1342)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserELSE {
		{
			p.SetState(1340)
			p.Match(YQLParserELSE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1341)
			p.Expr()
		}

	}
	{
		p.SetState(1344)
		p.Match(YQLParserEND)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILambdaContext is an interface to support dynamic dispatch.
type ILambdaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Smart_parenthesis() ISmart_parenthesisContext
	ARROW() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expr() IExprContext
	RPAREN() antlr.TerminalNode
	LBRACE_CURLY() antlr.TerminalNode
	Lambda_body() ILambda_bodyContext
	RBRACE_CURLY() antlr.TerminalNode

	// IsLambdaContext differentiates from other interfaces.
	IsLambdaContext()
}

type LambdaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaContext() *LambdaContext {
	var p = new(LambdaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_lambda
	return p
}

func InitEmptyLambdaContext(p *LambdaContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_lambda
}

func (*LambdaContext) IsLambdaContext() {}

func NewLambdaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaContext {
	var p = new(LambdaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_lambda

	return p
}

func (s *LambdaContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaContext) Smart_parenthesis() ISmart_parenthesisContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISmart_parenthesisContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISmart_parenthesisContext)
}

func (s *LambdaContext) ARROW() antlr.TerminalNode {
	return s.GetToken(YQLParserARROW, 0)
}

func (s *LambdaContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *LambdaContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LambdaContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *LambdaContext) LBRACE_CURLY() antlr.TerminalNode {
	return s.GetToken(YQLParserLBRACE_CURLY, 0)
}

func (s *LambdaContext) Lambda_body() ILambda_bodyContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambda_bodyContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambda_bodyContext)
}

func (s *LambdaContext) RBRACE_CURLY() antlr.TerminalNode {
	return s.GetToken(YQLParserRBRACE_CURLY, 0)
}

func (s *LambdaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LambdaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterLambda(s)
	}
}

func (s *LambdaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitLambda(s)
	}
}




func (p *YQLParser) Lambda() (localctx ILambdaContext) {
	localctx = NewLambdaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, YQLParserRULE_lambda)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1346)
		p.Smart_parenthesis()
	}
	p.SetState(1358)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserARROW {
		{
			p.SetState(1347)
			p.Match(YQLParserARROW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1356)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case YQLParserLPAREN:
			{
				p.SetState(1348)
				p.Match(YQLParserLPAREN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1349)
				p.Expr()
			}
			{
				p.SetState(1350)
				p.Match(YQLParserRPAREN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case YQLParserLBRACE_CURLY:
			{
				p.SetState(1352)
				p.Match(YQLParserLBRACE_CURLY)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1353)
				p.Lambda_body()
			}
			{
				p.SetState(1354)
				p.Match(YQLParserRBRACE_CURLY)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIn_exprContext is an interface to support dynamic dispatch.
type IIn_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	In_unary_subexpr() IIn_unary_subexprContext

	// IsIn_exprContext differentiates from other interfaces.
	IsIn_exprContext()
}

type In_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIn_exprContext() *In_exprContext {
	var p = new(In_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_in_expr
	return p
}

func InitEmptyIn_exprContext(p *In_exprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_in_expr
}

func (*In_exprContext) IsIn_exprContext() {}

func NewIn_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *In_exprContext {
	var p = new(In_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_in_expr

	return p
}

func (s *In_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *In_exprContext) In_unary_subexpr() IIn_unary_subexprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIn_unary_subexprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIn_unary_subexprContext)
}

func (s *In_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *In_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *In_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterIn_expr(s)
	}
}

func (s *In_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitIn_expr(s)
	}
}




func (p *YQLParser) In_expr() (localctx IIn_exprContext) {
	localctx = NewIn_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, YQLParserRULE_in_expr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1360)
		p.In_unary_subexpr()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IJson_api_exprContext is an interface to support dynamic dispatch.
type IJson_api_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Json_value() IJson_valueContext
	Json_exists() IJson_existsContext
	Json_query() IJson_queryContext

	// IsJson_api_exprContext differentiates from other interfaces.
	IsJson_api_exprContext()
}

type Json_api_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJson_api_exprContext() *Json_api_exprContext {
	var p = new(Json_api_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_json_api_expr
	return p
}

func InitEmptyJson_api_exprContext(p *Json_api_exprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_json_api_expr
}

func (*Json_api_exprContext) IsJson_api_exprContext() {}

func NewJson_api_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Json_api_exprContext {
	var p = new(Json_api_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_json_api_expr

	return p
}

func (s *Json_api_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Json_api_exprContext) Json_value() IJson_valueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJson_valueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJson_valueContext)
}

func (s *Json_api_exprContext) Json_exists() IJson_existsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJson_existsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJson_existsContext)
}

func (s *Json_api_exprContext) Json_query() IJson_queryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJson_queryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJson_queryContext)
}

func (s *Json_api_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Json_api_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Json_api_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterJson_api_expr(s)
	}
}

func (s *Json_api_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitJson_api_expr(s)
	}
}




func (p *YQLParser) Json_api_expr() (localctx IJson_api_exprContext) {
	localctx = NewJson_api_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, YQLParserRULE_json_api_expr)
	p.SetState(1365)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserJSON_VALUE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1362)
			p.Json_value()
		}


	case YQLParserJSON_EXISTS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1363)
			p.Json_exists()
		}


	case YQLParserJSON_QUERY:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1364)
			p.Json_query()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IJsonpath_specContext is an interface to support dynamic dispatch.
type IJsonpath_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_VALUE() antlr.TerminalNode

	// IsJsonpath_specContext differentiates from other interfaces.
	IsJsonpath_specContext()
}

type Jsonpath_specContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonpath_specContext() *Jsonpath_specContext {
	var p = new(Jsonpath_specContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_jsonpath_spec
	return p
}

func InitEmptyJsonpath_specContext(p *Jsonpath_specContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_jsonpath_spec
}

func (*Jsonpath_specContext) IsJsonpath_specContext() {}

func NewJsonpath_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Jsonpath_specContext {
	var p = new(Jsonpath_specContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_jsonpath_spec

	return p
}

func (s *Jsonpath_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Jsonpath_specContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(YQLParserSTRING_VALUE, 0)
}

func (s *Jsonpath_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Jsonpath_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Jsonpath_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterJsonpath_spec(s)
	}
}

func (s *Jsonpath_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitJsonpath_spec(s)
	}
}




func (p *YQLParser) Jsonpath_spec() (localctx IJsonpath_specContext) {
	localctx = NewJsonpath_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, YQLParserRULE_jsonpath_spec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1367)
		p.Match(YQLParserSTRING_VALUE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IJson_variable_nameContext is an interface to support dynamic dispatch.
type IJson_variable_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_expr() IId_exprContext
	STRING_VALUE() antlr.TerminalNode

	// IsJson_variable_nameContext differentiates from other interfaces.
	IsJson_variable_nameContext()
}

type Json_variable_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJson_variable_nameContext() *Json_variable_nameContext {
	var p = new(Json_variable_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_json_variable_name
	return p
}

func InitEmptyJson_variable_nameContext(p *Json_variable_nameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_json_variable_name
}

func (*Json_variable_nameContext) IsJson_variable_nameContext() {}

func NewJson_variable_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Json_variable_nameContext {
	var p = new(Json_variable_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_json_variable_name

	return p
}

func (s *Json_variable_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Json_variable_nameContext) Id_expr() IId_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_exprContext)
}

func (s *Json_variable_nameContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(YQLParserSTRING_VALUE, 0)
}

func (s *Json_variable_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Json_variable_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Json_variable_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterJson_variable_name(s)
	}
}

func (s *Json_variable_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitJson_variable_name(s)
	}
}




func (p *YQLParser) Json_variable_name() (localctx IJson_variable_nameContext) {
	localctx = NewJson_variable_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, YQLParserRULE_json_variable_name)
	p.SetState(1371)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserARRAY, YQLParserASC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBY, YQLParserCASCADE, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOLUMN, YQLParserCOLUMNS, YQLParserCOMMIT, YQLParserCOMPACT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCURRENT, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserENCRYPTED, YQLParserEND, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserGROUPS, YQLParserHASH, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOTNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserRANGE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROW, YQLParserROWS, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSCHEMA, YQLParserSECONDS, YQLParserSEEK, YQLParserSEMI, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTYPE, YQLParserUNCONDITIONAL, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWITH, YQLParserWRAPPER, YQLParserXOR, YQLParserID_PLAIN, YQLParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1369)
			p.Id_expr()
		}


	case YQLParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1370)
			p.Match(YQLParserSTRING_VALUE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IJson_variableContext is an interface to support dynamic dispatch.
type IJson_variableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	AS() antlr.TerminalNode
	Json_variable_name() IJson_variable_nameContext

	// IsJson_variableContext differentiates from other interfaces.
	IsJson_variableContext()
}

type Json_variableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJson_variableContext() *Json_variableContext {
	var p = new(Json_variableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_json_variable
	return p
}

func InitEmptyJson_variableContext(p *Json_variableContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_json_variable
}

func (*Json_variableContext) IsJson_variableContext() {}

func NewJson_variableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Json_variableContext {
	var p = new(Json_variableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_json_variable

	return p
}

func (s *Json_variableContext) GetParser() antlr.Parser { return s.parser }

func (s *Json_variableContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Json_variableContext) AS() antlr.TerminalNode {
	return s.GetToken(YQLParserAS, 0)
}

func (s *Json_variableContext) Json_variable_name() IJson_variable_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJson_variable_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJson_variable_nameContext)
}

func (s *Json_variableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Json_variableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Json_variableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterJson_variable(s)
	}
}

func (s *Json_variableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitJson_variable(s)
	}
}




func (p *YQLParser) Json_variable() (localctx IJson_variableContext) {
	localctx = NewJson_variableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, YQLParserRULE_json_variable)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1373)
		p.Expr()
	}
	{
		p.SetState(1374)
		p.Match(YQLParserAS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1375)
		p.Json_variable_name()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IJson_variablesContext is an interface to support dynamic dispatch.
type IJson_variablesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllJson_variable() []IJson_variableContext
	Json_variable(i int) IJson_variableContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsJson_variablesContext differentiates from other interfaces.
	IsJson_variablesContext()
}

type Json_variablesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJson_variablesContext() *Json_variablesContext {
	var p = new(Json_variablesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_json_variables
	return p
}

func InitEmptyJson_variablesContext(p *Json_variablesContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_json_variables
}

func (*Json_variablesContext) IsJson_variablesContext() {}

func NewJson_variablesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Json_variablesContext {
	var p = new(Json_variablesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_json_variables

	return p
}

func (s *Json_variablesContext) GetParser() antlr.Parser { return s.parser }

func (s *Json_variablesContext) AllJson_variable() []IJson_variableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJson_variableContext); ok {
			len++
		}
	}

	tst := make([]IJson_variableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJson_variableContext); ok {
			tst[i] = t.(IJson_variableContext)
			i++
		}
	}

	return tst
}

func (s *Json_variablesContext) Json_variable(i int) IJson_variableContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJson_variableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJson_variableContext)
}

func (s *Json_variablesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Json_variablesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Json_variablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Json_variablesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Json_variablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterJson_variables(s)
	}
}

func (s *Json_variablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitJson_variables(s)
	}
}




func (p *YQLParser) Json_variables() (localctx IJson_variablesContext) {
	localctx = NewJson_variablesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, YQLParserRULE_json_variables)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1377)
		p.Json_variable()
	}
	p.SetState(1382)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(1378)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1379)
			p.Json_variable()
		}


		p.SetState(1384)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IJson_common_argsContext is an interface to support dynamic dispatch.
type IJson_common_argsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	COMMA() antlr.TerminalNode
	Jsonpath_spec() IJsonpath_specContext
	PASSING() antlr.TerminalNode
	Json_variables() IJson_variablesContext

	// IsJson_common_argsContext differentiates from other interfaces.
	IsJson_common_argsContext()
}

type Json_common_argsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJson_common_argsContext() *Json_common_argsContext {
	var p = new(Json_common_argsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_json_common_args
	return p
}

func InitEmptyJson_common_argsContext(p *Json_common_argsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_json_common_args
}

func (*Json_common_argsContext) IsJson_common_argsContext() {}

func NewJson_common_argsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Json_common_argsContext {
	var p = new(Json_common_argsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_json_common_args

	return p
}

func (s *Json_common_argsContext) GetParser() antlr.Parser { return s.parser }

func (s *Json_common_argsContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Json_common_argsContext) COMMA() antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, 0)
}

func (s *Json_common_argsContext) Jsonpath_spec() IJsonpath_specContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonpath_specContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonpath_specContext)
}

func (s *Json_common_argsContext) PASSING() antlr.TerminalNode {
	return s.GetToken(YQLParserPASSING, 0)
}

func (s *Json_common_argsContext) Json_variables() IJson_variablesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJson_variablesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJson_variablesContext)
}

func (s *Json_common_argsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Json_common_argsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Json_common_argsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterJson_common_args(s)
	}
}

func (s *Json_common_argsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitJson_common_args(s)
	}
}




func (p *YQLParser) Json_common_args() (localctx IJson_common_argsContext) {
	localctx = NewJson_common_argsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, YQLParserRULE_json_common_args)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1385)
		p.Expr()
	}
	{
		p.SetState(1386)
		p.Match(YQLParserCOMMA)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1387)
		p.Jsonpath_spec()
	}
	p.SetState(1390)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserPASSING {
		{
			p.SetState(1388)
			p.Match(YQLParserPASSING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1389)
			p.Json_variables()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IJson_case_handlerContext is an interface to support dynamic dispatch.
type IJson_case_handlerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ERROR() antlr.TerminalNode
	NULL() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	Expr() IExprContext

	// IsJson_case_handlerContext differentiates from other interfaces.
	IsJson_case_handlerContext()
}

type Json_case_handlerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJson_case_handlerContext() *Json_case_handlerContext {
	var p = new(Json_case_handlerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_json_case_handler
	return p
}

func InitEmptyJson_case_handlerContext(p *Json_case_handlerContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_json_case_handler
}

func (*Json_case_handlerContext) IsJson_case_handlerContext() {}

func NewJson_case_handlerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Json_case_handlerContext {
	var p = new(Json_case_handlerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_json_case_handler

	return p
}

func (s *Json_case_handlerContext) GetParser() antlr.Parser { return s.parser }

func (s *Json_case_handlerContext) ERROR() antlr.TerminalNode {
	return s.GetToken(YQLParserERROR, 0)
}

func (s *Json_case_handlerContext) NULL() antlr.TerminalNode {
	return s.GetToken(YQLParserNULL, 0)
}

func (s *Json_case_handlerContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(YQLParserDEFAULT, 0)
}

func (s *Json_case_handlerContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Json_case_handlerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Json_case_handlerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Json_case_handlerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterJson_case_handler(s)
	}
}

func (s *Json_case_handlerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitJson_case_handler(s)
	}
}




func (p *YQLParser) Json_case_handler() (localctx IJson_case_handlerContext) {
	localctx = NewJson_case_handlerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, YQLParserRULE_json_case_handler)
	p.SetState(1396)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserERROR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1392)
			p.Match(YQLParserERROR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserNULL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1393)
			p.Match(YQLParserNULL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserDEFAULT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1394)
			p.Match(YQLParserDEFAULT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1395)
			p.Expr()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IJson_valueContext is an interface to support dynamic dispatch.
type IJson_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JSON_VALUE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Json_common_args() IJson_common_argsContext
	RPAREN() antlr.TerminalNode
	RETURNING() antlr.TerminalNode
	Type_name_simple() IType_name_simpleContext
	AllJson_case_handler() []IJson_case_handlerContext
	Json_case_handler(i int) IJson_case_handlerContext
	AllON() []antlr.TerminalNode
	ON(i int) antlr.TerminalNode
	AllEMPTY() []antlr.TerminalNode
	EMPTY(i int) antlr.TerminalNode
	AllERROR() []antlr.TerminalNode
	ERROR(i int) antlr.TerminalNode

	// IsJson_valueContext differentiates from other interfaces.
	IsJson_valueContext()
}

type Json_valueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJson_valueContext() *Json_valueContext {
	var p = new(Json_valueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_json_value
	return p
}

func InitEmptyJson_valueContext(p *Json_valueContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_json_value
}

func (*Json_valueContext) IsJson_valueContext() {}

func NewJson_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Json_valueContext {
	var p = new(Json_valueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_json_value

	return p
}

func (s *Json_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Json_valueContext) JSON_VALUE() antlr.TerminalNode {
	return s.GetToken(YQLParserJSON_VALUE, 0)
}

func (s *Json_valueContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Json_valueContext) Json_common_args() IJson_common_argsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJson_common_argsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJson_common_argsContext)
}

func (s *Json_valueContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Json_valueContext) RETURNING() antlr.TerminalNode {
	return s.GetToken(YQLParserRETURNING, 0)
}

func (s *Json_valueContext) Type_name_simple() IType_name_simpleContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_simpleContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_simpleContext)
}

func (s *Json_valueContext) AllJson_case_handler() []IJson_case_handlerContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJson_case_handlerContext); ok {
			len++
		}
	}

	tst := make([]IJson_case_handlerContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJson_case_handlerContext); ok {
			tst[i] = t.(IJson_case_handlerContext)
			i++
		}
	}

	return tst
}

func (s *Json_valueContext) Json_case_handler(i int) IJson_case_handlerContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJson_case_handlerContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJson_case_handlerContext)
}

func (s *Json_valueContext) AllON() []antlr.TerminalNode {
	return s.GetTokens(YQLParserON)
}

func (s *Json_valueContext) ON(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserON, i)
}

func (s *Json_valueContext) AllEMPTY() []antlr.TerminalNode {
	return s.GetTokens(YQLParserEMPTY)
}

func (s *Json_valueContext) EMPTY(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserEMPTY, i)
}

func (s *Json_valueContext) AllERROR() []antlr.TerminalNode {
	return s.GetTokens(YQLParserERROR)
}

func (s *Json_valueContext) ERROR(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserERROR, i)
}

func (s *Json_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Json_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Json_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterJson_value(s)
	}
}

func (s *Json_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitJson_value(s)
	}
}




func (p *YQLParser) Json_value() (localctx IJson_valueContext) {
	localctx = NewJson_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, YQLParserRULE_json_value)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1398)
		p.Match(YQLParserJSON_VALUE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1399)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1400)
		p.Json_common_args()
	}
	p.SetState(1403)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserRETURNING {
		{
			p.SetState(1401)
			p.Match(YQLParserRETURNING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1402)
			p.Type_name_simple()
		}

	}
	p.SetState(1411)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserDEFAULT || _la == YQLParserERROR || _la == YQLParserNULL {
		{
			p.SetState(1405)
			p.Json_case_handler()
		}
		{
			p.SetState(1406)
			p.Match(YQLParserON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1407)
			_la = p.GetTokenStream().LA(1)

			if !(_la == YQLParserEMPTY || _la == YQLParserERROR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


		p.SetState(1413)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1414)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IJson_exists_handlerContext is an interface to support dynamic dispatch.
type IJson_exists_handlerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	AllERROR() []antlr.TerminalNode
	ERROR(i int) antlr.TerminalNode
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode
	UNKNOWN() antlr.TerminalNode

	// IsJson_exists_handlerContext differentiates from other interfaces.
	IsJson_exists_handlerContext()
}

type Json_exists_handlerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJson_exists_handlerContext() *Json_exists_handlerContext {
	var p = new(Json_exists_handlerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_json_exists_handler
	return p
}

func InitEmptyJson_exists_handlerContext(p *Json_exists_handlerContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_json_exists_handler
}

func (*Json_exists_handlerContext) IsJson_exists_handlerContext() {}

func NewJson_exists_handlerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Json_exists_handlerContext {
	var p = new(Json_exists_handlerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_json_exists_handler

	return p
}

func (s *Json_exists_handlerContext) GetParser() antlr.Parser { return s.parser }

func (s *Json_exists_handlerContext) ON() antlr.TerminalNode {
	return s.GetToken(YQLParserON, 0)
}

func (s *Json_exists_handlerContext) AllERROR() []antlr.TerminalNode {
	return s.GetTokens(YQLParserERROR)
}

func (s *Json_exists_handlerContext) ERROR(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserERROR, i)
}

func (s *Json_exists_handlerContext) TRUE() antlr.TerminalNode {
	return s.GetToken(YQLParserTRUE, 0)
}

func (s *Json_exists_handlerContext) FALSE() antlr.TerminalNode {
	return s.GetToken(YQLParserFALSE, 0)
}

func (s *Json_exists_handlerContext) UNKNOWN() antlr.TerminalNode {
	return s.GetToken(YQLParserUNKNOWN, 0)
}

func (s *Json_exists_handlerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Json_exists_handlerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Json_exists_handlerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterJson_exists_handler(s)
	}
}

func (s *Json_exists_handlerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitJson_exists_handler(s)
	}
}




func (p *YQLParser) Json_exists_handler() (localctx IJson_exists_handlerContext) {
	localctx = NewJson_exists_handlerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, YQLParserRULE_json_exists_handler)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1416)
		_la = p.GetTokenStream().LA(1)

		if !(_la == YQLParserERROR || _la == YQLParserFALSE || _la == YQLParserTRUE || _la == YQLParserUNKNOWN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1417)
		p.Match(YQLParserON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1418)
		p.Match(YQLParserERROR)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IJson_existsContext is an interface to support dynamic dispatch.
type IJson_existsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JSON_EXISTS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Json_common_args() IJson_common_argsContext
	RPAREN() antlr.TerminalNode
	Json_exists_handler() IJson_exists_handlerContext

	// IsJson_existsContext differentiates from other interfaces.
	IsJson_existsContext()
}

type Json_existsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJson_existsContext() *Json_existsContext {
	var p = new(Json_existsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_json_exists
	return p
}

func InitEmptyJson_existsContext(p *Json_existsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_json_exists
}

func (*Json_existsContext) IsJson_existsContext() {}

func NewJson_existsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Json_existsContext {
	var p = new(Json_existsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_json_exists

	return p
}

func (s *Json_existsContext) GetParser() antlr.Parser { return s.parser }

func (s *Json_existsContext) JSON_EXISTS() antlr.TerminalNode {
	return s.GetToken(YQLParserJSON_EXISTS, 0)
}

func (s *Json_existsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Json_existsContext) Json_common_args() IJson_common_argsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJson_common_argsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJson_common_argsContext)
}

func (s *Json_existsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Json_existsContext) Json_exists_handler() IJson_exists_handlerContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJson_exists_handlerContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJson_exists_handlerContext)
}

func (s *Json_existsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Json_existsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Json_existsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterJson_exists(s)
	}
}

func (s *Json_existsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitJson_exists(s)
	}
}




func (p *YQLParser) Json_exists() (localctx IJson_existsContext) {
	localctx = NewJson_existsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, YQLParserRULE_json_exists)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1420)
		p.Match(YQLParserJSON_EXISTS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1421)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1422)
		p.Json_common_args()
	}
	p.SetState(1424)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserERROR || _la == YQLParserFALSE || _la == YQLParserTRUE || _la == YQLParserUNKNOWN {
		{
			p.SetState(1423)
			p.Json_exists_handler()
		}

	}
	{
		p.SetState(1426)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IJson_query_wrapperContext is an interface to support dynamic dispatch.
type IJson_query_wrapperContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITHOUT() antlr.TerminalNode
	ARRAY() antlr.TerminalNode
	WITH() antlr.TerminalNode
	CONDITIONAL() antlr.TerminalNode
	UNCONDITIONAL() antlr.TerminalNode

	// IsJson_query_wrapperContext differentiates from other interfaces.
	IsJson_query_wrapperContext()
}

type Json_query_wrapperContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJson_query_wrapperContext() *Json_query_wrapperContext {
	var p = new(Json_query_wrapperContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_json_query_wrapper
	return p
}

func InitEmptyJson_query_wrapperContext(p *Json_query_wrapperContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_json_query_wrapper
}

func (*Json_query_wrapperContext) IsJson_query_wrapperContext() {}

func NewJson_query_wrapperContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Json_query_wrapperContext {
	var p = new(Json_query_wrapperContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_json_query_wrapper

	return p
}

func (s *Json_query_wrapperContext) GetParser() antlr.Parser { return s.parser }

func (s *Json_query_wrapperContext) WITHOUT() antlr.TerminalNode {
	return s.GetToken(YQLParserWITHOUT, 0)
}

func (s *Json_query_wrapperContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(YQLParserARRAY, 0)
}

func (s *Json_query_wrapperContext) WITH() antlr.TerminalNode {
	return s.GetToken(YQLParserWITH, 0)
}

func (s *Json_query_wrapperContext) CONDITIONAL() antlr.TerminalNode {
	return s.GetToken(YQLParserCONDITIONAL, 0)
}

func (s *Json_query_wrapperContext) UNCONDITIONAL() antlr.TerminalNode {
	return s.GetToken(YQLParserUNCONDITIONAL, 0)
}

func (s *Json_query_wrapperContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Json_query_wrapperContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Json_query_wrapperContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterJson_query_wrapper(s)
	}
}

func (s *Json_query_wrapperContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitJson_query_wrapper(s)
	}
}




func (p *YQLParser) Json_query_wrapper() (localctx IJson_query_wrapperContext) {
	localctx = NewJson_query_wrapperContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, YQLParserRULE_json_query_wrapper)
	var _la int

	p.SetState(1439)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserWITHOUT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1428)
			p.Match(YQLParserWITHOUT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1430)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserARRAY {
			{
				p.SetState(1429)
				p.Match(YQLParserARRAY)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}


	case YQLParserWITH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1432)
			p.Match(YQLParserWITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1434)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserCONDITIONAL || _la == YQLParserUNCONDITIONAL {
			{
				p.SetState(1433)
				_la = p.GetTokenStream().LA(1)

				if !(_la == YQLParserCONDITIONAL || _la == YQLParserUNCONDITIONAL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1437)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserARRAY {
			{
				p.SetState(1436)
				p.Match(YQLParserARRAY)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IJson_query_handlerContext is an interface to support dynamic dispatch.
type IJson_query_handlerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ERROR() antlr.TerminalNode
	NULL() antlr.TerminalNode
	EMPTY() antlr.TerminalNode
	ARRAY() antlr.TerminalNode
	OBJECT() antlr.TerminalNode

	// IsJson_query_handlerContext differentiates from other interfaces.
	IsJson_query_handlerContext()
}

type Json_query_handlerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJson_query_handlerContext() *Json_query_handlerContext {
	var p = new(Json_query_handlerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_json_query_handler
	return p
}

func InitEmptyJson_query_handlerContext(p *Json_query_handlerContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_json_query_handler
}

func (*Json_query_handlerContext) IsJson_query_handlerContext() {}

func NewJson_query_handlerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Json_query_handlerContext {
	var p = new(Json_query_handlerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_json_query_handler

	return p
}

func (s *Json_query_handlerContext) GetParser() antlr.Parser { return s.parser }

func (s *Json_query_handlerContext) ERROR() antlr.TerminalNode {
	return s.GetToken(YQLParserERROR, 0)
}

func (s *Json_query_handlerContext) NULL() antlr.TerminalNode {
	return s.GetToken(YQLParserNULL, 0)
}

func (s *Json_query_handlerContext) EMPTY() antlr.TerminalNode {
	return s.GetToken(YQLParserEMPTY, 0)
}

func (s *Json_query_handlerContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(YQLParserARRAY, 0)
}

func (s *Json_query_handlerContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(YQLParserOBJECT, 0)
}

func (s *Json_query_handlerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Json_query_handlerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Json_query_handlerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterJson_query_handler(s)
	}
}

func (s *Json_query_handlerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitJson_query_handler(s)
	}
}




func (p *YQLParser) Json_query_handler() (localctx IJson_query_handlerContext) {
	localctx = NewJson_query_handlerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, YQLParserRULE_json_query_handler)
	p.SetState(1447)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 80, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1441)
			p.Match(YQLParserERROR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1442)
			p.Match(YQLParserNULL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1443)
			p.Match(YQLParserEMPTY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1444)
			p.Match(YQLParserARRAY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1445)
			p.Match(YQLParserEMPTY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1446)
			p.Match(YQLParserOBJECT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IJson_queryContext is an interface to support dynamic dispatch.
type IJson_queryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JSON_QUERY() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Json_common_args() IJson_common_argsContext
	RPAREN() antlr.TerminalNode
	Json_query_wrapper() IJson_query_wrapperContext
	WRAPPER() antlr.TerminalNode
	AllJson_query_handler() []IJson_query_handlerContext
	Json_query_handler(i int) IJson_query_handlerContext
	AllON() []antlr.TerminalNode
	ON(i int) antlr.TerminalNode
	EMPTY() antlr.TerminalNode
	ERROR() antlr.TerminalNode

	// IsJson_queryContext differentiates from other interfaces.
	IsJson_queryContext()
}

type Json_queryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJson_queryContext() *Json_queryContext {
	var p = new(Json_queryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_json_query
	return p
}

func InitEmptyJson_queryContext(p *Json_queryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_json_query
}

func (*Json_queryContext) IsJson_queryContext() {}

func NewJson_queryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Json_queryContext {
	var p = new(Json_queryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_json_query

	return p
}

func (s *Json_queryContext) GetParser() antlr.Parser { return s.parser }

func (s *Json_queryContext) JSON_QUERY() antlr.TerminalNode {
	return s.GetToken(YQLParserJSON_QUERY, 0)
}

func (s *Json_queryContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Json_queryContext) Json_common_args() IJson_common_argsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJson_common_argsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJson_common_argsContext)
}

func (s *Json_queryContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Json_queryContext) Json_query_wrapper() IJson_query_wrapperContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJson_query_wrapperContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJson_query_wrapperContext)
}

func (s *Json_queryContext) WRAPPER() antlr.TerminalNode {
	return s.GetToken(YQLParserWRAPPER, 0)
}

func (s *Json_queryContext) AllJson_query_handler() []IJson_query_handlerContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJson_query_handlerContext); ok {
			len++
		}
	}

	tst := make([]IJson_query_handlerContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJson_query_handlerContext); ok {
			tst[i] = t.(IJson_query_handlerContext)
			i++
		}
	}

	return tst
}

func (s *Json_queryContext) Json_query_handler(i int) IJson_query_handlerContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJson_query_handlerContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJson_query_handlerContext)
}

func (s *Json_queryContext) AllON() []antlr.TerminalNode {
	return s.GetTokens(YQLParserON)
}

func (s *Json_queryContext) ON(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserON, i)
}

func (s *Json_queryContext) EMPTY() antlr.TerminalNode {
	return s.GetToken(YQLParserEMPTY, 0)
}

func (s *Json_queryContext) ERROR() antlr.TerminalNode {
	return s.GetToken(YQLParserERROR, 0)
}

func (s *Json_queryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Json_queryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Json_queryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterJson_query(s)
	}
}

func (s *Json_queryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitJson_query(s)
	}
}




func (p *YQLParser) Json_query() (localctx IJson_queryContext) {
	localctx = NewJson_queryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, YQLParserRULE_json_query)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1449)
		p.Match(YQLParserJSON_QUERY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1450)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1451)
		p.Json_common_args()
	}
	p.SetState(1455)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserWITH || _la == YQLParserWITHOUT {
		{
			p.SetState(1452)
			p.Json_query_wrapper()
		}
		{
			p.SetState(1453)
			p.Match(YQLParserWRAPPER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(1461)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 82, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1457)
			p.Json_query_handler()
		}
		{
			p.SetState(1458)
			p.Match(YQLParserON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1459)
			p.Match(YQLParserEMPTY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(1467)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserEMPTY || _la == YQLParserERROR || _la == YQLParserNULL {
		{
			p.SetState(1463)
			p.Json_query_handler()
		}
		{
			p.SetState(1464)
			p.Match(YQLParserON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1465)
			p.Match(YQLParserERROR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(1469)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISmart_parenthesisContext is an interface to support dynamic dispatch.
type ISmart_parenthesisContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Named_expr_list() INamed_expr_listContext
	COMMA() antlr.TerminalNode

	// IsSmart_parenthesisContext differentiates from other interfaces.
	IsSmart_parenthesisContext()
}

type Smart_parenthesisContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySmart_parenthesisContext() *Smart_parenthesisContext {
	var p = new(Smart_parenthesisContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_smart_parenthesis
	return p
}

func InitEmptySmart_parenthesisContext(p *Smart_parenthesisContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_smart_parenthesis
}

func (*Smart_parenthesisContext) IsSmart_parenthesisContext() {}

func NewSmart_parenthesisContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Smart_parenthesisContext {
	var p = new(Smart_parenthesisContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_smart_parenthesis

	return p
}

func (s *Smart_parenthesisContext) GetParser() antlr.Parser { return s.parser }

func (s *Smart_parenthesisContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Smart_parenthesisContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Smart_parenthesisContext) Named_expr_list() INamed_expr_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_expr_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_expr_listContext)
}

func (s *Smart_parenthesisContext) COMMA() antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, 0)
}

func (s *Smart_parenthesisContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Smart_parenthesisContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Smart_parenthesisContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterSmart_parenthesis(s)
	}
}

func (s *Smart_parenthesisContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitSmart_parenthesis(s)
	}
}




func (p *YQLParser) Smart_parenthesis() (localctx ISmart_parenthesisContext) {
	localctx = NewSmart_parenthesisContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, YQLParserRULE_smart_parenthesis)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1471)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1473)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64((_la - 14)) & ^0x3f) == 0 && ((int64(1) << (_la - 14)) & -17592194234339) != 0) || ((int64((_la - 78)) & ^0x3f) == 0 && ((int64(1) << (_la - 78)) & -1) != 0) || ((int64((_la - 142)) & ^0x3f) == 0 && ((int64(1) << (_la - 142)) & -1) != 0) || ((int64((_la - 206)) & ^0x3f) == 0 && ((int64(1) << (_la - 206)) & -137438953473) != 0) || ((int64((_la - 270)) & ^0x3f) == 0 && ((int64(1) << (_la - 270)) & 2305843009213693951) != 0) {
		{
			p.SetState(1472)
			p.Named_expr_list()
		}

	}
	p.SetState(1476)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserCOMMA {
		{
			p.SetState(1475)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(1478)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpr_listContext is an interface to support dynamic dispatch.
type IExpr_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExpr_listContext differentiates from other interfaces.
	IsExpr_listContext()
}

type Expr_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_listContext() *Expr_listContext {
	var p = new(Expr_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_expr_list
	return p
}

func InitEmptyExpr_listContext(p *Expr_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_expr_list
}

func (*Expr_listContext) IsExpr_listContext() {}

func NewExpr_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_listContext {
	var p = new(Expr_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_expr_list

	return p
}

func (s *Expr_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_listContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Expr_listContext) Expr(i int) IExprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Expr_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Expr_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Expr_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterExpr_list(s)
	}
}

func (s *Expr_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitExpr_list(s)
	}
}




func (p *YQLParser) Expr_list() (localctx IExpr_listContext) {
	localctx = NewExpr_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, YQLParserRULE_expr_list)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1480)
		p.Expr()
	}
	p.SetState(1485)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1481)
				p.Match(YQLParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1482)
				p.Expr()
			}


		}
		p.SetState(1487)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPure_column_listContext is an interface to support dynamic dispatch.
type IPure_column_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllAn_id() []IAn_idContext
	An_id(i int) IAn_idContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPure_column_listContext differentiates from other interfaces.
	IsPure_column_listContext()
}

type Pure_column_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPure_column_listContext() *Pure_column_listContext {
	var p = new(Pure_column_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_pure_column_list
	return p
}

func InitEmptyPure_column_listContext(p *Pure_column_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_pure_column_list
}

func (*Pure_column_listContext) IsPure_column_listContext() {}

func NewPure_column_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pure_column_listContext {
	var p = new(Pure_column_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_pure_column_list

	return p
}

func (s *Pure_column_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Pure_column_listContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Pure_column_listContext) AllAn_id() []IAn_idContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAn_idContext); ok {
			len++
		}
	}

	tst := make([]IAn_idContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAn_idContext); ok {
			tst[i] = t.(IAn_idContext)
			i++
		}
	}

	return tst
}

func (s *Pure_column_listContext) An_id(i int) IAn_idContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Pure_column_listContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Pure_column_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Pure_column_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Pure_column_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pure_column_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Pure_column_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterPure_column_list(s)
	}
}

func (s *Pure_column_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitPure_column_list(s)
	}
}




func (p *YQLParser) Pure_column_list() (localctx IPure_column_listContext) {
	localctx = NewPure_column_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, YQLParserRULE_pure_column_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1488)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1489)
		p.An_id()
	}
	p.SetState(1494)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(1490)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1491)
			p.An_id()
		}


		p.SetState(1496)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1497)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPure_column_or_namedContext is an interface to support dynamic dispatch.
type IPure_column_or_namedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Bind_parameter() IBind_parameterContext
	An_id() IAn_idContext

	// IsPure_column_or_namedContext differentiates from other interfaces.
	IsPure_column_or_namedContext()
}

type Pure_column_or_namedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPure_column_or_namedContext() *Pure_column_or_namedContext {
	var p = new(Pure_column_or_namedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_pure_column_or_named
	return p
}

func InitEmptyPure_column_or_namedContext(p *Pure_column_or_namedContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_pure_column_or_named
}

func (*Pure_column_or_namedContext) IsPure_column_or_namedContext() {}

func NewPure_column_or_namedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pure_column_or_namedContext {
	var p = new(Pure_column_or_namedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_pure_column_or_named

	return p
}

func (s *Pure_column_or_namedContext) GetParser() antlr.Parser { return s.parser }

func (s *Pure_column_or_namedContext) Bind_parameter() IBind_parameterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *Pure_column_or_namedContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Pure_column_or_namedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pure_column_or_namedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Pure_column_or_namedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterPure_column_or_named(s)
	}
}

func (s *Pure_column_or_namedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitPure_column_or_named(s)
	}
}




func (p *YQLParser) Pure_column_or_named() (localctx IPure_column_or_namedContext) {
	localctx = NewPure_column_or_namedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, YQLParserRULE_pure_column_or_named)
	p.SetState(1501)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserDOLLAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1499)
			p.Bind_parameter()
		}


	case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALL, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserANY, YQLParserARRAY, YQLParserAS, YQLParserASC, YQLParserASSUME, YQLParserASYMMETRIC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBETWEEN, YQLParserBITCAST, YQLParserBY, YQLParserCASCADE, YQLParserCASE, YQLParserCAST, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOLUMN, YQLParserCOLUMNS, YQLParserCOMMIT, YQLParserCOMPACT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCUBE, YQLParserCURRENT, YQLParserCURRENT_DATE, YQLParserCURRENT_TIME, YQLParserCURRENT_TIMESTAMP, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDISTINCT, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserEMPTY_ACTION, YQLParserENCRYPTED, YQLParserEND, YQLParserERASE, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCEPT, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXISTS, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFROM, YQLParserFULL, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserGROUPS, YQLParserHASH, YQLParserHAVING, YQLParserHOP, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTERSECT, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserJSON_EXISTS, YQLParserJSON_QUERY, YQLParserJSON_VALUE, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLIMIT, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOT, YQLParserNOTNULL, YQLParserNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserPROCESS, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserRANGE, YQLParserREDUCE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserRETURN, YQLParserRETURNING, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROLLUP, YQLParserROW, YQLParserROWS, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSCHEMA, YQLParserSECONDS, YQLParserSEEK, YQLParserSELECT, YQLParserSEMI, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSTREAM, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYMMETRIC, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTYPE, YQLParserUNBOUNDED, YQLParserUNCONDITIONAL, YQLParserUNION, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWHEN, YQLParserWHERE, YQLParserWINDOW, YQLParserWITH, YQLParserWITHOUT, YQLParserWRAPPER, YQLParserXOR, YQLParserSTRING_VALUE, YQLParserID_PLAIN, YQLParserID_QUOTED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1500)
			p.An_id()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPure_column_or_named_listContext is an interface to support dynamic dispatch.
type IPure_column_or_named_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllPure_column_or_named() []IPure_column_or_namedContext
	Pure_column_or_named(i int) IPure_column_or_namedContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPure_column_or_named_listContext differentiates from other interfaces.
	IsPure_column_or_named_listContext()
}

type Pure_column_or_named_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPure_column_or_named_listContext() *Pure_column_or_named_listContext {
	var p = new(Pure_column_or_named_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_pure_column_or_named_list
	return p
}

func InitEmptyPure_column_or_named_listContext(p *Pure_column_or_named_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_pure_column_or_named_list
}

func (*Pure_column_or_named_listContext) IsPure_column_or_named_listContext() {}

func NewPure_column_or_named_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pure_column_or_named_listContext {
	var p = new(Pure_column_or_named_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_pure_column_or_named_list

	return p
}

func (s *Pure_column_or_named_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Pure_column_or_named_listContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Pure_column_or_named_listContext) AllPure_column_or_named() []IPure_column_or_namedContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPure_column_or_namedContext); ok {
			len++
		}
	}

	tst := make([]IPure_column_or_namedContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPure_column_or_namedContext); ok {
			tst[i] = t.(IPure_column_or_namedContext)
			i++
		}
	}

	return tst
}

func (s *Pure_column_or_named_listContext) Pure_column_or_named(i int) IPure_column_or_namedContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPure_column_or_namedContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPure_column_or_namedContext)
}

func (s *Pure_column_or_named_listContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Pure_column_or_named_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Pure_column_or_named_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Pure_column_or_named_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pure_column_or_named_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Pure_column_or_named_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterPure_column_or_named_list(s)
	}
}

func (s *Pure_column_or_named_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitPure_column_or_named_list(s)
	}
}




func (p *YQLParser) Pure_column_or_named_list() (localctx IPure_column_or_named_listContext) {
	localctx = NewPure_column_or_named_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, YQLParserRULE_pure_column_or_named_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1503)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1504)
		p.Pure_column_or_named()
	}
	p.SetState(1509)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(1505)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1506)
			p.Pure_column_or_named()
		}


		p.SetState(1511)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1512)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IColumn_nameContext is an interface to support dynamic dispatch.
type IColumn_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Opt_id_prefix() IOpt_id_prefixContext
	An_id() IAn_idContext

	// IsColumn_nameContext differentiates from other interfaces.
	IsColumn_nameContext()
}

type Column_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumn_nameContext() *Column_nameContext {
	var p = new(Column_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_column_name
	return p
}

func InitEmptyColumn_nameContext(p *Column_nameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_column_name
}

func (*Column_nameContext) IsColumn_nameContext() {}

func NewColumn_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_nameContext {
	var p = new(Column_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_column_name

	return p
}

func (s *Column_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_nameContext) Opt_id_prefix() IOpt_id_prefixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_id_prefixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_id_prefixContext)
}

func (s *Column_nameContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Column_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Column_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterColumn_name(s)
	}
}

func (s *Column_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitColumn_name(s)
	}
}




func (p *YQLParser) Column_name() (localctx IColumn_nameContext) {
	localctx = NewColumn_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, YQLParserRULE_column_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1514)
		p.Opt_id_prefix()
	}
	{
		p.SetState(1515)
		p.An_id()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWithout_column_nameContext is an interface to support dynamic dispatch.
type IWithout_column_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAn_id() []IAn_idContext
	An_id(i int) IAn_idContext
	DOT() antlr.TerminalNode
	An_id_without() IAn_id_withoutContext

	// IsWithout_column_nameContext differentiates from other interfaces.
	IsWithout_column_nameContext()
}

type Without_column_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithout_column_nameContext() *Without_column_nameContext {
	var p = new(Without_column_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_without_column_name
	return p
}

func InitEmptyWithout_column_nameContext(p *Without_column_nameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_without_column_name
}

func (*Without_column_nameContext) IsWithout_column_nameContext() {}

func NewWithout_column_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Without_column_nameContext {
	var p = new(Without_column_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_without_column_name

	return p
}

func (s *Without_column_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Without_column_nameContext) AllAn_id() []IAn_idContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAn_idContext); ok {
			len++
		}
	}

	tst := make([]IAn_idContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAn_idContext); ok {
			tst[i] = t.(IAn_idContext)
			i++
		}
	}

	return tst
}

func (s *Without_column_nameContext) An_id(i int) IAn_idContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Without_column_nameContext) DOT() antlr.TerminalNode {
	return s.GetToken(YQLParserDOT, 0)
}

func (s *Without_column_nameContext) An_id_without() IAn_id_withoutContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_withoutContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_withoutContext)
}

func (s *Without_column_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Without_column_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Without_column_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterWithout_column_name(s)
	}
}

func (s *Without_column_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitWithout_column_name(s)
	}
}




func (p *YQLParser) Without_column_name() (localctx IWithout_column_nameContext) {
	localctx = NewWithout_column_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, YQLParserRULE_without_column_name)
	p.SetState(1522)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 90, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1517)
			p.An_id()
		}
		{
			p.SetState(1518)
			p.Match(YQLParserDOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1519)
			p.An_id()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1521)
			p.An_id_without()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IColumn_listContext is an interface to support dynamic dispatch.
type IColumn_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumn_name() []IColumn_nameContext
	Column_name(i int) IColumn_nameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsColumn_listContext differentiates from other interfaces.
	IsColumn_listContext()
}

type Column_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumn_listContext() *Column_listContext {
	var p = new(Column_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_column_list
	return p
}

func InitEmptyColumn_listContext(p *Column_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_column_list
}

func (*Column_listContext) IsColumn_listContext() {}

func NewColumn_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_listContext {
	var p = new(Column_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_column_list

	return p
}

func (s *Column_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_listContext) AllColumn_name() []IColumn_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumn_nameContext); ok {
			len++
		}
	}

	tst := make([]IColumn_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumn_nameContext); ok {
			tst[i] = t.(IColumn_nameContext)
			i++
		}
	}

	return tst
}

func (s *Column_listContext) Column_name(i int) IColumn_nameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Column_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Column_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Column_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Column_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterColumn_list(s)
	}
}

func (s *Column_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitColumn_list(s)
	}
}




func (p *YQLParser) Column_list() (localctx IColumn_listContext) {
	localctx = NewColumn_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, YQLParserRULE_column_list)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1524)
		p.Column_name()
	}
	p.SetState(1529)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1525)
				p.Match(YQLParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1526)
				p.Column_name()
			}


		}
		p.SetState(1531)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1533)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserCOMMA {
		{
			p.SetState(1532)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWithout_column_listContext is an interface to support dynamic dispatch.
type IWithout_column_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllWithout_column_name() []IWithout_column_nameContext
	Without_column_name(i int) IWithout_column_nameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWithout_column_listContext differentiates from other interfaces.
	IsWithout_column_listContext()
}

type Without_column_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithout_column_listContext() *Without_column_listContext {
	var p = new(Without_column_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_without_column_list
	return p
}

func InitEmptyWithout_column_listContext(p *Without_column_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_without_column_list
}

func (*Without_column_listContext) IsWithout_column_listContext() {}

func NewWithout_column_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Without_column_listContext {
	var p = new(Without_column_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_without_column_list

	return p
}

func (s *Without_column_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Without_column_listContext) AllWithout_column_name() []IWithout_column_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWithout_column_nameContext); ok {
			len++
		}
	}

	tst := make([]IWithout_column_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWithout_column_nameContext); ok {
			tst[i] = t.(IWithout_column_nameContext)
			i++
		}
	}

	return tst
}

func (s *Without_column_listContext) Without_column_name(i int) IWithout_column_nameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithout_column_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithout_column_nameContext)
}

func (s *Without_column_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Without_column_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Without_column_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Without_column_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Without_column_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterWithout_column_list(s)
	}
}

func (s *Without_column_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitWithout_column_list(s)
	}
}




func (p *YQLParser) Without_column_list() (localctx IWithout_column_listContext) {
	localctx = NewWithout_column_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, YQLParserRULE_without_column_list)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1535)
		p.Without_column_name()
	}
	p.SetState(1540)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1536)
				p.Match(YQLParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1537)
				p.Without_column_name()
			}


		}
		p.SetState(1542)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1544)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserCOMMA {
		{
			p.SetState(1543)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// INamed_exprContext is an interface to support dynamic dispatch.
type INamed_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	AS() antlr.TerminalNode
	An_id_or_type() IAn_id_or_typeContext

	// IsNamed_exprContext differentiates from other interfaces.
	IsNamed_exprContext()
}

type Named_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamed_exprContext() *Named_exprContext {
	var p = new(Named_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_named_expr
	return p
}

func InitEmptyNamed_exprContext(p *Named_exprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_named_expr
}

func (*Named_exprContext) IsNamed_exprContext() {}

func NewNamed_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Named_exprContext {
	var p = new(Named_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_named_expr

	return p
}

func (s *Named_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Named_exprContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Named_exprContext) AS() antlr.TerminalNode {
	return s.GetToken(YQLParserAS, 0)
}

func (s *Named_exprContext) An_id_or_type() IAn_id_or_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_or_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_or_typeContext)
}

func (s *Named_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Named_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Named_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterNamed_expr(s)
	}
}

func (s *Named_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitNamed_expr(s)
	}
}




func (p *YQLParser) Named_expr() (localctx INamed_exprContext) {
	localctx = NewNamed_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, YQLParserRULE_named_expr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1546)
		p.Expr()
	}
	p.SetState(1549)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserAS {
		{
			p.SetState(1547)
			p.Match(YQLParserAS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1548)
			p.An_id_or_type()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// INamed_expr_listContext is an interface to support dynamic dispatch.
type INamed_expr_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNamed_expr() []INamed_exprContext
	Named_expr(i int) INamed_exprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsNamed_expr_listContext differentiates from other interfaces.
	IsNamed_expr_listContext()
}

type Named_expr_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamed_expr_listContext() *Named_expr_listContext {
	var p = new(Named_expr_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_named_expr_list
	return p
}

func InitEmptyNamed_expr_listContext(p *Named_expr_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_named_expr_list
}

func (*Named_expr_listContext) IsNamed_expr_listContext() {}

func NewNamed_expr_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Named_expr_listContext {
	var p = new(Named_expr_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_named_expr_list

	return p
}

func (s *Named_expr_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Named_expr_listContext) AllNamed_expr() []INamed_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamed_exprContext); ok {
			len++
		}
	}

	tst := make([]INamed_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamed_exprContext); ok {
			tst[i] = t.(INamed_exprContext)
			i++
		}
	}

	return tst
}

func (s *Named_expr_listContext) Named_expr(i int) INamed_exprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_exprContext)
}

func (s *Named_expr_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Named_expr_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Named_expr_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Named_expr_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Named_expr_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterNamed_expr_list(s)
	}
}

func (s *Named_expr_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitNamed_expr_list(s)
	}
}




func (p *YQLParser) Named_expr_list() (localctx INamed_expr_listContext) {
	localctx = NewNamed_expr_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, YQLParserRULE_named_expr_list)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1551)
		p.Named_expr()
	}
	p.SetState(1556)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 96, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1552)
				p.Match(YQLParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1553)
				p.Named_expr()
			}


		}
		p.SetState(1558)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 96, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IInvoke_exprContext is an interface to support dynamic dispatch.
type IInvoke_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Invoke_expr_tail() IInvoke_expr_tailContext
	Opt_set_quantifier() IOpt_set_quantifierContext
	Named_expr_list() INamed_expr_listContext
	ASTERISK() antlr.TerminalNode
	COMMA() antlr.TerminalNode

	// IsInvoke_exprContext differentiates from other interfaces.
	IsInvoke_exprContext()
}

type Invoke_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInvoke_exprContext() *Invoke_exprContext {
	var p = new(Invoke_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_invoke_expr
	return p
}

func InitEmptyInvoke_exprContext(p *Invoke_exprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_invoke_expr
}

func (*Invoke_exprContext) IsInvoke_exprContext() {}

func NewInvoke_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Invoke_exprContext {
	var p = new(Invoke_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_invoke_expr

	return p
}

func (s *Invoke_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Invoke_exprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Invoke_exprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Invoke_exprContext) Invoke_expr_tail() IInvoke_expr_tailContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInvoke_expr_tailContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInvoke_expr_tailContext)
}

func (s *Invoke_exprContext) Opt_set_quantifier() IOpt_set_quantifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_set_quantifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_set_quantifierContext)
}

func (s *Invoke_exprContext) Named_expr_list() INamed_expr_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_expr_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_expr_listContext)
}

func (s *Invoke_exprContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(YQLParserASTERISK, 0)
}

func (s *Invoke_exprContext) COMMA() antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, 0)
}

func (s *Invoke_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Invoke_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Invoke_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterInvoke_expr(s)
	}
}

func (s *Invoke_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitInvoke_expr(s)
	}
}




func (p *YQLParser) Invoke_expr() (localctx IInvoke_exprContext) {
	localctx = NewInvoke_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, YQLParserRULE_invoke_expr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1559)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1566)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case YQLParserSTRUCT_OPEN, YQLParserPLUS, YQLParserMINUS, YQLParserTILDA, YQLParserLPAREN, YQLParserDOLLAR, YQLParserLBRACE_CURLY, YQLParserLBRACE_SQUARE, YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALL, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserANY, YQLParserARRAY, YQLParserAS, YQLParserASC, YQLParserASSUME, YQLParserASYMMETRIC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBETWEEN, YQLParserBITCAST, YQLParserBY, YQLParserCALLABLE, YQLParserCASCADE, YQLParserCASE, YQLParserCAST, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOLUMN, YQLParserCOLUMNS, YQLParserCOMMIT, YQLParserCOMPACT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCUBE, YQLParserCURRENT, YQLParserCURRENT_DATE, YQLParserCURRENT_TIME, YQLParserCURRENT_TIMESTAMP, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDICT, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDISTINCT, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserEMPTY_ACTION, YQLParserENCRYPTED, YQLParserEND, YQLParserENUM, YQLParserERASE, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCEPT, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXISTS, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFALSE, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFLOW, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFROM, YQLParserFULL, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserGROUPS, YQLParserHASH, YQLParserHAVING, YQLParserHOP, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTERSECT, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserJSON_EXISTS, YQLParserJSON_QUERY, YQLParserJSON_VALUE, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLIMIT, YQLParserLIST, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOT, YQLParserNOTNULL, YQLParserNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOPTIONAL, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserPROCESS, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserRANGE, YQLParserREDUCE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESOURCE, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserRETURN, YQLParserRETURNING, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROLLUP, YQLParserROW, YQLParserROWS, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSCHEMA, YQLParserSECONDS, YQLParserSEEK, YQLParserSELECT, YQLParserSEMI, YQLParserSET, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSTREAM, YQLParserSTRUCT, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYMMETRIC, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTAGGED, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTRUE, YQLParserTUPLE, YQLParserTYPE, YQLParserUNBOUNDED, YQLParserUNCONDITIONAL, YQLParserUNION, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVARIANT, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWHEN, YQLParserWHERE, YQLParserWINDOW, YQLParserWITH, YQLParserWITHOUT, YQLParserWRAPPER, YQLParserXOR, YQLParserSTRING_VALUE, YQLParserID_PLAIN, YQLParserID_QUOTED, YQLParserDIGITS, YQLParserINTEGER_VALUE, YQLParserREAL, YQLParserBLOB:
		{
			p.SetState(1560)
			p.Opt_set_quantifier()
		}
		{
			p.SetState(1561)
			p.Named_expr_list()
		}
		p.SetState(1563)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserCOMMA {
			{
				p.SetState(1562)
				p.Match(YQLParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}


	case YQLParserASTERISK:
		{
			p.SetState(1565)
			p.Match(YQLParserASTERISK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserRPAREN:



	default:
	}
	{
		p.SetState(1568)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1569)
		p.Invoke_expr_tail()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IInvoke_expr_tailContext is an interface to support dynamic dispatch.
type IInvoke_expr_tailContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Null_treatment() INull_treatmentContext
	Filter_clause() IFilter_clauseContext
	OVER() antlr.TerminalNode
	Window_name_or_specification() IWindow_name_or_specificationContext

	// IsInvoke_expr_tailContext differentiates from other interfaces.
	IsInvoke_expr_tailContext()
}

type Invoke_expr_tailContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInvoke_expr_tailContext() *Invoke_expr_tailContext {
	var p = new(Invoke_expr_tailContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_invoke_expr_tail
	return p
}

func InitEmptyInvoke_expr_tailContext(p *Invoke_expr_tailContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_invoke_expr_tail
}

func (*Invoke_expr_tailContext) IsInvoke_expr_tailContext() {}

func NewInvoke_expr_tailContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Invoke_expr_tailContext {
	var p = new(Invoke_expr_tailContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_invoke_expr_tail

	return p
}

func (s *Invoke_expr_tailContext) GetParser() antlr.Parser { return s.parser }

func (s *Invoke_expr_tailContext) Null_treatment() INull_treatmentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INull_treatmentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INull_treatmentContext)
}

func (s *Invoke_expr_tailContext) Filter_clause() IFilter_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilter_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilter_clauseContext)
}

func (s *Invoke_expr_tailContext) OVER() antlr.TerminalNode {
	return s.GetToken(YQLParserOVER, 0)
}

func (s *Invoke_expr_tailContext) Window_name_or_specification() IWindow_name_or_specificationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_name_or_specificationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_name_or_specificationContext)
}

func (s *Invoke_expr_tailContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Invoke_expr_tailContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Invoke_expr_tailContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterInvoke_expr_tail(s)
	}
}

func (s *Invoke_expr_tailContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitInvoke_expr_tail(s)
	}
}




func (p *YQLParser) Invoke_expr_tail() (localctx IInvoke_expr_tailContext) {
	localctx = NewInvoke_expr_tailContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, YQLParserRULE_invoke_expr_tail)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1573)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 99, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1571)
			p.Null_treatment()
		}

		} else if p.HasError() { // JIM
			goto errorExit} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 99, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(1572)
			p.Filter_clause()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(1577)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserOVER {
		{
			p.SetState(1575)
			p.Match(YQLParserOVER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1576)
			p.Window_name_or_specification()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUsing_call_exprContext is an interface to support dynamic dispatch.
type IUsing_call_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Invoke_expr() IInvoke_exprContext
	AllAn_id_or_type() []IAn_id_or_typeContext
	An_id_or_type(i int) IAn_id_or_typeContext
	NAMESPACE() antlr.TerminalNode
	An_id_expr() IAn_id_exprContext
	Bind_parameter() IBind_parameterContext
	EXTERNAL() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode

	// IsUsing_call_exprContext differentiates from other interfaces.
	IsUsing_call_exprContext()
}

type Using_call_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsing_call_exprContext() *Using_call_exprContext {
	var p = new(Using_call_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_using_call_expr
	return p
}

func InitEmptyUsing_call_exprContext(p *Using_call_exprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_using_call_expr
}

func (*Using_call_exprContext) IsUsing_call_exprContext() {}

func NewUsing_call_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Using_call_exprContext {
	var p = new(Using_call_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_using_call_expr

	return p
}

func (s *Using_call_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Using_call_exprContext) Invoke_expr() IInvoke_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInvoke_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInvoke_exprContext)
}

func (s *Using_call_exprContext) AllAn_id_or_type() []IAn_id_or_typeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAn_id_or_typeContext); ok {
			len++
		}
	}

	tst := make([]IAn_id_or_typeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAn_id_or_typeContext); ok {
			tst[i] = t.(IAn_id_or_typeContext)
			i++
		}
	}

	return tst
}

func (s *Using_call_exprContext) An_id_or_type(i int) IAn_id_or_typeContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_or_typeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_or_typeContext)
}

func (s *Using_call_exprContext) NAMESPACE() antlr.TerminalNode {
	return s.GetToken(YQLParserNAMESPACE, 0)
}

func (s *Using_call_exprContext) An_id_expr() IAn_id_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_exprContext)
}

func (s *Using_call_exprContext) Bind_parameter() IBind_parameterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *Using_call_exprContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(YQLParserEXTERNAL, 0)
}

func (s *Using_call_exprContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(YQLParserFUNCTION, 0)
}

func (s *Using_call_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Using_call_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Using_call_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterUsing_call_expr(s)
	}
}

func (s *Using_call_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitUsing_call_expr(s)
	}
}




func (p *YQLParser) Using_call_expr() (localctx IUsing_call_exprContext) {
	localctx = NewUsing_call_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, YQLParserRULE_using_call_expr)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1587)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 101, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1579)
			p.An_id_or_type()
		}
		{
			p.SetState(1580)
			p.Match(YQLParserNAMESPACE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1581)
			p.An_id_or_type()
		}


	case 2:
		{
			p.SetState(1583)
			p.An_id_expr()
		}


	case 3:
		{
			p.SetState(1584)
			p.Bind_parameter()
		}


	case 4:
		{
			p.SetState(1585)
			p.Match(YQLParserEXTERNAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1586)
			p.Match(YQLParserFUNCTION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(1589)
		p.Invoke_expr()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IKey_exprContext is an interface to support dynamic dispatch.
type IKey_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE_SQUARE() antlr.TerminalNode
	Expr() IExprContext
	RBRACE_SQUARE() antlr.TerminalNode

	// IsKey_exprContext differentiates from other interfaces.
	IsKey_exprContext()
}

type Key_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKey_exprContext() *Key_exprContext {
	var p = new(Key_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_key_expr
	return p
}

func InitEmptyKey_exprContext(p *Key_exprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_key_expr
}

func (*Key_exprContext) IsKey_exprContext() {}

func NewKey_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Key_exprContext {
	var p = new(Key_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_key_expr

	return p
}

func (s *Key_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Key_exprContext) LBRACE_SQUARE() antlr.TerminalNode {
	return s.GetToken(YQLParserLBRACE_SQUARE, 0)
}

func (s *Key_exprContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Key_exprContext) RBRACE_SQUARE() antlr.TerminalNode {
	return s.GetToken(YQLParserRBRACE_SQUARE, 0)
}

func (s *Key_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Key_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Key_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterKey_expr(s)
	}
}

func (s *Key_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitKey_expr(s)
	}
}




func (p *YQLParser) Key_expr() (localctx IKey_exprContext) {
	localctx = NewKey_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, YQLParserRULE_key_expr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1591)
		p.Match(YQLParserLBRACE_SQUARE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1592)
		p.Expr()
	}
	{
		p.SetState(1593)
		p.Match(YQLParserRBRACE_SQUARE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWhen_exprContext is an interface to support dynamic dispatch.
type IWhen_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHEN() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	THEN() antlr.TerminalNode

	// IsWhen_exprContext differentiates from other interfaces.
	IsWhen_exprContext()
}

type When_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhen_exprContext() *When_exprContext {
	var p = new(When_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_when_expr
	return p
}

func InitEmptyWhen_exprContext(p *When_exprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_when_expr
}

func (*When_exprContext) IsWhen_exprContext() {}

func NewWhen_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *When_exprContext {
	var p = new(When_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_when_expr

	return p
}

func (s *When_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *When_exprContext) WHEN() antlr.TerminalNode {
	return s.GetToken(YQLParserWHEN, 0)
}

func (s *When_exprContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *When_exprContext) Expr(i int) IExprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *When_exprContext) THEN() antlr.TerminalNode {
	return s.GetToken(YQLParserTHEN, 0)
}

func (s *When_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *When_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *When_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterWhen_expr(s)
	}
}

func (s *When_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitWhen_expr(s)
	}
}




func (p *YQLParser) When_expr() (localctx IWhen_exprContext) {
	localctx = NewWhen_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, YQLParserRULE_when_expr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1595)
		p.Match(YQLParserWHEN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1596)
		p.Expr()
	}
	{
		p.SetState(1597)
		p.Match(YQLParserTHEN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1598)
		p.Expr()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILiteral_valueContext is an interface to support dynamic dispatch.
type ILiteral_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Integer() IIntegerContext
	Real_() IRealContext
	STRING_VALUE() antlr.TerminalNode
	BLOB() antlr.TerminalNode
	NULL() antlr.TerminalNode
	CURRENT_TIME() antlr.TerminalNode
	CURRENT_DATE() antlr.TerminalNode
	CURRENT_TIMESTAMP() antlr.TerminalNode
	Bool_value() IBool_valueContext
	EMPTY_ACTION() antlr.TerminalNode

	// IsLiteral_valueContext differentiates from other interfaces.
	IsLiteral_valueContext()
}

type Literal_valueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteral_valueContext() *Literal_valueContext {
	var p = new(Literal_valueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_literal_value
	return p
}

func InitEmptyLiteral_valueContext(p *Literal_valueContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_literal_value
}

func (*Literal_valueContext) IsLiteral_valueContext() {}

func NewLiteral_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Literal_valueContext {
	var p = new(Literal_valueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_literal_value

	return p
}

func (s *Literal_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Literal_valueContext) Integer() IIntegerContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerContext)
}

func (s *Literal_valueContext) Real_() IRealContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRealContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRealContext)
}

func (s *Literal_valueContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(YQLParserSTRING_VALUE, 0)
}

func (s *Literal_valueContext) BLOB() antlr.TerminalNode {
	return s.GetToken(YQLParserBLOB, 0)
}

func (s *Literal_valueContext) NULL() antlr.TerminalNode {
	return s.GetToken(YQLParserNULL, 0)
}

func (s *Literal_valueContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(YQLParserCURRENT_TIME, 0)
}

func (s *Literal_valueContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(YQLParserCURRENT_DATE, 0)
}

func (s *Literal_valueContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(YQLParserCURRENT_TIMESTAMP, 0)
}

func (s *Literal_valueContext) Bool_value() IBool_valueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_valueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_valueContext)
}

func (s *Literal_valueContext) EMPTY_ACTION() antlr.TerminalNode {
	return s.GetToken(YQLParserEMPTY_ACTION, 0)
}

func (s *Literal_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Literal_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Literal_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterLiteral_value(s)
	}
}

func (s *Literal_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitLiteral_value(s)
	}
}




func (p *YQLParser) Literal_value() (localctx ILiteral_valueContext) {
	localctx = NewLiteral_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, YQLParserRULE_literal_value)
	p.SetState(1610)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserDIGITS, YQLParserINTEGER_VALUE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1600)
			p.Integer()
		}


	case YQLParserREAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1601)
			p.Real_()
		}


	case YQLParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1602)
			p.Match(YQLParserSTRING_VALUE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserBLOB:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1603)
			p.Match(YQLParserBLOB)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserNULL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1604)
			p.Match(YQLParserNULL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserCURRENT_TIME:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1605)
			p.Match(YQLParserCURRENT_TIME)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserCURRENT_DATE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1606)
			p.Match(YQLParserCURRENT_DATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserCURRENT_TIMESTAMP:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1607)
			p.Match(YQLParserCURRENT_TIMESTAMP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserFALSE, YQLParserTRUE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1608)
			p.Bool_value()
		}


	case YQLParserEMPTY_ACTION:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1609)
			p.Match(YQLParserEMPTY_ACTION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBind_parameterContext is an interface to support dynamic dispatch.
type IBind_parameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOLLAR() antlr.TerminalNode
	An_id_or_type() IAn_id_or_typeContext
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsBind_parameterContext differentiates from other interfaces.
	IsBind_parameterContext()
}

type Bind_parameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBind_parameterContext() *Bind_parameterContext {
	var p = new(Bind_parameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_bind_parameter
	return p
}

func InitEmptyBind_parameterContext(p *Bind_parameterContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_bind_parameter
}

func (*Bind_parameterContext) IsBind_parameterContext() {}

func NewBind_parameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bind_parameterContext {
	var p = new(Bind_parameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_bind_parameter

	return p
}

func (s *Bind_parameterContext) GetParser() antlr.Parser { return s.parser }

func (s *Bind_parameterContext) DOLLAR() antlr.TerminalNode {
	return s.GetToken(YQLParserDOLLAR, 0)
}

func (s *Bind_parameterContext) An_id_or_type() IAn_id_or_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_or_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_or_typeContext)
}

func (s *Bind_parameterContext) TRUE() antlr.TerminalNode {
	return s.GetToken(YQLParserTRUE, 0)
}

func (s *Bind_parameterContext) FALSE() antlr.TerminalNode {
	return s.GetToken(YQLParserFALSE, 0)
}

func (s *Bind_parameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bind_parameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Bind_parameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterBind_parameter(s)
	}
}

func (s *Bind_parameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitBind_parameter(s)
	}
}




func (p *YQLParser) Bind_parameter() (localctx IBind_parameterContext) {
	localctx = NewBind_parameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, YQLParserRULE_bind_parameter)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1612)
		p.Match(YQLParserDOLLAR)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1616)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALL, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserANY, YQLParserARRAY, YQLParserAS, YQLParserASC, YQLParserASSUME, YQLParserASYMMETRIC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBETWEEN, YQLParserBITCAST, YQLParserBY, YQLParserCALLABLE, YQLParserCASCADE, YQLParserCASE, YQLParserCAST, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOLUMN, YQLParserCOLUMNS, YQLParserCOMMIT, YQLParserCOMPACT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCUBE, YQLParserCURRENT, YQLParserCURRENT_DATE, YQLParserCURRENT_TIME, YQLParserCURRENT_TIMESTAMP, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDICT, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDISTINCT, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserEMPTY_ACTION, YQLParserENCRYPTED, YQLParserEND, YQLParserENUM, YQLParserERASE, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCEPT, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXISTS, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFLOW, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFROM, YQLParserFULL, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserGROUPS, YQLParserHASH, YQLParserHAVING, YQLParserHOP, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTERSECT, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserJSON_EXISTS, YQLParserJSON_QUERY, YQLParserJSON_VALUE, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLIMIT, YQLParserLIST, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOT, YQLParserNOTNULL, YQLParserNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOPTIONAL, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserPROCESS, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserRANGE, YQLParserREDUCE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESOURCE, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserRETURN, YQLParserRETURNING, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROLLUP, YQLParserROW, YQLParserROWS, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSCHEMA, YQLParserSECONDS, YQLParserSEEK, YQLParserSELECT, YQLParserSEMI, YQLParserSET, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSTREAM, YQLParserSTRUCT, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYMMETRIC, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTAGGED, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTUPLE, YQLParserTYPE, YQLParserUNBOUNDED, YQLParserUNCONDITIONAL, YQLParserUNION, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVARIANT, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWHEN, YQLParserWHERE, YQLParserWINDOW, YQLParserWITH, YQLParserWITHOUT, YQLParserWRAPPER, YQLParserXOR, YQLParserSTRING_VALUE, YQLParserID_PLAIN, YQLParserID_QUOTED:
		{
			p.SetState(1613)
			p.An_id_or_type()
		}


	case YQLParserTRUE:
		{
			p.SetState(1614)
			p.Match(YQLParserTRUE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserFALSE:
		{
			p.SetState(1615)
			p.Match(YQLParserFALSE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOpt_bind_parameterContext is an interface to support dynamic dispatch.
type IOpt_bind_parameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Bind_parameter() IBind_parameterContext
	QUESTION() antlr.TerminalNode

	// IsOpt_bind_parameterContext differentiates from other interfaces.
	IsOpt_bind_parameterContext()
}

type Opt_bind_parameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_bind_parameterContext() *Opt_bind_parameterContext {
	var p = new(Opt_bind_parameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_opt_bind_parameter
	return p
}

func InitEmptyOpt_bind_parameterContext(p *Opt_bind_parameterContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_opt_bind_parameter
}

func (*Opt_bind_parameterContext) IsOpt_bind_parameterContext() {}

func NewOpt_bind_parameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_bind_parameterContext {
	var p = new(Opt_bind_parameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_opt_bind_parameter

	return p
}

func (s *Opt_bind_parameterContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_bind_parameterContext) Bind_parameter() IBind_parameterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *Opt_bind_parameterContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(YQLParserQUESTION, 0)
}

func (s *Opt_bind_parameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_bind_parameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Opt_bind_parameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterOpt_bind_parameter(s)
	}
}

func (s *Opt_bind_parameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitOpt_bind_parameter(s)
	}
}




func (p *YQLParser) Opt_bind_parameter() (localctx IOpt_bind_parameterContext) {
	localctx = NewOpt_bind_parameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, YQLParserRULE_opt_bind_parameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1618)
		p.Bind_parameter()
	}
	p.SetState(1620)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserQUESTION {
		{
			p.SetState(1619)
			p.Match(YQLParserQUESTION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBind_parameter_listContext is an interface to support dynamic dispatch.
type IBind_parameter_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllBind_parameter() []IBind_parameterContext
	Bind_parameter(i int) IBind_parameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsBind_parameter_listContext differentiates from other interfaces.
	IsBind_parameter_listContext()
}

type Bind_parameter_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBind_parameter_listContext() *Bind_parameter_listContext {
	var p = new(Bind_parameter_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_bind_parameter_list
	return p
}

func InitEmptyBind_parameter_listContext(p *Bind_parameter_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_bind_parameter_list
}

func (*Bind_parameter_listContext) IsBind_parameter_listContext() {}

func NewBind_parameter_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bind_parameter_listContext {
	var p = new(Bind_parameter_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_bind_parameter_list

	return p
}

func (s *Bind_parameter_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Bind_parameter_listContext) AllBind_parameter() []IBind_parameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBind_parameterContext); ok {
			len++
		}
	}

	tst := make([]IBind_parameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBind_parameterContext); ok {
			tst[i] = t.(IBind_parameterContext)
			i++
		}
	}

	return tst
}

func (s *Bind_parameter_listContext) Bind_parameter(i int) IBind_parameterContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *Bind_parameter_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Bind_parameter_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Bind_parameter_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bind_parameter_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Bind_parameter_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterBind_parameter_list(s)
	}
}

func (s *Bind_parameter_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitBind_parameter_list(s)
	}
}




func (p *YQLParser) Bind_parameter_list() (localctx IBind_parameter_listContext) {
	localctx = NewBind_parameter_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, YQLParserRULE_bind_parameter_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1622)
		p.Bind_parameter()
	}
	p.SetState(1627)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(1623)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1624)
			p.Bind_parameter()
		}


		p.SetState(1629)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// INamed_bind_parameterContext is an interface to support dynamic dispatch.
type INamed_bind_parameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllBind_parameter() []IBind_parameterContext
	Bind_parameter(i int) IBind_parameterContext
	AS() antlr.TerminalNode

	// IsNamed_bind_parameterContext differentiates from other interfaces.
	IsNamed_bind_parameterContext()
}

type Named_bind_parameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamed_bind_parameterContext() *Named_bind_parameterContext {
	var p = new(Named_bind_parameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_named_bind_parameter
	return p
}

func InitEmptyNamed_bind_parameterContext(p *Named_bind_parameterContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_named_bind_parameter
}

func (*Named_bind_parameterContext) IsNamed_bind_parameterContext() {}

func NewNamed_bind_parameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Named_bind_parameterContext {
	var p = new(Named_bind_parameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_named_bind_parameter

	return p
}

func (s *Named_bind_parameterContext) GetParser() antlr.Parser { return s.parser }

func (s *Named_bind_parameterContext) AllBind_parameter() []IBind_parameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBind_parameterContext); ok {
			len++
		}
	}

	tst := make([]IBind_parameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBind_parameterContext); ok {
			tst[i] = t.(IBind_parameterContext)
			i++
		}
	}

	return tst
}

func (s *Named_bind_parameterContext) Bind_parameter(i int) IBind_parameterContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *Named_bind_parameterContext) AS() antlr.TerminalNode {
	return s.GetToken(YQLParserAS, 0)
}

func (s *Named_bind_parameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Named_bind_parameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Named_bind_parameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterNamed_bind_parameter(s)
	}
}

func (s *Named_bind_parameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitNamed_bind_parameter(s)
	}
}




func (p *YQLParser) Named_bind_parameter() (localctx INamed_bind_parameterContext) {
	localctx = NewNamed_bind_parameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, YQLParserRULE_named_bind_parameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1630)
		p.Bind_parameter()
	}
	p.SetState(1633)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserAS {
		{
			p.SetState(1631)
			p.Match(YQLParserAS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1632)
			p.Bind_parameter()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// INamed_bind_parameter_listContext is an interface to support dynamic dispatch.
type INamed_bind_parameter_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNamed_bind_parameter() []INamed_bind_parameterContext
	Named_bind_parameter(i int) INamed_bind_parameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsNamed_bind_parameter_listContext differentiates from other interfaces.
	IsNamed_bind_parameter_listContext()
}

type Named_bind_parameter_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamed_bind_parameter_listContext() *Named_bind_parameter_listContext {
	var p = new(Named_bind_parameter_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_named_bind_parameter_list
	return p
}

func InitEmptyNamed_bind_parameter_listContext(p *Named_bind_parameter_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_named_bind_parameter_list
}

func (*Named_bind_parameter_listContext) IsNamed_bind_parameter_listContext() {}

func NewNamed_bind_parameter_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Named_bind_parameter_listContext {
	var p = new(Named_bind_parameter_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_named_bind_parameter_list

	return p
}

func (s *Named_bind_parameter_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Named_bind_parameter_listContext) AllNamed_bind_parameter() []INamed_bind_parameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamed_bind_parameterContext); ok {
			len++
		}
	}

	tst := make([]INamed_bind_parameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamed_bind_parameterContext); ok {
			tst[i] = t.(INamed_bind_parameterContext)
			i++
		}
	}

	return tst
}

func (s *Named_bind_parameter_listContext) Named_bind_parameter(i int) INamed_bind_parameterContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_bind_parameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_bind_parameterContext)
}

func (s *Named_bind_parameter_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Named_bind_parameter_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Named_bind_parameter_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Named_bind_parameter_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Named_bind_parameter_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterNamed_bind_parameter_list(s)
	}
}

func (s *Named_bind_parameter_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitNamed_bind_parameter_list(s)
	}
}




func (p *YQLParser) Named_bind_parameter_list() (localctx INamed_bind_parameter_listContext) {
	localctx = NewNamed_bind_parameter_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, YQLParserRULE_named_bind_parameter_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1635)
		p.Named_bind_parameter()
	}
	p.SetState(1640)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(1636)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1637)
			p.Named_bind_parameter()
		}


		p.SetState(1642)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISigned_numberContext is an interface to support dynamic dispatch.
type ISigned_numberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Integer() IIntegerContext
	Real_() IRealContext
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode

	// IsSigned_numberContext differentiates from other interfaces.
	IsSigned_numberContext()
}

type Signed_numberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySigned_numberContext() *Signed_numberContext {
	var p = new(Signed_numberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_signed_number
	return p
}

func InitEmptySigned_numberContext(p *Signed_numberContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_signed_number
}

func (*Signed_numberContext) IsSigned_numberContext() {}

func NewSigned_numberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Signed_numberContext {
	var p = new(Signed_numberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_signed_number

	return p
}

func (s *Signed_numberContext) GetParser() antlr.Parser { return s.parser }

func (s *Signed_numberContext) Integer() IIntegerContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerContext)
}

func (s *Signed_numberContext) Real_() IRealContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRealContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRealContext)
}

func (s *Signed_numberContext) PLUS() antlr.TerminalNode {
	return s.GetToken(YQLParserPLUS, 0)
}

func (s *Signed_numberContext) MINUS() antlr.TerminalNode {
	return s.GetToken(YQLParserMINUS, 0)
}

func (s *Signed_numberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Signed_numberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Signed_numberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterSigned_number(s)
	}
}

func (s *Signed_numberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitSigned_number(s)
	}
}




func (p *YQLParser) Signed_number() (localctx ISigned_numberContext) {
	localctx = NewSigned_numberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, YQLParserRULE_signed_number)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1644)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserPLUS || _la == YQLParserMINUS {
		{
			p.SetState(1643)
			_la = p.GetTokenStream().LA(1)

			if !(_la == YQLParserPLUS || _la == YQLParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1648)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserDIGITS, YQLParserINTEGER_VALUE:
		{
			p.SetState(1646)
			p.Integer()
		}


	case YQLParserREAL:
		{
			p.SetState(1647)
			p.Real_()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IType_name_simpleContext is an interface to support dynamic dispatch.
type IType_name_simpleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id_pure() IAn_id_pureContext

	// IsType_name_simpleContext differentiates from other interfaces.
	IsType_name_simpleContext()
}

type Type_name_simpleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_simpleContext() *Type_name_simpleContext {
	var p = new(Type_name_simpleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name_simple
	return p
}

func InitEmptyType_name_simpleContext(p *Type_name_simpleContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name_simple
}

func (*Type_name_simpleContext) IsType_name_simpleContext() {}

func NewType_name_simpleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_simpleContext {
	var p = new(Type_name_simpleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_type_name_simple

	return p
}

func (s *Type_name_simpleContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_simpleContext) An_id_pure() IAn_id_pureContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_pureContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_pureContext)
}

func (s *Type_name_simpleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_simpleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Type_name_simpleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterType_name_simple(s)
	}
}

func (s *Type_name_simpleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitType_name_simple(s)
	}
}




func (p *YQLParser) Type_name_simple() (localctx IType_name_simpleContext) {
	localctx = NewType_name_simpleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, YQLParserRULE_type_name_simple)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1650)
		p.An_id_pure()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IInteger_or_bindContext is an interface to support dynamic dispatch.
type IInteger_or_bindContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Integer() IIntegerContext
	Bind_parameter() IBind_parameterContext

	// IsInteger_or_bindContext differentiates from other interfaces.
	IsInteger_or_bindContext()
}

type Integer_or_bindContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInteger_or_bindContext() *Integer_or_bindContext {
	var p = new(Integer_or_bindContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_integer_or_bind
	return p
}

func InitEmptyInteger_or_bindContext(p *Integer_or_bindContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_integer_or_bind
}

func (*Integer_or_bindContext) IsInteger_or_bindContext() {}

func NewInteger_or_bindContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Integer_or_bindContext {
	var p = new(Integer_or_bindContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_integer_or_bind

	return p
}

func (s *Integer_or_bindContext) GetParser() antlr.Parser { return s.parser }

func (s *Integer_or_bindContext) Integer() IIntegerContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerContext)
}

func (s *Integer_or_bindContext) Bind_parameter() IBind_parameterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *Integer_or_bindContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Integer_or_bindContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Integer_or_bindContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterInteger_or_bind(s)
	}
}

func (s *Integer_or_bindContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitInteger_or_bind(s)
	}
}




func (p *YQLParser) Integer_or_bind() (localctx IInteger_or_bindContext) {
	localctx = NewInteger_or_bindContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, YQLParserRULE_integer_or_bind)
	p.SetState(1654)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserDIGITS, YQLParserINTEGER_VALUE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1652)
			p.Integer()
		}


	case YQLParserDOLLAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1653)
			p.Bind_parameter()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IType_name_tagContext is an interface to support dynamic dispatch.
type IType_name_tagContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id() IIdContext
	STRING_VALUE() antlr.TerminalNode
	Bind_parameter() IBind_parameterContext

	// IsType_name_tagContext differentiates from other interfaces.
	IsType_name_tagContext()
}

type Type_name_tagContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_tagContext() *Type_name_tagContext {
	var p = new(Type_name_tagContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name_tag
	return p
}

func InitEmptyType_name_tagContext(p *Type_name_tagContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name_tag
}

func (*Type_name_tagContext) IsType_name_tagContext() {}

func NewType_name_tagContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_tagContext {
	var p = new(Type_name_tagContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_type_name_tag

	return p
}

func (s *Type_name_tagContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_tagContext) Id() IIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *Type_name_tagContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(YQLParserSTRING_VALUE, 0)
}

func (s *Type_name_tagContext) Bind_parameter() IBind_parameterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *Type_name_tagContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_tagContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Type_name_tagContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterType_name_tag(s)
	}
}

func (s *Type_name_tagContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitType_name_tag(s)
	}
}




func (p *YQLParser) Type_name_tag() (localctx IType_name_tagContext) {
	localctx = NewType_name_tagContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, YQLParserRULE_type_name_tag)
	p.SetState(1659)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALL, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserANY, YQLParserARRAY, YQLParserAS, YQLParserASC, YQLParserASSUME, YQLParserASYMMETRIC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBETWEEN, YQLParserBITCAST, YQLParserBY, YQLParserCASCADE, YQLParserCASE, YQLParserCAST, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOLUMN, YQLParserCOLUMNS, YQLParserCOMMIT, YQLParserCOMPACT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCUBE, YQLParserCURRENT, YQLParserCURRENT_DATE, YQLParserCURRENT_TIME, YQLParserCURRENT_TIMESTAMP, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDISTINCT, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserEMPTY_ACTION, YQLParserENCRYPTED, YQLParserEND, YQLParserERASE, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCEPT, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXISTS, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFROM, YQLParserFULL, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserGROUPS, YQLParserHASH, YQLParserHAVING, YQLParserHOP, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTERSECT, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserJSON_EXISTS, YQLParserJSON_QUERY, YQLParserJSON_VALUE, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLIMIT, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOT, YQLParserNOTNULL, YQLParserNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserPROCESS, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserRANGE, YQLParserREDUCE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserRETURN, YQLParserRETURNING, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROLLUP, YQLParserROW, YQLParserROWS, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSCHEMA, YQLParserSECONDS, YQLParserSEEK, YQLParserSELECT, YQLParserSEMI, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSTREAM, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYMMETRIC, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTYPE, YQLParserUNBOUNDED, YQLParserUNCONDITIONAL, YQLParserUNION, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWHEN, YQLParserWHERE, YQLParserWINDOW, YQLParserWITH, YQLParserWITHOUT, YQLParserWRAPPER, YQLParserXOR, YQLParserID_PLAIN, YQLParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1656)
			p.Id()
		}


	case YQLParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1657)
			p.Match(YQLParserSTRING_VALUE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserDOLLAR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1658)
			p.Bind_parameter()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IStruct_argContext is an interface to support dynamic dispatch.
type IStruct_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_name_tag() IType_name_tagContext
	COLON() antlr.TerminalNode
	Type_name_or_bind() IType_name_or_bindContext

	// IsStruct_argContext differentiates from other interfaces.
	IsStruct_argContext()
}

type Struct_argContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_argContext() *Struct_argContext {
	var p = new(Struct_argContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_struct_arg
	return p
}

func InitEmptyStruct_argContext(p *Struct_argContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_struct_arg
}

func (*Struct_argContext) IsStruct_argContext() {}

func NewStruct_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_argContext {
	var p = new(Struct_argContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_struct_arg

	return p
}

func (s *Struct_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_argContext) Type_name_tag() IType_name_tagContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_tagContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_tagContext)
}

func (s *Struct_argContext) COLON() antlr.TerminalNode {
	return s.GetToken(YQLParserCOLON, 0)
}

func (s *Struct_argContext) Type_name_or_bind() IType_name_or_bindContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_or_bindContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_or_bindContext)
}

func (s *Struct_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Struct_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterStruct_arg(s)
	}
}

func (s *Struct_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitStruct_arg(s)
	}
}




func (p *YQLParser) Struct_arg() (localctx IStruct_argContext) {
	localctx = NewStruct_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, YQLParserRULE_struct_arg)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1661)
		p.Type_name_tag()
	}
	{
		p.SetState(1662)
		p.Match(YQLParserCOLON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1663)
		p.Type_name_or_bind()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IStruct_arg_positionalContext is an interface to support dynamic dispatch.
type IStruct_arg_positionalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_name_tag() IType_name_tagContext
	Type_name_or_bind() IType_name_or_bindContext
	NULL() antlr.TerminalNode
	NOT() antlr.TerminalNode
	AS() antlr.TerminalNode

	// IsStruct_arg_positionalContext differentiates from other interfaces.
	IsStruct_arg_positionalContext()
}

type Struct_arg_positionalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_arg_positionalContext() *Struct_arg_positionalContext {
	var p = new(Struct_arg_positionalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_struct_arg_positional
	return p
}

func InitEmptyStruct_arg_positionalContext(p *Struct_arg_positionalContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_struct_arg_positional
}

func (*Struct_arg_positionalContext) IsStruct_arg_positionalContext() {}

func NewStruct_arg_positionalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_arg_positionalContext {
	var p = new(Struct_arg_positionalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_struct_arg_positional

	return p
}

func (s *Struct_arg_positionalContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_arg_positionalContext) Type_name_tag() IType_name_tagContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_tagContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_tagContext)
}

func (s *Struct_arg_positionalContext) Type_name_or_bind() IType_name_or_bindContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_or_bindContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_or_bindContext)
}

func (s *Struct_arg_positionalContext) NULL() antlr.TerminalNode {
	return s.GetToken(YQLParserNULL, 0)
}

func (s *Struct_arg_positionalContext) NOT() antlr.TerminalNode {
	return s.GetToken(YQLParserNOT, 0)
}

func (s *Struct_arg_positionalContext) AS() antlr.TerminalNode {
	return s.GetToken(YQLParserAS, 0)
}

func (s *Struct_arg_positionalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_arg_positionalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Struct_arg_positionalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterStruct_arg_positional(s)
	}
}

func (s *Struct_arg_positionalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitStruct_arg_positional(s)
	}
}




func (p *YQLParser) Struct_arg_positional() (localctx IStruct_arg_positionalContext) {
	localctx = NewStruct_arg_positionalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, YQLParserRULE_struct_arg_positional)
	var _la int

	p.SetState(1677)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 114, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1665)
			p.Type_name_tag()
		}
		{
			p.SetState(1666)
			p.Type_name_or_bind()
		}
		p.SetState(1671)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserNOT || _la == YQLParserNULL {
			p.SetState(1668)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == YQLParserNOT {
				{
					p.SetState(1667)
					p.Match(YQLParserNOT)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			}
			{
				p.SetState(1670)
				p.Match(YQLParserNULL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1673)
			p.Type_name_or_bind()
		}
		{
			p.SetState(1674)
			p.Match(YQLParserAS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1675)
			p.Type_name_tag()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IVariant_argContext is an interface to support dynamic dispatch.
type IVariant_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_name_or_bind() IType_name_or_bindContext
	Type_name_tag() IType_name_tagContext
	COLON() antlr.TerminalNode

	// IsVariant_argContext differentiates from other interfaces.
	IsVariant_argContext()
}

type Variant_argContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariant_argContext() *Variant_argContext {
	var p = new(Variant_argContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_variant_arg
	return p
}

func InitEmptyVariant_argContext(p *Variant_argContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_variant_arg
}

func (*Variant_argContext) IsVariant_argContext() {}

func NewVariant_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variant_argContext {
	var p = new(Variant_argContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_variant_arg

	return p
}

func (s *Variant_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Variant_argContext) Type_name_or_bind() IType_name_or_bindContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_or_bindContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_or_bindContext)
}

func (s *Variant_argContext) Type_name_tag() IType_name_tagContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_tagContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_tagContext)
}

func (s *Variant_argContext) COLON() antlr.TerminalNode {
	return s.GetToken(YQLParserCOLON, 0)
}

func (s *Variant_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variant_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Variant_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterVariant_arg(s)
	}
}

func (s *Variant_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitVariant_arg(s)
	}
}




func (p *YQLParser) Variant_arg() (localctx IVariant_argContext) {
	localctx = NewVariant_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, YQLParserRULE_variant_arg)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1682)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 115, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1679)
			p.Type_name_tag()
		}
		{
			p.SetState(1680)
			p.Match(YQLParserCOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(1684)
		p.Type_name_or_bind()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICallable_argContext is an interface to support dynamic dispatch.
type ICallable_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Variant_arg() IVariant_argContext
	LBRACE_CURLY() antlr.TerminalNode
	AUTOMAP() antlr.TerminalNode
	RBRACE_CURLY() antlr.TerminalNode

	// IsCallable_argContext differentiates from other interfaces.
	IsCallable_argContext()
}

type Callable_argContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallable_argContext() *Callable_argContext {
	var p = new(Callable_argContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_callable_arg
	return p
}

func InitEmptyCallable_argContext(p *Callable_argContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_callable_arg
}

func (*Callable_argContext) IsCallable_argContext() {}

func NewCallable_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Callable_argContext {
	var p = new(Callable_argContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_callable_arg

	return p
}

func (s *Callable_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Callable_argContext) Variant_arg() IVariant_argContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariant_argContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariant_argContext)
}

func (s *Callable_argContext) LBRACE_CURLY() antlr.TerminalNode {
	return s.GetToken(YQLParserLBRACE_CURLY, 0)
}

func (s *Callable_argContext) AUTOMAP() antlr.TerminalNode {
	return s.GetToken(YQLParserAUTOMAP, 0)
}

func (s *Callable_argContext) RBRACE_CURLY() antlr.TerminalNode {
	return s.GetToken(YQLParserRBRACE_CURLY, 0)
}

func (s *Callable_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Callable_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Callable_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterCallable_arg(s)
	}
}

func (s *Callable_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitCallable_arg(s)
	}
}




func (p *YQLParser) Callable_arg() (localctx ICallable_argContext) {
	localctx = NewCallable_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, YQLParserRULE_callable_arg)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1686)
		p.Variant_arg()
	}
	p.SetState(1690)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserLBRACE_CURLY {
		{
			p.SetState(1687)
			p.Match(YQLParserLBRACE_CURLY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1688)
			p.Match(YQLParserAUTOMAP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1689)
			p.Match(YQLParserRBRACE_CURLY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICallable_arg_listContext is an interface to support dynamic dispatch.
type ICallable_arg_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCallable_arg() []ICallable_argContext
	Callable_arg(i int) ICallable_argContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCallable_arg_listContext differentiates from other interfaces.
	IsCallable_arg_listContext()
}

type Callable_arg_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallable_arg_listContext() *Callable_arg_listContext {
	var p = new(Callable_arg_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_callable_arg_list
	return p
}

func InitEmptyCallable_arg_listContext(p *Callable_arg_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_callable_arg_list
}

func (*Callable_arg_listContext) IsCallable_arg_listContext() {}

func NewCallable_arg_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Callable_arg_listContext {
	var p = new(Callable_arg_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_callable_arg_list

	return p
}

func (s *Callable_arg_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Callable_arg_listContext) AllCallable_arg() []ICallable_argContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICallable_argContext); ok {
			len++
		}
	}

	tst := make([]ICallable_argContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICallable_argContext); ok {
			tst[i] = t.(ICallable_argContext)
			i++
		}
	}

	return tst
}

func (s *Callable_arg_listContext) Callable_arg(i int) ICallable_argContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallable_argContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallable_argContext)
}

func (s *Callable_arg_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Callable_arg_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Callable_arg_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Callable_arg_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Callable_arg_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterCallable_arg_list(s)
	}
}

func (s *Callable_arg_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitCallable_arg_list(s)
	}
}




func (p *YQLParser) Callable_arg_list() (localctx ICallable_arg_listContext) {
	localctx = NewCallable_arg_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, YQLParserRULE_callable_arg_list)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1692)
		p.Callable_arg()
	}
	p.SetState(1697)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 117, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1693)
				p.Match(YQLParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1694)
				p.Callable_arg()
			}


		}
		p.SetState(1699)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 117, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IType_name_decimalContext is an interface to support dynamic dispatch.
type IType_name_decimalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECIMAL() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllInteger_or_bind() []IInteger_or_bindContext
	Integer_or_bind(i int) IInteger_or_bindContext
	COMMA() antlr.TerminalNode
	RPAREN() antlr.TerminalNode

	// IsType_name_decimalContext differentiates from other interfaces.
	IsType_name_decimalContext()
}

type Type_name_decimalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_decimalContext() *Type_name_decimalContext {
	var p = new(Type_name_decimalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name_decimal
	return p
}

func InitEmptyType_name_decimalContext(p *Type_name_decimalContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name_decimal
}

func (*Type_name_decimalContext) IsType_name_decimalContext() {}

func NewType_name_decimalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_decimalContext {
	var p = new(Type_name_decimalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_type_name_decimal

	return p
}

func (s *Type_name_decimalContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_decimalContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(YQLParserDECIMAL, 0)
}

func (s *Type_name_decimalContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Type_name_decimalContext) AllInteger_or_bind() []IInteger_or_bindContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInteger_or_bindContext); ok {
			len++
		}
	}

	tst := make([]IInteger_or_bindContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInteger_or_bindContext); ok {
			tst[i] = t.(IInteger_or_bindContext)
			i++
		}
	}

	return tst
}

func (s *Type_name_decimalContext) Integer_or_bind(i int) IInteger_or_bindContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInteger_or_bindContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInteger_or_bindContext)
}

func (s *Type_name_decimalContext) COMMA() antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, 0)
}

func (s *Type_name_decimalContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Type_name_decimalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_decimalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Type_name_decimalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterType_name_decimal(s)
	}
}

func (s *Type_name_decimalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitType_name_decimal(s)
	}
}




func (p *YQLParser) Type_name_decimal() (localctx IType_name_decimalContext) {
	localctx = NewType_name_decimalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, YQLParserRULE_type_name_decimal)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1700)
		p.Match(YQLParserDECIMAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1701)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1702)
		p.Integer_or_bind()
	}
	{
		p.SetState(1703)
		p.Match(YQLParserCOMMA)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1704)
		p.Integer_or_bind()
	}
	{
		p.SetState(1705)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IType_name_optionalContext is an interface to support dynamic dispatch.
type IType_name_optionalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPTIONAL() antlr.TerminalNode
	LESS() antlr.TerminalNode
	Type_name_or_bind() IType_name_or_bindContext
	GREATER() antlr.TerminalNode

	// IsType_name_optionalContext differentiates from other interfaces.
	IsType_name_optionalContext()
}

type Type_name_optionalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_optionalContext() *Type_name_optionalContext {
	var p = new(Type_name_optionalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name_optional
	return p
}

func InitEmptyType_name_optionalContext(p *Type_name_optionalContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name_optional
}

func (*Type_name_optionalContext) IsType_name_optionalContext() {}

func NewType_name_optionalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_optionalContext {
	var p = new(Type_name_optionalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_type_name_optional

	return p
}

func (s *Type_name_optionalContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_optionalContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(YQLParserOPTIONAL, 0)
}

func (s *Type_name_optionalContext) LESS() antlr.TerminalNode {
	return s.GetToken(YQLParserLESS, 0)
}

func (s *Type_name_optionalContext) Type_name_or_bind() IType_name_or_bindContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_or_bindContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_or_bindContext)
}

func (s *Type_name_optionalContext) GREATER() antlr.TerminalNode {
	return s.GetToken(YQLParserGREATER, 0)
}

func (s *Type_name_optionalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_optionalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Type_name_optionalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterType_name_optional(s)
	}
}

func (s *Type_name_optionalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitType_name_optional(s)
	}
}




func (p *YQLParser) Type_name_optional() (localctx IType_name_optionalContext) {
	localctx = NewType_name_optionalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, YQLParserRULE_type_name_optional)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1707)
		p.Match(YQLParserOPTIONAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1708)
		p.Match(YQLParserLESS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1709)
		p.Type_name_or_bind()
	}
	{
		p.SetState(1710)
		p.Match(YQLParserGREATER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IType_name_tupleContext is an interface to support dynamic dispatch.
type IType_name_tupleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TUPLE() antlr.TerminalNode
	LESS() antlr.TerminalNode
	GREATER() antlr.TerminalNode
	NOT_EQUALS2() antlr.TerminalNode
	AllType_name_or_bind() []IType_name_or_bindContext
	Type_name_or_bind(i int) IType_name_or_bindContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsType_name_tupleContext differentiates from other interfaces.
	IsType_name_tupleContext()
}

type Type_name_tupleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_tupleContext() *Type_name_tupleContext {
	var p = new(Type_name_tupleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name_tuple
	return p
}

func InitEmptyType_name_tupleContext(p *Type_name_tupleContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name_tuple
}

func (*Type_name_tupleContext) IsType_name_tupleContext() {}

func NewType_name_tupleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_tupleContext {
	var p = new(Type_name_tupleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_type_name_tuple

	return p
}

func (s *Type_name_tupleContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_tupleContext) TUPLE() antlr.TerminalNode {
	return s.GetToken(YQLParserTUPLE, 0)
}

func (s *Type_name_tupleContext) LESS() antlr.TerminalNode {
	return s.GetToken(YQLParserLESS, 0)
}

func (s *Type_name_tupleContext) GREATER() antlr.TerminalNode {
	return s.GetToken(YQLParserGREATER, 0)
}

func (s *Type_name_tupleContext) NOT_EQUALS2() antlr.TerminalNode {
	return s.GetToken(YQLParserNOT_EQUALS2, 0)
}

func (s *Type_name_tupleContext) AllType_name_or_bind() []IType_name_or_bindContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IType_name_or_bindContext); ok {
			len++
		}
	}

	tst := make([]IType_name_or_bindContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IType_name_or_bindContext); ok {
			tst[i] = t.(IType_name_or_bindContext)
			i++
		}
	}

	return tst
}

func (s *Type_name_tupleContext) Type_name_or_bind(i int) IType_name_or_bindContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_or_bindContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_or_bindContext)
}

func (s *Type_name_tupleContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Type_name_tupleContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Type_name_tupleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_tupleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Type_name_tupleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterType_name_tuple(s)
	}
}

func (s *Type_name_tupleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitType_name_tuple(s)
	}
}




func (p *YQLParser) Type_name_tuple() (localctx IType_name_tupleContext) {
	localctx = NewType_name_tupleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, YQLParserRULE_type_name_tuple)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1712)
		p.Match(YQLParserTUPLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1729)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserLESS:
		{
			p.SetState(1713)
			p.Match(YQLParserLESS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1725)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserDOLLAR || ((int64((_la - 67)) & ^0x3f) == 0 && ((int64(1) << (_la - 67)) & 1126037480013825) != 0) || _la == YQLParserFLOW || _la == YQLParserLIST || ((int64((_la - 210)) & ^0x3f) == 0 && ((int64(1) << (_la - 210)) & 1152921642045800449) != 0) || ((int64((_la - 277)) & ^0x3f) == 0 && ((int64(1) << (_la - 277)) & 985299861639171) != 0) {
			{
				p.SetState(1714)
				p.Type_name_or_bind()
			}
			p.SetState(1719)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 118, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(1715)
						p.Match(YQLParserCOMMA)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}
					{
						p.SetState(1716)
						p.Type_name_or_bind()
					}


				}
				p.SetState(1721)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
			    	goto errorExit
			    }
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 118, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			p.SetState(1723)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == YQLParserCOMMA {
				{
					p.SetState(1722)
					p.Match(YQLParserCOMMA)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			}

		}
		{
			p.SetState(1727)
			p.Match(YQLParserGREATER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserNOT_EQUALS2:
		{
			p.SetState(1728)
			p.Match(YQLParserNOT_EQUALS2)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IType_name_structContext is an interface to support dynamic dispatch.
type IType_name_structContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRUCT() antlr.TerminalNode
	LESS() antlr.TerminalNode
	GREATER() antlr.TerminalNode
	NOT_EQUALS2() antlr.TerminalNode
	AllStruct_arg() []IStruct_argContext
	Struct_arg(i int) IStruct_argContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsType_name_structContext differentiates from other interfaces.
	IsType_name_structContext()
}

type Type_name_structContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_structContext() *Type_name_structContext {
	var p = new(Type_name_structContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name_struct
	return p
}

func InitEmptyType_name_structContext(p *Type_name_structContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name_struct
}

func (*Type_name_structContext) IsType_name_structContext() {}

func NewType_name_structContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_structContext {
	var p = new(Type_name_structContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_type_name_struct

	return p
}

func (s *Type_name_structContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_structContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(YQLParserSTRUCT, 0)
}

func (s *Type_name_structContext) LESS() antlr.TerminalNode {
	return s.GetToken(YQLParserLESS, 0)
}

func (s *Type_name_structContext) GREATER() antlr.TerminalNode {
	return s.GetToken(YQLParserGREATER, 0)
}

func (s *Type_name_structContext) NOT_EQUALS2() antlr.TerminalNode {
	return s.GetToken(YQLParserNOT_EQUALS2, 0)
}

func (s *Type_name_structContext) AllStruct_arg() []IStruct_argContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStruct_argContext); ok {
			len++
		}
	}

	tst := make([]IStruct_argContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStruct_argContext); ok {
			tst[i] = t.(IStruct_argContext)
			i++
		}
	}

	return tst
}

func (s *Type_name_structContext) Struct_arg(i int) IStruct_argContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStruct_argContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStruct_argContext)
}

func (s *Type_name_structContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Type_name_structContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Type_name_structContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_structContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Type_name_structContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterType_name_struct(s)
	}
}

func (s *Type_name_structContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitType_name_struct(s)
	}
}




func (p *YQLParser) Type_name_struct() (localctx IType_name_structContext) {
	localctx = NewType_name_structContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, YQLParserRULE_type_name_struct)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1731)
		p.Match(YQLParserSTRUCT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1748)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserLESS:
		{
			p.SetState(1732)
			p.Match(YQLParserLESS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1744)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64((_la - 30)) & ^0x3f) == 0 && ((int64(1) << (_la - 30)) & -137707389183) != 0) || ((int64((_la - 94)) & ^0x3f) == 0 && ((int64(1) << (_la - 94)) & -4535493854209) != 0) || ((int64((_la - 158)) & ^0x3f) == 0 && ((int64(1) << (_la - 158)) & -4503599644147713) != 0) || ((int64((_la - 222)) & ^0x3f) == 0 && ((int64(1) << (_la - 222)) & -72339069050290177) != 0) || ((int64((_la - 286)) & ^0x3f) == 0 && ((int64(1) << (_la - 286)) & 2198754807799) != 0) {
			{
				p.SetState(1733)
				p.Struct_arg()
			}
			p.SetState(1738)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 122, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(1734)
						p.Match(YQLParserCOMMA)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}
					{
						p.SetState(1735)
						p.Struct_arg()
					}


				}
				p.SetState(1740)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
			    	goto errorExit
			    }
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 122, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			p.SetState(1742)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == YQLParserCOMMA {
				{
					p.SetState(1741)
					p.Match(YQLParserCOMMA)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			}

		}
		{
			p.SetState(1746)
			p.Match(YQLParserGREATER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserNOT_EQUALS2:
		{
			p.SetState(1747)
			p.Match(YQLParserNOT_EQUALS2)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IType_name_variantContext is an interface to support dynamic dispatch.
type IType_name_variantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VARIANT() antlr.TerminalNode
	LESS() antlr.TerminalNode
	AllVariant_arg() []IVariant_argContext
	Variant_arg(i int) IVariant_argContext
	GREATER() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsType_name_variantContext differentiates from other interfaces.
	IsType_name_variantContext()
}

type Type_name_variantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_variantContext() *Type_name_variantContext {
	var p = new(Type_name_variantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name_variant
	return p
}

func InitEmptyType_name_variantContext(p *Type_name_variantContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name_variant
}

func (*Type_name_variantContext) IsType_name_variantContext() {}

func NewType_name_variantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_variantContext {
	var p = new(Type_name_variantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_type_name_variant

	return p
}

func (s *Type_name_variantContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_variantContext) VARIANT() antlr.TerminalNode {
	return s.GetToken(YQLParserVARIANT, 0)
}

func (s *Type_name_variantContext) LESS() antlr.TerminalNode {
	return s.GetToken(YQLParserLESS, 0)
}

func (s *Type_name_variantContext) AllVariant_arg() []IVariant_argContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariant_argContext); ok {
			len++
		}
	}

	tst := make([]IVariant_argContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariant_argContext); ok {
			tst[i] = t.(IVariant_argContext)
			i++
		}
	}

	return tst
}

func (s *Type_name_variantContext) Variant_arg(i int) IVariant_argContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariant_argContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariant_argContext)
}

func (s *Type_name_variantContext) GREATER() antlr.TerminalNode {
	return s.GetToken(YQLParserGREATER, 0)
}

func (s *Type_name_variantContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Type_name_variantContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Type_name_variantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_variantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Type_name_variantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterType_name_variant(s)
	}
}

func (s *Type_name_variantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitType_name_variant(s)
	}
}




func (p *YQLParser) Type_name_variant() (localctx IType_name_variantContext) {
	localctx = NewType_name_variantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, YQLParserRULE_type_name_variant)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1750)
		p.Match(YQLParserVARIANT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1751)
		p.Match(YQLParserLESS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1752)
		p.Variant_arg()
	}
	p.SetState(1757)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1753)
				p.Match(YQLParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1754)
				p.Variant_arg()
			}


		}
		p.SetState(1759)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1761)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserCOMMA {
		{
			p.SetState(1760)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(1763)
		p.Match(YQLParserGREATER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IType_name_listContext is an interface to support dynamic dispatch.
type IType_name_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIST() antlr.TerminalNode
	LESS() antlr.TerminalNode
	Type_name_or_bind() IType_name_or_bindContext
	GREATER() antlr.TerminalNode

	// IsType_name_listContext differentiates from other interfaces.
	IsType_name_listContext()
}

type Type_name_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_listContext() *Type_name_listContext {
	var p = new(Type_name_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name_list
	return p
}

func InitEmptyType_name_listContext(p *Type_name_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name_list
}

func (*Type_name_listContext) IsType_name_listContext() {}

func NewType_name_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_listContext {
	var p = new(Type_name_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_type_name_list

	return p
}

func (s *Type_name_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_listContext) LIST() antlr.TerminalNode {
	return s.GetToken(YQLParserLIST, 0)
}

func (s *Type_name_listContext) LESS() antlr.TerminalNode {
	return s.GetToken(YQLParserLESS, 0)
}

func (s *Type_name_listContext) Type_name_or_bind() IType_name_or_bindContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_or_bindContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_or_bindContext)
}

func (s *Type_name_listContext) GREATER() antlr.TerminalNode {
	return s.GetToken(YQLParserGREATER, 0)
}

func (s *Type_name_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Type_name_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterType_name_list(s)
	}
}

func (s *Type_name_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitType_name_list(s)
	}
}




func (p *YQLParser) Type_name_list() (localctx IType_name_listContext) {
	localctx = NewType_name_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, YQLParserRULE_type_name_list)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1765)
		p.Match(YQLParserLIST)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1766)
		p.Match(YQLParserLESS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1767)
		p.Type_name_or_bind()
	}
	{
		p.SetState(1768)
		p.Match(YQLParserGREATER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IType_name_streamContext is an interface to support dynamic dispatch.
type IType_name_streamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STREAM() antlr.TerminalNode
	LESS() antlr.TerminalNode
	Type_name_or_bind() IType_name_or_bindContext
	GREATER() antlr.TerminalNode

	// IsType_name_streamContext differentiates from other interfaces.
	IsType_name_streamContext()
}

type Type_name_streamContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_streamContext() *Type_name_streamContext {
	var p = new(Type_name_streamContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name_stream
	return p
}

func InitEmptyType_name_streamContext(p *Type_name_streamContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name_stream
}

func (*Type_name_streamContext) IsType_name_streamContext() {}

func NewType_name_streamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_streamContext {
	var p = new(Type_name_streamContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_type_name_stream

	return p
}

func (s *Type_name_streamContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_streamContext) STREAM() antlr.TerminalNode {
	return s.GetToken(YQLParserSTREAM, 0)
}

func (s *Type_name_streamContext) LESS() antlr.TerminalNode {
	return s.GetToken(YQLParserLESS, 0)
}

func (s *Type_name_streamContext) Type_name_or_bind() IType_name_or_bindContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_or_bindContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_or_bindContext)
}

func (s *Type_name_streamContext) GREATER() antlr.TerminalNode {
	return s.GetToken(YQLParserGREATER, 0)
}

func (s *Type_name_streamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_streamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Type_name_streamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterType_name_stream(s)
	}
}

func (s *Type_name_streamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitType_name_stream(s)
	}
}




func (p *YQLParser) Type_name_stream() (localctx IType_name_streamContext) {
	localctx = NewType_name_streamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, YQLParserRULE_type_name_stream)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1770)
		p.Match(YQLParserSTREAM)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1771)
		p.Match(YQLParserLESS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1772)
		p.Type_name_or_bind()
	}
	{
		p.SetState(1773)
		p.Match(YQLParserGREATER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IType_name_flowContext is an interface to support dynamic dispatch.
type IType_name_flowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FLOW() antlr.TerminalNode
	LESS() antlr.TerminalNode
	Type_name_or_bind() IType_name_or_bindContext
	GREATER() antlr.TerminalNode

	// IsType_name_flowContext differentiates from other interfaces.
	IsType_name_flowContext()
}

type Type_name_flowContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_flowContext() *Type_name_flowContext {
	var p = new(Type_name_flowContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name_flow
	return p
}

func InitEmptyType_name_flowContext(p *Type_name_flowContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name_flow
}

func (*Type_name_flowContext) IsType_name_flowContext() {}

func NewType_name_flowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_flowContext {
	var p = new(Type_name_flowContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_type_name_flow

	return p
}

func (s *Type_name_flowContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_flowContext) FLOW() antlr.TerminalNode {
	return s.GetToken(YQLParserFLOW, 0)
}

func (s *Type_name_flowContext) LESS() antlr.TerminalNode {
	return s.GetToken(YQLParserLESS, 0)
}

func (s *Type_name_flowContext) Type_name_or_bind() IType_name_or_bindContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_or_bindContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_or_bindContext)
}

func (s *Type_name_flowContext) GREATER() antlr.TerminalNode {
	return s.GetToken(YQLParserGREATER, 0)
}

func (s *Type_name_flowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_flowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Type_name_flowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterType_name_flow(s)
	}
}

func (s *Type_name_flowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitType_name_flow(s)
	}
}




func (p *YQLParser) Type_name_flow() (localctx IType_name_flowContext) {
	localctx = NewType_name_flowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, YQLParserRULE_type_name_flow)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1775)
		p.Match(YQLParserFLOW)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1776)
		p.Match(YQLParserLESS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1777)
		p.Type_name_or_bind()
	}
	{
		p.SetState(1778)
		p.Match(YQLParserGREATER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IType_name_dictContext is an interface to support dynamic dispatch.
type IType_name_dictContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DICT() antlr.TerminalNode
	LESS() antlr.TerminalNode
	AllType_name_or_bind() []IType_name_or_bindContext
	Type_name_or_bind(i int) IType_name_or_bindContext
	COMMA() antlr.TerminalNode
	GREATER() antlr.TerminalNode

	// IsType_name_dictContext differentiates from other interfaces.
	IsType_name_dictContext()
}

type Type_name_dictContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_dictContext() *Type_name_dictContext {
	var p = new(Type_name_dictContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name_dict
	return p
}

func InitEmptyType_name_dictContext(p *Type_name_dictContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name_dict
}

func (*Type_name_dictContext) IsType_name_dictContext() {}

func NewType_name_dictContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_dictContext {
	var p = new(Type_name_dictContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_type_name_dict

	return p
}

func (s *Type_name_dictContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_dictContext) DICT() antlr.TerminalNode {
	return s.GetToken(YQLParserDICT, 0)
}

func (s *Type_name_dictContext) LESS() antlr.TerminalNode {
	return s.GetToken(YQLParserLESS, 0)
}

func (s *Type_name_dictContext) AllType_name_or_bind() []IType_name_or_bindContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IType_name_or_bindContext); ok {
			len++
		}
	}

	tst := make([]IType_name_or_bindContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IType_name_or_bindContext); ok {
			tst[i] = t.(IType_name_or_bindContext)
			i++
		}
	}

	return tst
}

func (s *Type_name_dictContext) Type_name_or_bind(i int) IType_name_or_bindContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_or_bindContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_or_bindContext)
}

func (s *Type_name_dictContext) COMMA() antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, 0)
}

func (s *Type_name_dictContext) GREATER() antlr.TerminalNode {
	return s.GetToken(YQLParserGREATER, 0)
}

func (s *Type_name_dictContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_dictContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Type_name_dictContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterType_name_dict(s)
	}
}

func (s *Type_name_dictContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitType_name_dict(s)
	}
}




func (p *YQLParser) Type_name_dict() (localctx IType_name_dictContext) {
	localctx = NewType_name_dictContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, YQLParserRULE_type_name_dict)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1780)
		p.Match(YQLParserDICT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1781)
		p.Match(YQLParserLESS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1782)
		p.Type_name_or_bind()
	}
	{
		p.SetState(1783)
		p.Match(YQLParserCOMMA)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1784)
		p.Type_name_or_bind()
	}
	{
		p.SetState(1785)
		p.Match(YQLParserGREATER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IType_name_setContext is an interface to support dynamic dispatch.
type IType_name_setContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	LESS() antlr.TerminalNode
	Type_name_or_bind() IType_name_or_bindContext
	GREATER() antlr.TerminalNode

	// IsType_name_setContext differentiates from other interfaces.
	IsType_name_setContext()
}

type Type_name_setContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_setContext() *Type_name_setContext {
	var p = new(Type_name_setContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name_set
	return p
}

func InitEmptyType_name_setContext(p *Type_name_setContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name_set
}

func (*Type_name_setContext) IsType_name_setContext() {}

func NewType_name_setContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_setContext {
	var p = new(Type_name_setContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_type_name_set

	return p
}

func (s *Type_name_setContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_setContext) SET() antlr.TerminalNode {
	return s.GetToken(YQLParserSET, 0)
}

func (s *Type_name_setContext) LESS() antlr.TerminalNode {
	return s.GetToken(YQLParserLESS, 0)
}

func (s *Type_name_setContext) Type_name_or_bind() IType_name_or_bindContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_or_bindContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_or_bindContext)
}

func (s *Type_name_setContext) GREATER() antlr.TerminalNode {
	return s.GetToken(YQLParserGREATER, 0)
}

func (s *Type_name_setContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_setContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Type_name_setContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterType_name_set(s)
	}
}

func (s *Type_name_setContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitType_name_set(s)
	}
}




func (p *YQLParser) Type_name_set() (localctx IType_name_setContext) {
	localctx = NewType_name_setContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, YQLParserRULE_type_name_set)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1787)
		p.Match(YQLParserSET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1788)
		p.Match(YQLParserLESS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1789)
		p.Type_name_or_bind()
	}
	{
		p.SetState(1790)
		p.Match(YQLParserGREATER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IType_name_enumContext is an interface to support dynamic dispatch.
type IType_name_enumContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENUM() antlr.TerminalNode
	LESS() antlr.TerminalNode
	AllType_name_tag() []IType_name_tagContext
	Type_name_tag(i int) IType_name_tagContext
	GREATER() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsType_name_enumContext differentiates from other interfaces.
	IsType_name_enumContext()
}

type Type_name_enumContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_enumContext() *Type_name_enumContext {
	var p = new(Type_name_enumContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name_enum
	return p
}

func InitEmptyType_name_enumContext(p *Type_name_enumContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name_enum
}

func (*Type_name_enumContext) IsType_name_enumContext() {}

func NewType_name_enumContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_enumContext {
	var p = new(Type_name_enumContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_type_name_enum

	return p
}

func (s *Type_name_enumContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_enumContext) ENUM() antlr.TerminalNode {
	return s.GetToken(YQLParserENUM, 0)
}

func (s *Type_name_enumContext) LESS() antlr.TerminalNode {
	return s.GetToken(YQLParserLESS, 0)
}

func (s *Type_name_enumContext) AllType_name_tag() []IType_name_tagContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IType_name_tagContext); ok {
			len++
		}
	}

	tst := make([]IType_name_tagContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IType_name_tagContext); ok {
			tst[i] = t.(IType_name_tagContext)
			i++
		}
	}

	return tst
}

func (s *Type_name_enumContext) Type_name_tag(i int) IType_name_tagContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_tagContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_tagContext)
}

func (s *Type_name_enumContext) GREATER() antlr.TerminalNode {
	return s.GetToken(YQLParserGREATER, 0)
}

func (s *Type_name_enumContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Type_name_enumContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Type_name_enumContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_enumContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Type_name_enumContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterType_name_enum(s)
	}
}

func (s *Type_name_enumContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitType_name_enum(s)
	}
}




func (p *YQLParser) Type_name_enum() (localctx IType_name_enumContext) {
	localctx = NewType_name_enumContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, YQLParserRULE_type_name_enum)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1792)
		p.Match(YQLParserENUM)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1793)
		p.Match(YQLParserLESS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1794)
		p.Type_name_tag()
	}
	p.SetState(1799)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 128, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1795)
				p.Match(YQLParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1796)
				p.Type_name_tag()
			}


		}
		p.SetState(1801)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 128, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1803)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserCOMMA {
		{
			p.SetState(1802)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(1805)
		p.Match(YQLParserGREATER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IType_name_resourceContext is an interface to support dynamic dispatch.
type IType_name_resourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESOURCE() antlr.TerminalNode
	LESS() antlr.TerminalNode
	Type_name_tag() IType_name_tagContext
	GREATER() antlr.TerminalNode

	// IsType_name_resourceContext differentiates from other interfaces.
	IsType_name_resourceContext()
}

type Type_name_resourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_resourceContext() *Type_name_resourceContext {
	var p = new(Type_name_resourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name_resource
	return p
}

func InitEmptyType_name_resourceContext(p *Type_name_resourceContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name_resource
}

func (*Type_name_resourceContext) IsType_name_resourceContext() {}

func NewType_name_resourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_resourceContext {
	var p = new(Type_name_resourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_type_name_resource

	return p
}

func (s *Type_name_resourceContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_resourceContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(YQLParserRESOURCE, 0)
}

func (s *Type_name_resourceContext) LESS() antlr.TerminalNode {
	return s.GetToken(YQLParserLESS, 0)
}

func (s *Type_name_resourceContext) Type_name_tag() IType_name_tagContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_tagContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_tagContext)
}

func (s *Type_name_resourceContext) GREATER() antlr.TerminalNode {
	return s.GetToken(YQLParserGREATER, 0)
}

func (s *Type_name_resourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_resourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Type_name_resourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterType_name_resource(s)
	}
}

func (s *Type_name_resourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitType_name_resource(s)
	}
}




func (p *YQLParser) Type_name_resource() (localctx IType_name_resourceContext) {
	localctx = NewType_name_resourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, YQLParserRULE_type_name_resource)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1807)
		p.Match(YQLParserRESOURCE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1808)
		p.Match(YQLParserLESS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1809)
		p.Type_name_tag()
	}
	{
		p.SetState(1810)
		p.Match(YQLParserGREATER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IType_name_taggedContext is an interface to support dynamic dispatch.
type IType_name_taggedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TAGGED() antlr.TerminalNode
	LESS() antlr.TerminalNode
	Type_name_or_bind() IType_name_or_bindContext
	COMMA() antlr.TerminalNode
	Type_name_tag() IType_name_tagContext
	GREATER() antlr.TerminalNode

	// IsType_name_taggedContext differentiates from other interfaces.
	IsType_name_taggedContext()
}

type Type_name_taggedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_taggedContext() *Type_name_taggedContext {
	var p = new(Type_name_taggedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name_tagged
	return p
}

func InitEmptyType_name_taggedContext(p *Type_name_taggedContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name_tagged
}

func (*Type_name_taggedContext) IsType_name_taggedContext() {}

func NewType_name_taggedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_taggedContext {
	var p = new(Type_name_taggedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_type_name_tagged

	return p
}

func (s *Type_name_taggedContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_taggedContext) TAGGED() antlr.TerminalNode {
	return s.GetToken(YQLParserTAGGED, 0)
}

func (s *Type_name_taggedContext) LESS() antlr.TerminalNode {
	return s.GetToken(YQLParserLESS, 0)
}

func (s *Type_name_taggedContext) Type_name_or_bind() IType_name_or_bindContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_or_bindContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_or_bindContext)
}

func (s *Type_name_taggedContext) COMMA() antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, 0)
}

func (s *Type_name_taggedContext) Type_name_tag() IType_name_tagContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_tagContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_tagContext)
}

func (s *Type_name_taggedContext) GREATER() antlr.TerminalNode {
	return s.GetToken(YQLParserGREATER, 0)
}

func (s *Type_name_taggedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_taggedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Type_name_taggedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterType_name_tagged(s)
	}
}

func (s *Type_name_taggedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitType_name_tagged(s)
	}
}




func (p *YQLParser) Type_name_tagged() (localctx IType_name_taggedContext) {
	localctx = NewType_name_taggedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, YQLParserRULE_type_name_tagged)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1812)
		p.Match(YQLParserTAGGED)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1813)
		p.Match(YQLParserLESS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1814)
		p.Type_name_or_bind()
	}
	{
		p.SetState(1815)
		p.Match(YQLParserCOMMA)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1816)
		p.Type_name_tag()
	}
	{
		p.SetState(1817)
		p.Match(YQLParserGREATER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IType_name_callableContext is an interface to support dynamic dispatch.
type IType_name_callableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CALLABLE() antlr.TerminalNode
	LESS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ARROW() antlr.TerminalNode
	Type_name_or_bind() IType_name_or_bindContext
	GREATER() antlr.TerminalNode
	AllCallable_arg_list() []ICallable_arg_listContext
	Callable_arg_list(i int) ICallable_arg_listContext
	COMMA() antlr.TerminalNode
	LBRACE_SQUARE() antlr.TerminalNode
	RBRACE_SQUARE() antlr.TerminalNode

	// IsType_name_callableContext differentiates from other interfaces.
	IsType_name_callableContext()
}

type Type_name_callableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_callableContext() *Type_name_callableContext {
	var p = new(Type_name_callableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name_callable
	return p
}

func InitEmptyType_name_callableContext(p *Type_name_callableContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name_callable
}

func (*Type_name_callableContext) IsType_name_callableContext() {}

func NewType_name_callableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_callableContext {
	var p = new(Type_name_callableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_type_name_callable

	return p
}

func (s *Type_name_callableContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_callableContext) CALLABLE() antlr.TerminalNode {
	return s.GetToken(YQLParserCALLABLE, 0)
}

func (s *Type_name_callableContext) LESS() antlr.TerminalNode {
	return s.GetToken(YQLParserLESS, 0)
}

func (s *Type_name_callableContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Type_name_callableContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Type_name_callableContext) ARROW() antlr.TerminalNode {
	return s.GetToken(YQLParserARROW, 0)
}

func (s *Type_name_callableContext) Type_name_or_bind() IType_name_or_bindContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_or_bindContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_or_bindContext)
}

func (s *Type_name_callableContext) GREATER() antlr.TerminalNode {
	return s.GetToken(YQLParserGREATER, 0)
}

func (s *Type_name_callableContext) AllCallable_arg_list() []ICallable_arg_listContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICallable_arg_listContext); ok {
			len++
		}
	}

	tst := make([]ICallable_arg_listContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICallable_arg_listContext); ok {
			tst[i] = t.(ICallable_arg_listContext)
			i++
		}
	}

	return tst
}

func (s *Type_name_callableContext) Callable_arg_list(i int) ICallable_arg_listContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallable_arg_listContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallable_arg_listContext)
}

func (s *Type_name_callableContext) COMMA() antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, 0)
}

func (s *Type_name_callableContext) LBRACE_SQUARE() antlr.TerminalNode {
	return s.GetToken(YQLParserLBRACE_SQUARE, 0)
}

func (s *Type_name_callableContext) RBRACE_SQUARE() antlr.TerminalNode {
	return s.GetToken(YQLParserRBRACE_SQUARE, 0)
}

func (s *Type_name_callableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_callableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Type_name_callableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterType_name_callable(s)
	}
}

func (s *Type_name_callableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitType_name_callable(s)
	}
}




func (p *YQLParser) Type_name_callable() (localctx IType_name_callableContext) {
	localctx = NewType_name_callableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, YQLParserRULE_type_name_callable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1819)
		p.Match(YQLParserCALLABLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1820)
		p.Match(YQLParserLESS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1821)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1823)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64((_la - 30)) & ^0x3f) == 0 && ((int64(1) << (_la - 30)) & -268435711) != 0) || ((int64((_la - 94)) & ^0x3f) == 0 && ((int64(1) << (_la - 94)) & -137438953473) != 0) || ((int64((_la - 158)) & ^0x3f) == 0 && ((int64(1) << (_la - 158)) & -1) != 0) || ((int64((_la - 222)) & ^0x3f) == 0 && ((int64(1) << (_la - 222)) & -2097153) != 0) || ((int64((_la - 286)) & ^0x3f) == 0 && ((int64(1) << (_la - 286)) & 2199023251455) != 0) {
		{
			p.SetState(1822)
			p.Callable_arg_list()
		}

	}
	p.SetState(1826)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserCOMMA {
		{
			p.SetState(1825)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(1832)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserLBRACE_SQUARE {
		{
			p.SetState(1828)
			p.Match(YQLParserLBRACE_SQUARE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1829)
			p.Callable_arg_list()
		}
		{
			p.SetState(1830)
			p.Match(YQLParserRBRACE_SQUARE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(1834)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1835)
		p.Match(YQLParserARROW)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1836)
		p.Type_name_or_bind()
	}
	{
		p.SetState(1837)
		p.Match(YQLParserGREATER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IType_name_compositeContext is an interface to support dynamic dispatch.
type IType_name_compositeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_name_optional() IType_name_optionalContext
	Type_name_tuple() IType_name_tupleContext
	Type_name_struct() IType_name_structContext
	Type_name_variant() IType_name_variantContext
	Type_name_list() IType_name_listContext
	Type_name_stream() IType_name_streamContext
	Type_name_flow() IType_name_flowContext
	Type_name_dict() IType_name_dictContext
	Type_name_set() IType_name_setContext
	Type_name_enum() IType_name_enumContext
	Type_name_resource() IType_name_resourceContext
	Type_name_tagged() IType_name_taggedContext
	Type_name_callable() IType_name_callableContext
	AllQUESTION() []antlr.TerminalNode
	QUESTION(i int) antlr.TerminalNode

	// IsType_name_compositeContext differentiates from other interfaces.
	IsType_name_compositeContext()
}

type Type_name_compositeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_compositeContext() *Type_name_compositeContext {
	var p = new(Type_name_compositeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name_composite
	return p
}

func InitEmptyType_name_compositeContext(p *Type_name_compositeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name_composite
}

func (*Type_name_compositeContext) IsType_name_compositeContext() {}

func NewType_name_compositeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_compositeContext {
	var p = new(Type_name_compositeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_type_name_composite

	return p
}

func (s *Type_name_compositeContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_compositeContext) Type_name_optional() IType_name_optionalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_optionalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_optionalContext)
}

func (s *Type_name_compositeContext) Type_name_tuple() IType_name_tupleContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_tupleContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_tupleContext)
}

func (s *Type_name_compositeContext) Type_name_struct() IType_name_structContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_structContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_structContext)
}

func (s *Type_name_compositeContext) Type_name_variant() IType_name_variantContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_variantContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_variantContext)
}

func (s *Type_name_compositeContext) Type_name_list() IType_name_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_listContext)
}

func (s *Type_name_compositeContext) Type_name_stream() IType_name_streamContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_streamContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_streamContext)
}

func (s *Type_name_compositeContext) Type_name_flow() IType_name_flowContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_flowContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_flowContext)
}

func (s *Type_name_compositeContext) Type_name_dict() IType_name_dictContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_dictContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_dictContext)
}

func (s *Type_name_compositeContext) Type_name_set() IType_name_setContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_setContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_setContext)
}

func (s *Type_name_compositeContext) Type_name_enum() IType_name_enumContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_enumContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_enumContext)
}

func (s *Type_name_compositeContext) Type_name_resource() IType_name_resourceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_resourceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_resourceContext)
}

func (s *Type_name_compositeContext) Type_name_tagged() IType_name_taggedContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_taggedContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_taggedContext)
}

func (s *Type_name_compositeContext) Type_name_callable() IType_name_callableContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_callableContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_callableContext)
}

func (s *Type_name_compositeContext) AllQUESTION() []antlr.TerminalNode {
	return s.GetTokens(YQLParserQUESTION)
}

func (s *Type_name_compositeContext) QUESTION(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserQUESTION, i)
}

func (s *Type_name_compositeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_compositeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Type_name_compositeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterType_name_composite(s)
	}
}

func (s *Type_name_compositeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitType_name_composite(s)
	}
}




func (p *YQLParser) Type_name_composite() (localctx IType_name_compositeContext) {
	localctx = NewType_name_compositeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, YQLParserRULE_type_name_composite)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1852)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserOPTIONAL:
		{
			p.SetState(1839)
			p.Type_name_optional()
		}


	case YQLParserTUPLE:
		{
			p.SetState(1840)
			p.Type_name_tuple()
		}


	case YQLParserSTRUCT:
		{
			p.SetState(1841)
			p.Type_name_struct()
		}


	case YQLParserVARIANT:
		{
			p.SetState(1842)
			p.Type_name_variant()
		}


	case YQLParserLIST:
		{
			p.SetState(1843)
			p.Type_name_list()
		}


	case YQLParserSTREAM:
		{
			p.SetState(1844)
			p.Type_name_stream()
		}


	case YQLParserFLOW:
		{
			p.SetState(1845)
			p.Type_name_flow()
		}


	case YQLParserDICT:
		{
			p.SetState(1846)
			p.Type_name_dict()
		}


	case YQLParserSET:
		{
			p.SetState(1847)
			p.Type_name_set()
		}


	case YQLParserENUM:
		{
			p.SetState(1848)
			p.Type_name_enum()
		}


	case YQLParserRESOURCE:
		{
			p.SetState(1849)
			p.Type_name_resource()
		}


	case YQLParserTAGGED:
		{
			p.SetState(1850)
			p.Type_name_tagged()
		}


	case YQLParserCALLABLE:
		{
			p.SetState(1851)
			p.Type_name_callable()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(1857)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserQUESTION {
		{
			p.SetState(1854)
			p.Match(YQLParserQUESTION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


		p.SetState(1859)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IType_nameContext is an interface to support dynamic dispatch.
type IType_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_name_composite() IType_name_compositeContext
	Type_name_decimal() IType_name_decimalContext
	Type_name_simple() IType_name_simpleContext
	AllQUESTION() []antlr.TerminalNode
	QUESTION(i int) antlr.TerminalNode

	// IsType_nameContext differentiates from other interfaces.
	IsType_nameContext()
}

type Type_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_nameContext() *Type_nameContext {
	var p = new(Type_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name
	return p
}

func InitEmptyType_nameContext(p *Type_nameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name
}

func (*Type_nameContext) IsType_nameContext() {}

func NewType_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_nameContext {
	var p = new(Type_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_type_name

	return p
}

func (s *Type_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_nameContext) Type_name_composite() IType_name_compositeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_compositeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_compositeContext)
}

func (s *Type_nameContext) Type_name_decimal() IType_name_decimalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_decimalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_decimalContext)
}

func (s *Type_nameContext) Type_name_simple() IType_name_simpleContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_simpleContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_simpleContext)
}

func (s *Type_nameContext) AllQUESTION() []antlr.TerminalNode {
	return s.GetTokens(YQLParserQUESTION)
}

func (s *Type_nameContext) QUESTION(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserQUESTION, i)
}

func (s *Type_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Type_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterType_name(s)
	}
}

func (s *Type_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitType_name(s)
	}
}




func (p *YQLParser) Type_name() (localctx IType_nameContext) {
	localctx = NewType_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, YQLParserRULE_type_name)
	var _la int

	p.SetState(1871)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserCALLABLE, YQLParserDICT, YQLParserENUM, YQLParserFLOW, YQLParserLIST, YQLParserOPTIONAL, YQLParserRESOURCE, YQLParserSET, YQLParserSTREAM, YQLParserSTRUCT, YQLParserTAGGED, YQLParserTUPLE, YQLParserVARIANT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1860)
			p.Type_name_composite()
		}


	case YQLParserDECIMAL, YQLParserSTRING_VALUE, YQLParserID_PLAIN, YQLParserID_QUOTED:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1863)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case YQLParserDECIMAL:
			{
				p.SetState(1861)
				p.Type_name_decimal()
			}


		case YQLParserSTRING_VALUE, YQLParserID_PLAIN, YQLParserID_QUOTED:
			{
				p.SetState(1862)
				p.Type_name_simple()
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(1868)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == YQLParserQUESTION {
			{
				p.SetState(1865)
				p.Match(YQLParserQUESTION)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


			p.SetState(1870)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IType_name_or_bindContext is an interface to support dynamic dispatch.
type IType_name_or_bindContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_name() IType_nameContext
	Bind_parameter() IBind_parameterContext

	// IsType_name_or_bindContext differentiates from other interfaces.
	IsType_name_or_bindContext()
}

type Type_name_or_bindContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_or_bindContext() *Type_name_or_bindContext {
	var p = new(Type_name_or_bindContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name_or_bind
	return p
}

func InitEmptyType_name_or_bindContext(p *Type_name_or_bindContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_name_or_bind
}

func (*Type_name_or_bindContext) IsType_name_or_bindContext() {}

func NewType_name_or_bindContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_or_bindContext {
	var p = new(Type_name_or_bindContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_type_name_or_bind

	return p
}

func (s *Type_name_or_bindContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_or_bindContext) Type_name() IType_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_nameContext)
}

func (s *Type_name_or_bindContext) Bind_parameter() IBind_parameterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *Type_name_or_bindContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_or_bindContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Type_name_or_bindContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterType_name_or_bind(s)
	}
}

func (s *Type_name_or_bindContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitType_name_or_bind(s)
	}
}




func (p *YQLParser) Type_name_or_bind() (localctx IType_name_or_bindContext) {
	localctx = NewType_name_or_bindContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, YQLParserRULE_type_name_or_bind)
	p.SetState(1875)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserCALLABLE, YQLParserDECIMAL, YQLParserDICT, YQLParserENUM, YQLParserFLOW, YQLParserLIST, YQLParserOPTIONAL, YQLParserRESOURCE, YQLParserSET, YQLParserSTREAM, YQLParserSTRUCT, YQLParserTAGGED, YQLParserTUPLE, YQLParserVARIANT, YQLParserSTRING_VALUE, YQLParserID_PLAIN, YQLParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1873)
			p.Type_name()
		}


	case YQLParserDOLLAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1874)
			p.Bind_parameter()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IValue_constructor_literalContext is an interface to support dynamic dispatch.
type IValue_constructor_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_VALUE() antlr.TerminalNode

	// IsValue_constructor_literalContext differentiates from other interfaces.
	IsValue_constructor_literalContext()
}

type Value_constructor_literalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValue_constructor_literalContext() *Value_constructor_literalContext {
	var p = new(Value_constructor_literalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_value_constructor_literal
	return p
}

func InitEmptyValue_constructor_literalContext(p *Value_constructor_literalContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_value_constructor_literal
}

func (*Value_constructor_literalContext) IsValue_constructor_literalContext() {}

func NewValue_constructor_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Value_constructor_literalContext {
	var p = new(Value_constructor_literalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_value_constructor_literal

	return p
}

func (s *Value_constructor_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Value_constructor_literalContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(YQLParserSTRING_VALUE, 0)
}

func (s *Value_constructor_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Value_constructor_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Value_constructor_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterValue_constructor_literal(s)
	}
}

func (s *Value_constructor_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitValue_constructor_literal(s)
	}
}




func (p *YQLParser) Value_constructor_literal() (localctx IValue_constructor_literalContext) {
	localctx = NewValue_constructor_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, YQLParserRULE_value_constructor_literal)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1877)
		p.Match(YQLParserSTRING_VALUE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IValue_constructorContext is an interface to support dynamic dispatch.
type IValue_constructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VARIANT() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ENUM() antlr.TerminalNode
	CALLABLE() antlr.TerminalNode

	// IsValue_constructorContext differentiates from other interfaces.
	IsValue_constructorContext()
}

type Value_constructorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValue_constructorContext() *Value_constructorContext {
	var p = new(Value_constructorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_value_constructor
	return p
}

func InitEmptyValue_constructorContext(p *Value_constructorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_value_constructor
}

func (*Value_constructorContext) IsValue_constructorContext() {}

func NewValue_constructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Value_constructorContext {
	var p = new(Value_constructorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_value_constructor

	return p
}

func (s *Value_constructorContext) GetParser() antlr.Parser { return s.parser }

func (s *Value_constructorContext) VARIANT() antlr.TerminalNode {
	return s.GetToken(YQLParserVARIANT, 0)
}

func (s *Value_constructorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Value_constructorContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Value_constructorContext) Expr(i int) IExprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Value_constructorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Value_constructorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Value_constructorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Value_constructorContext) ENUM() antlr.TerminalNode {
	return s.GetToken(YQLParserENUM, 0)
}

func (s *Value_constructorContext) CALLABLE() antlr.TerminalNode {
	return s.GetToken(YQLParserCALLABLE, 0)
}

func (s *Value_constructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Value_constructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Value_constructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterValue_constructor(s)
	}
}

func (s *Value_constructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitValue_constructor(s)
	}
}




func (p *YQLParser) Value_constructor() (localctx IValue_constructorContext) {
	localctx = NewValue_constructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, YQLParserRULE_value_constructor)
	p.SetState(1902)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserVARIANT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1879)
			p.Match(YQLParserVARIANT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1880)
			p.Match(YQLParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1881)
			p.Expr()
		}
		{
			p.SetState(1882)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1883)
			p.Expr()
		}
		{
			p.SetState(1884)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1885)
			p.Expr()
		}
		{
			p.SetState(1886)
			p.Match(YQLParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserENUM:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1888)
			p.Match(YQLParserENUM)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1889)
			p.Match(YQLParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1890)
			p.Expr()
		}
		{
			p.SetState(1891)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1892)
			p.Expr()
		}
		{
			p.SetState(1893)
			p.Match(YQLParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserCALLABLE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1895)
			p.Match(YQLParserCALLABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1896)
			p.Match(YQLParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1897)
			p.Expr()
		}
		{
			p.SetState(1898)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1899)
			p.Expr()
		}
		{
			p.SetState(1900)
			p.Match(YQLParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDeclare_stmtContext is an interface to support dynamic dispatch.
type IDeclare_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECLARE() antlr.TerminalNode
	Bind_parameter() IBind_parameterContext
	AS() antlr.TerminalNode
	Type_name() IType_nameContext
	EQUALS() antlr.TerminalNode
	Literal_value() ILiteral_valueContext

	// IsDeclare_stmtContext differentiates from other interfaces.
	IsDeclare_stmtContext()
}

type Declare_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclare_stmtContext() *Declare_stmtContext {
	var p = new(Declare_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_declare_stmt
	return p
}

func InitEmptyDeclare_stmtContext(p *Declare_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_declare_stmt
}

func (*Declare_stmtContext) IsDeclare_stmtContext() {}

func NewDeclare_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declare_stmtContext {
	var p = new(Declare_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_declare_stmt

	return p
}

func (s *Declare_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Declare_stmtContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(YQLParserDECLARE, 0)
}

func (s *Declare_stmtContext) Bind_parameter() IBind_parameterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *Declare_stmtContext) AS() antlr.TerminalNode {
	return s.GetToken(YQLParserAS, 0)
}

func (s *Declare_stmtContext) Type_name() IType_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_nameContext)
}

func (s *Declare_stmtContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(YQLParserEQUALS, 0)
}

func (s *Declare_stmtContext) Literal_value() ILiteral_valueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteral_valueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteral_valueContext)
}

func (s *Declare_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declare_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Declare_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterDeclare_stmt(s)
	}
}

func (s *Declare_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitDeclare_stmt(s)
	}
}




func (p *YQLParser) Declare_stmt() (localctx IDeclare_stmtContext) {
	localctx = NewDeclare_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, YQLParserRULE_declare_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1904)
		p.Match(YQLParserDECLARE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1905)
		p.Bind_parameter()
	}
	{
		p.SetState(1906)
		p.Match(YQLParserAS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1907)
		p.Type_name()
	}
	p.SetState(1910)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserEQUALS {
		{
			p.SetState(1908)
			p.Match(YQLParserEQUALS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1909)
			p.Literal_value()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IModule_pathContext is an interface to support dynamic dispatch.
type IModule_pathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAn_id() []IAn_idContext
	An_id(i int) IAn_idContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsModule_pathContext differentiates from other interfaces.
	IsModule_pathContext()
}

type Module_pathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_pathContext() *Module_pathContext {
	var p = new(Module_pathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_module_path
	return p
}

func InitEmptyModule_pathContext(p *Module_pathContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_module_path
}

func (*Module_pathContext) IsModule_pathContext() {}

func NewModule_pathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_pathContext {
	var p = new(Module_pathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_module_path

	return p
}

func (s *Module_pathContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_pathContext) AllAn_id() []IAn_idContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAn_idContext); ok {
			len++
		}
	}

	tst := make([]IAn_idContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAn_idContext); ok {
			tst[i] = t.(IAn_idContext)
			i++
		}
	}

	return tst
}

func (s *Module_pathContext) An_id(i int) IAn_idContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Module_pathContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(YQLParserDOT)
}

func (s *Module_pathContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserDOT, i)
}

func (s *Module_pathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_pathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Module_pathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterModule_path(s)
	}
}

func (s *Module_pathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitModule_path(s)
	}
}




func (p *YQLParser) Module_path() (localctx IModule_pathContext) {
	localctx = NewModule_pathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, YQLParserRULE_module_path)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1913)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserDOT {
		{
			p.SetState(1912)
			p.Match(YQLParserDOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(1915)
		p.An_id()
	}
	p.SetState(1920)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserDOT {
		{
			p.SetState(1916)
			p.Match(YQLParserDOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1917)
			p.An_id()
		}


		p.SetState(1922)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IImport_stmtContext is an interface to support dynamic dispatch.
type IImport_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IMPORT() antlr.TerminalNode
	Module_path() IModule_pathContext
	SYMBOLS() antlr.TerminalNode
	Named_bind_parameter_list() INamed_bind_parameter_listContext

	// IsImport_stmtContext differentiates from other interfaces.
	IsImport_stmtContext()
}

type Import_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_stmtContext() *Import_stmtContext {
	var p = new(Import_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_import_stmt
	return p
}

func InitEmptyImport_stmtContext(p *Import_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_import_stmt
}

func (*Import_stmtContext) IsImport_stmtContext() {}

func NewImport_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_stmtContext {
	var p = new(Import_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_import_stmt

	return p
}

func (s *Import_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_stmtContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(YQLParserIMPORT, 0)
}

func (s *Import_stmtContext) Module_path() IModule_pathContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModule_pathContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModule_pathContext)
}

func (s *Import_stmtContext) SYMBOLS() antlr.TerminalNode {
	return s.GetToken(YQLParserSYMBOLS, 0)
}

func (s *Import_stmtContext) Named_bind_parameter_list() INamed_bind_parameter_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_bind_parameter_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_bind_parameter_listContext)
}

func (s *Import_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Import_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterImport_stmt(s)
	}
}

func (s *Import_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitImport_stmt(s)
	}
}




func (p *YQLParser) Import_stmt() (localctx IImport_stmtContext) {
	localctx = NewImport_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, YQLParserRULE_import_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1923)
		p.Match(YQLParserIMPORT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1924)
		p.Module_path()
	}
	{
		p.SetState(1925)
		p.Match(YQLParserSYMBOLS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1926)
		p.Named_bind_parameter_list()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExport_stmtContext is an interface to support dynamic dispatch.
type IExport_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXPORT() antlr.TerminalNode
	Bind_parameter_list() IBind_parameter_listContext

	// IsExport_stmtContext differentiates from other interfaces.
	IsExport_stmtContext()
}

type Export_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExport_stmtContext() *Export_stmtContext {
	var p = new(Export_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_export_stmt
	return p
}

func InitEmptyExport_stmtContext(p *Export_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_export_stmt
}

func (*Export_stmtContext) IsExport_stmtContext() {}

func NewExport_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Export_stmtContext {
	var p = new(Export_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_export_stmt

	return p
}

func (s *Export_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Export_stmtContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(YQLParserEXPORT, 0)
}

func (s *Export_stmtContext) Bind_parameter_list() IBind_parameter_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameter_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameter_listContext)
}

func (s *Export_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Export_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Export_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterExport_stmt(s)
	}
}

func (s *Export_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitExport_stmt(s)
	}
}




func (p *YQLParser) Export_stmt() (localctx IExport_stmtContext) {
	localctx = NewExport_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, YQLParserRULE_export_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1928)
		p.Match(YQLParserEXPORT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1929)
		p.Bind_parameter_list()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICall_actionContext is an interface to support dynamic dispatch.
type ICall_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Bind_parameter() IBind_parameterContext
	EMPTY_ACTION() antlr.TerminalNode
	Expr_list() IExpr_listContext

	// IsCall_actionContext differentiates from other interfaces.
	IsCall_actionContext()
}

type Call_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCall_actionContext() *Call_actionContext {
	var p = new(Call_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_call_action
	return p
}

func InitEmptyCall_actionContext(p *Call_actionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_call_action
}

func (*Call_actionContext) IsCall_actionContext() {}

func NewCall_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Call_actionContext {
	var p = new(Call_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_call_action

	return p
}

func (s *Call_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Call_actionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Call_actionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Call_actionContext) Bind_parameter() IBind_parameterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *Call_actionContext) EMPTY_ACTION() antlr.TerminalNode {
	return s.GetToken(YQLParserEMPTY_ACTION, 0)
}

func (s *Call_actionContext) Expr_list() IExpr_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_listContext)
}

func (s *Call_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Call_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Call_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterCall_action(s)
	}
}

func (s *Call_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitCall_action(s)
	}
}




func (p *YQLParser) Call_action() (localctx ICall_actionContext) {
	localctx = NewCall_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, YQLParserRULE_call_action)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1933)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserDOLLAR:
		{
			p.SetState(1931)
			p.Bind_parameter()
		}


	case YQLParserEMPTY_ACTION:
		{
			p.SetState(1932)
			p.Match(YQLParserEMPTY_ACTION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(1935)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1937)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64((_la - 14)) & ^0x3f) == 0 && ((int64(1) << (_la - 14)) & -17592194234339) != 0) || ((int64((_la - 78)) & ^0x3f) == 0 && ((int64(1) << (_la - 78)) & -1) != 0) || ((int64((_la - 142)) & ^0x3f) == 0 && ((int64(1) << (_la - 142)) & -1) != 0) || ((int64((_la - 206)) & ^0x3f) == 0 && ((int64(1) << (_la - 206)) & -137438953473) != 0) || ((int64((_la - 270)) & ^0x3f) == 0 && ((int64(1) << (_la - 270)) & 2305843009213693951) != 0) {
		{
			p.SetState(1936)
			p.Expr_list()
		}

	}
	{
		p.SetState(1939)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IInline_actionContext is an interface to support dynamic dispatch.
type IInline_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BEGIN() antlr.TerminalNode
	Define_action_or_subquery_body() IDefine_action_or_subquery_bodyContext
	END() antlr.TerminalNode
	DO() antlr.TerminalNode

	// IsInline_actionContext differentiates from other interfaces.
	IsInline_actionContext()
}

type Inline_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInline_actionContext() *Inline_actionContext {
	var p = new(Inline_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_inline_action
	return p
}

func InitEmptyInline_actionContext(p *Inline_actionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_inline_action
}

func (*Inline_actionContext) IsInline_actionContext() {}

func NewInline_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inline_actionContext {
	var p = new(Inline_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_inline_action

	return p
}

func (s *Inline_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Inline_actionContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(YQLParserBEGIN, 0)
}

func (s *Inline_actionContext) Define_action_or_subquery_body() IDefine_action_or_subquery_bodyContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefine_action_or_subquery_bodyContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefine_action_or_subquery_bodyContext)
}

func (s *Inline_actionContext) END() antlr.TerminalNode {
	return s.GetToken(YQLParserEND, 0)
}

func (s *Inline_actionContext) DO() antlr.TerminalNode {
	return s.GetToken(YQLParserDO, 0)
}

func (s *Inline_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inline_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Inline_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterInline_action(s)
	}
}

func (s *Inline_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitInline_action(s)
	}
}




func (p *YQLParser) Inline_action() (localctx IInline_actionContext) {
	localctx = NewInline_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, YQLParserRULE_inline_action)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1941)
		p.Match(YQLParserBEGIN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1942)
		p.Define_action_or_subquery_body()
	}
	{
		p.SetState(1943)
		p.Match(YQLParserEND)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1944)
		p.Match(YQLParserDO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDo_stmtContext is an interface to support dynamic dispatch.
type IDo_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DO() antlr.TerminalNode
	Call_action() ICall_actionContext
	Inline_action() IInline_actionContext

	// IsDo_stmtContext differentiates from other interfaces.
	IsDo_stmtContext()
}

type Do_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDo_stmtContext() *Do_stmtContext {
	var p = new(Do_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_do_stmt
	return p
}

func InitEmptyDo_stmtContext(p *Do_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_do_stmt
}

func (*Do_stmtContext) IsDo_stmtContext() {}

func NewDo_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Do_stmtContext {
	var p = new(Do_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_do_stmt

	return p
}

func (s *Do_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Do_stmtContext) DO() antlr.TerminalNode {
	return s.GetToken(YQLParserDO, 0)
}

func (s *Do_stmtContext) Call_action() ICall_actionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICall_actionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICall_actionContext)
}

func (s *Do_stmtContext) Inline_action() IInline_actionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInline_actionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInline_actionContext)
}

func (s *Do_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Do_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Do_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterDo_stmt(s)
	}
}

func (s *Do_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitDo_stmt(s)
	}
}




func (p *YQLParser) Do_stmt() (localctx IDo_stmtContext) {
	localctx = NewDo_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, YQLParserRULE_do_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1946)
		p.Match(YQLParserDO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1949)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserDOLLAR, YQLParserEMPTY_ACTION:
		{
			p.SetState(1947)
			p.Call_action()
		}


	case YQLParserBEGIN:
		{
			p.SetState(1948)
			p.Inline_action()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPragma_stmtContext is an interface to support dynamic dispatch.
type IPragma_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PRAGMA() antlr.TerminalNode
	Opt_id_prefix_or_type() IOpt_id_prefix_or_typeContext
	An_id() IAn_idContext
	EQUALS() antlr.TerminalNode
	AllPragma_value() []IPragma_valueContext
	Pragma_value(i int) IPragma_valueContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPragma_stmtContext differentiates from other interfaces.
	IsPragma_stmtContext()
}

type Pragma_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPragma_stmtContext() *Pragma_stmtContext {
	var p = new(Pragma_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_pragma_stmt
	return p
}

func InitEmptyPragma_stmtContext(p *Pragma_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_pragma_stmt
}

func (*Pragma_stmtContext) IsPragma_stmtContext() {}

func NewPragma_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pragma_stmtContext {
	var p = new(Pragma_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_pragma_stmt

	return p
}

func (s *Pragma_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Pragma_stmtContext) PRAGMA() antlr.TerminalNode {
	return s.GetToken(YQLParserPRAGMA, 0)
}

func (s *Pragma_stmtContext) Opt_id_prefix_or_type() IOpt_id_prefix_or_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_id_prefix_or_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_id_prefix_or_typeContext)
}

func (s *Pragma_stmtContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Pragma_stmtContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(YQLParserEQUALS, 0)
}

func (s *Pragma_stmtContext) AllPragma_value() []IPragma_valueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPragma_valueContext); ok {
			len++
		}
	}

	tst := make([]IPragma_valueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPragma_valueContext); ok {
			tst[i] = t.(IPragma_valueContext)
			i++
		}
	}

	return tst
}

func (s *Pragma_stmtContext) Pragma_value(i int) IPragma_valueContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPragma_valueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPragma_valueContext)
}

func (s *Pragma_stmtContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Pragma_stmtContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Pragma_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Pragma_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Pragma_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pragma_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Pragma_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterPragma_stmt(s)
	}
}

func (s *Pragma_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitPragma_stmt(s)
	}
}




func (p *YQLParser) Pragma_stmt() (localctx IPragma_stmtContext) {
	localctx = NewPragma_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, YQLParserRULE_pragma_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1951)
		p.Match(YQLParserPRAGMA)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1952)
		p.Opt_id_prefix_or_type()
	}
	{
		p.SetState(1953)
		p.An_id()
	}
	p.SetState(1967)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case YQLParserEQUALS:
		{
			p.SetState(1954)
			p.Match(YQLParserEQUALS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1955)
			p.Pragma_value()
		}


	case YQLParserLPAREN:
		{
			p.SetState(1956)
			p.Match(YQLParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1957)
			p.Pragma_value()
		}
		p.SetState(1962)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == YQLParserCOMMA {
			{
				p.SetState(1958)
				p.Match(YQLParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1959)
				p.Pragma_value()
			}


			p.SetState(1964)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1965)
			p.Match(YQLParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserEOF, YQLParserSEMICOLON, YQLParserEND:



	default:
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPragma_valueContext is an interface to support dynamic dispatch.
type IPragma_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Signed_number() ISigned_numberContext
	Id() IIdContext
	STRING_VALUE() antlr.TerminalNode
	Bool_value() IBool_valueContext
	Bind_parameter() IBind_parameterContext

	// IsPragma_valueContext differentiates from other interfaces.
	IsPragma_valueContext()
}

type Pragma_valueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPragma_valueContext() *Pragma_valueContext {
	var p = new(Pragma_valueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_pragma_value
	return p
}

func InitEmptyPragma_valueContext(p *Pragma_valueContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_pragma_value
}

func (*Pragma_valueContext) IsPragma_valueContext() {}

func NewPragma_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pragma_valueContext {
	var p = new(Pragma_valueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_pragma_value

	return p
}

func (s *Pragma_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Pragma_valueContext) Signed_number() ISigned_numberContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISigned_numberContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISigned_numberContext)
}

func (s *Pragma_valueContext) Id() IIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *Pragma_valueContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(YQLParserSTRING_VALUE, 0)
}

func (s *Pragma_valueContext) Bool_value() IBool_valueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_valueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_valueContext)
}

func (s *Pragma_valueContext) Bind_parameter() IBind_parameterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *Pragma_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pragma_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Pragma_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterPragma_value(s)
	}
}

func (s *Pragma_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitPragma_value(s)
	}
}




func (p *YQLParser) Pragma_value() (localctx IPragma_valueContext) {
	localctx = NewPragma_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, YQLParserRULE_pragma_value)
	p.SetState(1974)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserPLUS, YQLParserMINUS, YQLParserDIGITS, YQLParserINTEGER_VALUE, YQLParserREAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1969)
			p.Signed_number()
		}


	case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALL, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserANY, YQLParserARRAY, YQLParserAS, YQLParserASC, YQLParserASSUME, YQLParserASYMMETRIC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBETWEEN, YQLParserBITCAST, YQLParserBY, YQLParserCASCADE, YQLParserCASE, YQLParserCAST, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOLUMN, YQLParserCOLUMNS, YQLParserCOMMIT, YQLParserCOMPACT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCUBE, YQLParserCURRENT, YQLParserCURRENT_DATE, YQLParserCURRENT_TIME, YQLParserCURRENT_TIMESTAMP, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDISTINCT, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserEMPTY_ACTION, YQLParserENCRYPTED, YQLParserEND, YQLParserERASE, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCEPT, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXISTS, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFROM, YQLParserFULL, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserGROUPS, YQLParserHASH, YQLParserHAVING, YQLParserHOP, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTERSECT, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserJSON_EXISTS, YQLParserJSON_QUERY, YQLParserJSON_VALUE, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLIMIT, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOT, YQLParserNOTNULL, YQLParserNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserPROCESS, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserRANGE, YQLParserREDUCE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserRETURN, YQLParserRETURNING, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROLLUP, YQLParserROW, YQLParserROWS, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSCHEMA, YQLParserSECONDS, YQLParserSEEK, YQLParserSELECT, YQLParserSEMI, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSTREAM, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYMMETRIC, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTYPE, YQLParserUNBOUNDED, YQLParserUNCONDITIONAL, YQLParserUNION, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWHEN, YQLParserWHERE, YQLParserWINDOW, YQLParserWITH, YQLParserWITHOUT, YQLParserWRAPPER, YQLParserXOR, YQLParserID_PLAIN, YQLParserID_QUOTED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1970)
			p.Id()
		}


	case YQLParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1971)
			p.Match(YQLParserSTRING_VALUE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserFALSE, YQLParserTRUE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1972)
			p.Bool_value()
		}


	case YQLParserDOLLAR:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1973)
			p.Bind_parameter()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISort_specificationContext is an interface to support dynamic dispatch.
type ISort_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode

	// IsSort_specificationContext differentiates from other interfaces.
	IsSort_specificationContext()
}

type Sort_specificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySort_specificationContext() *Sort_specificationContext {
	var p = new(Sort_specificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_sort_specification
	return p
}

func InitEmptySort_specificationContext(p *Sort_specificationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_sort_specification
}

func (*Sort_specificationContext) IsSort_specificationContext() {}

func NewSort_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sort_specificationContext {
	var p = new(Sort_specificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_sort_specification

	return p
}

func (s *Sort_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Sort_specificationContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Sort_specificationContext) ASC() antlr.TerminalNode {
	return s.GetToken(YQLParserASC, 0)
}

func (s *Sort_specificationContext) DESC() antlr.TerminalNode {
	return s.GetToken(YQLParserDESC, 0)
}

func (s *Sort_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sort_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Sort_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterSort_specification(s)
	}
}

func (s *Sort_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitSort_specification(s)
	}
}




func (p *YQLParser) Sort_specification() (localctx ISort_specificationContext) {
	localctx = NewSort_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, YQLParserRULE_sort_specification)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1976)
		p.Expr()
	}
	p.SetState(1978)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserASC || _la == YQLParserDESC {
		{
			p.SetState(1977)
			_la = p.GetTokenStream().LA(1)

			if !(_la == YQLParserASC || _la == YQLParserDESC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISort_specification_listContext is an interface to support dynamic dispatch.
type ISort_specification_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSort_specification() []ISort_specificationContext
	Sort_specification(i int) ISort_specificationContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSort_specification_listContext differentiates from other interfaces.
	IsSort_specification_listContext()
}

type Sort_specification_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySort_specification_listContext() *Sort_specification_listContext {
	var p = new(Sort_specification_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_sort_specification_list
	return p
}

func InitEmptySort_specification_listContext(p *Sort_specification_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_sort_specification_list
}

func (*Sort_specification_listContext) IsSort_specification_listContext() {}

func NewSort_specification_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sort_specification_listContext {
	var p = new(Sort_specification_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_sort_specification_list

	return p
}

func (s *Sort_specification_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Sort_specification_listContext) AllSort_specification() []ISort_specificationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISort_specificationContext); ok {
			len++
		}
	}

	tst := make([]ISort_specificationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISort_specificationContext); ok {
			tst[i] = t.(ISort_specificationContext)
			i++
		}
	}

	return tst
}

func (s *Sort_specification_listContext) Sort_specification(i int) ISort_specificationContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISort_specificationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISort_specificationContext)
}

func (s *Sort_specification_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Sort_specification_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Sort_specification_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sort_specification_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Sort_specification_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterSort_specification_list(s)
	}
}

func (s *Sort_specification_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitSort_specification_list(s)
	}
}




func (p *YQLParser) Sort_specification_list() (localctx ISort_specification_listContext) {
	localctx = NewSort_specification_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, YQLParserRULE_sort_specification_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1980)
		p.Sort_specification()
	}
	p.SetState(1985)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(1981)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1982)
			p.Sort_specification()
		}


		p.SetState(1987)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelect_stmtContext is an interface to support dynamic dispatch.
type ISelect_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSelect_kind_parenthesis() []ISelect_kind_parenthesisContext
	Select_kind_parenthesis(i int) ISelect_kind_parenthesisContext
	AllSelect_op() []ISelect_opContext
	Select_op(i int) ISelect_opContext

	// IsSelect_stmtContext differentiates from other interfaces.
	IsSelect_stmtContext()
}

type Select_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_stmtContext() *Select_stmtContext {
	var p = new(Select_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_select_stmt
	return p
}

func InitEmptySelect_stmtContext(p *Select_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_select_stmt
}

func (*Select_stmtContext) IsSelect_stmtContext() {}

func NewSelect_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_stmtContext {
	var p = new(Select_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_select_stmt

	return p
}

func (s *Select_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_stmtContext) AllSelect_kind_parenthesis() []ISelect_kind_parenthesisContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelect_kind_parenthesisContext); ok {
			len++
		}
	}

	tst := make([]ISelect_kind_parenthesisContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelect_kind_parenthesisContext); ok {
			tst[i] = t.(ISelect_kind_parenthesisContext)
			i++
		}
	}

	return tst
}

func (s *Select_stmtContext) Select_kind_parenthesis(i int) ISelect_kind_parenthesisContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_kind_parenthesisContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_kind_parenthesisContext)
}

func (s *Select_stmtContext) AllSelect_op() []ISelect_opContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelect_opContext); ok {
			len++
		}
	}

	tst := make([]ISelect_opContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelect_opContext); ok {
			tst[i] = t.(ISelect_opContext)
			i++
		}
	}

	return tst
}

func (s *Select_stmtContext) Select_op(i int) ISelect_opContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_opContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_opContext)
}

func (s *Select_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterSelect_stmt(s)
	}
}

func (s *Select_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitSelect_stmt(s)
	}
}




func (p *YQLParser) Select_stmt() (localctx ISelect_stmtContext) {
	localctx = NewSelect_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, YQLParserRULE_select_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1988)
		p.Select_kind_parenthesis()
	}
	p.SetState(1994)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserEXCEPT || _la == YQLParserINTERSECT || _la == YQLParserUNION {
		{
			p.SetState(1989)
			p.Select_op()
		}
		{
			p.SetState(1990)
			p.Select_kind_parenthesis()
		}


		p.SetState(1996)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelect_unparenthesized_stmtContext is an interface to support dynamic dispatch.
type ISelect_unparenthesized_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Select_kind_partial() ISelect_kind_partialContext
	AllSelect_op() []ISelect_opContext
	Select_op(i int) ISelect_opContext
	AllSelect_kind_parenthesis() []ISelect_kind_parenthesisContext
	Select_kind_parenthesis(i int) ISelect_kind_parenthesisContext

	// IsSelect_unparenthesized_stmtContext differentiates from other interfaces.
	IsSelect_unparenthesized_stmtContext()
}

type Select_unparenthesized_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_unparenthesized_stmtContext() *Select_unparenthesized_stmtContext {
	var p = new(Select_unparenthesized_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_select_unparenthesized_stmt
	return p
}

func InitEmptySelect_unparenthesized_stmtContext(p *Select_unparenthesized_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_select_unparenthesized_stmt
}

func (*Select_unparenthesized_stmtContext) IsSelect_unparenthesized_stmtContext() {}

func NewSelect_unparenthesized_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_unparenthesized_stmtContext {
	var p = new(Select_unparenthesized_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_select_unparenthesized_stmt

	return p
}

func (s *Select_unparenthesized_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_unparenthesized_stmtContext) Select_kind_partial() ISelect_kind_partialContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_kind_partialContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_kind_partialContext)
}

func (s *Select_unparenthesized_stmtContext) AllSelect_op() []ISelect_opContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelect_opContext); ok {
			len++
		}
	}

	tst := make([]ISelect_opContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelect_opContext); ok {
			tst[i] = t.(ISelect_opContext)
			i++
		}
	}

	return tst
}

func (s *Select_unparenthesized_stmtContext) Select_op(i int) ISelect_opContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_opContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_opContext)
}

func (s *Select_unparenthesized_stmtContext) AllSelect_kind_parenthesis() []ISelect_kind_parenthesisContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelect_kind_parenthesisContext); ok {
			len++
		}
	}

	tst := make([]ISelect_kind_parenthesisContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelect_kind_parenthesisContext); ok {
			tst[i] = t.(ISelect_kind_parenthesisContext)
			i++
		}
	}

	return tst
}

func (s *Select_unparenthesized_stmtContext) Select_kind_parenthesis(i int) ISelect_kind_parenthesisContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_kind_parenthesisContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_kind_parenthesisContext)
}

func (s *Select_unparenthesized_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_unparenthesized_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_unparenthesized_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterSelect_unparenthesized_stmt(s)
	}
}

func (s *Select_unparenthesized_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitSelect_unparenthesized_stmt(s)
	}
}




func (p *YQLParser) Select_unparenthesized_stmt() (localctx ISelect_unparenthesized_stmtContext) {
	localctx = NewSelect_unparenthesized_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, YQLParserRULE_select_unparenthesized_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1997)
		p.Select_kind_partial()
	}
	p.SetState(2003)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserEXCEPT || _la == YQLParserINTERSECT || _la == YQLParserUNION {
		{
			p.SetState(1998)
			p.Select_op()
		}
		{
			p.SetState(1999)
			p.Select_kind_parenthesis()
		}


		p.SetState(2005)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelect_kind_parenthesisContext is an interface to support dynamic dispatch.
type ISelect_kind_parenthesisContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Select_kind_partial() ISelect_kind_partialContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode

	// IsSelect_kind_parenthesisContext differentiates from other interfaces.
	IsSelect_kind_parenthesisContext()
}

type Select_kind_parenthesisContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_kind_parenthesisContext() *Select_kind_parenthesisContext {
	var p = new(Select_kind_parenthesisContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_select_kind_parenthesis
	return p
}

func InitEmptySelect_kind_parenthesisContext(p *Select_kind_parenthesisContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_select_kind_parenthesis
}

func (*Select_kind_parenthesisContext) IsSelect_kind_parenthesisContext() {}

func NewSelect_kind_parenthesisContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_kind_parenthesisContext {
	var p = new(Select_kind_parenthesisContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_select_kind_parenthesis

	return p
}

func (s *Select_kind_parenthesisContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_kind_parenthesisContext) Select_kind_partial() ISelect_kind_partialContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_kind_partialContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_kind_partialContext)
}

func (s *Select_kind_parenthesisContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Select_kind_parenthesisContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Select_kind_parenthesisContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_kind_parenthesisContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_kind_parenthesisContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterSelect_kind_parenthesis(s)
	}
}

func (s *Select_kind_parenthesisContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitSelect_kind_parenthesis(s)
	}
}




func (p *YQLParser) Select_kind_parenthesis() (localctx ISelect_kind_parenthesisContext) {
	localctx = NewSelect_kind_parenthesisContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, YQLParserRULE_select_kind_parenthesis)
	p.SetState(2011)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserDISCARD, YQLParserFROM, YQLParserPROCESS, YQLParserREDUCE, YQLParserSELECT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2006)
			p.Select_kind_partial()
		}


	case YQLParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2007)
			p.Match(YQLParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2008)
			p.Select_kind_partial()
		}
		{
			p.SetState(2009)
			p.Match(YQLParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelect_opContext is an interface to support dynamic dispatch.
type ISelect_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNION() antlr.TerminalNode
	ALL() antlr.TerminalNode
	INTERSECT() antlr.TerminalNode
	EXCEPT() antlr.TerminalNode

	// IsSelect_opContext differentiates from other interfaces.
	IsSelect_opContext()
}

type Select_opContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_opContext() *Select_opContext {
	var p = new(Select_opContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_select_op
	return p
}

func InitEmptySelect_opContext(p *Select_opContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_select_op
}

func (*Select_opContext) IsSelect_opContext() {}

func NewSelect_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_opContext {
	var p = new(Select_opContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_select_op

	return p
}

func (s *Select_opContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_opContext) UNION() antlr.TerminalNode {
	return s.GetToken(YQLParserUNION, 0)
}

func (s *Select_opContext) ALL() antlr.TerminalNode {
	return s.GetToken(YQLParserALL, 0)
}

func (s *Select_opContext) INTERSECT() antlr.TerminalNode {
	return s.GetToken(YQLParserINTERSECT, 0)
}

func (s *Select_opContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(YQLParserEXCEPT, 0)
}

func (s *Select_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterSelect_op(s)
	}
}

func (s *Select_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitSelect_op(s)
	}
}




func (p *YQLParser) Select_op() (localctx ISelect_opContext) {
	localctx = NewSelect_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, YQLParserRULE_select_op)
	var _la int

	p.SetState(2019)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserUNION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2013)
			p.Match(YQLParserUNION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2015)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserALL {
			{
				p.SetState(2014)
				p.Match(YQLParserALL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}


	case YQLParserINTERSECT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2017)
			p.Match(YQLParserINTERSECT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserEXCEPT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2018)
			p.Match(YQLParserEXCEPT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelect_kind_partialContext is an interface to support dynamic dispatch.
type ISelect_kind_partialContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Select_kind() ISelect_kindContext
	LIMIT() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	OFFSET() antlr.TerminalNode
	COMMA() antlr.TerminalNode

	// IsSelect_kind_partialContext differentiates from other interfaces.
	IsSelect_kind_partialContext()
}

type Select_kind_partialContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_kind_partialContext() *Select_kind_partialContext {
	var p = new(Select_kind_partialContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_select_kind_partial
	return p
}

func InitEmptySelect_kind_partialContext(p *Select_kind_partialContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_select_kind_partial
}

func (*Select_kind_partialContext) IsSelect_kind_partialContext() {}

func NewSelect_kind_partialContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_kind_partialContext {
	var p = new(Select_kind_partialContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_select_kind_partial

	return p
}

func (s *Select_kind_partialContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_kind_partialContext) Select_kind() ISelect_kindContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_kindContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_kindContext)
}

func (s *Select_kind_partialContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(YQLParserLIMIT, 0)
}

func (s *Select_kind_partialContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Select_kind_partialContext) Expr(i int) IExprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Select_kind_partialContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(YQLParserOFFSET, 0)
}

func (s *Select_kind_partialContext) COMMA() antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, 0)
}

func (s *Select_kind_partialContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_kind_partialContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_kind_partialContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterSelect_kind_partial(s)
	}
}

func (s *Select_kind_partialContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitSelect_kind_partial(s)
	}
}




func (p *YQLParser) Select_kind_partial() (localctx ISelect_kind_partialContext) {
	localctx = NewSelect_kind_partialContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, YQLParserRULE_select_kind_partial)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2021)
		p.Select_kind()
	}
	p.SetState(2028)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserLIMIT {
		{
			p.SetState(2022)
			p.Match(YQLParserLIMIT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2023)
			p.Expr()
		}
		p.SetState(2026)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserCOMMA || _la == YQLParserOFFSET {
			{
				p.SetState(2024)
				_la = p.GetTokenStream().LA(1)

				if !(_la == YQLParserCOMMA || _la == YQLParserOFFSET) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2025)
				p.Expr()
			}

		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelect_kindContext is an interface to support dynamic dispatch.
type ISelect_kindContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Process_core() IProcess_coreContext
	Reduce_core() IReduce_coreContext
	Select_core() ISelect_coreContext
	DISCARD() antlr.TerminalNode
	INTO() antlr.TerminalNode
	RESULT() antlr.TerminalNode
	Pure_column_or_named() IPure_column_or_namedContext

	// IsSelect_kindContext differentiates from other interfaces.
	IsSelect_kindContext()
}

type Select_kindContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_kindContext() *Select_kindContext {
	var p = new(Select_kindContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_select_kind
	return p
}

func InitEmptySelect_kindContext(p *Select_kindContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_select_kind
}

func (*Select_kindContext) IsSelect_kindContext() {}

func NewSelect_kindContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_kindContext {
	var p = new(Select_kindContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_select_kind

	return p
}

func (s *Select_kindContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_kindContext) Process_core() IProcess_coreContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcess_coreContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcess_coreContext)
}

func (s *Select_kindContext) Reduce_core() IReduce_coreContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReduce_coreContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReduce_coreContext)
}

func (s *Select_kindContext) Select_core() ISelect_coreContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_coreContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_coreContext)
}

func (s *Select_kindContext) DISCARD() antlr.TerminalNode {
	return s.GetToken(YQLParserDISCARD, 0)
}

func (s *Select_kindContext) INTO() antlr.TerminalNode {
	return s.GetToken(YQLParserINTO, 0)
}

func (s *Select_kindContext) RESULT() antlr.TerminalNode {
	return s.GetToken(YQLParserRESULT, 0)
}

func (s *Select_kindContext) Pure_column_or_named() IPure_column_or_namedContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPure_column_or_namedContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPure_column_or_namedContext)
}

func (s *Select_kindContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_kindContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_kindContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterSelect_kind(s)
	}
}

func (s *Select_kindContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitSelect_kind(s)
	}
}




func (p *YQLParser) Select_kind() (localctx ISelect_kindContext) {
	localctx = NewSelect_kindContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, YQLParserRULE_select_kind)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2031)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserDISCARD {
		{
			p.SetState(2030)
			p.Match(YQLParserDISCARD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(2036)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserPROCESS:
		{
			p.SetState(2033)
			p.Process_core()
		}


	case YQLParserREDUCE:
		{
			p.SetState(2034)
			p.Reduce_core()
		}


	case YQLParserFROM, YQLParserSELECT:
		{
			p.SetState(2035)
			p.Select_core()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(2041)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserINTO {
		{
			p.SetState(2038)
			p.Match(YQLParserINTO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2039)
			p.Match(YQLParserRESULT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2040)
			p.Pure_column_or_named()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IProcess_coreContext is an interface to support dynamic dispatch.
type IProcess_coreContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROCESS() antlr.TerminalNode
	AllNamed_single_source() []INamed_single_sourceContext
	Named_single_source(i int) INamed_single_sourceContext
	STREAM() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	USING() antlr.TerminalNode
	Using_call_expr() IUsing_call_exprContext
	AS() antlr.TerminalNode
	An_id() IAn_idContext
	WITH() antlr.TerminalNode
	External_call_settings() IExternal_call_settingsContext
	WHERE() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	HAVING() antlr.TerminalNode
	ASSUME() antlr.TerminalNode
	Order_by_clause() IOrder_by_clauseContext

	// IsProcess_coreContext differentiates from other interfaces.
	IsProcess_coreContext()
}

type Process_coreContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcess_coreContext() *Process_coreContext {
	var p = new(Process_coreContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_process_core
	return p
}

func InitEmptyProcess_coreContext(p *Process_coreContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_process_core
}

func (*Process_coreContext) IsProcess_coreContext() {}

func NewProcess_coreContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Process_coreContext {
	var p = new(Process_coreContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_process_core

	return p
}

func (s *Process_coreContext) GetParser() antlr.Parser { return s.parser }

func (s *Process_coreContext) PROCESS() antlr.TerminalNode {
	return s.GetToken(YQLParserPROCESS, 0)
}

func (s *Process_coreContext) AllNamed_single_source() []INamed_single_sourceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamed_single_sourceContext); ok {
			len++
		}
	}

	tst := make([]INamed_single_sourceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamed_single_sourceContext); ok {
			tst[i] = t.(INamed_single_sourceContext)
			i++
		}
	}

	return tst
}

func (s *Process_coreContext) Named_single_source(i int) INamed_single_sourceContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_single_sourceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_single_sourceContext)
}

func (s *Process_coreContext) STREAM() antlr.TerminalNode {
	return s.GetToken(YQLParserSTREAM, 0)
}

func (s *Process_coreContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Process_coreContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Process_coreContext) USING() antlr.TerminalNode {
	return s.GetToken(YQLParserUSING, 0)
}

func (s *Process_coreContext) Using_call_expr() IUsing_call_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsing_call_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsing_call_exprContext)
}

func (s *Process_coreContext) AS() antlr.TerminalNode {
	return s.GetToken(YQLParserAS, 0)
}

func (s *Process_coreContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Process_coreContext) WITH() antlr.TerminalNode {
	return s.GetToken(YQLParserWITH, 0)
}

func (s *Process_coreContext) External_call_settings() IExternal_call_settingsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExternal_call_settingsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExternal_call_settingsContext)
}

func (s *Process_coreContext) WHERE() antlr.TerminalNode {
	return s.GetToken(YQLParserWHERE, 0)
}

func (s *Process_coreContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Process_coreContext) Expr(i int) IExprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Process_coreContext) HAVING() antlr.TerminalNode {
	return s.GetToken(YQLParserHAVING, 0)
}

func (s *Process_coreContext) ASSUME() antlr.TerminalNode {
	return s.GetToken(YQLParserASSUME, 0)
}

func (s *Process_coreContext) Order_by_clause() IOrder_by_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrder_by_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrder_by_clauseContext)
}

func (s *Process_coreContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Process_coreContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Process_coreContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterProcess_core(s)
	}
}

func (s *Process_coreContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitProcess_core(s)
	}
}




func (p *YQLParser) Process_core() (localctx IProcess_coreContext) {
	localctx = NewProcess_coreContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, YQLParserRULE_process_core)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2043)
		p.Match(YQLParserPROCESS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2045)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 161, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2044)
			p.Match(YQLParserSTREAM)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(2047)
		p.Named_single_source()
	}
	p.SetState(2052)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(2048)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2049)
			p.Named_single_source()
		}


		p.SetState(2054)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(2077)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserUSING {
		{
			p.SetState(2055)
			p.Match(YQLParserUSING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2056)
			p.Using_call_expr()
		}
		p.SetState(2059)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserAS {
			{
				p.SetState(2057)
				p.Match(YQLParserAS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2058)
				p.An_id()
			}

		}
		p.SetState(2063)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserWITH {
			{
				p.SetState(2061)
				p.Match(YQLParserWITH)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2062)
				p.External_call_settings()
			}

		}
		p.SetState(2067)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserWHERE {
			{
				p.SetState(2065)
				p.Match(YQLParserWHERE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2066)
				p.Expr()
			}

		}
		p.SetState(2071)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserHAVING {
			{
				p.SetState(2069)
				p.Match(YQLParserHAVING)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2070)
				p.Expr()
			}

		}
		p.SetState(2075)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserASSUME {
			{
				p.SetState(2073)
				p.Match(YQLParserASSUME)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2074)
				p.Order_by_clause()
			}

		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExternal_call_paramContext is an interface to support dynamic dispatch.
type IExternal_call_paramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id() IAn_idContext
	EQUALS() antlr.TerminalNode
	Expr() IExprContext

	// IsExternal_call_paramContext differentiates from other interfaces.
	IsExternal_call_paramContext()
}

type External_call_paramContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternal_call_paramContext() *External_call_paramContext {
	var p = new(External_call_paramContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_external_call_param
	return p
}

func InitEmptyExternal_call_paramContext(p *External_call_paramContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_external_call_param
}

func (*External_call_paramContext) IsExternal_call_paramContext() {}

func NewExternal_call_paramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *External_call_paramContext {
	var p = new(External_call_paramContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_external_call_param

	return p
}

func (s *External_call_paramContext) GetParser() antlr.Parser { return s.parser }

func (s *External_call_paramContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *External_call_paramContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(YQLParserEQUALS, 0)
}

func (s *External_call_paramContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *External_call_paramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *External_call_paramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *External_call_paramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterExternal_call_param(s)
	}
}

func (s *External_call_paramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitExternal_call_param(s)
	}
}




func (p *YQLParser) External_call_param() (localctx IExternal_call_paramContext) {
	localctx = NewExternal_call_paramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, YQLParserRULE_external_call_param)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2079)
		p.An_id()
	}
	{
		p.SetState(2080)
		p.Match(YQLParserEQUALS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2081)
		p.Expr()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExternal_call_settingsContext is an interface to support dynamic dispatch.
type IExternal_call_settingsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExternal_call_param() []IExternal_call_paramContext
	External_call_param(i int) IExternal_call_paramContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExternal_call_settingsContext differentiates from other interfaces.
	IsExternal_call_settingsContext()
}

type External_call_settingsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternal_call_settingsContext() *External_call_settingsContext {
	var p = new(External_call_settingsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_external_call_settings
	return p
}

func InitEmptyExternal_call_settingsContext(p *External_call_settingsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_external_call_settings
}

func (*External_call_settingsContext) IsExternal_call_settingsContext() {}

func NewExternal_call_settingsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *External_call_settingsContext {
	var p = new(External_call_settingsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_external_call_settings

	return p
}

func (s *External_call_settingsContext) GetParser() antlr.Parser { return s.parser }

func (s *External_call_settingsContext) AllExternal_call_param() []IExternal_call_paramContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExternal_call_paramContext); ok {
			len++
		}
	}

	tst := make([]IExternal_call_paramContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExternal_call_paramContext); ok {
			tst[i] = t.(IExternal_call_paramContext)
			i++
		}
	}

	return tst
}

func (s *External_call_settingsContext) External_call_param(i int) IExternal_call_paramContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExternal_call_paramContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExternal_call_paramContext)
}

func (s *External_call_settingsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *External_call_settingsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *External_call_settingsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *External_call_settingsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *External_call_settingsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterExternal_call_settings(s)
	}
}

func (s *External_call_settingsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitExternal_call_settings(s)
	}
}




func (p *YQLParser) External_call_settings() (localctx IExternal_call_settingsContext) {
	localctx = NewExternal_call_settingsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, YQLParserRULE_external_call_settings)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2083)
		p.External_call_param()
	}
	p.SetState(2088)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(2084)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2085)
			p.External_call_param()
		}


		p.SetState(2090)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IReduce_coreContext is an interface to support dynamic dispatch.
type IReduce_coreContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REDUCE() antlr.TerminalNode
	AllNamed_single_source() []INamed_single_sourceContext
	Named_single_source(i int) INamed_single_sourceContext
	ON() antlr.TerminalNode
	Column_list() IColumn_listContext
	USING() antlr.TerminalNode
	Using_call_expr() IUsing_call_exprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	PRESORT() antlr.TerminalNode
	Sort_specification_list() ISort_specification_listContext
	ALL() antlr.TerminalNode
	AS() antlr.TerminalNode
	An_id() IAn_idContext
	WHERE() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	HAVING() antlr.TerminalNode
	ASSUME() antlr.TerminalNode
	Order_by_clause() IOrder_by_clauseContext

	// IsReduce_coreContext differentiates from other interfaces.
	IsReduce_coreContext()
}

type Reduce_coreContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReduce_coreContext() *Reduce_coreContext {
	var p = new(Reduce_coreContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_reduce_core
	return p
}

func InitEmptyReduce_coreContext(p *Reduce_coreContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_reduce_core
}

func (*Reduce_coreContext) IsReduce_coreContext() {}

func NewReduce_coreContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Reduce_coreContext {
	var p = new(Reduce_coreContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_reduce_core

	return p
}

func (s *Reduce_coreContext) GetParser() antlr.Parser { return s.parser }

func (s *Reduce_coreContext) REDUCE() antlr.TerminalNode {
	return s.GetToken(YQLParserREDUCE, 0)
}

func (s *Reduce_coreContext) AllNamed_single_source() []INamed_single_sourceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamed_single_sourceContext); ok {
			len++
		}
	}

	tst := make([]INamed_single_sourceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamed_single_sourceContext); ok {
			tst[i] = t.(INamed_single_sourceContext)
			i++
		}
	}

	return tst
}

func (s *Reduce_coreContext) Named_single_source(i int) INamed_single_sourceContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_single_sourceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_single_sourceContext)
}

func (s *Reduce_coreContext) ON() antlr.TerminalNode {
	return s.GetToken(YQLParserON, 0)
}

func (s *Reduce_coreContext) Column_list() IColumn_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_listContext)
}

func (s *Reduce_coreContext) USING() antlr.TerminalNode {
	return s.GetToken(YQLParserUSING, 0)
}

func (s *Reduce_coreContext) Using_call_expr() IUsing_call_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsing_call_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsing_call_exprContext)
}

func (s *Reduce_coreContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Reduce_coreContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Reduce_coreContext) PRESORT() antlr.TerminalNode {
	return s.GetToken(YQLParserPRESORT, 0)
}

func (s *Reduce_coreContext) Sort_specification_list() ISort_specification_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISort_specification_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISort_specification_listContext)
}

func (s *Reduce_coreContext) ALL() antlr.TerminalNode {
	return s.GetToken(YQLParserALL, 0)
}

func (s *Reduce_coreContext) AS() antlr.TerminalNode {
	return s.GetToken(YQLParserAS, 0)
}

func (s *Reduce_coreContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Reduce_coreContext) WHERE() antlr.TerminalNode {
	return s.GetToken(YQLParserWHERE, 0)
}

func (s *Reduce_coreContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Reduce_coreContext) Expr(i int) IExprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Reduce_coreContext) HAVING() antlr.TerminalNode {
	return s.GetToken(YQLParserHAVING, 0)
}

func (s *Reduce_coreContext) ASSUME() antlr.TerminalNode {
	return s.GetToken(YQLParserASSUME, 0)
}

func (s *Reduce_coreContext) Order_by_clause() IOrder_by_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrder_by_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrder_by_clauseContext)
}

func (s *Reduce_coreContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Reduce_coreContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Reduce_coreContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterReduce_core(s)
	}
}

func (s *Reduce_coreContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitReduce_core(s)
	}
}




func (p *YQLParser) Reduce_core() (localctx IReduce_coreContext) {
	localctx = NewReduce_coreContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, YQLParserRULE_reduce_core)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2091)
		p.Match(YQLParserREDUCE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2092)
		p.Named_single_source()
	}
	p.SetState(2097)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(2093)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2094)
			p.Named_single_source()
		}


		p.SetState(2099)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(2102)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserPRESORT {
		{
			p.SetState(2100)
			p.Match(YQLParserPRESORT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2101)
			p.Sort_specification_list()
		}

	}
	{
		p.SetState(2104)
		p.Match(YQLParserON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2105)
		p.Column_list()
	}
	{
		p.SetState(2106)
		p.Match(YQLParserUSING)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2108)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 172, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2107)
			p.Match(YQLParserALL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(2110)
		p.Using_call_expr()
	}
	p.SetState(2113)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserAS {
		{
			p.SetState(2111)
			p.Match(YQLParserAS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2112)
			p.An_id()
		}

	}
	p.SetState(2117)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserWHERE {
		{
			p.SetState(2115)
			p.Match(YQLParserWHERE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2116)
			p.Expr()
		}

	}
	p.SetState(2121)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserHAVING {
		{
			p.SetState(2119)
			p.Match(YQLParserHAVING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2120)
			p.Expr()
		}

	}
	p.SetState(2125)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserASSUME {
		{
			p.SetState(2123)
			p.Match(YQLParserASSUME)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2124)
			p.Order_by_clause()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOpt_set_quantifierContext is an interface to support dynamic dispatch.
type IOpt_set_quantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode

	// IsOpt_set_quantifierContext differentiates from other interfaces.
	IsOpt_set_quantifierContext()
}

type Opt_set_quantifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_set_quantifierContext() *Opt_set_quantifierContext {
	var p = new(Opt_set_quantifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_opt_set_quantifier
	return p
}

func InitEmptyOpt_set_quantifierContext(p *Opt_set_quantifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_opt_set_quantifier
}

func (*Opt_set_quantifierContext) IsOpt_set_quantifierContext() {}

func NewOpt_set_quantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_set_quantifierContext {
	var p = new(Opt_set_quantifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_opt_set_quantifier

	return p
}

func (s *Opt_set_quantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_set_quantifierContext) ALL() antlr.TerminalNode {
	return s.GetToken(YQLParserALL, 0)
}

func (s *Opt_set_quantifierContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(YQLParserDISTINCT, 0)
}

func (s *Opt_set_quantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_set_quantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Opt_set_quantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterOpt_set_quantifier(s)
	}
}

func (s *Opt_set_quantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitOpt_set_quantifier(s)
	}
}




func (p *YQLParser) Opt_set_quantifier() (localctx IOpt_set_quantifierContext) {
	localctx = NewOpt_set_quantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, YQLParserRULE_opt_set_quantifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2128)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 177, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2127)
			_la = p.GetTokenStream().LA(1)

			if !(_la == YQLParserALL || _la == YQLParserDISTINCT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelect_coreContext is an interface to support dynamic dispatch.
type ISelect_coreContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SELECT() antlr.TerminalNode
	Opt_set_quantifier() IOpt_set_quantifierContext
	AllResult_column() []IResult_columnContext
	Result_column(i int) IResult_columnContext
	AllFROM() []antlr.TerminalNode
	FROM(i int) antlr.TerminalNode
	AllJoin_source() []IJoin_sourceContext
	Join_source(i int) IJoin_sourceContext
	STREAM() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	WITHOUT() antlr.TerminalNode
	Without_column_list() IWithout_column_listContext
	WHERE() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	Group_by_clause() IGroup_by_clauseContext
	HAVING() antlr.TerminalNode
	Window_clause() IWindow_clauseContext
	Ext_order_by_clause() IExt_order_by_clauseContext

	// IsSelect_coreContext differentiates from other interfaces.
	IsSelect_coreContext()
}

type Select_coreContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_coreContext() *Select_coreContext {
	var p = new(Select_coreContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_select_core
	return p
}

func InitEmptySelect_coreContext(p *Select_coreContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_select_core
}

func (*Select_coreContext) IsSelect_coreContext() {}

func NewSelect_coreContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_coreContext {
	var p = new(Select_coreContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_select_core

	return p
}

func (s *Select_coreContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_coreContext) SELECT() antlr.TerminalNode {
	return s.GetToken(YQLParserSELECT, 0)
}

func (s *Select_coreContext) Opt_set_quantifier() IOpt_set_quantifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_set_quantifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_set_quantifierContext)
}

func (s *Select_coreContext) AllResult_column() []IResult_columnContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IResult_columnContext); ok {
			len++
		}
	}

	tst := make([]IResult_columnContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IResult_columnContext); ok {
			tst[i] = t.(IResult_columnContext)
			i++
		}
	}

	return tst
}

func (s *Select_coreContext) Result_column(i int) IResult_columnContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResult_columnContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResult_columnContext)
}

func (s *Select_coreContext) AllFROM() []antlr.TerminalNode {
	return s.GetTokens(YQLParserFROM)
}

func (s *Select_coreContext) FROM(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserFROM, i)
}

func (s *Select_coreContext) AllJoin_source() []IJoin_sourceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoin_sourceContext); ok {
			len++
		}
	}

	tst := make([]IJoin_sourceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoin_sourceContext); ok {
			tst[i] = t.(IJoin_sourceContext)
			i++
		}
	}

	return tst
}

func (s *Select_coreContext) Join_source(i int) IJoin_sourceContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoin_sourceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoin_sourceContext)
}

func (s *Select_coreContext) STREAM() antlr.TerminalNode {
	return s.GetToken(YQLParserSTREAM, 0)
}

func (s *Select_coreContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Select_coreContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Select_coreContext) WITHOUT() antlr.TerminalNode {
	return s.GetToken(YQLParserWITHOUT, 0)
}

func (s *Select_coreContext) Without_column_list() IWithout_column_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithout_column_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithout_column_listContext)
}

func (s *Select_coreContext) WHERE() antlr.TerminalNode {
	return s.GetToken(YQLParserWHERE, 0)
}

func (s *Select_coreContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Select_coreContext) Expr(i int) IExprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Select_coreContext) Group_by_clause() IGroup_by_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroup_by_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroup_by_clauseContext)
}

func (s *Select_coreContext) HAVING() antlr.TerminalNode {
	return s.GetToken(YQLParserHAVING, 0)
}

func (s *Select_coreContext) Window_clause() IWindow_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_clauseContext)
}

func (s *Select_coreContext) Ext_order_by_clause() IExt_order_by_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExt_order_by_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExt_order_by_clauseContext)
}

func (s *Select_coreContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_coreContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_coreContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterSelect_core(s)
	}
}

func (s *Select_coreContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitSelect_core(s)
	}
}




func (p *YQLParser) Select_core() (localctx ISelect_coreContext) {
	localctx = NewSelect_coreContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, YQLParserRULE_select_core)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2132)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserFROM {
		{
			p.SetState(2130)
			p.Match(YQLParserFROM)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2131)
			p.Join_source()
		}

	}
	{
		p.SetState(2134)
		p.Match(YQLParserSELECT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2136)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 179, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2135)
			p.Match(YQLParserSTREAM)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(2138)
		p.Opt_set_quantifier()
	}
	{
		p.SetState(2139)
		p.Result_column()
	}
	p.SetState(2144)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 180, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2140)
				p.Match(YQLParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2141)
				p.Result_column()
			}


		}
		p.SetState(2146)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 180, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2148)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserCOMMA {
		{
			p.SetState(2147)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(2152)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserWITHOUT {
		{
			p.SetState(2150)
			p.Match(YQLParserWITHOUT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2151)
			p.Without_column_list()
		}

	}
	p.SetState(2156)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserFROM {
		{
			p.SetState(2154)
			p.Match(YQLParserFROM)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2155)
			p.Join_source()
		}

	}
	p.SetState(2160)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserWHERE {
		{
			p.SetState(2158)
			p.Match(YQLParserWHERE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2159)
			p.Expr()
		}

	}
	p.SetState(2163)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserGROUP {
		{
			p.SetState(2162)
			p.Group_by_clause()
		}

	}
	p.SetState(2167)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserHAVING {
		{
			p.SetState(2165)
			p.Match(YQLParserHAVING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2166)
			p.Expr()
		}

	}
	p.SetState(2170)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserWINDOW {
		{
			p.SetState(2169)
			p.Window_clause()
		}

	}
	p.SetState(2173)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserASSUME || _la == YQLParserORDER {
		{
			p.SetState(2172)
			p.Ext_order_by_clause()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRow_pattern_recognition_clauseContext is an interface to support dynamic dispatch.
type IRow_pattern_recognition_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MATCH_RECOGNIZE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Row_pattern_common_syntax() IRow_pattern_common_syntaxContext
	RPAREN() antlr.TerminalNode
	Window_partition_clause() IWindow_partition_clauseContext
	Order_by_clause() IOrder_by_clauseContext
	Row_pattern_measures() IRow_pattern_measuresContext
	Row_pattern_rows_per_match() IRow_pattern_rows_per_matchContext

	// IsRow_pattern_recognition_clauseContext differentiates from other interfaces.
	IsRow_pattern_recognition_clauseContext()
}

type Row_pattern_recognition_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_recognition_clauseContext() *Row_pattern_recognition_clauseContext {
	var p = new(Row_pattern_recognition_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_recognition_clause
	return p
}

func InitEmptyRow_pattern_recognition_clauseContext(p *Row_pattern_recognition_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_recognition_clause
}

func (*Row_pattern_recognition_clauseContext) IsRow_pattern_recognition_clauseContext() {}

func NewRow_pattern_recognition_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_recognition_clauseContext {
	var p = new(Row_pattern_recognition_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_row_pattern_recognition_clause

	return p
}

func (s *Row_pattern_recognition_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_recognition_clauseContext) MATCH_RECOGNIZE() antlr.TerminalNode {
	return s.GetToken(YQLParserMATCH_RECOGNIZE, 0)
}

func (s *Row_pattern_recognition_clauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Row_pattern_recognition_clauseContext) Row_pattern_common_syntax() IRow_pattern_common_syntaxContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_common_syntaxContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_common_syntaxContext)
}

func (s *Row_pattern_recognition_clauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Row_pattern_recognition_clauseContext) Window_partition_clause() IWindow_partition_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_partition_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_partition_clauseContext)
}

func (s *Row_pattern_recognition_clauseContext) Order_by_clause() IOrder_by_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrder_by_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrder_by_clauseContext)
}

func (s *Row_pattern_recognition_clauseContext) Row_pattern_measures() IRow_pattern_measuresContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_measuresContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_measuresContext)
}

func (s *Row_pattern_recognition_clauseContext) Row_pattern_rows_per_match() IRow_pattern_rows_per_matchContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_rows_per_matchContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_rows_per_matchContext)
}

func (s *Row_pattern_recognition_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_recognition_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Row_pattern_recognition_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterRow_pattern_recognition_clause(s)
	}
}

func (s *Row_pattern_recognition_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitRow_pattern_recognition_clause(s)
	}
}




func (p *YQLParser) Row_pattern_recognition_clause() (localctx IRow_pattern_recognition_clauseContext) {
	localctx = NewRow_pattern_recognition_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, YQLParserRULE_row_pattern_recognition_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2175)
		p.Match(YQLParserMATCH_RECOGNIZE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2176)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2178)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserPARTITION {
		{
			p.SetState(2177)
			p.Window_partition_clause()
		}

	}
	p.SetState(2181)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserORDER {
		{
			p.SetState(2180)
			p.Order_by_clause()
		}

	}
	p.SetState(2184)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserMEASURES {
		{
			p.SetState(2183)
			p.Row_pattern_measures()
		}

	}
	p.SetState(2187)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserALL || _la == YQLParserONE {
		{
			p.SetState(2186)
			p.Row_pattern_rows_per_match()
		}

	}
	{
		p.SetState(2189)
		p.Row_pattern_common_syntax()
	}
	{
		p.SetState(2190)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRow_pattern_rows_per_matchContext is an interface to support dynamic dispatch.
type IRow_pattern_rows_per_matchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ONE() antlr.TerminalNode
	ROW() antlr.TerminalNode
	PER() antlr.TerminalNode
	MATCH() antlr.TerminalNode
	ALL() antlr.TerminalNode
	ROWS() antlr.TerminalNode
	Row_pattern_empty_match_handling() IRow_pattern_empty_match_handlingContext

	// IsRow_pattern_rows_per_matchContext differentiates from other interfaces.
	IsRow_pattern_rows_per_matchContext()
}

type Row_pattern_rows_per_matchContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_rows_per_matchContext() *Row_pattern_rows_per_matchContext {
	var p = new(Row_pattern_rows_per_matchContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_rows_per_match
	return p
}

func InitEmptyRow_pattern_rows_per_matchContext(p *Row_pattern_rows_per_matchContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_rows_per_match
}

func (*Row_pattern_rows_per_matchContext) IsRow_pattern_rows_per_matchContext() {}

func NewRow_pattern_rows_per_matchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_rows_per_matchContext {
	var p = new(Row_pattern_rows_per_matchContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_row_pattern_rows_per_match

	return p
}

func (s *Row_pattern_rows_per_matchContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_rows_per_matchContext) ONE() antlr.TerminalNode {
	return s.GetToken(YQLParserONE, 0)
}

func (s *Row_pattern_rows_per_matchContext) ROW() antlr.TerminalNode {
	return s.GetToken(YQLParserROW, 0)
}

func (s *Row_pattern_rows_per_matchContext) PER() antlr.TerminalNode {
	return s.GetToken(YQLParserPER, 0)
}

func (s *Row_pattern_rows_per_matchContext) MATCH() antlr.TerminalNode {
	return s.GetToken(YQLParserMATCH, 0)
}

func (s *Row_pattern_rows_per_matchContext) ALL() antlr.TerminalNode {
	return s.GetToken(YQLParserALL, 0)
}

func (s *Row_pattern_rows_per_matchContext) ROWS() antlr.TerminalNode {
	return s.GetToken(YQLParserROWS, 0)
}

func (s *Row_pattern_rows_per_matchContext) Row_pattern_empty_match_handling() IRow_pattern_empty_match_handlingContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_empty_match_handlingContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_empty_match_handlingContext)
}

func (s *Row_pattern_rows_per_matchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_rows_per_matchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Row_pattern_rows_per_matchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterRow_pattern_rows_per_match(s)
	}
}

func (s *Row_pattern_rows_per_matchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitRow_pattern_rows_per_match(s)
	}
}




func (p *YQLParser) Row_pattern_rows_per_match() (localctx IRow_pattern_rows_per_matchContext) {
	localctx = NewRow_pattern_rows_per_matchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, YQLParserRULE_row_pattern_rows_per_match)
	var _la int

	p.SetState(2203)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserONE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2192)
			p.Match(YQLParserONE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2193)
			p.Match(YQLParserROW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2194)
			p.Match(YQLParserPER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2195)
			p.Match(YQLParserMATCH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserALL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2196)
			p.Match(YQLParserALL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2197)
			p.Match(YQLParserROWS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2198)
			p.Match(YQLParserPER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2199)
			p.Match(YQLParserMATCH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2201)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserOMIT || _la == YQLParserSHOW || _la == YQLParserWITH {
			{
				p.SetState(2200)
				p.Row_pattern_empty_match_handling()
			}

		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRow_pattern_empty_match_handlingContext is an interface to support dynamic dispatch.
type IRow_pattern_empty_match_handlingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	EMPTY() antlr.TerminalNode
	MATCHES() antlr.TerminalNode
	OMIT() antlr.TerminalNode
	WITH() antlr.TerminalNode
	UNMATCHED() antlr.TerminalNode
	ROWS() antlr.TerminalNode

	// IsRow_pattern_empty_match_handlingContext differentiates from other interfaces.
	IsRow_pattern_empty_match_handlingContext()
}

type Row_pattern_empty_match_handlingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_empty_match_handlingContext() *Row_pattern_empty_match_handlingContext {
	var p = new(Row_pattern_empty_match_handlingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_empty_match_handling
	return p
}

func InitEmptyRow_pattern_empty_match_handlingContext(p *Row_pattern_empty_match_handlingContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_empty_match_handling
}

func (*Row_pattern_empty_match_handlingContext) IsRow_pattern_empty_match_handlingContext() {}

func NewRow_pattern_empty_match_handlingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_empty_match_handlingContext {
	var p = new(Row_pattern_empty_match_handlingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_row_pattern_empty_match_handling

	return p
}

func (s *Row_pattern_empty_match_handlingContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_empty_match_handlingContext) SHOW() antlr.TerminalNode {
	return s.GetToken(YQLParserSHOW, 0)
}

func (s *Row_pattern_empty_match_handlingContext) EMPTY() antlr.TerminalNode {
	return s.GetToken(YQLParserEMPTY, 0)
}

func (s *Row_pattern_empty_match_handlingContext) MATCHES() antlr.TerminalNode {
	return s.GetToken(YQLParserMATCHES, 0)
}

func (s *Row_pattern_empty_match_handlingContext) OMIT() antlr.TerminalNode {
	return s.GetToken(YQLParserOMIT, 0)
}

func (s *Row_pattern_empty_match_handlingContext) WITH() antlr.TerminalNode {
	return s.GetToken(YQLParserWITH, 0)
}

func (s *Row_pattern_empty_match_handlingContext) UNMATCHED() antlr.TerminalNode {
	return s.GetToken(YQLParserUNMATCHED, 0)
}

func (s *Row_pattern_empty_match_handlingContext) ROWS() antlr.TerminalNode {
	return s.GetToken(YQLParserROWS, 0)
}

func (s *Row_pattern_empty_match_handlingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_empty_match_handlingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Row_pattern_empty_match_handlingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterRow_pattern_empty_match_handling(s)
	}
}

func (s *Row_pattern_empty_match_handlingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitRow_pattern_empty_match_handling(s)
	}
}




func (p *YQLParser) Row_pattern_empty_match_handling() (localctx IRow_pattern_empty_match_handlingContext) {
	localctx = NewRow_pattern_empty_match_handlingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, YQLParserRULE_row_pattern_empty_match_handling)
	p.SetState(2214)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserSHOW:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2205)
			p.Match(YQLParserSHOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2206)
			p.Match(YQLParserEMPTY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2207)
			p.Match(YQLParserMATCHES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserOMIT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2208)
			p.Match(YQLParserOMIT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2209)
			p.Match(YQLParserEMPTY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2210)
			p.Match(YQLParserMATCHES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserWITH:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2211)
			p.Match(YQLParserWITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2212)
			p.Match(YQLParserUNMATCHED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2213)
			p.Match(YQLParserROWS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRow_pattern_measuresContext is an interface to support dynamic dispatch.
type IRow_pattern_measuresContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MEASURES() antlr.TerminalNode
	Row_pattern_measure_list() IRow_pattern_measure_listContext

	// IsRow_pattern_measuresContext differentiates from other interfaces.
	IsRow_pattern_measuresContext()
}

type Row_pattern_measuresContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_measuresContext() *Row_pattern_measuresContext {
	var p = new(Row_pattern_measuresContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_measures
	return p
}

func InitEmptyRow_pattern_measuresContext(p *Row_pattern_measuresContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_measures
}

func (*Row_pattern_measuresContext) IsRow_pattern_measuresContext() {}

func NewRow_pattern_measuresContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_measuresContext {
	var p = new(Row_pattern_measuresContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_row_pattern_measures

	return p
}

func (s *Row_pattern_measuresContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_measuresContext) MEASURES() antlr.TerminalNode {
	return s.GetToken(YQLParserMEASURES, 0)
}

func (s *Row_pattern_measuresContext) Row_pattern_measure_list() IRow_pattern_measure_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_measure_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_measure_listContext)
}

func (s *Row_pattern_measuresContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_measuresContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Row_pattern_measuresContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterRow_pattern_measures(s)
	}
}

func (s *Row_pattern_measuresContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitRow_pattern_measures(s)
	}
}




func (p *YQLParser) Row_pattern_measures() (localctx IRow_pattern_measuresContext) {
	localctx = NewRow_pattern_measuresContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, YQLParserRULE_row_pattern_measures)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2216)
		p.Match(YQLParserMEASURES)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2217)
		p.Row_pattern_measure_list()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRow_pattern_measure_listContext is an interface to support dynamic dispatch.
type IRow_pattern_measure_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRow_pattern_measure_definition() []IRow_pattern_measure_definitionContext
	Row_pattern_measure_definition(i int) IRow_pattern_measure_definitionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRow_pattern_measure_listContext differentiates from other interfaces.
	IsRow_pattern_measure_listContext()
}

type Row_pattern_measure_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_measure_listContext() *Row_pattern_measure_listContext {
	var p = new(Row_pattern_measure_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_measure_list
	return p
}

func InitEmptyRow_pattern_measure_listContext(p *Row_pattern_measure_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_measure_list
}

func (*Row_pattern_measure_listContext) IsRow_pattern_measure_listContext() {}

func NewRow_pattern_measure_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_measure_listContext {
	var p = new(Row_pattern_measure_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_row_pattern_measure_list

	return p
}

func (s *Row_pattern_measure_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_measure_listContext) AllRow_pattern_measure_definition() []IRow_pattern_measure_definitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRow_pattern_measure_definitionContext); ok {
			len++
		}
	}

	tst := make([]IRow_pattern_measure_definitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRow_pattern_measure_definitionContext); ok {
			tst[i] = t.(IRow_pattern_measure_definitionContext)
			i++
		}
	}

	return tst
}

func (s *Row_pattern_measure_listContext) Row_pattern_measure_definition(i int) IRow_pattern_measure_definitionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_measure_definitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_measure_definitionContext)
}

func (s *Row_pattern_measure_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Row_pattern_measure_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Row_pattern_measure_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_measure_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Row_pattern_measure_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterRow_pattern_measure_list(s)
	}
}

func (s *Row_pattern_measure_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitRow_pattern_measure_list(s)
	}
}




func (p *YQLParser) Row_pattern_measure_list() (localctx IRow_pattern_measure_listContext) {
	localctx = NewRow_pattern_measure_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, YQLParserRULE_row_pattern_measure_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2219)
		p.Row_pattern_measure_definition()
	}
	p.SetState(2224)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(2220)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2221)
			p.Row_pattern_measure_definition()
		}


		p.SetState(2226)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRow_pattern_measure_definitionContext is an interface to support dynamic dispatch.
type IRow_pattern_measure_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	AS() antlr.TerminalNode
	An_id() IAn_idContext

	// IsRow_pattern_measure_definitionContext differentiates from other interfaces.
	IsRow_pattern_measure_definitionContext()
}

type Row_pattern_measure_definitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_measure_definitionContext() *Row_pattern_measure_definitionContext {
	var p = new(Row_pattern_measure_definitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_measure_definition
	return p
}

func InitEmptyRow_pattern_measure_definitionContext(p *Row_pattern_measure_definitionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_measure_definition
}

func (*Row_pattern_measure_definitionContext) IsRow_pattern_measure_definitionContext() {}

func NewRow_pattern_measure_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_measure_definitionContext {
	var p = new(Row_pattern_measure_definitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_row_pattern_measure_definition

	return p
}

func (s *Row_pattern_measure_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_measure_definitionContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Row_pattern_measure_definitionContext) AS() antlr.TerminalNode {
	return s.GetToken(YQLParserAS, 0)
}

func (s *Row_pattern_measure_definitionContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Row_pattern_measure_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_measure_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Row_pattern_measure_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterRow_pattern_measure_definition(s)
	}
}

func (s *Row_pattern_measure_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitRow_pattern_measure_definition(s)
	}
}




func (p *YQLParser) Row_pattern_measure_definition() (localctx IRow_pattern_measure_definitionContext) {
	localctx = NewRow_pattern_measure_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, YQLParserRULE_row_pattern_measure_definition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2227)
		p.Expr()
	}
	{
		p.SetState(2228)
		p.Match(YQLParserAS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2229)
		p.An_id()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRow_pattern_common_syntaxContext is an interface to support dynamic dispatch.
type IRow_pattern_common_syntaxContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PATTERN() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Row_pattern() IRow_patternContext
	RPAREN() antlr.TerminalNode
	DEFINE() antlr.TerminalNode
	Row_pattern_definition_list() IRow_pattern_definition_listContext
	AFTER() antlr.TerminalNode
	MATCH() antlr.TerminalNode
	Row_pattern_skip_to() IRow_pattern_skip_toContext
	Row_pattern_initial_or_seek() IRow_pattern_initial_or_seekContext
	Row_pattern_subset_clause() IRow_pattern_subset_clauseContext

	// IsRow_pattern_common_syntaxContext differentiates from other interfaces.
	IsRow_pattern_common_syntaxContext()
}

type Row_pattern_common_syntaxContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_common_syntaxContext() *Row_pattern_common_syntaxContext {
	var p = new(Row_pattern_common_syntaxContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_common_syntax
	return p
}

func InitEmptyRow_pattern_common_syntaxContext(p *Row_pattern_common_syntaxContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_common_syntax
}

func (*Row_pattern_common_syntaxContext) IsRow_pattern_common_syntaxContext() {}

func NewRow_pattern_common_syntaxContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_common_syntaxContext {
	var p = new(Row_pattern_common_syntaxContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_row_pattern_common_syntax

	return p
}

func (s *Row_pattern_common_syntaxContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_common_syntaxContext) PATTERN() antlr.TerminalNode {
	return s.GetToken(YQLParserPATTERN, 0)
}

func (s *Row_pattern_common_syntaxContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Row_pattern_common_syntaxContext) Row_pattern() IRow_patternContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_patternContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_patternContext)
}

func (s *Row_pattern_common_syntaxContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Row_pattern_common_syntaxContext) DEFINE() antlr.TerminalNode {
	return s.GetToken(YQLParserDEFINE, 0)
}

func (s *Row_pattern_common_syntaxContext) Row_pattern_definition_list() IRow_pattern_definition_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_definition_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_definition_listContext)
}

func (s *Row_pattern_common_syntaxContext) AFTER() antlr.TerminalNode {
	return s.GetToken(YQLParserAFTER, 0)
}

func (s *Row_pattern_common_syntaxContext) MATCH() antlr.TerminalNode {
	return s.GetToken(YQLParserMATCH, 0)
}

func (s *Row_pattern_common_syntaxContext) Row_pattern_skip_to() IRow_pattern_skip_toContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_skip_toContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_skip_toContext)
}

func (s *Row_pattern_common_syntaxContext) Row_pattern_initial_or_seek() IRow_pattern_initial_or_seekContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_initial_or_seekContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_initial_or_seekContext)
}

func (s *Row_pattern_common_syntaxContext) Row_pattern_subset_clause() IRow_pattern_subset_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_subset_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_subset_clauseContext)
}

func (s *Row_pattern_common_syntaxContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_common_syntaxContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Row_pattern_common_syntaxContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterRow_pattern_common_syntax(s)
	}
}

func (s *Row_pattern_common_syntaxContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitRow_pattern_common_syntax(s)
	}
}




func (p *YQLParser) Row_pattern_common_syntax() (localctx IRow_pattern_common_syntaxContext) {
	localctx = NewRow_pattern_common_syntaxContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, YQLParserRULE_row_pattern_common_syntax)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2234)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserAFTER {
		{
			p.SetState(2231)
			p.Match(YQLParserAFTER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2232)
			p.Match(YQLParserMATCH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2233)
			p.Row_pattern_skip_to()
		}

	}
	p.SetState(2237)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserINITIAL || _la == YQLParserSEEK {
		{
			p.SetState(2236)
			p.Row_pattern_initial_or_seek()
		}

	}
	{
		p.SetState(2239)
		p.Match(YQLParserPATTERN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2240)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2241)
		p.Row_pattern()
	}
	{
		p.SetState(2242)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2244)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserSUBSET {
		{
			p.SetState(2243)
			p.Row_pattern_subset_clause()
		}

	}
	{
		p.SetState(2246)
		p.Match(YQLParserDEFINE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2247)
		p.Row_pattern_definition_list()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRow_pattern_skip_toContext is an interface to support dynamic dispatch.
type IRow_pattern_skip_toContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TSKIP() antlr.TerminalNode
	TO() antlr.TerminalNode
	NEXT() antlr.TerminalNode
	ROW() antlr.TerminalNode
	PAST() antlr.TerminalNode
	LAST() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	Row_pattern_skip_to_variable_name() IRow_pattern_skip_to_variable_nameContext

	// IsRow_pattern_skip_toContext differentiates from other interfaces.
	IsRow_pattern_skip_toContext()
}

type Row_pattern_skip_toContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_skip_toContext() *Row_pattern_skip_toContext {
	var p = new(Row_pattern_skip_toContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_skip_to
	return p
}

func InitEmptyRow_pattern_skip_toContext(p *Row_pattern_skip_toContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_skip_to
}

func (*Row_pattern_skip_toContext) IsRow_pattern_skip_toContext() {}

func NewRow_pattern_skip_toContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_skip_toContext {
	var p = new(Row_pattern_skip_toContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_row_pattern_skip_to

	return p
}

func (s *Row_pattern_skip_toContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_skip_toContext) TSKIP() antlr.TerminalNode {
	return s.GetToken(YQLParserTSKIP, 0)
}

func (s *Row_pattern_skip_toContext) TO() antlr.TerminalNode {
	return s.GetToken(YQLParserTO, 0)
}

func (s *Row_pattern_skip_toContext) NEXT() antlr.TerminalNode {
	return s.GetToken(YQLParserNEXT, 0)
}

func (s *Row_pattern_skip_toContext) ROW() antlr.TerminalNode {
	return s.GetToken(YQLParserROW, 0)
}

func (s *Row_pattern_skip_toContext) PAST() antlr.TerminalNode {
	return s.GetToken(YQLParserPAST, 0)
}

func (s *Row_pattern_skip_toContext) LAST() antlr.TerminalNode {
	return s.GetToken(YQLParserLAST, 0)
}

func (s *Row_pattern_skip_toContext) FIRST() antlr.TerminalNode {
	return s.GetToken(YQLParserFIRST, 0)
}

func (s *Row_pattern_skip_toContext) Row_pattern_skip_to_variable_name() IRow_pattern_skip_to_variable_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_skip_to_variable_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_skip_to_variable_nameContext)
}

func (s *Row_pattern_skip_toContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_skip_toContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Row_pattern_skip_toContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterRow_pattern_skip_to(s)
	}
}

func (s *Row_pattern_skip_toContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitRow_pattern_skip_to(s)
	}
}




func (p *YQLParser) Row_pattern_skip_to() (localctx IRow_pattern_skip_toContext) {
	localctx = NewRow_pattern_skip_toContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, YQLParserRULE_row_pattern_skip_to)
	p.SetState(2268)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 200, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2249)
			p.Match(YQLParserTSKIP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2250)
			p.Match(YQLParserTO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2251)
			p.Match(YQLParserNEXT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2252)
			p.Match(YQLParserROW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2253)
			p.Match(YQLParserTSKIP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2254)
			p.Match(YQLParserPAST)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2255)
			p.Match(YQLParserLAST)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2256)
			p.Match(YQLParserROW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2257)
			p.Match(YQLParserTSKIP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2258)
			p.Match(YQLParserTO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2259)
			p.Match(YQLParserFIRST)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2260)
			p.Row_pattern_skip_to_variable_name()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2261)
			p.Match(YQLParserTSKIP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2262)
			p.Match(YQLParserTO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2263)
			p.Match(YQLParserLAST)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2264)
			p.Row_pattern_skip_to_variable_name()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2265)
			p.Match(YQLParserTSKIP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2266)
			p.Match(YQLParserTO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2267)
			p.Row_pattern_skip_to_variable_name()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRow_pattern_skip_to_variable_nameContext is an interface to support dynamic dispatch.
type IRow_pattern_skip_to_variable_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Row_pattern_variable_name() IRow_pattern_variable_nameContext

	// IsRow_pattern_skip_to_variable_nameContext differentiates from other interfaces.
	IsRow_pattern_skip_to_variable_nameContext()
}

type Row_pattern_skip_to_variable_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_skip_to_variable_nameContext() *Row_pattern_skip_to_variable_nameContext {
	var p = new(Row_pattern_skip_to_variable_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_skip_to_variable_name
	return p
}

func InitEmptyRow_pattern_skip_to_variable_nameContext(p *Row_pattern_skip_to_variable_nameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_skip_to_variable_name
}

func (*Row_pattern_skip_to_variable_nameContext) IsRow_pattern_skip_to_variable_nameContext() {}

func NewRow_pattern_skip_to_variable_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_skip_to_variable_nameContext {
	var p = new(Row_pattern_skip_to_variable_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_row_pattern_skip_to_variable_name

	return p
}

func (s *Row_pattern_skip_to_variable_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_skip_to_variable_nameContext) Row_pattern_variable_name() IRow_pattern_variable_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_variable_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_variable_nameContext)
}

func (s *Row_pattern_skip_to_variable_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_skip_to_variable_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Row_pattern_skip_to_variable_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterRow_pattern_skip_to_variable_name(s)
	}
}

func (s *Row_pattern_skip_to_variable_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitRow_pattern_skip_to_variable_name(s)
	}
}




func (p *YQLParser) Row_pattern_skip_to_variable_name() (localctx IRow_pattern_skip_to_variable_nameContext) {
	localctx = NewRow_pattern_skip_to_variable_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, YQLParserRULE_row_pattern_skip_to_variable_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2270)
		p.Row_pattern_variable_name()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRow_pattern_initial_or_seekContext is an interface to support dynamic dispatch.
type IRow_pattern_initial_or_seekContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INITIAL() antlr.TerminalNode
	SEEK() antlr.TerminalNode

	// IsRow_pattern_initial_or_seekContext differentiates from other interfaces.
	IsRow_pattern_initial_or_seekContext()
}

type Row_pattern_initial_or_seekContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_initial_or_seekContext() *Row_pattern_initial_or_seekContext {
	var p = new(Row_pattern_initial_or_seekContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_initial_or_seek
	return p
}

func InitEmptyRow_pattern_initial_or_seekContext(p *Row_pattern_initial_or_seekContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_initial_or_seek
}

func (*Row_pattern_initial_or_seekContext) IsRow_pattern_initial_or_seekContext() {}

func NewRow_pattern_initial_or_seekContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_initial_or_seekContext {
	var p = new(Row_pattern_initial_or_seekContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_row_pattern_initial_or_seek

	return p
}

func (s *Row_pattern_initial_or_seekContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_initial_or_seekContext) INITIAL() antlr.TerminalNode {
	return s.GetToken(YQLParserINITIAL, 0)
}

func (s *Row_pattern_initial_or_seekContext) SEEK() antlr.TerminalNode {
	return s.GetToken(YQLParserSEEK, 0)
}

func (s *Row_pattern_initial_or_seekContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_initial_or_seekContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Row_pattern_initial_or_seekContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterRow_pattern_initial_or_seek(s)
	}
}

func (s *Row_pattern_initial_or_seekContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitRow_pattern_initial_or_seek(s)
	}
}




func (p *YQLParser) Row_pattern_initial_or_seek() (localctx IRow_pattern_initial_or_seekContext) {
	localctx = NewRow_pattern_initial_or_seekContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, YQLParserRULE_row_pattern_initial_or_seek)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2272)
		_la = p.GetTokenStream().LA(1)

		if !(_la == YQLParserINITIAL || _la == YQLParserSEEK) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRow_patternContext is an interface to support dynamic dispatch.
type IRow_patternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRow_pattern_term() []IRow_pattern_termContext
	Row_pattern_term(i int) IRow_pattern_termContext
	AllPIPE() []antlr.TerminalNode
	PIPE(i int) antlr.TerminalNode

	// IsRow_patternContext differentiates from other interfaces.
	IsRow_patternContext()
}

type Row_patternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_patternContext() *Row_patternContext {
	var p = new(Row_patternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern
	return p
}

func InitEmptyRow_patternContext(p *Row_patternContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern
}

func (*Row_patternContext) IsRow_patternContext() {}

func NewRow_patternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_patternContext {
	var p = new(Row_patternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_row_pattern

	return p
}

func (s *Row_patternContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_patternContext) AllRow_pattern_term() []IRow_pattern_termContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRow_pattern_termContext); ok {
			len++
		}
	}

	tst := make([]IRow_pattern_termContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRow_pattern_termContext); ok {
			tst[i] = t.(IRow_pattern_termContext)
			i++
		}
	}

	return tst
}

func (s *Row_patternContext) Row_pattern_term(i int) IRow_pattern_termContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_termContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_termContext)
}

func (s *Row_patternContext) AllPIPE() []antlr.TerminalNode {
	return s.GetTokens(YQLParserPIPE)
}

func (s *Row_patternContext) PIPE(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserPIPE, i)
}

func (s *Row_patternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_patternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Row_patternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterRow_pattern(s)
	}
}

func (s *Row_patternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitRow_pattern(s)
	}
}




func (p *YQLParser) Row_pattern() (localctx IRow_patternContext) {
	localctx = NewRow_patternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, YQLParserRULE_row_pattern)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2274)
		p.Row_pattern_term()
	}
	p.SetState(2279)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserPIPE {
		{
			p.SetState(2275)
			p.Match(YQLParserPIPE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2276)
			p.Row_pattern_term()
		}


		p.SetState(2281)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRow_pattern_termContext is an interface to support dynamic dispatch.
type IRow_pattern_termContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRow_pattern_factor() []IRow_pattern_factorContext
	Row_pattern_factor(i int) IRow_pattern_factorContext

	// IsRow_pattern_termContext differentiates from other interfaces.
	IsRow_pattern_termContext()
}

type Row_pattern_termContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_termContext() *Row_pattern_termContext {
	var p = new(Row_pattern_termContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_term
	return p
}

func InitEmptyRow_pattern_termContext(p *Row_pattern_termContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_term
}

func (*Row_pattern_termContext) IsRow_pattern_termContext() {}

func NewRow_pattern_termContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_termContext {
	var p = new(Row_pattern_termContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_row_pattern_term

	return p
}

func (s *Row_pattern_termContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_termContext) AllRow_pattern_factor() []IRow_pattern_factorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRow_pattern_factorContext); ok {
			len++
		}
	}

	tst := make([]IRow_pattern_factorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRow_pattern_factorContext); ok {
			tst[i] = t.(IRow_pattern_factorContext)
			i++
		}
	}

	return tst
}

func (s *Row_pattern_termContext) Row_pattern_factor(i int) IRow_pattern_factorContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_factorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_factorContext)
}

func (s *Row_pattern_termContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_termContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Row_pattern_termContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterRow_pattern_term(s)
	}
}

func (s *Row_pattern_termContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitRow_pattern_term(s)
	}
}




func (p *YQLParser) Row_pattern_term() (localctx IRow_pattern_termContext) {
	localctx = NewRow_pattern_termContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, YQLParserRULE_row_pattern_term)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2283)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 11844714496) != 0) || _la == YQLParserPERMUTE || _la == YQLParserID_PLAIN || _la == YQLParserID_QUOTED {
		{
			p.SetState(2282)
			p.Row_pattern_factor()
		}


		p.SetState(2285)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRow_pattern_factorContext is an interface to support dynamic dispatch.
type IRow_pattern_factorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Row_pattern_primary() IRow_pattern_primaryContext
	Row_pattern_quantifier() IRow_pattern_quantifierContext

	// IsRow_pattern_factorContext differentiates from other interfaces.
	IsRow_pattern_factorContext()
}

type Row_pattern_factorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_factorContext() *Row_pattern_factorContext {
	var p = new(Row_pattern_factorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_factor
	return p
}

func InitEmptyRow_pattern_factorContext(p *Row_pattern_factorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_factor
}

func (*Row_pattern_factorContext) IsRow_pattern_factorContext() {}

func NewRow_pattern_factorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_factorContext {
	var p = new(Row_pattern_factorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_row_pattern_factor

	return p
}

func (s *Row_pattern_factorContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_factorContext) Row_pattern_primary() IRow_pattern_primaryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_primaryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_primaryContext)
}

func (s *Row_pattern_factorContext) Row_pattern_quantifier() IRow_pattern_quantifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_quantifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_quantifierContext)
}

func (s *Row_pattern_factorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_factorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Row_pattern_factorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterRow_pattern_factor(s)
	}
}

func (s *Row_pattern_factorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitRow_pattern_factor(s)
	}
}




func (p *YQLParser) Row_pattern_factor() (localctx IRow_pattern_factorContext) {
	localctx = NewRow_pattern_factorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, YQLParserRULE_row_pattern_factor)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2287)
		p.Row_pattern_primary()
	}
	p.SetState(2289)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 203, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2288)
			p.Row_pattern_quantifier()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRow_pattern_quantifierContext is an interface to support dynamic dispatch.
type IRow_pattern_quantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASTERISK() antlr.TerminalNode
	AllQUESTION() []antlr.TerminalNode
	QUESTION(i int) antlr.TerminalNode
	PLUS() antlr.TerminalNode
	LBRACE_CURLY() antlr.TerminalNode
	COMMA() antlr.TerminalNode
	RBRACE_CURLY() antlr.TerminalNode
	AllInteger() []IIntegerContext
	Integer(i int) IIntegerContext

	// IsRow_pattern_quantifierContext differentiates from other interfaces.
	IsRow_pattern_quantifierContext()
}

type Row_pattern_quantifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_quantifierContext() *Row_pattern_quantifierContext {
	var p = new(Row_pattern_quantifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_quantifier
	return p
}

func InitEmptyRow_pattern_quantifierContext(p *Row_pattern_quantifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_quantifier
}

func (*Row_pattern_quantifierContext) IsRow_pattern_quantifierContext() {}

func NewRow_pattern_quantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_quantifierContext {
	var p = new(Row_pattern_quantifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_row_pattern_quantifier

	return p
}

func (s *Row_pattern_quantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_quantifierContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(YQLParserASTERISK, 0)
}

func (s *Row_pattern_quantifierContext) AllQUESTION() []antlr.TerminalNode {
	return s.GetTokens(YQLParserQUESTION)
}

func (s *Row_pattern_quantifierContext) QUESTION(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserQUESTION, i)
}

func (s *Row_pattern_quantifierContext) PLUS() antlr.TerminalNode {
	return s.GetToken(YQLParserPLUS, 0)
}

func (s *Row_pattern_quantifierContext) LBRACE_CURLY() antlr.TerminalNode {
	return s.GetToken(YQLParserLBRACE_CURLY, 0)
}

func (s *Row_pattern_quantifierContext) COMMA() antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, 0)
}

func (s *Row_pattern_quantifierContext) RBRACE_CURLY() antlr.TerminalNode {
	return s.GetToken(YQLParserRBRACE_CURLY, 0)
}

func (s *Row_pattern_quantifierContext) AllInteger() []IIntegerContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIntegerContext); ok {
			len++
		}
	}

	tst := make([]IIntegerContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIntegerContext); ok {
			tst[i] = t.(IIntegerContext)
			i++
		}
	}

	return tst
}

func (s *Row_pattern_quantifierContext) Integer(i int) IIntegerContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerContext)
}

func (s *Row_pattern_quantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_quantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Row_pattern_quantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterRow_pattern_quantifier(s)
	}
}

func (s *Row_pattern_quantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitRow_pattern_quantifier(s)
	}
}




func (p *YQLParser) Row_pattern_quantifier() (localctx IRow_pattern_quantifierContext) {
	localctx = NewRow_pattern_quantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, YQLParserRULE_row_pattern_quantifier)
	var _la int

	p.SetState(2319)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 210, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2291)
			p.Match(YQLParserASTERISK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2293)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserQUESTION {
			{
				p.SetState(2292)
				p.Match(YQLParserQUESTION)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2295)
			p.Match(YQLParserPLUS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2297)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserQUESTION {
			{
				p.SetState(2296)
				p.Match(YQLParserQUESTION)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2299)
			p.Match(YQLParserQUESTION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2301)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserQUESTION {
			{
				p.SetState(2300)
				p.Match(YQLParserQUESTION)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2303)
			p.Match(YQLParserLBRACE_CURLY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2305)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserDIGITS || _la == YQLParserINTEGER_VALUE {
			{
				p.SetState(2304)
				p.Integer()
			}

		}
		{
			p.SetState(2307)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2309)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserDIGITS || _la == YQLParserINTEGER_VALUE {
			{
				p.SetState(2308)
				p.Integer()
			}

		}
		{
			p.SetState(2311)
			p.Match(YQLParserRBRACE_CURLY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2313)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserQUESTION {
			{
				p.SetState(2312)
				p.Match(YQLParserQUESTION)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2315)
			p.Match(YQLParserLBRACE_CURLY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2316)
			p.Integer()
		}
		{
			p.SetState(2317)
			p.Match(YQLParserRBRACE_CURLY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRow_pattern_primaryContext is an interface to support dynamic dispatch.
type IRow_pattern_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Row_pattern_primary_variable_name() IRow_pattern_primary_variable_nameContext
	DOLLAR() antlr.TerminalNode
	CARET() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Row_pattern() IRow_patternContext
	LBRACE_CURLY() antlr.TerminalNode
	AllMINUS() []antlr.TerminalNode
	MINUS(i int) antlr.TerminalNode
	RBRACE_CURLY() antlr.TerminalNode
	Row_pattern_permute() IRow_pattern_permuteContext

	// IsRow_pattern_primaryContext differentiates from other interfaces.
	IsRow_pattern_primaryContext()
}

type Row_pattern_primaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_primaryContext() *Row_pattern_primaryContext {
	var p = new(Row_pattern_primaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_primary
	return p
}

func InitEmptyRow_pattern_primaryContext(p *Row_pattern_primaryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_primary
}

func (*Row_pattern_primaryContext) IsRow_pattern_primaryContext() {}

func NewRow_pattern_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_primaryContext {
	var p = new(Row_pattern_primaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_row_pattern_primary

	return p
}

func (s *Row_pattern_primaryContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_primaryContext) Row_pattern_primary_variable_name() IRow_pattern_primary_variable_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_primary_variable_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_primary_variable_nameContext)
}

func (s *Row_pattern_primaryContext) DOLLAR() antlr.TerminalNode {
	return s.GetToken(YQLParserDOLLAR, 0)
}

func (s *Row_pattern_primaryContext) CARET() antlr.TerminalNode {
	return s.GetToken(YQLParserCARET, 0)
}

func (s *Row_pattern_primaryContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Row_pattern_primaryContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Row_pattern_primaryContext) Row_pattern() IRow_patternContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_patternContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_patternContext)
}

func (s *Row_pattern_primaryContext) LBRACE_CURLY() antlr.TerminalNode {
	return s.GetToken(YQLParserLBRACE_CURLY, 0)
}

func (s *Row_pattern_primaryContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(YQLParserMINUS)
}

func (s *Row_pattern_primaryContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserMINUS, i)
}

func (s *Row_pattern_primaryContext) RBRACE_CURLY() antlr.TerminalNode {
	return s.GetToken(YQLParserRBRACE_CURLY, 0)
}

func (s *Row_pattern_primaryContext) Row_pattern_permute() IRow_pattern_permuteContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_permuteContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_permuteContext)
}

func (s *Row_pattern_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Row_pattern_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterRow_pattern_primary(s)
	}
}

func (s *Row_pattern_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitRow_pattern_primary(s)
	}
}




func (p *YQLParser) Row_pattern_primary() (localctx IRow_pattern_primaryContext) {
	localctx = NewRow_pattern_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, YQLParserRULE_row_pattern_primary)
	var _la int

	p.SetState(2336)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserID_PLAIN, YQLParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2321)
			p.Row_pattern_primary_variable_name()
		}


	case YQLParserDOLLAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2322)
			p.Match(YQLParserDOLLAR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserCARET:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2323)
			p.Match(YQLParserCARET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserLPAREN:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2324)
			p.Match(YQLParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2326)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 11844714496) != 0) || _la == YQLParserPERMUTE || _la == YQLParserID_PLAIN || _la == YQLParserID_QUOTED {
			{
				p.SetState(2325)
				p.Row_pattern()
			}

		}
		{
			p.SetState(2328)
			p.Match(YQLParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserLBRACE_CURLY:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2329)
			p.Match(YQLParserLBRACE_CURLY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2330)
			p.Match(YQLParserMINUS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2331)
			p.Row_pattern()
		}
		{
			p.SetState(2332)
			p.Match(YQLParserMINUS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2333)
			p.Match(YQLParserRBRACE_CURLY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserPERMUTE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2335)
			p.Row_pattern_permute()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRow_pattern_primary_variable_nameContext is an interface to support dynamic dispatch.
type IRow_pattern_primary_variable_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Row_pattern_variable_name() IRow_pattern_variable_nameContext

	// IsRow_pattern_primary_variable_nameContext differentiates from other interfaces.
	IsRow_pattern_primary_variable_nameContext()
}

type Row_pattern_primary_variable_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_primary_variable_nameContext() *Row_pattern_primary_variable_nameContext {
	var p = new(Row_pattern_primary_variable_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_primary_variable_name
	return p
}

func InitEmptyRow_pattern_primary_variable_nameContext(p *Row_pattern_primary_variable_nameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_primary_variable_name
}

func (*Row_pattern_primary_variable_nameContext) IsRow_pattern_primary_variable_nameContext() {}

func NewRow_pattern_primary_variable_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_primary_variable_nameContext {
	var p = new(Row_pattern_primary_variable_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_row_pattern_primary_variable_name

	return p
}

func (s *Row_pattern_primary_variable_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_primary_variable_nameContext) Row_pattern_variable_name() IRow_pattern_variable_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_variable_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_variable_nameContext)
}

func (s *Row_pattern_primary_variable_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_primary_variable_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Row_pattern_primary_variable_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterRow_pattern_primary_variable_name(s)
	}
}

func (s *Row_pattern_primary_variable_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitRow_pattern_primary_variable_name(s)
	}
}




func (p *YQLParser) Row_pattern_primary_variable_name() (localctx IRow_pattern_primary_variable_nameContext) {
	localctx = NewRow_pattern_primary_variable_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, YQLParserRULE_row_pattern_primary_variable_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2338)
		p.Row_pattern_variable_name()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRow_pattern_permuteContext is an interface to support dynamic dispatch.
type IRow_pattern_permuteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PERMUTE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllRow_pattern() []IRow_patternContext
	Row_pattern(i int) IRow_patternContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRow_pattern_permuteContext differentiates from other interfaces.
	IsRow_pattern_permuteContext()
}

type Row_pattern_permuteContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_permuteContext() *Row_pattern_permuteContext {
	var p = new(Row_pattern_permuteContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_permute
	return p
}

func InitEmptyRow_pattern_permuteContext(p *Row_pattern_permuteContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_permute
}

func (*Row_pattern_permuteContext) IsRow_pattern_permuteContext() {}

func NewRow_pattern_permuteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_permuteContext {
	var p = new(Row_pattern_permuteContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_row_pattern_permute

	return p
}

func (s *Row_pattern_permuteContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_permuteContext) PERMUTE() antlr.TerminalNode {
	return s.GetToken(YQLParserPERMUTE, 0)
}

func (s *Row_pattern_permuteContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Row_pattern_permuteContext) AllRow_pattern() []IRow_patternContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRow_patternContext); ok {
			len++
		}
	}

	tst := make([]IRow_patternContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRow_patternContext); ok {
			tst[i] = t.(IRow_patternContext)
			i++
		}
	}

	return tst
}

func (s *Row_pattern_permuteContext) Row_pattern(i int) IRow_patternContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_patternContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_patternContext)
}

func (s *Row_pattern_permuteContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Row_pattern_permuteContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Row_pattern_permuteContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Row_pattern_permuteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_permuteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Row_pattern_permuteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterRow_pattern_permute(s)
	}
}

func (s *Row_pattern_permuteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitRow_pattern_permute(s)
	}
}




func (p *YQLParser) Row_pattern_permute() (localctx IRow_pattern_permuteContext) {
	localctx = NewRow_pattern_permuteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, YQLParserRULE_row_pattern_permute)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2340)
		p.Match(YQLParserPERMUTE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2341)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2342)
		p.Row_pattern()
	}
	p.SetState(2347)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(2343)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2344)
			p.Row_pattern()
		}


		p.SetState(2349)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2350)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRow_pattern_subset_clauseContext is an interface to support dynamic dispatch.
type IRow_pattern_subset_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUBSET() antlr.TerminalNode
	Row_pattern_subset_list() IRow_pattern_subset_listContext

	// IsRow_pattern_subset_clauseContext differentiates from other interfaces.
	IsRow_pattern_subset_clauseContext()
}

type Row_pattern_subset_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_subset_clauseContext() *Row_pattern_subset_clauseContext {
	var p = new(Row_pattern_subset_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_subset_clause
	return p
}

func InitEmptyRow_pattern_subset_clauseContext(p *Row_pattern_subset_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_subset_clause
}

func (*Row_pattern_subset_clauseContext) IsRow_pattern_subset_clauseContext() {}

func NewRow_pattern_subset_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_subset_clauseContext {
	var p = new(Row_pattern_subset_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_row_pattern_subset_clause

	return p
}

func (s *Row_pattern_subset_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_subset_clauseContext) SUBSET() antlr.TerminalNode {
	return s.GetToken(YQLParserSUBSET, 0)
}

func (s *Row_pattern_subset_clauseContext) Row_pattern_subset_list() IRow_pattern_subset_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_subset_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_subset_listContext)
}

func (s *Row_pattern_subset_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_subset_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Row_pattern_subset_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterRow_pattern_subset_clause(s)
	}
}

func (s *Row_pattern_subset_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitRow_pattern_subset_clause(s)
	}
}




func (p *YQLParser) Row_pattern_subset_clause() (localctx IRow_pattern_subset_clauseContext) {
	localctx = NewRow_pattern_subset_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, YQLParserRULE_row_pattern_subset_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2352)
		p.Match(YQLParserSUBSET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2353)
		p.Row_pattern_subset_list()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRow_pattern_subset_listContext is an interface to support dynamic dispatch.
type IRow_pattern_subset_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRow_pattern_subset_item() []IRow_pattern_subset_itemContext
	Row_pattern_subset_item(i int) IRow_pattern_subset_itemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRow_pattern_subset_listContext differentiates from other interfaces.
	IsRow_pattern_subset_listContext()
}

type Row_pattern_subset_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_subset_listContext() *Row_pattern_subset_listContext {
	var p = new(Row_pattern_subset_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_subset_list
	return p
}

func InitEmptyRow_pattern_subset_listContext(p *Row_pattern_subset_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_subset_list
}

func (*Row_pattern_subset_listContext) IsRow_pattern_subset_listContext() {}

func NewRow_pattern_subset_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_subset_listContext {
	var p = new(Row_pattern_subset_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_row_pattern_subset_list

	return p
}

func (s *Row_pattern_subset_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_subset_listContext) AllRow_pattern_subset_item() []IRow_pattern_subset_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRow_pattern_subset_itemContext); ok {
			len++
		}
	}

	tst := make([]IRow_pattern_subset_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRow_pattern_subset_itemContext); ok {
			tst[i] = t.(IRow_pattern_subset_itemContext)
			i++
		}
	}

	return tst
}

func (s *Row_pattern_subset_listContext) Row_pattern_subset_item(i int) IRow_pattern_subset_itemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_subset_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_subset_itemContext)
}

func (s *Row_pattern_subset_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Row_pattern_subset_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Row_pattern_subset_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_subset_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Row_pattern_subset_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterRow_pattern_subset_list(s)
	}
}

func (s *Row_pattern_subset_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitRow_pattern_subset_list(s)
	}
}




func (p *YQLParser) Row_pattern_subset_list() (localctx IRow_pattern_subset_listContext) {
	localctx = NewRow_pattern_subset_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, YQLParserRULE_row_pattern_subset_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2355)
		p.Row_pattern_subset_item()
	}
	p.SetState(2360)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(2356)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2357)
			p.Row_pattern_subset_item()
		}


		p.SetState(2362)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRow_pattern_subset_itemContext is an interface to support dynamic dispatch.
type IRow_pattern_subset_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Row_pattern_subset_item_variable_name() IRow_pattern_subset_item_variable_nameContext
	EQUALS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Row_pattern_subset_rhs() IRow_pattern_subset_rhsContext
	RPAREN() antlr.TerminalNode

	// IsRow_pattern_subset_itemContext differentiates from other interfaces.
	IsRow_pattern_subset_itemContext()
}

type Row_pattern_subset_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_subset_itemContext() *Row_pattern_subset_itemContext {
	var p = new(Row_pattern_subset_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_subset_item
	return p
}

func InitEmptyRow_pattern_subset_itemContext(p *Row_pattern_subset_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_subset_item
}

func (*Row_pattern_subset_itemContext) IsRow_pattern_subset_itemContext() {}

func NewRow_pattern_subset_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_subset_itemContext {
	var p = new(Row_pattern_subset_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_row_pattern_subset_item

	return p
}

func (s *Row_pattern_subset_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_subset_itemContext) Row_pattern_subset_item_variable_name() IRow_pattern_subset_item_variable_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_subset_item_variable_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_subset_item_variable_nameContext)
}

func (s *Row_pattern_subset_itemContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(YQLParserEQUALS, 0)
}

func (s *Row_pattern_subset_itemContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Row_pattern_subset_itemContext) Row_pattern_subset_rhs() IRow_pattern_subset_rhsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_subset_rhsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_subset_rhsContext)
}

func (s *Row_pattern_subset_itemContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Row_pattern_subset_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_subset_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Row_pattern_subset_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterRow_pattern_subset_item(s)
	}
}

func (s *Row_pattern_subset_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitRow_pattern_subset_item(s)
	}
}




func (p *YQLParser) Row_pattern_subset_item() (localctx IRow_pattern_subset_itemContext) {
	localctx = NewRow_pattern_subset_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, YQLParserRULE_row_pattern_subset_item)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2363)
		p.Row_pattern_subset_item_variable_name()
	}
	{
		p.SetState(2364)
		p.Match(YQLParserEQUALS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2365)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2366)
		p.Row_pattern_subset_rhs()
	}
	{
		p.SetState(2367)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRow_pattern_subset_item_variable_nameContext is an interface to support dynamic dispatch.
type IRow_pattern_subset_item_variable_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Row_pattern_variable_name() IRow_pattern_variable_nameContext

	// IsRow_pattern_subset_item_variable_nameContext differentiates from other interfaces.
	IsRow_pattern_subset_item_variable_nameContext()
}

type Row_pattern_subset_item_variable_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_subset_item_variable_nameContext() *Row_pattern_subset_item_variable_nameContext {
	var p = new(Row_pattern_subset_item_variable_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_subset_item_variable_name
	return p
}

func InitEmptyRow_pattern_subset_item_variable_nameContext(p *Row_pattern_subset_item_variable_nameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_subset_item_variable_name
}

func (*Row_pattern_subset_item_variable_nameContext) IsRow_pattern_subset_item_variable_nameContext() {}

func NewRow_pattern_subset_item_variable_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_subset_item_variable_nameContext {
	var p = new(Row_pattern_subset_item_variable_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_row_pattern_subset_item_variable_name

	return p
}

func (s *Row_pattern_subset_item_variable_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_subset_item_variable_nameContext) Row_pattern_variable_name() IRow_pattern_variable_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_variable_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_variable_nameContext)
}

func (s *Row_pattern_subset_item_variable_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_subset_item_variable_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Row_pattern_subset_item_variable_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterRow_pattern_subset_item_variable_name(s)
	}
}

func (s *Row_pattern_subset_item_variable_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitRow_pattern_subset_item_variable_name(s)
	}
}




func (p *YQLParser) Row_pattern_subset_item_variable_name() (localctx IRow_pattern_subset_item_variable_nameContext) {
	localctx = NewRow_pattern_subset_item_variable_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, YQLParserRULE_row_pattern_subset_item_variable_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2369)
		p.Row_pattern_variable_name()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRow_pattern_subset_rhsContext is an interface to support dynamic dispatch.
type IRow_pattern_subset_rhsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRow_pattern_subset_rhs_variable_name() []IRow_pattern_subset_rhs_variable_nameContext
	Row_pattern_subset_rhs_variable_name(i int) IRow_pattern_subset_rhs_variable_nameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRow_pattern_subset_rhsContext differentiates from other interfaces.
	IsRow_pattern_subset_rhsContext()
}

type Row_pattern_subset_rhsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_subset_rhsContext() *Row_pattern_subset_rhsContext {
	var p = new(Row_pattern_subset_rhsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_subset_rhs
	return p
}

func InitEmptyRow_pattern_subset_rhsContext(p *Row_pattern_subset_rhsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_subset_rhs
}

func (*Row_pattern_subset_rhsContext) IsRow_pattern_subset_rhsContext() {}

func NewRow_pattern_subset_rhsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_subset_rhsContext {
	var p = new(Row_pattern_subset_rhsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_row_pattern_subset_rhs

	return p
}

func (s *Row_pattern_subset_rhsContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_subset_rhsContext) AllRow_pattern_subset_rhs_variable_name() []IRow_pattern_subset_rhs_variable_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRow_pattern_subset_rhs_variable_nameContext); ok {
			len++
		}
	}

	tst := make([]IRow_pattern_subset_rhs_variable_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRow_pattern_subset_rhs_variable_nameContext); ok {
			tst[i] = t.(IRow_pattern_subset_rhs_variable_nameContext)
			i++
		}
	}

	return tst
}

func (s *Row_pattern_subset_rhsContext) Row_pattern_subset_rhs_variable_name(i int) IRow_pattern_subset_rhs_variable_nameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_subset_rhs_variable_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_subset_rhs_variable_nameContext)
}

func (s *Row_pattern_subset_rhsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Row_pattern_subset_rhsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Row_pattern_subset_rhsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_subset_rhsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Row_pattern_subset_rhsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterRow_pattern_subset_rhs(s)
	}
}

func (s *Row_pattern_subset_rhsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitRow_pattern_subset_rhs(s)
	}
}




func (p *YQLParser) Row_pattern_subset_rhs() (localctx IRow_pattern_subset_rhsContext) {
	localctx = NewRow_pattern_subset_rhsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, YQLParserRULE_row_pattern_subset_rhs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2371)
		p.Row_pattern_subset_rhs_variable_name()
	}
	p.SetState(2376)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(2372)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2373)
			p.Row_pattern_subset_rhs_variable_name()
		}


		p.SetState(2378)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRow_pattern_subset_rhs_variable_nameContext is an interface to support dynamic dispatch.
type IRow_pattern_subset_rhs_variable_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Row_pattern_variable_name() IRow_pattern_variable_nameContext

	// IsRow_pattern_subset_rhs_variable_nameContext differentiates from other interfaces.
	IsRow_pattern_subset_rhs_variable_nameContext()
}

type Row_pattern_subset_rhs_variable_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_subset_rhs_variable_nameContext() *Row_pattern_subset_rhs_variable_nameContext {
	var p = new(Row_pattern_subset_rhs_variable_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_subset_rhs_variable_name
	return p
}

func InitEmptyRow_pattern_subset_rhs_variable_nameContext(p *Row_pattern_subset_rhs_variable_nameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_subset_rhs_variable_name
}

func (*Row_pattern_subset_rhs_variable_nameContext) IsRow_pattern_subset_rhs_variable_nameContext() {}

func NewRow_pattern_subset_rhs_variable_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_subset_rhs_variable_nameContext {
	var p = new(Row_pattern_subset_rhs_variable_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_row_pattern_subset_rhs_variable_name

	return p
}

func (s *Row_pattern_subset_rhs_variable_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_subset_rhs_variable_nameContext) Row_pattern_variable_name() IRow_pattern_variable_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_variable_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_variable_nameContext)
}

func (s *Row_pattern_subset_rhs_variable_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_subset_rhs_variable_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Row_pattern_subset_rhs_variable_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterRow_pattern_subset_rhs_variable_name(s)
	}
}

func (s *Row_pattern_subset_rhs_variable_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitRow_pattern_subset_rhs_variable_name(s)
	}
}




func (p *YQLParser) Row_pattern_subset_rhs_variable_name() (localctx IRow_pattern_subset_rhs_variable_nameContext) {
	localctx = NewRow_pattern_subset_rhs_variable_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, YQLParserRULE_row_pattern_subset_rhs_variable_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2379)
		p.Row_pattern_variable_name()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRow_pattern_definition_listContext is an interface to support dynamic dispatch.
type IRow_pattern_definition_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRow_pattern_definition() []IRow_pattern_definitionContext
	Row_pattern_definition(i int) IRow_pattern_definitionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRow_pattern_definition_listContext differentiates from other interfaces.
	IsRow_pattern_definition_listContext()
}

type Row_pattern_definition_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_definition_listContext() *Row_pattern_definition_listContext {
	var p = new(Row_pattern_definition_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_definition_list
	return p
}

func InitEmptyRow_pattern_definition_listContext(p *Row_pattern_definition_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_definition_list
}

func (*Row_pattern_definition_listContext) IsRow_pattern_definition_listContext() {}

func NewRow_pattern_definition_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_definition_listContext {
	var p = new(Row_pattern_definition_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_row_pattern_definition_list

	return p
}

func (s *Row_pattern_definition_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_definition_listContext) AllRow_pattern_definition() []IRow_pattern_definitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRow_pattern_definitionContext); ok {
			len++
		}
	}

	tst := make([]IRow_pattern_definitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRow_pattern_definitionContext); ok {
			tst[i] = t.(IRow_pattern_definitionContext)
			i++
		}
	}

	return tst
}

func (s *Row_pattern_definition_listContext) Row_pattern_definition(i int) IRow_pattern_definitionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_definitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_definitionContext)
}

func (s *Row_pattern_definition_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Row_pattern_definition_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Row_pattern_definition_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_definition_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Row_pattern_definition_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterRow_pattern_definition_list(s)
	}
}

func (s *Row_pattern_definition_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitRow_pattern_definition_list(s)
	}
}




func (p *YQLParser) Row_pattern_definition_list() (localctx IRow_pattern_definition_listContext) {
	localctx = NewRow_pattern_definition_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, YQLParserRULE_row_pattern_definition_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2381)
		p.Row_pattern_definition()
	}
	p.SetState(2386)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(2382)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2383)
			p.Row_pattern_definition()
		}


		p.SetState(2388)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRow_pattern_definitionContext is an interface to support dynamic dispatch.
type IRow_pattern_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Row_pattern_definition_variable_name() IRow_pattern_definition_variable_nameContext
	AS() antlr.TerminalNode
	Row_pattern_definition_search_condition() IRow_pattern_definition_search_conditionContext

	// IsRow_pattern_definitionContext differentiates from other interfaces.
	IsRow_pattern_definitionContext()
}

type Row_pattern_definitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_definitionContext() *Row_pattern_definitionContext {
	var p = new(Row_pattern_definitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_definition
	return p
}

func InitEmptyRow_pattern_definitionContext(p *Row_pattern_definitionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_definition
}

func (*Row_pattern_definitionContext) IsRow_pattern_definitionContext() {}

func NewRow_pattern_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_definitionContext {
	var p = new(Row_pattern_definitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_row_pattern_definition

	return p
}

func (s *Row_pattern_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_definitionContext) Row_pattern_definition_variable_name() IRow_pattern_definition_variable_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_definition_variable_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_definition_variable_nameContext)
}

func (s *Row_pattern_definitionContext) AS() antlr.TerminalNode {
	return s.GetToken(YQLParserAS, 0)
}

func (s *Row_pattern_definitionContext) Row_pattern_definition_search_condition() IRow_pattern_definition_search_conditionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_definition_search_conditionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_definition_search_conditionContext)
}

func (s *Row_pattern_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Row_pattern_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterRow_pattern_definition(s)
	}
}

func (s *Row_pattern_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitRow_pattern_definition(s)
	}
}




func (p *YQLParser) Row_pattern_definition() (localctx IRow_pattern_definitionContext) {
	localctx = NewRow_pattern_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, YQLParserRULE_row_pattern_definition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2389)
		p.Row_pattern_definition_variable_name()
	}
	{
		p.SetState(2390)
		p.Match(YQLParserAS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2391)
		p.Row_pattern_definition_search_condition()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRow_pattern_definition_variable_nameContext is an interface to support dynamic dispatch.
type IRow_pattern_definition_variable_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Row_pattern_variable_name() IRow_pattern_variable_nameContext

	// IsRow_pattern_definition_variable_nameContext differentiates from other interfaces.
	IsRow_pattern_definition_variable_nameContext()
}

type Row_pattern_definition_variable_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_definition_variable_nameContext() *Row_pattern_definition_variable_nameContext {
	var p = new(Row_pattern_definition_variable_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_definition_variable_name
	return p
}

func InitEmptyRow_pattern_definition_variable_nameContext(p *Row_pattern_definition_variable_nameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_definition_variable_name
}

func (*Row_pattern_definition_variable_nameContext) IsRow_pattern_definition_variable_nameContext() {}

func NewRow_pattern_definition_variable_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_definition_variable_nameContext {
	var p = new(Row_pattern_definition_variable_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_row_pattern_definition_variable_name

	return p
}

func (s *Row_pattern_definition_variable_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_definition_variable_nameContext) Row_pattern_variable_name() IRow_pattern_variable_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_variable_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_variable_nameContext)
}

func (s *Row_pattern_definition_variable_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_definition_variable_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Row_pattern_definition_variable_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterRow_pattern_definition_variable_name(s)
	}
}

func (s *Row_pattern_definition_variable_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitRow_pattern_definition_variable_name(s)
	}
}




func (p *YQLParser) Row_pattern_definition_variable_name() (localctx IRow_pattern_definition_variable_nameContext) {
	localctx = NewRow_pattern_definition_variable_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, YQLParserRULE_row_pattern_definition_variable_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2393)
		p.Row_pattern_variable_name()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRow_pattern_definition_search_conditionContext is an interface to support dynamic dispatch.
type IRow_pattern_definition_search_conditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Search_condition() ISearch_conditionContext

	// IsRow_pattern_definition_search_conditionContext differentiates from other interfaces.
	IsRow_pattern_definition_search_conditionContext()
}

type Row_pattern_definition_search_conditionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_definition_search_conditionContext() *Row_pattern_definition_search_conditionContext {
	var p = new(Row_pattern_definition_search_conditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_definition_search_condition
	return p
}

func InitEmptyRow_pattern_definition_search_conditionContext(p *Row_pattern_definition_search_conditionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_definition_search_condition
}

func (*Row_pattern_definition_search_conditionContext) IsRow_pattern_definition_search_conditionContext() {}

func NewRow_pattern_definition_search_conditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_definition_search_conditionContext {
	var p = new(Row_pattern_definition_search_conditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_row_pattern_definition_search_condition

	return p
}

func (s *Row_pattern_definition_search_conditionContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_definition_search_conditionContext) Search_condition() ISearch_conditionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISearch_conditionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISearch_conditionContext)
}

func (s *Row_pattern_definition_search_conditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_definition_search_conditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Row_pattern_definition_search_conditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterRow_pattern_definition_search_condition(s)
	}
}

func (s *Row_pattern_definition_search_conditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitRow_pattern_definition_search_condition(s)
	}
}




func (p *YQLParser) Row_pattern_definition_search_condition() (localctx IRow_pattern_definition_search_conditionContext) {
	localctx = NewRow_pattern_definition_search_conditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, YQLParserRULE_row_pattern_definition_search_condition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2395)
		p.Search_condition()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISearch_conditionContext is an interface to support dynamic dispatch.
type ISearch_conditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext

	// IsSearch_conditionContext differentiates from other interfaces.
	IsSearch_conditionContext()
}

type Search_conditionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySearch_conditionContext() *Search_conditionContext {
	var p = new(Search_conditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_search_condition
	return p
}

func InitEmptySearch_conditionContext(p *Search_conditionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_search_condition
}

func (*Search_conditionContext) IsSearch_conditionContext() {}

func NewSearch_conditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Search_conditionContext {
	var p = new(Search_conditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_search_condition

	return p
}

func (s *Search_conditionContext) GetParser() antlr.Parser { return s.parser }

func (s *Search_conditionContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Search_conditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Search_conditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Search_conditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterSearch_condition(s)
	}
}

func (s *Search_conditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitSearch_condition(s)
	}
}




func (p *YQLParser) Search_condition() (localctx ISearch_conditionContext) {
	localctx = NewSearch_conditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, YQLParserRULE_search_condition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2397)
		p.Expr()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRow_pattern_variable_nameContext is an interface to support dynamic dispatch.
type IRow_pattern_variable_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsRow_pattern_variable_nameContext differentiates from other interfaces.
	IsRow_pattern_variable_nameContext()
}

type Row_pattern_variable_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_variable_nameContext() *Row_pattern_variable_nameContext {
	var p = new(Row_pattern_variable_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_variable_name
	return p
}

func InitEmptyRow_pattern_variable_nameContext(p *Row_pattern_variable_nameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_row_pattern_variable_name
}

func (*Row_pattern_variable_nameContext) IsRow_pattern_variable_nameContext() {}

func NewRow_pattern_variable_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_variable_nameContext {
	var p = new(Row_pattern_variable_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_row_pattern_variable_name

	return p
}

func (s *Row_pattern_variable_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_variable_nameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Row_pattern_variable_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_variable_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Row_pattern_variable_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterRow_pattern_variable_name(s)
	}
}

func (s *Row_pattern_variable_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitRow_pattern_variable_name(s)
	}
}




func (p *YQLParser) Row_pattern_variable_name() (localctx IRow_pattern_variable_nameContext) {
	localctx = NewRow_pattern_variable_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, YQLParserRULE_row_pattern_variable_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2399)
		p.Identifier()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOrder_by_clauseContext is an interface to support dynamic dispatch.
type IOrder_by_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	Sort_specification_list() ISort_specification_listContext

	// IsOrder_by_clauseContext differentiates from other interfaces.
	IsOrder_by_clauseContext()
}

type Order_by_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrder_by_clauseContext() *Order_by_clauseContext {
	var p = new(Order_by_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_order_by_clause
	return p
}

func InitEmptyOrder_by_clauseContext(p *Order_by_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_order_by_clause
}

func (*Order_by_clauseContext) IsOrder_by_clauseContext() {}

func NewOrder_by_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Order_by_clauseContext {
	var p = new(Order_by_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_order_by_clause

	return p
}

func (s *Order_by_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Order_by_clauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(YQLParserORDER, 0)
}

func (s *Order_by_clauseContext) BY() antlr.TerminalNode {
	return s.GetToken(YQLParserBY, 0)
}

func (s *Order_by_clauseContext) Sort_specification_list() ISort_specification_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISort_specification_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISort_specification_listContext)
}

func (s *Order_by_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Order_by_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Order_by_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterOrder_by_clause(s)
	}
}

func (s *Order_by_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitOrder_by_clause(s)
	}
}




func (p *YQLParser) Order_by_clause() (localctx IOrder_by_clauseContext) {
	localctx = NewOrder_by_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, YQLParserRULE_order_by_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2401)
		p.Match(YQLParserORDER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2402)
		p.Match(YQLParserBY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2403)
		p.Sort_specification_list()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExt_order_by_clauseContext is an interface to support dynamic dispatch.
type IExt_order_by_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Order_by_clause() IOrder_by_clauseContext
	ASSUME() antlr.TerminalNode

	// IsExt_order_by_clauseContext differentiates from other interfaces.
	IsExt_order_by_clauseContext()
}

type Ext_order_by_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExt_order_by_clauseContext() *Ext_order_by_clauseContext {
	var p = new(Ext_order_by_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_ext_order_by_clause
	return p
}

func InitEmptyExt_order_by_clauseContext(p *Ext_order_by_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_ext_order_by_clause
}

func (*Ext_order_by_clauseContext) IsExt_order_by_clauseContext() {}

func NewExt_order_by_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ext_order_by_clauseContext {
	var p = new(Ext_order_by_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_ext_order_by_clause

	return p
}

func (s *Ext_order_by_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Ext_order_by_clauseContext) Order_by_clause() IOrder_by_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrder_by_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrder_by_clauseContext)
}

func (s *Ext_order_by_clauseContext) ASSUME() antlr.TerminalNode {
	return s.GetToken(YQLParserASSUME, 0)
}

func (s *Ext_order_by_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ext_order_by_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Ext_order_by_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterExt_order_by_clause(s)
	}
}

func (s *Ext_order_by_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitExt_order_by_clause(s)
	}
}




func (p *YQLParser) Ext_order_by_clause() (localctx IExt_order_by_clauseContext) {
	localctx = NewExt_order_by_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, YQLParserRULE_ext_order_by_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2406)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserASSUME {
		{
			p.SetState(2405)
			p.Match(YQLParserASSUME)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(2408)
		p.Order_by_clause()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGroup_by_clauseContext is an interface to support dynamic dispatch.
type IGroup_by_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GROUP() antlr.TerminalNode
	BY() antlr.TerminalNode
	Opt_set_quantifier() IOpt_set_quantifierContext
	Grouping_element_list() IGrouping_element_listContext
	COMPACT() antlr.TerminalNode
	WITH() antlr.TerminalNode
	An_id() IAn_idContext

	// IsGroup_by_clauseContext differentiates from other interfaces.
	IsGroup_by_clauseContext()
}

type Group_by_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroup_by_clauseContext() *Group_by_clauseContext {
	var p = new(Group_by_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_group_by_clause
	return p
}

func InitEmptyGroup_by_clauseContext(p *Group_by_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_group_by_clause
}

func (*Group_by_clauseContext) IsGroup_by_clauseContext() {}

func NewGroup_by_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Group_by_clauseContext {
	var p = new(Group_by_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_group_by_clause

	return p
}

func (s *Group_by_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Group_by_clauseContext) GROUP() antlr.TerminalNode {
	return s.GetToken(YQLParserGROUP, 0)
}

func (s *Group_by_clauseContext) BY() antlr.TerminalNode {
	return s.GetToken(YQLParserBY, 0)
}

func (s *Group_by_clauseContext) Opt_set_quantifier() IOpt_set_quantifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_set_quantifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_set_quantifierContext)
}

func (s *Group_by_clauseContext) Grouping_element_list() IGrouping_element_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrouping_element_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrouping_element_listContext)
}

func (s *Group_by_clauseContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(YQLParserCOMPACT, 0)
}

func (s *Group_by_clauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(YQLParserWITH, 0)
}

func (s *Group_by_clauseContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Group_by_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Group_by_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Group_by_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterGroup_by_clause(s)
	}
}

func (s *Group_by_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitGroup_by_clause(s)
	}
}




func (p *YQLParser) Group_by_clause() (localctx IGroup_by_clauseContext) {
	localctx = NewGroup_by_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, YQLParserRULE_group_by_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2410)
		p.Match(YQLParserGROUP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2412)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserCOMPACT {
		{
			p.SetState(2411)
			p.Match(YQLParserCOMPACT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(2414)
		p.Match(YQLParserBY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2415)
		p.Opt_set_quantifier()
	}
	{
		p.SetState(2416)
		p.Grouping_element_list()
	}
	p.SetState(2419)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserWITH {
		{
			p.SetState(2417)
			p.Match(YQLParserWITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2418)
			p.An_id()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGrouping_element_listContext is an interface to support dynamic dispatch.
type IGrouping_element_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllGrouping_element() []IGrouping_elementContext
	Grouping_element(i int) IGrouping_elementContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsGrouping_element_listContext differentiates from other interfaces.
	IsGrouping_element_listContext()
}

type Grouping_element_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrouping_element_listContext() *Grouping_element_listContext {
	var p = new(Grouping_element_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_grouping_element_list
	return p
}

func InitEmptyGrouping_element_listContext(p *Grouping_element_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_grouping_element_list
}

func (*Grouping_element_listContext) IsGrouping_element_listContext() {}

func NewGrouping_element_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Grouping_element_listContext {
	var p = new(Grouping_element_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_grouping_element_list

	return p
}

func (s *Grouping_element_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Grouping_element_listContext) AllGrouping_element() []IGrouping_elementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGrouping_elementContext); ok {
			len++
		}
	}

	tst := make([]IGrouping_elementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGrouping_elementContext); ok {
			tst[i] = t.(IGrouping_elementContext)
			i++
		}
	}

	return tst
}

func (s *Grouping_element_listContext) Grouping_element(i int) IGrouping_elementContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrouping_elementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrouping_elementContext)
}

func (s *Grouping_element_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Grouping_element_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Grouping_element_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Grouping_element_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Grouping_element_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterGrouping_element_list(s)
	}
}

func (s *Grouping_element_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitGrouping_element_list(s)
	}
}




func (p *YQLParser) Grouping_element_list() (localctx IGrouping_element_listContext) {
	localctx = NewGrouping_element_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, YQLParserRULE_grouping_element_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2421)
		p.Grouping_element()
	}
	p.SetState(2426)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(2422)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2423)
			p.Grouping_element()
		}


		p.SetState(2428)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGrouping_elementContext is an interface to support dynamic dispatch.
type IGrouping_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Ordinary_grouping_set() IOrdinary_grouping_setContext
	Rollup_list() IRollup_listContext
	Cube_list() ICube_listContext
	Grouping_sets_specification() IGrouping_sets_specificationContext
	Hopping_window_specification() IHopping_window_specificationContext

	// IsGrouping_elementContext differentiates from other interfaces.
	IsGrouping_elementContext()
}

type Grouping_elementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrouping_elementContext() *Grouping_elementContext {
	var p = new(Grouping_elementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_grouping_element
	return p
}

func InitEmptyGrouping_elementContext(p *Grouping_elementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_grouping_element
}

func (*Grouping_elementContext) IsGrouping_elementContext() {}

func NewGrouping_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Grouping_elementContext {
	var p = new(Grouping_elementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_grouping_element

	return p
}

func (s *Grouping_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Grouping_elementContext) Ordinary_grouping_set() IOrdinary_grouping_setContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrdinary_grouping_setContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrdinary_grouping_setContext)
}

func (s *Grouping_elementContext) Rollup_list() IRollup_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollup_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollup_listContext)
}

func (s *Grouping_elementContext) Cube_list() ICube_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICube_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICube_listContext)
}

func (s *Grouping_elementContext) Grouping_sets_specification() IGrouping_sets_specificationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrouping_sets_specificationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrouping_sets_specificationContext)
}

func (s *Grouping_elementContext) Hopping_window_specification() IHopping_window_specificationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHopping_window_specificationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHopping_window_specificationContext)
}

func (s *Grouping_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Grouping_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Grouping_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterGrouping_element(s)
	}
}

func (s *Grouping_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitGrouping_element(s)
	}
}




func (p *YQLParser) Grouping_element() (localctx IGrouping_elementContext) {
	localctx = NewGrouping_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, YQLParserRULE_grouping_element)
	p.SetState(2434)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 221, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2429)
			p.Ordinary_grouping_set()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2430)
			p.Rollup_list()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2431)
			p.Cube_list()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2432)
			p.Grouping_sets_specification()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2433)
			p.Hopping_window_specification()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOrdinary_grouping_setContext is an interface to support dynamic dispatch.
type IOrdinary_grouping_setContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Named_expr() INamed_exprContext

	// IsOrdinary_grouping_setContext differentiates from other interfaces.
	IsOrdinary_grouping_setContext()
}

type Ordinary_grouping_setContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrdinary_grouping_setContext() *Ordinary_grouping_setContext {
	var p = new(Ordinary_grouping_setContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_ordinary_grouping_set
	return p
}

func InitEmptyOrdinary_grouping_setContext(p *Ordinary_grouping_setContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_ordinary_grouping_set
}

func (*Ordinary_grouping_setContext) IsOrdinary_grouping_setContext() {}

func NewOrdinary_grouping_setContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ordinary_grouping_setContext {
	var p = new(Ordinary_grouping_setContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_ordinary_grouping_set

	return p
}

func (s *Ordinary_grouping_setContext) GetParser() antlr.Parser { return s.parser }

func (s *Ordinary_grouping_setContext) Named_expr() INamed_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_exprContext)
}

func (s *Ordinary_grouping_setContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ordinary_grouping_setContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Ordinary_grouping_setContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterOrdinary_grouping_set(s)
	}
}

func (s *Ordinary_grouping_setContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitOrdinary_grouping_set(s)
	}
}




func (p *YQLParser) Ordinary_grouping_set() (localctx IOrdinary_grouping_setContext) {
	localctx = NewOrdinary_grouping_setContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, YQLParserRULE_ordinary_grouping_set)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2436)
		p.Named_expr()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOrdinary_grouping_set_listContext is an interface to support dynamic dispatch.
type IOrdinary_grouping_set_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllOrdinary_grouping_set() []IOrdinary_grouping_setContext
	Ordinary_grouping_set(i int) IOrdinary_grouping_setContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsOrdinary_grouping_set_listContext differentiates from other interfaces.
	IsOrdinary_grouping_set_listContext()
}

type Ordinary_grouping_set_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrdinary_grouping_set_listContext() *Ordinary_grouping_set_listContext {
	var p = new(Ordinary_grouping_set_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_ordinary_grouping_set_list
	return p
}

func InitEmptyOrdinary_grouping_set_listContext(p *Ordinary_grouping_set_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_ordinary_grouping_set_list
}

func (*Ordinary_grouping_set_listContext) IsOrdinary_grouping_set_listContext() {}

func NewOrdinary_grouping_set_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ordinary_grouping_set_listContext {
	var p = new(Ordinary_grouping_set_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_ordinary_grouping_set_list

	return p
}

func (s *Ordinary_grouping_set_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Ordinary_grouping_set_listContext) AllOrdinary_grouping_set() []IOrdinary_grouping_setContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOrdinary_grouping_setContext); ok {
			len++
		}
	}

	tst := make([]IOrdinary_grouping_setContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOrdinary_grouping_setContext); ok {
			tst[i] = t.(IOrdinary_grouping_setContext)
			i++
		}
	}

	return tst
}

func (s *Ordinary_grouping_set_listContext) Ordinary_grouping_set(i int) IOrdinary_grouping_setContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrdinary_grouping_setContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrdinary_grouping_setContext)
}

func (s *Ordinary_grouping_set_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Ordinary_grouping_set_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Ordinary_grouping_set_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ordinary_grouping_set_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Ordinary_grouping_set_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterOrdinary_grouping_set_list(s)
	}
}

func (s *Ordinary_grouping_set_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitOrdinary_grouping_set_list(s)
	}
}




func (p *YQLParser) Ordinary_grouping_set_list() (localctx IOrdinary_grouping_set_listContext) {
	localctx = NewOrdinary_grouping_set_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, YQLParserRULE_ordinary_grouping_set_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2438)
		p.Ordinary_grouping_set()
	}
	p.SetState(2443)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(2439)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2440)
			p.Ordinary_grouping_set()
		}


		p.SetState(2445)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRollup_listContext is an interface to support dynamic dispatch.
type IRollup_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROLLUP() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Ordinary_grouping_set_list() IOrdinary_grouping_set_listContext
	RPAREN() antlr.TerminalNode

	// IsRollup_listContext differentiates from other interfaces.
	IsRollup_listContext()
}

type Rollup_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRollup_listContext() *Rollup_listContext {
	var p = new(Rollup_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_rollup_list
	return p
}

func InitEmptyRollup_listContext(p *Rollup_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_rollup_list
}

func (*Rollup_listContext) IsRollup_listContext() {}

func NewRollup_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rollup_listContext {
	var p = new(Rollup_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_rollup_list

	return p
}

func (s *Rollup_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Rollup_listContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(YQLParserROLLUP, 0)
}

func (s *Rollup_listContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Rollup_listContext) Ordinary_grouping_set_list() IOrdinary_grouping_set_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrdinary_grouping_set_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrdinary_grouping_set_listContext)
}

func (s *Rollup_listContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Rollup_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rollup_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Rollup_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterRollup_list(s)
	}
}

func (s *Rollup_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitRollup_list(s)
	}
}




func (p *YQLParser) Rollup_list() (localctx IRollup_listContext) {
	localctx = NewRollup_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, YQLParserRULE_rollup_list)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2446)
		p.Match(YQLParserROLLUP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2447)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2448)
		p.Ordinary_grouping_set_list()
	}
	{
		p.SetState(2449)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICube_listContext is an interface to support dynamic dispatch.
type ICube_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CUBE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Ordinary_grouping_set_list() IOrdinary_grouping_set_listContext
	RPAREN() antlr.TerminalNode

	// IsCube_listContext differentiates from other interfaces.
	IsCube_listContext()
}

type Cube_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCube_listContext() *Cube_listContext {
	var p = new(Cube_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_cube_list
	return p
}

func InitEmptyCube_listContext(p *Cube_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_cube_list
}

func (*Cube_listContext) IsCube_listContext() {}

func NewCube_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cube_listContext {
	var p = new(Cube_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_cube_list

	return p
}

func (s *Cube_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Cube_listContext) CUBE() antlr.TerminalNode {
	return s.GetToken(YQLParserCUBE, 0)
}

func (s *Cube_listContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Cube_listContext) Ordinary_grouping_set_list() IOrdinary_grouping_set_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrdinary_grouping_set_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrdinary_grouping_set_listContext)
}

func (s *Cube_listContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Cube_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cube_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Cube_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterCube_list(s)
	}
}

func (s *Cube_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitCube_list(s)
	}
}




func (p *YQLParser) Cube_list() (localctx ICube_listContext) {
	localctx = NewCube_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, YQLParserRULE_cube_list)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2451)
		p.Match(YQLParserCUBE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2452)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2453)
		p.Ordinary_grouping_set_list()
	}
	{
		p.SetState(2454)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGrouping_sets_specificationContext is an interface to support dynamic dispatch.
type IGrouping_sets_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GROUPING() antlr.TerminalNode
	SETS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Grouping_element_list() IGrouping_element_listContext
	RPAREN() antlr.TerminalNode

	// IsGrouping_sets_specificationContext differentiates from other interfaces.
	IsGrouping_sets_specificationContext()
}

type Grouping_sets_specificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrouping_sets_specificationContext() *Grouping_sets_specificationContext {
	var p = new(Grouping_sets_specificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_grouping_sets_specification
	return p
}

func InitEmptyGrouping_sets_specificationContext(p *Grouping_sets_specificationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_grouping_sets_specification
}

func (*Grouping_sets_specificationContext) IsGrouping_sets_specificationContext() {}

func NewGrouping_sets_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Grouping_sets_specificationContext {
	var p = new(Grouping_sets_specificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_grouping_sets_specification

	return p
}

func (s *Grouping_sets_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Grouping_sets_specificationContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(YQLParserGROUPING, 0)
}

func (s *Grouping_sets_specificationContext) SETS() antlr.TerminalNode {
	return s.GetToken(YQLParserSETS, 0)
}

func (s *Grouping_sets_specificationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Grouping_sets_specificationContext) Grouping_element_list() IGrouping_element_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrouping_element_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrouping_element_listContext)
}

func (s *Grouping_sets_specificationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Grouping_sets_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Grouping_sets_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Grouping_sets_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterGrouping_sets_specification(s)
	}
}

func (s *Grouping_sets_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitGrouping_sets_specification(s)
	}
}




func (p *YQLParser) Grouping_sets_specification() (localctx IGrouping_sets_specificationContext) {
	localctx = NewGrouping_sets_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, YQLParserRULE_grouping_sets_specification)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2456)
		p.Match(YQLParserGROUPING)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2457)
		p.Match(YQLParserSETS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2458)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2459)
		p.Grouping_element_list()
	}
	{
		p.SetState(2460)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IHopping_window_specificationContext is an interface to support dynamic dispatch.
type IHopping_window_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HOP() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	RPAREN() antlr.TerminalNode

	// IsHopping_window_specificationContext differentiates from other interfaces.
	IsHopping_window_specificationContext()
}

type Hopping_window_specificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHopping_window_specificationContext() *Hopping_window_specificationContext {
	var p = new(Hopping_window_specificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_hopping_window_specification
	return p
}

func InitEmptyHopping_window_specificationContext(p *Hopping_window_specificationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_hopping_window_specification
}

func (*Hopping_window_specificationContext) IsHopping_window_specificationContext() {}

func NewHopping_window_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hopping_window_specificationContext {
	var p = new(Hopping_window_specificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_hopping_window_specification

	return p
}

func (s *Hopping_window_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Hopping_window_specificationContext) HOP() antlr.TerminalNode {
	return s.GetToken(YQLParserHOP, 0)
}

func (s *Hopping_window_specificationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Hopping_window_specificationContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Hopping_window_specificationContext) Expr(i int) IExprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Hopping_window_specificationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Hopping_window_specificationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Hopping_window_specificationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Hopping_window_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hopping_window_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Hopping_window_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterHopping_window_specification(s)
	}
}

func (s *Hopping_window_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitHopping_window_specification(s)
	}
}




func (p *YQLParser) Hopping_window_specification() (localctx IHopping_window_specificationContext) {
	localctx = NewHopping_window_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, YQLParserRULE_hopping_window_specification)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2462)
		p.Match(YQLParserHOP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2463)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2464)
		p.Expr()
	}
	{
		p.SetState(2465)
		p.Match(YQLParserCOMMA)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2466)
		p.Expr()
	}
	{
		p.SetState(2467)
		p.Match(YQLParserCOMMA)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2468)
		p.Expr()
	}
	{
		p.SetState(2469)
		p.Match(YQLParserCOMMA)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2470)
		p.Expr()
	}
	{
		p.SetState(2471)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IResult_columnContext is an interface to support dynamic dispatch.
type IResult_columnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Opt_id_prefix() IOpt_id_prefixContext
	ASTERISK() antlr.TerminalNode
	Expr() IExprContext
	AS() antlr.TerminalNode
	An_id_or_type() IAn_id_or_typeContext
	An_id_as_compat() IAn_id_as_compatContext

	// IsResult_columnContext differentiates from other interfaces.
	IsResult_columnContext()
}

type Result_columnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResult_columnContext() *Result_columnContext {
	var p = new(Result_columnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_result_column
	return p
}

func InitEmptyResult_columnContext(p *Result_columnContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_result_column
}

func (*Result_columnContext) IsResult_columnContext() {}

func NewResult_columnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Result_columnContext {
	var p = new(Result_columnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_result_column

	return p
}

func (s *Result_columnContext) GetParser() antlr.Parser { return s.parser }

func (s *Result_columnContext) Opt_id_prefix() IOpt_id_prefixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_id_prefixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_id_prefixContext)
}

func (s *Result_columnContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(YQLParserASTERISK, 0)
}

func (s *Result_columnContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Result_columnContext) AS() antlr.TerminalNode {
	return s.GetToken(YQLParserAS, 0)
}

func (s *Result_columnContext) An_id_or_type() IAn_id_or_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_or_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_or_typeContext)
}

func (s *Result_columnContext) An_id_as_compat() IAn_id_as_compatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_as_compatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_as_compatContext)
}

func (s *Result_columnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Result_columnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Result_columnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterResult_column(s)
	}
}

func (s *Result_columnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitResult_column(s)
	}
}




func (p *YQLParser) Result_column() (localctx IResult_columnContext) {
	localctx = NewResult_columnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, YQLParserRULE_result_column)
	p.SetState(2482)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 224, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2473)
			p.Opt_id_prefix()
		}
		{
			p.SetState(2474)
			p.Match(YQLParserASTERISK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2476)
			p.Expr()
		}
		p.SetState(2480)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 223, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2477)
				p.Match(YQLParserAS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2478)
				p.An_id_or_type()
			}

			} else if p.HasError() { // JIM
				goto errorExit} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 223, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(2479)
				p.An_id_as_compat()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IJoin_sourceContext is an interface to support dynamic dispatch.
type IJoin_sourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFlatten_source() []IFlatten_sourceContext
	Flatten_source(i int) IFlatten_sourceContext
	AllANY() []antlr.TerminalNode
	ANY(i int) antlr.TerminalNode
	AllJoin_op() []IJoin_opContext
	Join_op(i int) IJoin_opContext
	AllJoin_constraint() []IJoin_constraintContext
	Join_constraint(i int) IJoin_constraintContext

	// IsJoin_sourceContext differentiates from other interfaces.
	IsJoin_sourceContext()
}

type Join_sourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoin_sourceContext() *Join_sourceContext {
	var p = new(Join_sourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_join_source
	return p
}

func InitEmptyJoin_sourceContext(p *Join_sourceContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_join_source
}

func (*Join_sourceContext) IsJoin_sourceContext() {}

func NewJoin_sourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Join_sourceContext {
	var p = new(Join_sourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_join_source

	return p
}

func (s *Join_sourceContext) GetParser() antlr.Parser { return s.parser }

func (s *Join_sourceContext) AllFlatten_source() []IFlatten_sourceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFlatten_sourceContext); ok {
			len++
		}
	}

	tst := make([]IFlatten_sourceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFlatten_sourceContext); ok {
			tst[i] = t.(IFlatten_sourceContext)
			i++
		}
	}

	return tst
}

func (s *Join_sourceContext) Flatten_source(i int) IFlatten_sourceContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFlatten_sourceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFlatten_sourceContext)
}

func (s *Join_sourceContext) AllANY() []antlr.TerminalNode {
	return s.GetTokens(YQLParserANY)
}

func (s *Join_sourceContext) ANY(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserANY, i)
}

func (s *Join_sourceContext) AllJoin_op() []IJoin_opContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoin_opContext); ok {
			len++
		}
	}

	tst := make([]IJoin_opContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoin_opContext); ok {
			tst[i] = t.(IJoin_opContext)
			i++
		}
	}

	return tst
}

func (s *Join_sourceContext) Join_op(i int) IJoin_opContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoin_opContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoin_opContext)
}

func (s *Join_sourceContext) AllJoin_constraint() []IJoin_constraintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoin_constraintContext); ok {
			len++
		}
	}

	tst := make([]IJoin_constraintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoin_constraintContext); ok {
			tst[i] = t.(IJoin_constraintContext)
			i++
		}
	}

	return tst
}

func (s *Join_sourceContext) Join_constraint(i int) IJoin_constraintContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoin_constraintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoin_constraintContext)
}

func (s *Join_sourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Join_sourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Join_sourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterJoin_source(s)
	}
}

func (s *Join_sourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitJoin_source(s)
	}
}




func (p *YQLParser) Join_source() (localctx IJoin_sourceContext) {
	localctx = NewJoin_sourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, YQLParserRULE_join_source)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2485)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 225, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2484)
			p.Match(YQLParserANY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(2487)
		p.Flatten_source()
	}
	p.SetState(2498)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA || _la == YQLParserCROSS || ((int64((_la - 124)) & ^0x3f) == 0 && ((int64(1) << (_la - 124)) & 18298072509579265) != 0) || ((int64((_la - 194)) & ^0x3f) == 0 && ((int64(1) << (_la - 194)) & -9223372036853727231) != 0) {
		{
			p.SetState(2488)
			p.Join_op()
		}
		p.SetState(2490)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 226, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2489)
				p.Match(YQLParserANY)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(2492)
			p.Flatten_source()
		}
		p.SetState(2494)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserON || _la == YQLParserUSING {
			{
				p.SetState(2493)
				p.Join_constraint()
			}

		}


		p.SetState(2500)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// INamed_columnContext is an interface to support dynamic dispatch.
type INamed_columnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Column_name() IColumn_nameContext
	AS() antlr.TerminalNode
	An_id() IAn_idContext

	// IsNamed_columnContext differentiates from other interfaces.
	IsNamed_columnContext()
}

type Named_columnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamed_columnContext() *Named_columnContext {
	var p = new(Named_columnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_named_column
	return p
}

func InitEmptyNamed_columnContext(p *Named_columnContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_named_column
}

func (*Named_columnContext) IsNamed_columnContext() {}

func NewNamed_columnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Named_columnContext {
	var p = new(Named_columnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_named_column

	return p
}

func (s *Named_columnContext) GetParser() antlr.Parser { return s.parser }

func (s *Named_columnContext) Column_name() IColumn_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Named_columnContext) AS() antlr.TerminalNode {
	return s.GetToken(YQLParserAS, 0)
}

func (s *Named_columnContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Named_columnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Named_columnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Named_columnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterNamed_column(s)
	}
}

func (s *Named_columnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitNamed_column(s)
	}
}




func (p *YQLParser) Named_column() (localctx INamed_columnContext) {
	localctx = NewNamed_columnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, YQLParserRULE_named_column)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2501)
		p.Column_name()
	}
	p.SetState(2504)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserAS {
		{
			p.SetState(2502)
			p.Match(YQLParserAS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2503)
			p.An_id()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFlatten_by_argContext is an interface to support dynamic dispatch.
type IFlatten_by_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Named_column() INamed_columnContext
	LPAREN() antlr.TerminalNode
	Named_expr_list() INamed_expr_listContext
	RPAREN() antlr.TerminalNode
	COMMA() antlr.TerminalNode

	// IsFlatten_by_argContext differentiates from other interfaces.
	IsFlatten_by_argContext()
}

type Flatten_by_argContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlatten_by_argContext() *Flatten_by_argContext {
	var p = new(Flatten_by_argContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_flatten_by_arg
	return p
}

func InitEmptyFlatten_by_argContext(p *Flatten_by_argContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_flatten_by_arg
}

func (*Flatten_by_argContext) IsFlatten_by_argContext() {}

func NewFlatten_by_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Flatten_by_argContext {
	var p = new(Flatten_by_argContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_flatten_by_arg

	return p
}

func (s *Flatten_by_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Flatten_by_argContext) Named_column() INamed_columnContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_columnContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_columnContext)
}

func (s *Flatten_by_argContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Flatten_by_argContext) Named_expr_list() INamed_expr_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_expr_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_expr_listContext)
}

func (s *Flatten_by_argContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Flatten_by_argContext) COMMA() antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, 0)
}

func (s *Flatten_by_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Flatten_by_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Flatten_by_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterFlatten_by_arg(s)
	}
}

func (s *Flatten_by_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitFlatten_by_arg(s)
	}
}




func (p *YQLParser) Flatten_by_arg() (localctx IFlatten_by_argContext) {
	localctx = NewFlatten_by_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, YQLParserRULE_flatten_by_arg)
	var _la int

	p.SetState(2514)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALL, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserANY, YQLParserARRAY, YQLParserAS, YQLParserASC, YQLParserASSUME, YQLParserASYMMETRIC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBETWEEN, YQLParserBITCAST, YQLParserBY, YQLParserCASCADE, YQLParserCASE, YQLParserCAST, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOLUMN, YQLParserCOLUMNS, YQLParserCOMMIT, YQLParserCOMPACT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCUBE, YQLParserCURRENT, YQLParserCURRENT_DATE, YQLParserCURRENT_TIME, YQLParserCURRENT_TIMESTAMP, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDISTINCT, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserEMPTY_ACTION, YQLParserENCRYPTED, YQLParserEND, YQLParserERASE, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCEPT, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXISTS, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFROM, YQLParserFULL, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserGROUPS, YQLParserHASH, YQLParserHAVING, YQLParserHOP, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTERSECT, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserJSON_EXISTS, YQLParserJSON_QUERY, YQLParserJSON_VALUE, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLIMIT, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOT, YQLParserNOTNULL, YQLParserNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserPROCESS, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserRANGE, YQLParserREDUCE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserRETURN, YQLParserRETURNING, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROLLUP, YQLParserROW, YQLParserROWS, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSCHEMA, YQLParserSECONDS, YQLParserSEEK, YQLParserSELECT, YQLParserSEMI, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSTREAM, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYMMETRIC, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTYPE, YQLParserUNBOUNDED, YQLParserUNCONDITIONAL, YQLParserUNION, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWHEN, YQLParserWHERE, YQLParserWINDOW, YQLParserWITH, YQLParserWITHOUT, YQLParserWRAPPER, YQLParserXOR, YQLParserSTRING_VALUE, YQLParserID_PLAIN, YQLParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2506)
			p.Named_column()
		}


	case YQLParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2507)
			p.Match(YQLParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2508)
			p.Named_expr_list()
		}
		p.SetState(2510)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserCOMMA {
			{
				p.SetState(2509)
				p.Match(YQLParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2512)
			p.Match(YQLParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFlatten_sourceContext is an interface to support dynamic dispatch.
type IFlatten_sourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Named_single_source() INamed_single_sourceContext
	FLATTEN() antlr.TerminalNode
	BY() antlr.TerminalNode
	Flatten_by_arg() IFlatten_by_argContext
	COLUMNS() antlr.TerminalNode
	OPTIONAL() antlr.TerminalNode
	LIST() antlr.TerminalNode
	DICT() antlr.TerminalNode

	// IsFlatten_sourceContext differentiates from other interfaces.
	IsFlatten_sourceContext()
}

type Flatten_sourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlatten_sourceContext() *Flatten_sourceContext {
	var p = new(Flatten_sourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_flatten_source
	return p
}

func InitEmptyFlatten_sourceContext(p *Flatten_sourceContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_flatten_source
}

func (*Flatten_sourceContext) IsFlatten_sourceContext() {}

func NewFlatten_sourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Flatten_sourceContext {
	var p = new(Flatten_sourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_flatten_source

	return p
}

func (s *Flatten_sourceContext) GetParser() antlr.Parser { return s.parser }

func (s *Flatten_sourceContext) Named_single_source() INamed_single_sourceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_single_sourceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_single_sourceContext)
}

func (s *Flatten_sourceContext) FLATTEN() antlr.TerminalNode {
	return s.GetToken(YQLParserFLATTEN, 0)
}

func (s *Flatten_sourceContext) BY() antlr.TerminalNode {
	return s.GetToken(YQLParserBY, 0)
}

func (s *Flatten_sourceContext) Flatten_by_arg() IFlatten_by_argContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFlatten_by_argContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFlatten_by_argContext)
}

func (s *Flatten_sourceContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(YQLParserCOLUMNS, 0)
}

func (s *Flatten_sourceContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(YQLParserOPTIONAL, 0)
}

func (s *Flatten_sourceContext) LIST() antlr.TerminalNode {
	return s.GetToken(YQLParserLIST, 0)
}

func (s *Flatten_sourceContext) DICT() antlr.TerminalNode {
	return s.GetToken(YQLParserDICT, 0)
}

func (s *Flatten_sourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Flatten_sourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Flatten_sourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterFlatten_source(s)
	}
}

func (s *Flatten_sourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitFlatten_source(s)
	}
}




func (p *YQLParser) Flatten_source() (localctx IFlatten_sourceContext) {
	localctx = NewFlatten_sourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, YQLParserRULE_flatten_source)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2516)
		p.Named_single_source()
	}
	p.SetState(2526)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserFLATTEN {
		{
			p.SetState(2517)
			p.Match(YQLParserFLATTEN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2524)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case YQLParserBY, YQLParserDICT, YQLParserLIST, YQLParserOPTIONAL:
			p.SetState(2519)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == YQLParserDICT || _la == YQLParserLIST || _la == YQLParserOPTIONAL {
				{
					p.SetState(2518)
					_la = p.GetTokenStream().LA(1)

					if !(_la == YQLParserDICT || _la == YQLParserLIST || _la == YQLParserOPTIONAL) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(2521)
				p.Match(YQLParserBY)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2522)
				p.Flatten_by_arg()
			}


		case YQLParserCOLUMNS:
			{
				p.SetState(2523)
				p.Match(YQLParserCOLUMNS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// INamed_single_sourceContext is an interface to support dynamic dispatch.
type INamed_single_sourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Single_source() ISingle_sourceContext
	Row_pattern_recognition_clause() IRow_pattern_recognition_clauseContext
	Sample_clause() ISample_clauseContext
	Tablesample_clause() ITablesample_clauseContext
	AS() antlr.TerminalNode
	An_id() IAn_idContext
	An_id_as_compat() IAn_id_as_compatContext
	Pure_column_list() IPure_column_listContext

	// IsNamed_single_sourceContext differentiates from other interfaces.
	IsNamed_single_sourceContext()
}

type Named_single_sourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamed_single_sourceContext() *Named_single_sourceContext {
	var p = new(Named_single_sourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_named_single_source
	return p
}

func InitEmptyNamed_single_sourceContext(p *Named_single_sourceContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_named_single_source
}

func (*Named_single_sourceContext) IsNamed_single_sourceContext() {}

func NewNamed_single_sourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Named_single_sourceContext {
	var p = new(Named_single_sourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_named_single_source

	return p
}

func (s *Named_single_sourceContext) GetParser() antlr.Parser { return s.parser }

func (s *Named_single_sourceContext) Single_source() ISingle_sourceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingle_sourceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingle_sourceContext)
}

func (s *Named_single_sourceContext) Row_pattern_recognition_clause() IRow_pattern_recognition_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_recognition_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_recognition_clauseContext)
}

func (s *Named_single_sourceContext) Sample_clause() ISample_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISample_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISample_clauseContext)
}

func (s *Named_single_sourceContext) Tablesample_clause() ITablesample_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesample_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesample_clauseContext)
}

func (s *Named_single_sourceContext) AS() antlr.TerminalNode {
	return s.GetToken(YQLParserAS, 0)
}

func (s *Named_single_sourceContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Named_single_sourceContext) An_id_as_compat() IAn_id_as_compatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_as_compatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_as_compatContext)
}

func (s *Named_single_sourceContext) Pure_column_list() IPure_column_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPure_column_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPure_column_listContext)
}

func (s *Named_single_sourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Named_single_sourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Named_single_sourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterNamed_single_source(s)
	}
}

func (s *Named_single_sourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitNamed_single_source(s)
	}
}




func (p *YQLParser) Named_single_source() (localctx INamed_single_sourceContext) {
	localctx = NewNamed_single_sourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, YQLParserRULE_named_single_source)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2528)
		p.Single_source()
	}
	p.SetState(2530)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 235, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2529)
			p.Row_pattern_recognition_clause()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(2540)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 238, p.GetParserRuleContext()) == 1 {
		p.SetState(2535)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case YQLParserAS:
			{
				p.SetState(2532)
				p.Match(YQLParserAS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2533)
				p.An_id()
			}


		case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserARRAY, YQLParserASC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBY, YQLParserCASCADE, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOMMIT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCURRENT, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserENCRYPTED, YQLParserEND, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCLUDE, YQLParserEXCLUSIVE, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserHASH, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTO, YQLParserIS, YQLParserLAST, YQLParserLEGACY, YQLParserLIKE, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserREVERT, YQLParserREVOKE, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROW, YQLParserSAVEPOINT, YQLParserSECONDS, YQLParserSEEK, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTYPE, YQLParserUNCONDITIONAL, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserVACUUM, YQLParserVALUES, YQLParserVIRTUAL, YQLParserWRAPPER, YQLParserXOR, YQLParserSTRING_VALUE, YQLParserID_PLAIN, YQLParserID_QUOTED:
			{
				p.SetState(2534)
				p.An_id_as_compat()
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(2538)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserLPAREN {
			{
				p.SetState(2537)
				p.Pure_column_list()
			}

		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(2544)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case YQLParserSAMPLE:
		{
			p.SetState(2542)
			p.Sample_clause()
		}


	case YQLParserTABLESAMPLE:
		{
			p.SetState(2543)
			p.Tablesample_clause()
		}


	case YQLParserEOF, YQLParserSEMICOLON, YQLParserCOMMA, YQLParserRPAREN, YQLParserASSUME, YQLParserCROSS, YQLParserEND, YQLParserEXCEPT, YQLParserEXCLUSION, YQLParserFLATTEN, YQLParserFULL, YQLParserGROUP, YQLParserHAVING, YQLParserINNER, YQLParserINTERSECT, YQLParserINTO, YQLParserJOIN, YQLParserLEFT, YQLParserLIMIT, YQLParserNATURAL, YQLParserON, YQLParserORDER, YQLParserOUTER, YQLParserPRESORT, YQLParserRETURNING, YQLParserRIGHT, YQLParserSELECT, YQLParserUNION, YQLParserUSING, YQLParserWHERE, YQLParserWINDOW:



	default:
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISingle_sourceContext is an interface to support dynamic dispatch.
type ISingle_sourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Table_ref() ITable_refContext
	LPAREN() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	RPAREN() antlr.TerminalNode
	Values_stmt() IValues_stmtContext

	// IsSingle_sourceContext differentiates from other interfaces.
	IsSingle_sourceContext()
}

type Single_sourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingle_sourceContext() *Single_sourceContext {
	var p = new(Single_sourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_single_source
	return p
}

func InitEmptySingle_sourceContext(p *Single_sourceContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_single_source
}

func (*Single_sourceContext) IsSingle_sourceContext() {}

func NewSingle_sourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Single_sourceContext {
	var p = new(Single_sourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_single_source

	return p
}

func (s *Single_sourceContext) GetParser() antlr.Parser { return s.parser }

func (s *Single_sourceContext) Table_ref() ITable_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_refContext)
}

func (s *Single_sourceContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Single_sourceContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Single_sourceContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Single_sourceContext) Values_stmt() IValues_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValues_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValues_stmtContext)
}

func (s *Single_sourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Single_sourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Single_sourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterSingle_source(s)
	}
}

func (s *Single_sourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitSingle_source(s)
	}
}




func (p *YQLParser) Single_source() (localctx ISingle_sourceContext) {
	localctx = NewSingle_sourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, YQLParserRULE_single_source)
	p.SetState(2555)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 240, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2546)
			p.Table_ref()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2547)
			p.Match(YQLParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2548)
			p.Select_stmt()
		}
		{
			p.SetState(2549)
			p.Match(YQLParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2551)
			p.Match(YQLParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2552)
			p.Values_stmt()
		}
		{
			p.SetState(2553)
			p.Match(YQLParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISample_clauseContext is an interface to support dynamic dispatch.
type ISample_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SAMPLE() antlr.TerminalNode
	Expr() IExprContext

	// IsSample_clauseContext differentiates from other interfaces.
	IsSample_clauseContext()
}

type Sample_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySample_clauseContext() *Sample_clauseContext {
	var p = new(Sample_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_sample_clause
	return p
}

func InitEmptySample_clauseContext(p *Sample_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_sample_clause
}

func (*Sample_clauseContext) IsSample_clauseContext() {}

func NewSample_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sample_clauseContext {
	var p = new(Sample_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_sample_clause

	return p
}

func (s *Sample_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Sample_clauseContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(YQLParserSAMPLE, 0)
}

func (s *Sample_clauseContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Sample_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sample_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Sample_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterSample_clause(s)
	}
}

func (s *Sample_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitSample_clause(s)
	}
}




func (p *YQLParser) Sample_clause() (localctx ISample_clauseContext) {
	localctx = NewSample_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, YQLParserRULE_sample_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2557)
		p.Match(YQLParserSAMPLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2558)
		p.Expr()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITablesample_clauseContext is an interface to support dynamic dispatch.
type ITablesample_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLESAMPLE() antlr.TerminalNode
	Sampling_mode() ISampling_modeContext
	LPAREN() antlr.TerminalNode
	Expr() IExprContext
	RPAREN() antlr.TerminalNode
	Repeatable_clause() IRepeatable_clauseContext

	// IsTablesample_clauseContext differentiates from other interfaces.
	IsTablesample_clauseContext()
}

type Tablesample_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablesample_clauseContext() *Tablesample_clauseContext {
	var p = new(Tablesample_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_tablesample_clause
	return p
}

func InitEmptyTablesample_clauseContext(p *Tablesample_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_tablesample_clause
}

func (*Tablesample_clauseContext) IsTablesample_clauseContext() {}

func NewTablesample_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tablesample_clauseContext {
	var p = new(Tablesample_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_tablesample_clause

	return p
}

func (s *Tablesample_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Tablesample_clauseContext) TABLESAMPLE() antlr.TerminalNode {
	return s.GetToken(YQLParserTABLESAMPLE, 0)
}

func (s *Tablesample_clauseContext) Sampling_mode() ISampling_modeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISampling_modeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISampling_modeContext)
}

func (s *Tablesample_clauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Tablesample_clauseContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Tablesample_clauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Tablesample_clauseContext) Repeatable_clause() IRepeatable_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRepeatable_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRepeatable_clauseContext)
}

func (s *Tablesample_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tablesample_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Tablesample_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterTablesample_clause(s)
	}
}

func (s *Tablesample_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitTablesample_clause(s)
	}
}




func (p *YQLParser) Tablesample_clause() (localctx ITablesample_clauseContext) {
	localctx = NewTablesample_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, YQLParserRULE_tablesample_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2560)
		p.Match(YQLParserTABLESAMPLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2561)
		p.Sampling_mode()
	}
	{
		p.SetState(2562)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2563)
		p.Expr()
	}
	{
		p.SetState(2564)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2566)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserREPEATABLE {
		{
			p.SetState(2565)
			p.Repeatable_clause()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISampling_modeContext is an interface to support dynamic dispatch.
type ISampling_modeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BERNOULLI() antlr.TerminalNode
	SYSTEM() antlr.TerminalNode

	// IsSampling_modeContext differentiates from other interfaces.
	IsSampling_modeContext()
}

type Sampling_modeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySampling_modeContext() *Sampling_modeContext {
	var p = new(Sampling_modeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_sampling_mode
	return p
}

func InitEmptySampling_modeContext(p *Sampling_modeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_sampling_mode
}

func (*Sampling_modeContext) IsSampling_modeContext() {}

func NewSampling_modeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sampling_modeContext {
	var p = new(Sampling_modeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_sampling_mode

	return p
}

func (s *Sampling_modeContext) GetParser() antlr.Parser { return s.parser }

func (s *Sampling_modeContext) BERNOULLI() antlr.TerminalNode {
	return s.GetToken(YQLParserBERNOULLI, 0)
}

func (s *Sampling_modeContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(YQLParserSYSTEM, 0)
}

func (s *Sampling_modeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sampling_modeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Sampling_modeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterSampling_mode(s)
	}
}

func (s *Sampling_modeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitSampling_mode(s)
	}
}




func (p *YQLParser) Sampling_mode() (localctx ISampling_modeContext) {
	localctx = NewSampling_modeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, YQLParserRULE_sampling_mode)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2568)
		_la = p.GetTokenStream().LA(1)

		if !(_la == YQLParserBERNOULLI || _la == YQLParserSYSTEM) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRepeatable_clauseContext is an interface to support dynamic dispatch.
type IRepeatable_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPEATABLE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expr() IExprContext
	RPAREN() antlr.TerminalNode

	// IsRepeatable_clauseContext differentiates from other interfaces.
	IsRepeatable_clauseContext()
}

type Repeatable_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRepeatable_clauseContext() *Repeatable_clauseContext {
	var p = new(Repeatable_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_repeatable_clause
	return p
}

func InitEmptyRepeatable_clauseContext(p *Repeatable_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_repeatable_clause
}

func (*Repeatable_clauseContext) IsRepeatable_clauseContext() {}

func NewRepeatable_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Repeatable_clauseContext {
	var p = new(Repeatable_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_repeatable_clause

	return p
}

func (s *Repeatable_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Repeatable_clauseContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(YQLParserREPEATABLE, 0)
}

func (s *Repeatable_clauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Repeatable_clauseContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Repeatable_clauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Repeatable_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Repeatable_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Repeatable_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterRepeatable_clause(s)
	}
}

func (s *Repeatable_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitRepeatable_clause(s)
	}
}




func (p *YQLParser) Repeatable_clause() (localctx IRepeatable_clauseContext) {
	localctx = NewRepeatable_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, YQLParserRULE_repeatable_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2570)
		p.Match(YQLParserREPEATABLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2571)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2572)
		p.Expr()
	}
	{
		p.SetState(2573)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IJoin_opContext is an interface to support dynamic dispatch.
type IJoin_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMA() antlr.TerminalNode
	JOIN() antlr.TerminalNode
	INNER() antlr.TerminalNode
	CROSS() antlr.TerminalNode
	NATURAL() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	EXCLUSION() antlr.TerminalNode
	FULL() antlr.TerminalNode
	OUTER() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	SEMI() antlr.TerminalNode

	// IsJoin_opContext differentiates from other interfaces.
	IsJoin_opContext()
}

type Join_opContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoin_opContext() *Join_opContext {
	var p = new(Join_opContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_join_op
	return p
}

func InitEmptyJoin_opContext(p *Join_opContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_join_op
}

func (*Join_opContext) IsJoin_opContext() {}

func NewJoin_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Join_opContext {
	var p = new(Join_opContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_join_op

	return p
}

func (s *Join_opContext) GetParser() antlr.Parser { return s.parser }

func (s *Join_opContext) COMMA() antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, 0)
}

func (s *Join_opContext) JOIN() antlr.TerminalNode {
	return s.GetToken(YQLParserJOIN, 0)
}

func (s *Join_opContext) INNER() antlr.TerminalNode {
	return s.GetToken(YQLParserINNER, 0)
}

func (s *Join_opContext) CROSS() antlr.TerminalNode {
	return s.GetToken(YQLParserCROSS, 0)
}

func (s *Join_opContext) NATURAL() antlr.TerminalNode {
	return s.GetToken(YQLParserNATURAL, 0)
}

func (s *Join_opContext) LEFT() antlr.TerminalNode {
	return s.GetToken(YQLParserLEFT, 0)
}

func (s *Join_opContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(YQLParserRIGHT, 0)
}

func (s *Join_opContext) EXCLUSION() antlr.TerminalNode {
	return s.GetToken(YQLParserEXCLUSION, 0)
}

func (s *Join_opContext) FULL() antlr.TerminalNode {
	return s.GetToken(YQLParserFULL, 0)
}

func (s *Join_opContext) OUTER() antlr.TerminalNode {
	return s.GetToken(YQLParserOUTER, 0)
}

func (s *Join_opContext) ONLY() antlr.TerminalNode {
	return s.GetToken(YQLParserONLY, 0)
}

func (s *Join_opContext) SEMI() antlr.TerminalNode {
	return s.GetToken(YQLParserSEMI, 0)
}

func (s *Join_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Join_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Join_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterJoin_op(s)
	}
}

func (s *Join_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitJoin_op(s)
	}
}




func (p *YQLParser) Join_op() (localctx IJoin_opContext) {
	localctx = NewJoin_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, YQLParserRULE_join_op)
	var _la int

	p.SetState(2599)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserCOMMA:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2575)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserCROSS, YQLParserEXCLUSION, YQLParserFULL, YQLParserINNER, YQLParserJOIN, YQLParserLEFT, YQLParserNATURAL, YQLParserOUTER, YQLParserRIGHT:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2577)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserNATURAL {
			{
				p.SetState(2576)
				p.Match(YQLParserNATURAL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		p.SetState(2596)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case YQLParserEXCLUSION, YQLParserFULL, YQLParserJOIN, YQLParserLEFT, YQLParserOUTER, YQLParserRIGHT:
			p.SetState(2589)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			switch p.GetTokenStream().LA(1) {
			case YQLParserLEFT:
				{
					p.SetState(2579)
					p.Match(YQLParserLEFT)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				p.SetState(2581)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)


				if _la == YQLParserONLY || _la == YQLParserSEMI {
					{
						p.SetState(2580)
						_la = p.GetTokenStream().LA(1)

						if !(_la == YQLParserONLY || _la == YQLParserSEMI) {
							p.GetErrorHandler().RecoverInline(p)
						} else {
							p.GetErrorHandler().ReportMatch(p)
							p.Consume()
						}
					}

				}


			case YQLParserRIGHT:
				{
					p.SetState(2583)
					p.Match(YQLParserRIGHT)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				p.SetState(2585)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)


				if _la == YQLParserONLY || _la == YQLParserSEMI {
					{
						p.SetState(2584)
						_la = p.GetTokenStream().LA(1)

						if !(_la == YQLParserONLY || _la == YQLParserSEMI) {
							p.GetErrorHandler().RecoverInline(p)
						} else {
							p.GetErrorHandler().ReportMatch(p)
							p.Consume()
						}
					}

				}


			case YQLParserEXCLUSION:
				{
					p.SetState(2587)
					p.Match(YQLParserEXCLUSION)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}


			case YQLParserFULL:
				{
					p.SetState(2588)
					p.Match(YQLParserFULL)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}


			case YQLParserJOIN, YQLParserOUTER:



			default:
			}
			p.SetState(2592)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == YQLParserOUTER {
				{
					p.SetState(2591)
					p.Match(YQLParserOUTER)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			}


		case YQLParserINNER:
			{
				p.SetState(2594)
				p.Match(YQLParserINNER)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case YQLParserCROSS:
			{
				p.SetState(2595)
				p.Match(YQLParserCROSS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(2598)
			p.Match(YQLParserJOIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IJoin_constraintContext is an interface to support dynamic dispatch.
type IJoin_constraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	Expr() IExprContext
	USING() antlr.TerminalNode
	Pure_column_or_named_list() IPure_column_or_named_listContext

	// IsJoin_constraintContext differentiates from other interfaces.
	IsJoin_constraintContext()
}

type Join_constraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoin_constraintContext() *Join_constraintContext {
	var p = new(Join_constraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_join_constraint
	return p
}

func InitEmptyJoin_constraintContext(p *Join_constraintContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_join_constraint
}

func (*Join_constraintContext) IsJoin_constraintContext() {}

func NewJoin_constraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Join_constraintContext {
	var p = new(Join_constraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_join_constraint

	return p
}

func (s *Join_constraintContext) GetParser() antlr.Parser { return s.parser }

func (s *Join_constraintContext) ON() antlr.TerminalNode {
	return s.GetToken(YQLParserON, 0)
}

func (s *Join_constraintContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Join_constraintContext) USING() antlr.TerminalNode {
	return s.GetToken(YQLParserUSING, 0)
}

func (s *Join_constraintContext) Pure_column_or_named_list() IPure_column_or_named_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPure_column_or_named_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPure_column_or_named_listContext)
}

func (s *Join_constraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Join_constraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Join_constraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterJoin_constraint(s)
	}
}

func (s *Join_constraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitJoin_constraint(s)
	}
}




func (p *YQLParser) Join_constraint() (localctx IJoin_constraintContext) {
	localctx = NewJoin_constraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, YQLParserRULE_join_constraint)
	p.SetState(2605)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserON:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2601)
			p.Match(YQLParserON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2602)
			p.Expr()
		}


	case YQLParserUSING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2603)
			p.Match(YQLParserUSING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2604)
			p.Pure_column_or_named_list()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IReturning_columns_listContext is an interface to support dynamic dispatch.
type IReturning_columns_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETURNING() antlr.TerminalNode
	ASTERISK() antlr.TerminalNode
	AllAn_id() []IAn_idContext
	An_id(i int) IAn_idContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsReturning_columns_listContext differentiates from other interfaces.
	IsReturning_columns_listContext()
}

type Returning_columns_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturning_columns_listContext() *Returning_columns_listContext {
	var p = new(Returning_columns_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_returning_columns_list
	return p
}

func InitEmptyReturning_columns_listContext(p *Returning_columns_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_returning_columns_list
}

func (*Returning_columns_listContext) IsReturning_columns_listContext() {}

func NewReturning_columns_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Returning_columns_listContext {
	var p = new(Returning_columns_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_returning_columns_list

	return p
}

func (s *Returning_columns_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Returning_columns_listContext) RETURNING() antlr.TerminalNode {
	return s.GetToken(YQLParserRETURNING, 0)
}

func (s *Returning_columns_listContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(YQLParserASTERISK, 0)
}

func (s *Returning_columns_listContext) AllAn_id() []IAn_idContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAn_idContext); ok {
			len++
		}
	}

	tst := make([]IAn_idContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAn_idContext); ok {
			tst[i] = t.(IAn_idContext)
			i++
		}
	}

	return tst
}

func (s *Returning_columns_listContext) An_id(i int) IAn_idContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Returning_columns_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Returning_columns_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Returning_columns_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Returning_columns_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Returning_columns_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterReturning_columns_list(s)
	}
}

func (s *Returning_columns_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitReturning_columns_list(s)
	}
}




func (p *YQLParser) Returning_columns_list() (localctx IReturning_columns_listContext) {
	localctx = NewReturning_columns_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, YQLParserRULE_returning_columns_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2607)
		p.Match(YQLParserRETURNING)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2617)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserASTERISK:
		{
			p.SetState(2608)
			p.Match(YQLParserASTERISK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALL, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserANY, YQLParserARRAY, YQLParserAS, YQLParserASC, YQLParserASSUME, YQLParserASYMMETRIC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBETWEEN, YQLParserBITCAST, YQLParserBY, YQLParserCASCADE, YQLParserCASE, YQLParserCAST, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOLUMN, YQLParserCOLUMNS, YQLParserCOMMIT, YQLParserCOMPACT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCUBE, YQLParserCURRENT, YQLParserCURRENT_DATE, YQLParserCURRENT_TIME, YQLParserCURRENT_TIMESTAMP, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDISTINCT, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserEMPTY_ACTION, YQLParserENCRYPTED, YQLParserEND, YQLParserERASE, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCEPT, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXISTS, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFROM, YQLParserFULL, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserGROUPS, YQLParserHASH, YQLParserHAVING, YQLParserHOP, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTERSECT, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserJSON_EXISTS, YQLParserJSON_QUERY, YQLParserJSON_VALUE, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLIMIT, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOT, YQLParserNOTNULL, YQLParserNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserPROCESS, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserRANGE, YQLParserREDUCE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserRETURN, YQLParserRETURNING, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROLLUP, YQLParserROW, YQLParserROWS, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSCHEMA, YQLParserSECONDS, YQLParserSEEK, YQLParserSELECT, YQLParserSEMI, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSTREAM, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYMMETRIC, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTYPE, YQLParserUNBOUNDED, YQLParserUNCONDITIONAL, YQLParserUNION, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWHEN, YQLParserWHERE, YQLParserWINDOW, YQLParserWITH, YQLParserWITHOUT, YQLParserWRAPPER, YQLParserXOR, YQLParserSTRING_VALUE, YQLParserID_PLAIN, YQLParserID_QUOTED:
		{
			p.SetState(2609)
			p.An_id()
		}
		p.SetState(2614)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == YQLParserCOMMA {
			{
				p.SetState(2610)
				p.Match(YQLParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2611)
				p.An_id()
			}


			p.SetState(2616)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IInto_table_stmtContext is an interface to support dynamic dispatch.
type IInto_table_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTO() antlr.TerminalNode
	Into_simple_table_ref() IInto_simple_table_refContext
	Into_values_source() IInto_values_sourceContext
	INSERT() antlr.TerminalNode
	OR() antlr.TerminalNode
	ABORT() antlr.TerminalNode
	REVERT() antlr.TerminalNode
	IGNORE() antlr.TerminalNode
	UPSERT() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	Returning_columns_list() IReturning_columns_listContext

	// IsInto_table_stmtContext differentiates from other interfaces.
	IsInto_table_stmtContext()
}

type Into_table_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInto_table_stmtContext() *Into_table_stmtContext {
	var p = new(Into_table_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_into_table_stmt
	return p
}

func InitEmptyInto_table_stmtContext(p *Into_table_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_into_table_stmt
}

func (*Into_table_stmtContext) IsInto_table_stmtContext() {}

func NewInto_table_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Into_table_stmtContext {
	var p = new(Into_table_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_into_table_stmt

	return p
}

func (s *Into_table_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Into_table_stmtContext) INTO() antlr.TerminalNode {
	return s.GetToken(YQLParserINTO, 0)
}

func (s *Into_table_stmtContext) Into_simple_table_ref() IInto_simple_table_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInto_simple_table_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInto_simple_table_refContext)
}

func (s *Into_table_stmtContext) Into_values_source() IInto_values_sourceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInto_values_sourceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInto_values_sourceContext)
}

func (s *Into_table_stmtContext) INSERT() antlr.TerminalNode {
	return s.GetToken(YQLParserINSERT, 0)
}

func (s *Into_table_stmtContext) OR() antlr.TerminalNode {
	return s.GetToken(YQLParserOR, 0)
}

func (s *Into_table_stmtContext) ABORT() antlr.TerminalNode {
	return s.GetToken(YQLParserABORT, 0)
}

func (s *Into_table_stmtContext) REVERT() antlr.TerminalNode {
	return s.GetToken(YQLParserREVERT, 0)
}

func (s *Into_table_stmtContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(YQLParserIGNORE, 0)
}

func (s *Into_table_stmtContext) UPSERT() antlr.TerminalNode {
	return s.GetToken(YQLParserUPSERT, 0)
}

func (s *Into_table_stmtContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(YQLParserREPLACE, 0)
}

func (s *Into_table_stmtContext) Returning_columns_list() IReturning_columns_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturning_columns_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturning_columns_listContext)
}

func (s *Into_table_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Into_table_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Into_table_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterInto_table_stmt(s)
	}
}

func (s *Into_table_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitInto_table_stmt(s)
	}
}




func (p *YQLParser) Into_table_stmt() (localctx IInto_table_stmtContext) {
	localctx = NewInto_table_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, YQLParserRULE_into_table_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2631)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 252, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2619)
			p.Match(YQLParserINSERT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		{
			p.SetState(2620)
			p.Match(YQLParserINSERT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2621)
			p.Match(YQLParserOR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2622)
			p.Match(YQLParserABORT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		{
			p.SetState(2623)
			p.Match(YQLParserINSERT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2624)
			p.Match(YQLParserOR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2625)
			p.Match(YQLParserREVERT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 4:
		{
			p.SetState(2626)
			p.Match(YQLParserINSERT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2627)
			p.Match(YQLParserOR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2628)
			p.Match(YQLParserIGNORE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 5:
		{
			p.SetState(2629)
			p.Match(YQLParserUPSERT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 6:
		{
			p.SetState(2630)
			p.Match(YQLParserREPLACE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(2633)
		p.Match(YQLParserINTO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2634)
		p.Into_simple_table_ref()
	}
	{
		p.SetState(2635)
		p.Into_values_source()
	}
	p.SetState(2637)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserRETURNING {
		{
			p.SetState(2636)
			p.Returning_columns_list()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IInto_values_sourceContext is an interface to support dynamic dispatch.
type IInto_values_sourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Values_source() IValues_sourceContext
	Pure_column_list() IPure_column_listContext
	DEFAULT() antlr.TerminalNode
	VALUES() antlr.TerminalNode

	// IsInto_values_sourceContext differentiates from other interfaces.
	IsInto_values_sourceContext()
}

type Into_values_sourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInto_values_sourceContext() *Into_values_sourceContext {
	var p = new(Into_values_sourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_into_values_source
	return p
}

func InitEmptyInto_values_sourceContext(p *Into_values_sourceContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_into_values_source
}

func (*Into_values_sourceContext) IsInto_values_sourceContext() {}

func NewInto_values_sourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Into_values_sourceContext {
	var p = new(Into_values_sourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_into_values_source

	return p
}

func (s *Into_values_sourceContext) GetParser() antlr.Parser { return s.parser }

func (s *Into_values_sourceContext) Values_source() IValues_sourceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValues_sourceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValues_sourceContext)
}

func (s *Into_values_sourceContext) Pure_column_list() IPure_column_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPure_column_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPure_column_listContext)
}

func (s *Into_values_sourceContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(YQLParserDEFAULT, 0)
}

func (s *Into_values_sourceContext) VALUES() antlr.TerminalNode {
	return s.GetToken(YQLParserVALUES, 0)
}

func (s *Into_values_sourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Into_values_sourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Into_values_sourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterInto_values_source(s)
	}
}

func (s *Into_values_sourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitInto_values_source(s)
	}
}




func (p *YQLParser) Into_values_source() (localctx IInto_values_sourceContext) {
	localctx = NewInto_values_sourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, YQLParserRULE_into_values_source)
	p.SetState(2645)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserLPAREN, YQLParserDISCARD, YQLParserFROM, YQLParserPROCESS, YQLParserREDUCE, YQLParserSELECT, YQLParserVALUES:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2640)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 254, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2639)
				p.Pure_column_list()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(2642)
			p.Values_source()
		}


	case YQLParserDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2643)
			p.Match(YQLParserDEFAULT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2644)
			p.Match(YQLParserVALUES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IValues_stmtContext is an interface to support dynamic dispatch.
type IValues_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VALUES() antlr.TerminalNode
	Values_source_row_list() IValues_source_row_listContext

	// IsValues_stmtContext differentiates from other interfaces.
	IsValues_stmtContext()
}

type Values_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValues_stmtContext() *Values_stmtContext {
	var p = new(Values_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_values_stmt
	return p
}

func InitEmptyValues_stmtContext(p *Values_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_values_stmt
}

func (*Values_stmtContext) IsValues_stmtContext() {}

func NewValues_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Values_stmtContext {
	var p = new(Values_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_values_stmt

	return p
}

func (s *Values_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Values_stmtContext) VALUES() antlr.TerminalNode {
	return s.GetToken(YQLParserVALUES, 0)
}

func (s *Values_stmtContext) Values_source_row_list() IValues_source_row_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValues_source_row_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValues_source_row_listContext)
}

func (s *Values_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Values_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Values_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterValues_stmt(s)
	}
}

func (s *Values_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitValues_stmt(s)
	}
}




func (p *YQLParser) Values_stmt() (localctx IValues_stmtContext) {
	localctx = NewValues_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, YQLParserRULE_values_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2647)
		p.Match(YQLParserVALUES)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2648)
		p.Values_source_row_list()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IValues_sourceContext is an interface to support dynamic dispatch.
type IValues_sourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Values_stmt() IValues_stmtContext
	Select_stmt() ISelect_stmtContext

	// IsValues_sourceContext differentiates from other interfaces.
	IsValues_sourceContext()
}

type Values_sourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValues_sourceContext() *Values_sourceContext {
	var p = new(Values_sourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_values_source
	return p
}

func InitEmptyValues_sourceContext(p *Values_sourceContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_values_source
}

func (*Values_sourceContext) IsValues_sourceContext() {}

func NewValues_sourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Values_sourceContext {
	var p = new(Values_sourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_values_source

	return p
}

func (s *Values_sourceContext) GetParser() antlr.Parser { return s.parser }

func (s *Values_sourceContext) Values_stmt() IValues_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValues_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValues_stmtContext)
}

func (s *Values_sourceContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Values_sourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Values_sourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Values_sourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterValues_source(s)
	}
}

func (s *Values_sourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitValues_source(s)
	}
}




func (p *YQLParser) Values_source() (localctx IValues_sourceContext) {
	localctx = NewValues_sourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, YQLParserRULE_values_source)
	p.SetState(2652)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserVALUES:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2650)
			p.Values_stmt()
		}


	case YQLParserLPAREN, YQLParserDISCARD, YQLParserFROM, YQLParserPROCESS, YQLParserREDUCE, YQLParserSELECT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2651)
			p.Select_stmt()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IValues_source_row_listContext is an interface to support dynamic dispatch.
type IValues_source_row_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllValues_source_row() []IValues_source_rowContext
	Values_source_row(i int) IValues_source_rowContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsValues_source_row_listContext differentiates from other interfaces.
	IsValues_source_row_listContext()
}

type Values_source_row_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValues_source_row_listContext() *Values_source_row_listContext {
	var p = new(Values_source_row_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_values_source_row_list
	return p
}

func InitEmptyValues_source_row_listContext(p *Values_source_row_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_values_source_row_list
}

func (*Values_source_row_listContext) IsValues_source_row_listContext() {}

func NewValues_source_row_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Values_source_row_listContext {
	var p = new(Values_source_row_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_values_source_row_list

	return p
}

func (s *Values_source_row_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Values_source_row_listContext) AllValues_source_row() []IValues_source_rowContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValues_source_rowContext); ok {
			len++
		}
	}

	tst := make([]IValues_source_rowContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValues_source_rowContext); ok {
			tst[i] = t.(IValues_source_rowContext)
			i++
		}
	}

	return tst
}

func (s *Values_source_row_listContext) Values_source_row(i int) IValues_source_rowContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValues_source_rowContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValues_source_rowContext)
}

func (s *Values_source_row_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Values_source_row_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Values_source_row_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Values_source_row_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Values_source_row_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterValues_source_row_list(s)
	}
}

func (s *Values_source_row_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitValues_source_row_list(s)
	}
}




func (p *YQLParser) Values_source_row_list() (localctx IValues_source_row_listContext) {
	localctx = NewValues_source_row_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, YQLParserRULE_values_source_row_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2654)
		p.Values_source_row()
	}
	p.SetState(2659)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(2655)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2656)
			p.Values_source_row()
		}


		p.SetState(2661)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IValues_source_rowContext is an interface to support dynamic dispatch.
type IValues_source_rowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	Expr_list() IExpr_listContext
	RPAREN() antlr.TerminalNode

	// IsValues_source_rowContext differentiates from other interfaces.
	IsValues_source_rowContext()
}

type Values_source_rowContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValues_source_rowContext() *Values_source_rowContext {
	var p = new(Values_source_rowContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_values_source_row
	return p
}

func InitEmptyValues_source_rowContext(p *Values_source_rowContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_values_source_row
}

func (*Values_source_rowContext) IsValues_source_rowContext() {}

func NewValues_source_rowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Values_source_rowContext {
	var p = new(Values_source_rowContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_values_source_row

	return p
}

func (s *Values_source_rowContext) GetParser() antlr.Parser { return s.parser }

func (s *Values_source_rowContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Values_source_rowContext) Expr_list() IExpr_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_listContext)
}

func (s *Values_source_rowContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Values_source_rowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Values_source_rowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Values_source_rowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterValues_source_row(s)
	}
}

func (s *Values_source_rowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitValues_source_row(s)
	}
}




func (p *YQLParser) Values_source_row() (localctx IValues_source_rowContext) {
	localctx = NewValues_source_rowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, YQLParserRULE_values_source_row)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2662)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2663)
		p.Expr_list()
	}
	{
		p.SetState(2664)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISimple_values_sourceContext is an interface to support dynamic dispatch.
type ISimple_values_sourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr_list() IExpr_listContext
	Select_stmt() ISelect_stmtContext

	// IsSimple_values_sourceContext differentiates from other interfaces.
	IsSimple_values_sourceContext()
}

type Simple_values_sourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_values_sourceContext() *Simple_values_sourceContext {
	var p = new(Simple_values_sourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_simple_values_source
	return p
}

func InitEmptySimple_values_sourceContext(p *Simple_values_sourceContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_simple_values_source
}

func (*Simple_values_sourceContext) IsSimple_values_sourceContext() {}

func NewSimple_values_sourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_values_sourceContext {
	var p = new(Simple_values_sourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_simple_values_source

	return p
}

func (s *Simple_values_sourceContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_values_sourceContext) Expr_list() IExpr_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_listContext)
}

func (s *Simple_values_sourceContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Simple_values_sourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_values_sourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Simple_values_sourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterSimple_values_source(s)
	}
}

func (s *Simple_values_sourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitSimple_values_source(s)
	}
}




func (p *YQLParser) Simple_values_source() (localctx ISimple_values_sourceContext) {
	localctx = NewSimple_values_sourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, YQLParserRULE_simple_values_source)
	p.SetState(2668)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 258, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2666)
			p.Expr_list()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2667)
			p.Select_stmt()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_external_data_source_stmtContext is an interface to support dynamic dispatch.
type ICreate_external_data_source_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	DATA() antlr.TerminalNode
	SOURCE() antlr.TerminalNode
	Object_ref() IObject_refContext
	With_table_settings() IWith_table_settingsContext
	OR() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsCreate_external_data_source_stmtContext differentiates from other interfaces.
	IsCreate_external_data_source_stmtContext()
}

type Create_external_data_source_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_external_data_source_stmtContext() *Create_external_data_source_stmtContext {
	var p = new(Create_external_data_source_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_create_external_data_source_stmt
	return p
}

func InitEmptyCreate_external_data_source_stmtContext(p *Create_external_data_source_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_create_external_data_source_stmt
}

func (*Create_external_data_source_stmtContext) IsCreate_external_data_source_stmtContext() {}

func NewCreate_external_data_source_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_external_data_source_stmtContext {
	var p = new(Create_external_data_source_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_create_external_data_source_stmt

	return p
}

func (s *Create_external_data_source_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_external_data_source_stmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(YQLParserCREATE, 0)
}

func (s *Create_external_data_source_stmtContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(YQLParserEXTERNAL, 0)
}

func (s *Create_external_data_source_stmtContext) DATA() antlr.TerminalNode {
	return s.GetToken(YQLParserDATA, 0)
}

func (s *Create_external_data_source_stmtContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(YQLParserSOURCE, 0)
}

func (s *Create_external_data_source_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Create_external_data_source_stmtContext) With_table_settings() IWith_table_settingsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWith_table_settingsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWith_table_settingsContext)
}

func (s *Create_external_data_source_stmtContext) OR() antlr.TerminalNode {
	return s.GetToken(YQLParserOR, 0)
}

func (s *Create_external_data_source_stmtContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(YQLParserREPLACE, 0)
}

func (s *Create_external_data_source_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(YQLParserIF, 0)
}

func (s *Create_external_data_source_stmtContext) NOT() antlr.TerminalNode {
	return s.GetToken(YQLParserNOT, 0)
}

func (s *Create_external_data_source_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(YQLParserEXISTS, 0)
}

func (s *Create_external_data_source_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_external_data_source_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_external_data_source_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterCreate_external_data_source_stmt(s)
	}
}

func (s *Create_external_data_source_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitCreate_external_data_source_stmt(s)
	}
}




func (p *YQLParser) Create_external_data_source_stmt() (localctx ICreate_external_data_source_stmtContext) {
	localctx = NewCreate_external_data_source_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, YQLParserRULE_create_external_data_source_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2670)
		p.Match(YQLParserCREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2673)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserOR {
		{
			p.SetState(2671)
			p.Match(YQLParserOR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2672)
			p.Match(YQLParserREPLACE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(2675)
		p.Match(YQLParserEXTERNAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2676)
		p.Match(YQLParserDATA)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2677)
		p.Match(YQLParserSOURCE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2681)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 260, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2678)
			p.Match(YQLParserIF)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2679)
			p.Match(YQLParserNOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2680)
			p.Match(YQLParserEXISTS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(2683)
		p.Object_ref()
	}
	{
		p.SetState(2684)
		p.With_table_settings()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_external_data_source_stmtContext is an interface to support dynamic dispatch.
type IAlter_external_data_source_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	DATA() antlr.TerminalNode
	SOURCE() antlr.TerminalNode
	Object_ref() IObject_refContext
	AllAlter_external_data_source_action() []IAlter_external_data_source_actionContext
	Alter_external_data_source_action(i int) IAlter_external_data_source_actionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAlter_external_data_source_stmtContext differentiates from other interfaces.
	IsAlter_external_data_source_stmtContext()
}

type Alter_external_data_source_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_external_data_source_stmtContext() *Alter_external_data_source_stmtContext {
	var p = new(Alter_external_data_source_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_external_data_source_stmt
	return p
}

func InitEmptyAlter_external_data_source_stmtContext(p *Alter_external_data_source_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_external_data_source_stmt
}

func (*Alter_external_data_source_stmtContext) IsAlter_external_data_source_stmtContext() {}

func NewAlter_external_data_source_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_external_data_source_stmtContext {
	var p = new(Alter_external_data_source_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_external_data_source_stmt

	return p
}

func (s *Alter_external_data_source_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_external_data_source_stmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(YQLParserALTER, 0)
}

func (s *Alter_external_data_source_stmtContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(YQLParserEXTERNAL, 0)
}

func (s *Alter_external_data_source_stmtContext) DATA() antlr.TerminalNode {
	return s.GetToken(YQLParserDATA, 0)
}

func (s *Alter_external_data_source_stmtContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(YQLParserSOURCE, 0)
}

func (s *Alter_external_data_source_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Alter_external_data_source_stmtContext) AllAlter_external_data_source_action() []IAlter_external_data_source_actionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlter_external_data_source_actionContext); ok {
			len++
		}
	}

	tst := make([]IAlter_external_data_source_actionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlter_external_data_source_actionContext); ok {
			tst[i] = t.(IAlter_external_data_source_actionContext)
			i++
		}
	}

	return tst
}

func (s *Alter_external_data_source_stmtContext) Alter_external_data_source_action(i int) IAlter_external_data_source_actionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_external_data_source_actionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_external_data_source_actionContext)
}

func (s *Alter_external_data_source_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Alter_external_data_source_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Alter_external_data_source_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_external_data_source_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_external_data_source_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_external_data_source_stmt(s)
	}
}

func (s *Alter_external_data_source_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_external_data_source_stmt(s)
	}
}




func (p *YQLParser) Alter_external_data_source_stmt() (localctx IAlter_external_data_source_stmtContext) {
	localctx = NewAlter_external_data_source_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, YQLParserRULE_alter_external_data_source_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2686)
		p.Match(YQLParserALTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2687)
		p.Match(YQLParserEXTERNAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2688)
		p.Match(YQLParserDATA)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2689)
		p.Match(YQLParserSOURCE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2690)
		p.Object_ref()
	}
	{
		p.SetState(2691)
		p.Alter_external_data_source_action()
	}
	p.SetState(2696)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(2692)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2693)
			p.Alter_external_data_source_action()
		}


		p.SetState(2698)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_external_data_source_actionContext is an interface to support dynamic dispatch.
type IAlter_external_data_source_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Alter_table_set_table_setting_uncompat() IAlter_table_set_table_setting_uncompatContext
	Alter_table_set_table_setting_compat() IAlter_table_set_table_setting_compatContext
	Alter_table_reset_table_setting() IAlter_table_reset_table_settingContext

	// IsAlter_external_data_source_actionContext differentiates from other interfaces.
	IsAlter_external_data_source_actionContext()
}

type Alter_external_data_source_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_external_data_source_actionContext() *Alter_external_data_source_actionContext {
	var p = new(Alter_external_data_source_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_external_data_source_action
	return p
}

func InitEmptyAlter_external_data_source_actionContext(p *Alter_external_data_source_actionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_external_data_source_action
}

func (*Alter_external_data_source_actionContext) IsAlter_external_data_source_actionContext() {}

func NewAlter_external_data_source_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_external_data_source_actionContext {
	var p = new(Alter_external_data_source_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_external_data_source_action

	return p
}

func (s *Alter_external_data_source_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_external_data_source_actionContext) Alter_table_set_table_setting_uncompat() IAlter_table_set_table_setting_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_set_table_setting_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_set_table_setting_uncompatContext)
}

func (s *Alter_external_data_source_actionContext) Alter_table_set_table_setting_compat() IAlter_table_set_table_setting_compatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_set_table_setting_compatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_set_table_setting_compatContext)
}

func (s *Alter_external_data_source_actionContext) Alter_table_reset_table_setting() IAlter_table_reset_table_settingContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_reset_table_settingContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_reset_table_settingContext)
}

func (s *Alter_external_data_source_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_external_data_source_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_external_data_source_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_external_data_source_action(s)
	}
}

func (s *Alter_external_data_source_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_external_data_source_action(s)
	}
}




func (p *YQLParser) Alter_external_data_source_action() (localctx IAlter_external_data_source_actionContext) {
	localctx = NewAlter_external_data_source_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, YQLParserRULE_alter_external_data_source_action)
	p.SetState(2702)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 262, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2699)
			p.Alter_table_set_table_setting_uncompat()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2700)
			p.Alter_table_set_table_setting_compat()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2701)
			p.Alter_table_reset_table_setting()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDrop_external_data_source_stmtContext is an interface to support dynamic dispatch.
type IDrop_external_data_source_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	DATA() antlr.TerminalNode
	SOURCE() antlr.TerminalNode
	Object_ref() IObject_refContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDrop_external_data_source_stmtContext differentiates from other interfaces.
	IsDrop_external_data_source_stmtContext()
}

type Drop_external_data_source_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_external_data_source_stmtContext() *Drop_external_data_source_stmtContext {
	var p = new(Drop_external_data_source_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_drop_external_data_source_stmt
	return p
}

func InitEmptyDrop_external_data_source_stmtContext(p *Drop_external_data_source_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_drop_external_data_source_stmt
}

func (*Drop_external_data_source_stmtContext) IsDrop_external_data_source_stmtContext() {}

func NewDrop_external_data_source_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_external_data_source_stmtContext {
	var p = new(Drop_external_data_source_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_drop_external_data_source_stmt

	return p
}

func (s *Drop_external_data_source_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_external_data_source_stmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(YQLParserDROP, 0)
}

func (s *Drop_external_data_source_stmtContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(YQLParserEXTERNAL, 0)
}

func (s *Drop_external_data_source_stmtContext) DATA() antlr.TerminalNode {
	return s.GetToken(YQLParserDATA, 0)
}

func (s *Drop_external_data_source_stmtContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(YQLParserSOURCE, 0)
}

func (s *Drop_external_data_source_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Drop_external_data_source_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(YQLParserIF, 0)
}

func (s *Drop_external_data_source_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(YQLParserEXISTS, 0)
}

func (s *Drop_external_data_source_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_external_data_source_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Drop_external_data_source_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterDrop_external_data_source_stmt(s)
	}
}

func (s *Drop_external_data_source_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitDrop_external_data_source_stmt(s)
	}
}




func (p *YQLParser) Drop_external_data_source_stmt() (localctx IDrop_external_data_source_stmtContext) {
	localctx = NewDrop_external_data_source_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, YQLParserRULE_drop_external_data_source_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2704)
		p.Match(YQLParserDROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2705)
		p.Match(YQLParserEXTERNAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2706)
		p.Match(YQLParserDATA)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2707)
		p.Match(YQLParserSOURCE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2710)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 263, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2708)
			p.Match(YQLParserIF)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2709)
			p.Match(YQLParserEXISTS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(2712)
		p.Object_ref()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_view_stmtContext is an interface to support dynamic dispatch.
type ICreate_view_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	Object_ref() IObject_refContext
	AS() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	Create_object_features() ICreate_object_featuresContext

	// IsCreate_view_stmtContext differentiates from other interfaces.
	IsCreate_view_stmtContext()
}

type Create_view_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_view_stmtContext() *Create_view_stmtContext {
	var p = new(Create_view_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_create_view_stmt
	return p
}

func InitEmptyCreate_view_stmtContext(p *Create_view_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_create_view_stmt
}

func (*Create_view_stmtContext) IsCreate_view_stmtContext() {}

func NewCreate_view_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_view_stmtContext {
	var p = new(Create_view_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_create_view_stmt

	return p
}

func (s *Create_view_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_view_stmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(YQLParserCREATE, 0)
}

func (s *Create_view_stmtContext) VIEW() antlr.TerminalNode {
	return s.GetToken(YQLParserVIEW, 0)
}

func (s *Create_view_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Create_view_stmtContext) AS() antlr.TerminalNode {
	return s.GetToken(YQLParserAS, 0)
}

func (s *Create_view_stmtContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Create_view_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(YQLParserIF, 0)
}

func (s *Create_view_stmtContext) NOT() antlr.TerminalNode {
	return s.GetToken(YQLParserNOT, 0)
}

func (s *Create_view_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(YQLParserEXISTS, 0)
}

func (s *Create_view_stmtContext) Create_object_features() ICreate_object_featuresContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_object_featuresContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_object_featuresContext)
}

func (s *Create_view_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_view_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_view_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterCreate_view_stmt(s)
	}
}

func (s *Create_view_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitCreate_view_stmt(s)
	}
}




func (p *YQLParser) Create_view_stmt() (localctx ICreate_view_stmtContext) {
	localctx = NewCreate_view_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, YQLParserRULE_create_view_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2714)
		p.Match(YQLParserCREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2715)
		p.Match(YQLParserVIEW)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2719)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 264, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2716)
			p.Match(YQLParserIF)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2717)
			p.Match(YQLParserNOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2718)
			p.Match(YQLParserEXISTS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(2721)
		p.Object_ref()
	}
	p.SetState(2723)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserWITH {
		{
			p.SetState(2722)
			p.Create_object_features()
		}

	}
	{
		p.SetState(2725)
		p.Match(YQLParserAS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2726)
		p.Select_stmt()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDrop_view_stmtContext is an interface to support dynamic dispatch.
type IDrop_view_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	Object_ref() IObject_refContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDrop_view_stmtContext differentiates from other interfaces.
	IsDrop_view_stmtContext()
}

type Drop_view_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_view_stmtContext() *Drop_view_stmtContext {
	var p = new(Drop_view_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_drop_view_stmt
	return p
}

func InitEmptyDrop_view_stmtContext(p *Drop_view_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_drop_view_stmt
}

func (*Drop_view_stmtContext) IsDrop_view_stmtContext() {}

func NewDrop_view_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_view_stmtContext {
	var p = new(Drop_view_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_drop_view_stmt

	return p
}

func (s *Drop_view_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_view_stmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(YQLParserDROP, 0)
}

func (s *Drop_view_stmtContext) VIEW() antlr.TerminalNode {
	return s.GetToken(YQLParserVIEW, 0)
}

func (s *Drop_view_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Drop_view_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(YQLParserIF, 0)
}

func (s *Drop_view_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(YQLParserEXISTS, 0)
}

func (s *Drop_view_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_view_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Drop_view_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterDrop_view_stmt(s)
	}
}

func (s *Drop_view_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitDrop_view_stmt(s)
	}
}




func (p *YQLParser) Drop_view_stmt() (localctx IDrop_view_stmtContext) {
	localctx = NewDrop_view_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, YQLParserRULE_drop_view_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2728)
		p.Match(YQLParserDROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2729)
		p.Match(YQLParserVIEW)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2732)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 266, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2730)
			p.Match(YQLParserIF)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2731)
			p.Match(YQLParserEXISTS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(2734)
		p.Object_ref()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUpsert_object_stmtContext is an interface to support dynamic dispatch.
type IUpsert_object_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UPSERT() antlr.TerminalNode
	OBJECT() antlr.TerminalNode
	Object_ref() IObject_refContext
	LPAREN() antlr.TerminalNode
	TYPE() antlr.TerminalNode
	Object_type_ref() IObject_type_refContext
	RPAREN() antlr.TerminalNode
	Create_object_features() ICreate_object_featuresContext

	// IsUpsert_object_stmtContext differentiates from other interfaces.
	IsUpsert_object_stmtContext()
}

type Upsert_object_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpsert_object_stmtContext() *Upsert_object_stmtContext {
	var p = new(Upsert_object_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_upsert_object_stmt
	return p
}

func InitEmptyUpsert_object_stmtContext(p *Upsert_object_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_upsert_object_stmt
}

func (*Upsert_object_stmtContext) IsUpsert_object_stmtContext() {}

func NewUpsert_object_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Upsert_object_stmtContext {
	var p = new(Upsert_object_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_upsert_object_stmt

	return p
}

func (s *Upsert_object_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Upsert_object_stmtContext) UPSERT() antlr.TerminalNode {
	return s.GetToken(YQLParserUPSERT, 0)
}

func (s *Upsert_object_stmtContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(YQLParserOBJECT, 0)
}

func (s *Upsert_object_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Upsert_object_stmtContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Upsert_object_stmtContext) TYPE() antlr.TerminalNode {
	return s.GetToken(YQLParserTYPE, 0)
}

func (s *Upsert_object_stmtContext) Object_type_ref() IObject_type_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_type_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_type_refContext)
}

func (s *Upsert_object_stmtContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Upsert_object_stmtContext) Create_object_features() ICreate_object_featuresContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_object_featuresContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_object_featuresContext)
}

func (s *Upsert_object_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Upsert_object_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Upsert_object_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterUpsert_object_stmt(s)
	}
}

func (s *Upsert_object_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitUpsert_object_stmt(s)
	}
}




func (p *YQLParser) Upsert_object_stmt() (localctx IUpsert_object_stmtContext) {
	localctx = NewUpsert_object_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, YQLParserRULE_upsert_object_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2736)
		p.Match(YQLParserUPSERT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2737)
		p.Match(YQLParserOBJECT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2738)
		p.Object_ref()
	}
	{
		p.SetState(2739)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2740)
		p.Match(YQLParserTYPE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2741)
		p.Object_type_ref()
	}
	{
		p.SetState(2742)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2744)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserWITH {
		{
			p.SetState(2743)
			p.Create_object_features()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_object_stmtContext is an interface to support dynamic dispatch.
type ICreate_object_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	OBJECT() antlr.TerminalNode
	Object_ref() IObject_refContext
	LPAREN() antlr.TerminalNode
	TYPE() antlr.TerminalNode
	Object_type_ref() IObject_type_refContext
	RPAREN() antlr.TerminalNode
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	Create_object_features() ICreate_object_featuresContext

	// IsCreate_object_stmtContext differentiates from other interfaces.
	IsCreate_object_stmtContext()
}

type Create_object_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_object_stmtContext() *Create_object_stmtContext {
	var p = new(Create_object_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_create_object_stmt
	return p
}

func InitEmptyCreate_object_stmtContext(p *Create_object_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_create_object_stmt
}

func (*Create_object_stmtContext) IsCreate_object_stmtContext() {}

func NewCreate_object_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_object_stmtContext {
	var p = new(Create_object_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_create_object_stmt

	return p
}

func (s *Create_object_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_object_stmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(YQLParserCREATE, 0)
}

func (s *Create_object_stmtContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(YQLParserOBJECT, 0)
}

func (s *Create_object_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Create_object_stmtContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Create_object_stmtContext) TYPE() antlr.TerminalNode {
	return s.GetToken(YQLParserTYPE, 0)
}

func (s *Create_object_stmtContext) Object_type_ref() IObject_type_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_type_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_type_refContext)
}

func (s *Create_object_stmtContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Create_object_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(YQLParserIF, 0)
}

func (s *Create_object_stmtContext) NOT() antlr.TerminalNode {
	return s.GetToken(YQLParserNOT, 0)
}

func (s *Create_object_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(YQLParserEXISTS, 0)
}

func (s *Create_object_stmtContext) Create_object_features() ICreate_object_featuresContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_object_featuresContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_object_featuresContext)
}

func (s *Create_object_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_object_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_object_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterCreate_object_stmt(s)
	}
}

func (s *Create_object_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitCreate_object_stmt(s)
	}
}




func (p *YQLParser) Create_object_stmt() (localctx ICreate_object_stmtContext) {
	localctx = NewCreate_object_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, YQLParserRULE_create_object_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2746)
		p.Match(YQLParserCREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2747)
		p.Match(YQLParserOBJECT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2751)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 268, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2748)
			p.Match(YQLParserIF)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2749)
			p.Match(YQLParserNOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2750)
			p.Match(YQLParserEXISTS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(2753)
		p.Object_ref()
	}
	{
		p.SetState(2754)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2755)
		p.Match(YQLParserTYPE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2756)
		p.Object_type_ref()
	}
	{
		p.SetState(2757)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2759)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserWITH {
		{
			p.SetState(2758)
			p.Create_object_features()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_object_featuresContext is an interface to support dynamic dispatch.
type ICreate_object_featuresContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	Object_features() IObject_featuresContext

	// IsCreate_object_featuresContext differentiates from other interfaces.
	IsCreate_object_featuresContext()
}

type Create_object_featuresContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_object_featuresContext() *Create_object_featuresContext {
	var p = new(Create_object_featuresContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_create_object_features
	return p
}

func InitEmptyCreate_object_featuresContext(p *Create_object_featuresContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_create_object_features
}

func (*Create_object_featuresContext) IsCreate_object_featuresContext() {}

func NewCreate_object_featuresContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_object_featuresContext {
	var p = new(Create_object_featuresContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_create_object_features

	return p
}

func (s *Create_object_featuresContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_object_featuresContext) WITH() antlr.TerminalNode {
	return s.GetToken(YQLParserWITH, 0)
}

func (s *Create_object_featuresContext) Object_features() IObject_featuresContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_featuresContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_featuresContext)
}

func (s *Create_object_featuresContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_object_featuresContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_object_featuresContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterCreate_object_features(s)
	}
}

func (s *Create_object_featuresContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitCreate_object_features(s)
	}
}




func (p *YQLParser) Create_object_features() (localctx ICreate_object_featuresContext) {
	localctx = NewCreate_object_featuresContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, YQLParserRULE_create_object_features)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2761)
		p.Match(YQLParserWITH)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2762)
		p.Object_features()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_object_stmtContext is an interface to support dynamic dispatch.
type IAlter_object_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	OBJECT() antlr.TerminalNode
	Object_ref() IObject_refContext
	LPAREN() antlr.TerminalNode
	TYPE() antlr.TerminalNode
	Object_type_ref() IObject_type_refContext
	RPAREN() antlr.TerminalNode
	Alter_object_features() IAlter_object_featuresContext

	// IsAlter_object_stmtContext differentiates from other interfaces.
	IsAlter_object_stmtContext()
}

type Alter_object_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_object_stmtContext() *Alter_object_stmtContext {
	var p = new(Alter_object_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_object_stmt
	return p
}

func InitEmptyAlter_object_stmtContext(p *Alter_object_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_object_stmt
}

func (*Alter_object_stmtContext) IsAlter_object_stmtContext() {}

func NewAlter_object_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_object_stmtContext {
	var p = new(Alter_object_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_object_stmt

	return p
}

func (s *Alter_object_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_object_stmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(YQLParserALTER, 0)
}

func (s *Alter_object_stmtContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(YQLParserOBJECT, 0)
}

func (s *Alter_object_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Alter_object_stmtContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Alter_object_stmtContext) TYPE() antlr.TerminalNode {
	return s.GetToken(YQLParserTYPE, 0)
}

func (s *Alter_object_stmtContext) Object_type_ref() IObject_type_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_type_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_type_refContext)
}

func (s *Alter_object_stmtContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Alter_object_stmtContext) Alter_object_features() IAlter_object_featuresContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_object_featuresContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_object_featuresContext)
}

func (s *Alter_object_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_object_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_object_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_object_stmt(s)
	}
}

func (s *Alter_object_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_object_stmt(s)
	}
}




func (p *YQLParser) Alter_object_stmt() (localctx IAlter_object_stmtContext) {
	localctx = NewAlter_object_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, YQLParserRULE_alter_object_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2764)
		p.Match(YQLParserALTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2765)
		p.Match(YQLParserOBJECT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2766)
		p.Object_ref()
	}
	{
		p.SetState(2767)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2768)
		p.Match(YQLParserTYPE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2769)
		p.Object_type_ref()
	}
	{
		p.SetState(2770)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2771)
		p.Alter_object_features()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_object_featuresContext is an interface to support dynamic dispatch.
type IAlter_object_featuresContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	Object_features() IObject_featuresContext

	// IsAlter_object_featuresContext differentiates from other interfaces.
	IsAlter_object_featuresContext()
}

type Alter_object_featuresContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_object_featuresContext() *Alter_object_featuresContext {
	var p = new(Alter_object_featuresContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_object_features
	return p
}

func InitEmptyAlter_object_featuresContext(p *Alter_object_featuresContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_object_features
}

func (*Alter_object_featuresContext) IsAlter_object_featuresContext() {}

func NewAlter_object_featuresContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_object_featuresContext {
	var p = new(Alter_object_featuresContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_object_features

	return p
}

func (s *Alter_object_featuresContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_object_featuresContext) SET() antlr.TerminalNode {
	return s.GetToken(YQLParserSET, 0)
}

func (s *Alter_object_featuresContext) Object_features() IObject_featuresContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_featuresContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_featuresContext)
}

func (s *Alter_object_featuresContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_object_featuresContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_object_featuresContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_object_features(s)
	}
}

func (s *Alter_object_featuresContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_object_features(s)
	}
}




func (p *YQLParser) Alter_object_features() (localctx IAlter_object_featuresContext) {
	localctx = NewAlter_object_featuresContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, YQLParserRULE_alter_object_features)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2773)
		p.Match(YQLParserSET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2774)
		p.Object_features()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDrop_object_stmtContext is an interface to support dynamic dispatch.
type IDrop_object_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	OBJECT() antlr.TerminalNode
	Object_ref() IObject_refContext
	LPAREN() antlr.TerminalNode
	TYPE() antlr.TerminalNode
	Object_type_ref() IObject_type_refContext
	RPAREN() antlr.TerminalNode
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	Drop_object_features() IDrop_object_featuresContext

	// IsDrop_object_stmtContext differentiates from other interfaces.
	IsDrop_object_stmtContext()
}

type Drop_object_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_object_stmtContext() *Drop_object_stmtContext {
	var p = new(Drop_object_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_drop_object_stmt
	return p
}

func InitEmptyDrop_object_stmtContext(p *Drop_object_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_drop_object_stmt
}

func (*Drop_object_stmtContext) IsDrop_object_stmtContext() {}

func NewDrop_object_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_object_stmtContext {
	var p = new(Drop_object_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_drop_object_stmt

	return p
}

func (s *Drop_object_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_object_stmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(YQLParserDROP, 0)
}

func (s *Drop_object_stmtContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(YQLParserOBJECT, 0)
}

func (s *Drop_object_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Drop_object_stmtContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Drop_object_stmtContext) TYPE() antlr.TerminalNode {
	return s.GetToken(YQLParserTYPE, 0)
}

func (s *Drop_object_stmtContext) Object_type_ref() IObject_type_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_type_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_type_refContext)
}

func (s *Drop_object_stmtContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Drop_object_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(YQLParserIF, 0)
}

func (s *Drop_object_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(YQLParserEXISTS, 0)
}

func (s *Drop_object_stmtContext) Drop_object_features() IDrop_object_featuresContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_object_featuresContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_object_featuresContext)
}

func (s *Drop_object_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_object_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Drop_object_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterDrop_object_stmt(s)
	}
}

func (s *Drop_object_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitDrop_object_stmt(s)
	}
}




func (p *YQLParser) Drop_object_stmt() (localctx IDrop_object_stmtContext) {
	localctx = NewDrop_object_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, YQLParserRULE_drop_object_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2776)
		p.Match(YQLParserDROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2777)
		p.Match(YQLParserOBJECT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2780)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 270, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2778)
			p.Match(YQLParserIF)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2779)
			p.Match(YQLParserEXISTS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(2782)
		p.Object_ref()
	}
	{
		p.SetState(2783)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2784)
		p.Match(YQLParserTYPE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2785)
		p.Object_type_ref()
	}
	{
		p.SetState(2786)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2788)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserWITH {
		{
			p.SetState(2787)
			p.Drop_object_features()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDrop_object_featuresContext is an interface to support dynamic dispatch.
type IDrop_object_featuresContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	Object_features() IObject_featuresContext

	// IsDrop_object_featuresContext differentiates from other interfaces.
	IsDrop_object_featuresContext()
}

type Drop_object_featuresContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_object_featuresContext() *Drop_object_featuresContext {
	var p = new(Drop_object_featuresContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_drop_object_features
	return p
}

func InitEmptyDrop_object_featuresContext(p *Drop_object_featuresContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_drop_object_features
}

func (*Drop_object_featuresContext) IsDrop_object_featuresContext() {}

func NewDrop_object_featuresContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_object_featuresContext {
	var p = new(Drop_object_featuresContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_drop_object_features

	return p
}

func (s *Drop_object_featuresContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_object_featuresContext) WITH() antlr.TerminalNode {
	return s.GetToken(YQLParserWITH, 0)
}

func (s *Drop_object_featuresContext) Object_features() IObject_featuresContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_featuresContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_featuresContext)
}

func (s *Drop_object_featuresContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_object_featuresContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Drop_object_featuresContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterDrop_object_features(s)
	}
}

func (s *Drop_object_featuresContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitDrop_object_features(s)
	}
}




func (p *YQLParser) Drop_object_features() (localctx IDrop_object_featuresContext) {
	localctx = NewDrop_object_featuresContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, YQLParserRULE_drop_object_features)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2790)
		p.Match(YQLParserWITH)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2791)
		p.Object_features()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IObject_feature_valueContext is an interface to support dynamic dispatch.
type IObject_feature_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_or_type() IId_or_typeContext
	Bind_parameter() IBind_parameterContext
	STRING_VALUE() antlr.TerminalNode
	Bool_value() IBool_valueContext

	// IsObject_feature_valueContext differentiates from other interfaces.
	IsObject_feature_valueContext()
}

type Object_feature_valueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObject_feature_valueContext() *Object_feature_valueContext {
	var p = new(Object_feature_valueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_object_feature_value
	return p
}

func InitEmptyObject_feature_valueContext(p *Object_feature_valueContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_object_feature_value
}

func (*Object_feature_valueContext) IsObject_feature_valueContext() {}

func NewObject_feature_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Object_feature_valueContext {
	var p = new(Object_feature_valueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_object_feature_value

	return p
}

func (s *Object_feature_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Object_feature_valueContext) Id_or_type() IId_or_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_or_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_or_typeContext)
}

func (s *Object_feature_valueContext) Bind_parameter() IBind_parameterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *Object_feature_valueContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(YQLParserSTRING_VALUE, 0)
}

func (s *Object_feature_valueContext) Bool_value() IBool_valueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_valueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_valueContext)
}

func (s *Object_feature_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Object_feature_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Object_feature_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterObject_feature_value(s)
	}
}

func (s *Object_feature_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitObject_feature_value(s)
	}
}




func (p *YQLParser) Object_feature_value() (localctx IObject_feature_valueContext) {
	localctx = NewObject_feature_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, YQLParserRULE_object_feature_value)
	p.SetState(2797)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALL, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserANY, YQLParserARRAY, YQLParserAS, YQLParserASC, YQLParserASSUME, YQLParserASYMMETRIC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBETWEEN, YQLParserBITCAST, YQLParserBY, YQLParserCALLABLE, YQLParserCASCADE, YQLParserCASE, YQLParserCAST, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOLUMN, YQLParserCOLUMNS, YQLParserCOMMIT, YQLParserCOMPACT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCUBE, YQLParserCURRENT, YQLParserCURRENT_DATE, YQLParserCURRENT_TIME, YQLParserCURRENT_TIMESTAMP, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDICT, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDISTINCT, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserEMPTY_ACTION, YQLParserENCRYPTED, YQLParserEND, YQLParserENUM, YQLParserERASE, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCEPT, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXISTS, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFLOW, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFROM, YQLParserFULL, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserGROUPS, YQLParserHASH, YQLParserHAVING, YQLParserHOP, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTERSECT, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserJSON_EXISTS, YQLParserJSON_QUERY, YQLParserJSON_VALUE, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLIMIT, YQLParserLIST, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOT, YQLParserNOTNULL, YQLParserNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOPTIONAL, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserPROCESS, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserRANGE, YQLParserREDUCE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESOURCE, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserRETURN, YQLParserRETURNING, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROLLUP, YQLParserROW, YQLParserROWS, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSCHEMA, YQLParserSECONDS, YQLParserSEEK, YQLParserSELECT, YQLParserSEMI, YQLParserSET, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSTREAM, YQLParserSTRUCT, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYMMETRIC, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTAGGED, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTUPLE, YQLParserTYPE, YQLParserUNBOUNDED, YQLParserUNCONDITIONAL, YQLParserUNION, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVARIANT, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWHEN, YQLParserWHERE, YQLParserWINDOW, YQLParserWITH, YQLParserWITHOUT, YQLParserWRAPPER, YQLParserXOR, YQLParserID_PLAIN, YQLParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2793)
			p.Id_or_type()
		}


	case YQLParserDOLLAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2794)
			p.Bind_parameter()
		}


	case YQLParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2795)
			p.Match(YQLParserSTRING_VALUE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserFALSE, YQLParserTRUE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2796)
			p.Bool_value()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IObject_feature_kvContext is an interface to support dynamic dispatch.
type IObject_feature_kvContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id_or_type() IAn_id_or_typeContext
	EQUALS() antlr.TerminalNode
	Object_feature_value() IObject_feature_valueContext

	// IsObject_feature_kvContext differentiates from other interfaces.
	IsObject_feature_kvContext()
}

type Object_feature_kvContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObject_feature_kvContext() *Object_feature_kvContext {
	var p = new(Object_feature_kvContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_object_feature_kv
	return p
}

func InitEmptyObject_feature_kvContext(p *Object_feature_kvContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_object_feature_kv
}

func (*Object_feature_kvContext) IsObject_feature_kvContext() {}

func NewObject_feature_kvContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Object_feature_kvContext {
	var p = new(Object_feature_kvContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_object_feature_kv

	return p
}

func (s *Object_feature_kvContext) GetParser() antlr.Parser { return s.parser }

func (s *Object_feature_kvContext) An_id_or_type() IAn_id_or_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_or_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_or_typeContext)
}

func (s *Object_feature_kvContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(YQLParserEQUALS, 0)
}

func (s *Object_feature_kvContext) Object_feature_value() IObject_feature_valueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_feature_valueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_feature_valueContext)
}

func (s *Object_feature_kvContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Object_feature_kvContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Object_feature_kvContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterObject_feature_kv(s)
	}
}

func (s *Object_feature_kvContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitObject_feature_kv(s)
	}
}




func (p *YQLParser) Object_feature_kv() (localctx IObject_feature_kvContext) {
	localctx = NewObject_feature_kvContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, YQLParserRULE_object_feature_kv)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2799)
		p.An_id_or_type()
	}
	{
		p.SetState(2800)
		p.Match(YQLParserEQUALS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2801)
		p.Object_feature_value()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IObject_feature_flagContext is an interface to support dynamic dispatch.
type IObject_feature_flagContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id_or_type() IAn_id_or_typeContext

	// IsObject_feature_flagContext differentiates from other interfaces.
	IsObject_feature_flagContext()
}

type Object_feature_flagContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObject_feature_flagContext() *Object_feature_flagContext {
	var p = new(Object_feature_flagContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_object_feature_flag
	return p
}

func InitEmptyObject_feature_flagContext(p *Object_feature_flagContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_object_feature_flag
}

func (*Object_feature_flagContext) IsObject_feature_flagContext() {}

func NewObject_feature_flagContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Object_feature_flagContext {
	var p = new(Object_feature_flagContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_object_feature_flag

	return p
}

func (s *Object_feature_flagContext) GetParser() antlr.Parser { return s.parser }

func (s *Object_feature_flagContext) An_id_or_type() IAn_id_or_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_or_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_or_typeContext)
}

func (s *Object_feature_flagContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Object_feature_flagContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Object_feature_flagContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterObject_feature_flag(s)
	}
}

func (s *Object_feature_flagContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitObject_feature_flag(s)
	}
}




func (p *YQLParser) Object_feature_flag() (localctx IObject_feature_flagContext) {
	localctx = NewObject_feature_flagContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, YQLParserRULE_object_feature_flag)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2803)
		p.An_id_or_type()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IObject_featureContext is an interface to support dynamic dispatch.
type IObject_featureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Object_feature_kv() IObject_feature_kvContext
	Object_feature_flag() IObject_feature_flagContext

	// IsObject_featureContext differentiates from other interfaces.
	IsObject_featureContext()
}

type Object_featureContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObject_featureContext() *Object_featureContext {
	var p = new(Object_featureContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_object_feature
	return p
}

func InitEmptyObject_featureContext(p *Object_featureContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_object_feature
}

func (*Object_featureContext) IsObject_featureContext() {}

func NewObject_featureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Object_featureContext {
	var p = new(Object_featureContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_object_feature

	return p
}

func (s *Object_featureContext) GetParser() antlr.Parser { return s.parser }

func (s *Object_featureContext) Object_feature_kv() IObject_feature_kvContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_feature_kvContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_feature_kvContext)
}

func (s *Object_featureContext) Object_feature_flag() IObject_feature_flagContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_feature_flagContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_feature_flagContext)
}

func (s *Object_featureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Object_featureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Object_featureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterObject_feature(s)
	}
}

func (s *Object_featureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitObject_feature(s)
	}
}




func (p *YQLParser) Object_feature() (localctx IObject_featureContext) {
	localctx = NewObject_featureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, YQLParserRULE_object_feature)
	p.SetState(2807)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 273, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2805)
			p.Object_feature_kv()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2806)
			p.Object_feature_flag()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IObject_featuresContext is an interface to support dynamic dispatch.
type IObject_featuresContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllObject_feature() []IObject_featureContext
	Object_feature(i int) IObject_featureContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsObject_featuresContext differentiates from other interfaces.
	IsObject_featuresContext()
}

type Object_featuresContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObject_featuresContext() *Object_featuresContext {
	var p = new(Object_featuresContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_object_features
	return p
}

func InitEmptyObject_featuresContext(p *Object_featuresContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_object_features
}

func (*Object_featuresContext) IsObject_featuresContext() {}

func NewObject_featuresContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Object_featuresContext {
	var p = new(Object_featuresContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_object_features

	return p
}

func (s *Object_featuresContext) GetParser() antlr.Parser { return s.parser }

func (s *Object_featuresContext) AllObject_feature() []IObject_featureContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IObject_featureContext); ok {
			len++
		}
	}

	tst := make([]IObject_featureContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IObject_featureContext); ok {
			tst[i] = t.(IObject_featureContext)
			i++
		}
	}

	return tst
}

func (s *Object_featuresContext) Object_feature(i int) IObject_featureContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_featureContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_featureContext)
}

func (s *Object_featuresContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Object_featuresContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Object_featuresContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Object_featuresContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Object_featuresContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Object_featuresContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Object_featuresContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterObject_features(s)
	}
}

func (s *Object_featuresContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitObject_features(s)
	}
}




func (p *YQLParser) Object_features() (localctx IObject_featuresContext) {
	localctx = NewObject_featuresContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, YQLParserRULE_object_features)
	var _la int

	p.SetState(2821)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALL, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserANY, YQLParserARRAY, YQLParserAS, YQLParserASC, YQLParserASSUME, YQLParserASYMMETRIC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBETWEEN, YQLParserBITCAST, YQLParserBY, YQLParserCALLABLE, YQLParserCASCADE, YQLParserCASE, YQLParserCAST, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOLUMN, YQLParserCOLUMNS, YQLParserCOMMIT, YQLParserCOMPACT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCUBE, YQLParserCURRENT, YQLParserCURRENT_DATE, YQLParserCURRENT_TIME, YQLParserCURRENT_TIMESTAMP, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDICT, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDISTINCT, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserEMPTY_ACTION, YQLParserENCRYPTED, YQLParserEND, YQLParserENUM, YQLParserERASE, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCEPT, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXISTS, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFLOW, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFROM, YQLParserFULL, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserGROUPS, YQLParserHASH, YQLParserHAVING, YQLParserHOP, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTERSECT, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserJSON_EXISTS, YQLParserJSON_QUERY, YQLParserJSON_VALUE, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLIMIT, YQLParserLIST, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOT, YQLParserNOTNULL, YQLParserNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOPTIONAL, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserPROCESS, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserRANGE, YQLParserREDUCE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESOURCE, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserRETURN, YQLParserRETURNING, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROLLUP, YQLParserROW, YQLParserROWS, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSCHEMA, YQLParserSECONDS, YQLParserSEEK, YQLParserSELECT, YQLParserSEMI, YQLParserSET, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSTREAM, YQLParserSTRUCT, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYMMETRIC, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTAGGED, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTUPLE, YQLParserTYPE, YQLParserUNBOUNDED, YQLParserUNCONDITIONAL, YQLParserUNION, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVARIANT, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWHEN, YQLParserWHERE, YQLParserWINDOW, YQLParserWITH, YQLParserWITHOUT, YQLParserWRAPPER, YQLParserXOR, YQLParserSTRING_VALUE, YQLParserID_PLAIN, YQLParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2809)
			p.Object_feature()
		}


	case YQLParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2810)
			p.Match(YQLParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2811)
			p.Object_feature()
		}
		p.SetState(2816)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == YQLParserCOMMA {
			{
				p.SetState(2812)
				p.Match(YQLParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2813)
				p.Object_feature()
			}


			p.SetState(2818)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2819)
			p.Match(YQLParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IObject_type_refContext is an interface to support dynamic dispatch.
type IObject_type_refContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id_or_type() IAn_id_or_typeContext

	// IsObject_type_refContext differentiates from other interfaces.
	IsObject_type_refContext()
}

type Object_type_refContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObject_type_refContext() *Object_type_refContext {
	var p = new(Object_type_refContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_object_type_ref
	return p
}

func InitEmptyObject_type_refContext(p *Object_type_refContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_object_type_ref
}

func (*Object_type_refContext) IsObject_type_refContext() {}

func NewObject_type_refContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Object_type_refContext {
	var p = new(Object_type_refContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_object_type_ref

	return p
}

func (s *Object_type_refContext) GetParser() antlr.Parser { return s.parser }

func (s *Object_type_refContext) An_id_or_type() IAn_id_or_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_or_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_or_typeContext)
}

func (s *Object_type_refContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Object_type_refContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Object_type_refContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterObject_type_ref(s)
	}
}

func (s *Object_type_refContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitObject_type_ref(s)
	}
}




func (p *YQLParser) Object_type_ref() (localctx IObject_type_refContext) {
	localctx = NewObject_type_refContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, YQLParserRULE_object_type_ref)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2823)
		p.An_id_or_type()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_table_stmtContext is an interface to support dynamic dispatch.
type ICreate_table_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	Simple_table_ref() ISimple_table_refContext
	LPAREN() antlr.TerminalNode
	AllCreate_table_entry() []ICreate_table_entryContext
	Create_table_entry(i int) ICreate_table_entryContext
	RPAREN() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TABLESTORE() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	TEMP() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	OR() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	Table_inherits() ITable_inheritsContext
	Table_partition_by() ITable_partition_byContext
	With_table_settings() IWith_table_settingsContext
	Table_tablestore() ITable_tablestoreContext
	Table_as_source() ITable_as_sourceContext

	// IsCreate_table_stmtContext differentiates from other interfaces.
	IsCreate_table_stmtContext()
}

type Create_table_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_stmtContext() *Create_table_stmtContext {
	var p = new(Create_table_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_create_table_stmt
	return p
}

func InitEmptyCreate_table_stmtContext(p *Create_table_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_create_table_stmt
}

func (*Create_table_stmtContext) IsCreate_table_stmtContext() {}

func NewCreate_table_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_stmtContext {
	var p = new(Create_table_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_create_table_stmt

	return p
}

func (s *Create_table_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_stmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(YQLParserCREATE, 0)
}

func (s *Create_table_stmtContext) Simple_table_ref() ISimple_table_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_table_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_table_refContext)
}

func (s *Create_table_stmtContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Create_table_stmtContext) AllCreate_table_entry() []ICreate_table_entryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_table_entryContext); ok {
			len++
		}
	}

	tst := make([]ICreate_table_entryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_table_entryContext); ok {
			tst[i] = t.(ICreate_table_entryContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_stmtContext) Create_table_entry(i int) ICreate_table_entryContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_entryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_entryContext)
}

func (s *Create_table_stmtContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Create_table_stmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(YQLParserTABLE, 0)
}

func (s *Create_table_stmtContext) TABLESTORE() antlr.TerminalNode {
	return s.GetToken(YQLParserTABLESTORE, 0)
}

func (s *Create_table_stmtContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(YQLParserEXTERNAL, 0)
}

func (s *Create_table_stmtContext) TEMP() antlr.TerminalNode {
	return s.GetToken(YQLParserTEMP, 0)
}

func (s *Create_table_stmtContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(YQLParserTEMPORARY, 0)
}

func (s *Create_table_stmtContext) OR() antlr.TerminalNode {
	return s.GetToken(YQLParserOR, 0)
}

func (s *Create_table_stmtContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(YQLParserREPLACE, 0)
}

func (s *Create_table_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(YQLParserIF, 0)
}

func (s *Create_table_stmtContext) NOT() antlr.TerminalNode {
	return s.GetToken(YQLParserNOT, 0)
}

func (s *Create_table_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(YQLParserEXISTS, 0)
}

func (s *Create_table_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Create_table_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Create_table_stmtContext) Table_inherits() ITable_inheritsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_inheritsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_inheritsContext)
}

func (s *Create_table_stmtContext) Table_partition_by() ITable_partition_byContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_partition_byContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_partition_byContext)
}

func (s *Create_table_stmtContext) With_table_settings() IWith_table_settingsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWith_table_settingsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWith_table_settingsContext)
}

func (s *Create_table_stmtContext) Table_tablestore() ITable_tablestoreContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_tablestoreContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_tablestoreContext)
}

func (s *Create_table_stmtContext) Table_as_source() ITable_as_sourceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_as_sourceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_as_sourceContext)
}

func (s *Create_table_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_table_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterCreate_table_stmt(s)
	}
}

func (s *Create_table_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitCreate_table_stmt(s)
	}
}




func (p *YQLParser) Create_table_stmt() (localctx ICreate_table_stmtContext) {
	localctx = NewCreate_table_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, YQLParserRULE_create_table_stmt)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2825)
		p.Match(YQLParserCREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2828)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserOR {
		{
			p.SetState(2826)
			p.Match(YQLParserOR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2827)
			p.Match(YQLParserREPLACE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(2838)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserTABLE:
		{
			p.SetState(2830)
			p.Match(YQLParserTABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserTABLESTORE:
		{
			p.SetState(2831)
			p.Match(YQLParserTABLESTORE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserEXTERNAL:
		{
			p.SetState(2832)
			p.Match(YQLParserEXTERNAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2833)
			p.Match(YQLParserTABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserTEMP:
		{
			p.SetState(2834)
			p.Match(YQLParserTEMP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2835)
			p.Match(YQLParserTABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserTEMPORARY:
		{
			p.SetState(2836)
			p.Match(YQLParserTEMPORARY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2837)
			p.Match(YQLParserTABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(2843)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 278, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2840)
			p.Match(YQLParserIF)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2841)
			p.Match(YQLParserNOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2842)
			p.Match(YQLParserEXISTS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(2845)
		p.Simple_table_ref()
	}
	{
		p.SetState(2846)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2847)
		p.Create_table_entry()
	}
	p.SetState(2852)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 279, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2848)
				p.Match(YQLParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2849)
				p.Create_table_entry()
			}


		}
		p.SetState(2854)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 279, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2856)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserCOMMA {
		{
			p.SetState(2855)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(2858)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2860)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserINHERITS {
		{
			p.SetState(2859)
			p.Table_inherits()
		}

	}
	p.SetState(2863)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserPARTITION {
		{
			p.SetState(2862)
			p.Table_partition_by()
		}

	}
	p.SetState(2866)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserWITH {
		{
			p.SetState(2865)
			p.With_table_settings()
		}

	}
	p.SetState(2869)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserTABLESTORE {
		{
			p.SetState(2868)
			p.Table_tablestore()
		}

	}
	p.SetState(2872)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserAS {
		{
			p.SetState(2871)
			p.Table_as_source()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_table_entryContext is an interface to support dynamic dispatch.
type ICreate_table_entryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Column_schema() IColumn_schemaContext
	Table_constraint() ITable_constraintContext
	Table_index() ITable_indexContext
	Family_entry() IFamily_entryContext
	Changefeed() IChangefeedContext
	An_id_schema() IAn_id_schemaContext

	// IsCreate_table_entryContext differentiates from other interfaces.
	IsCreate_table_entryContext()
}

type Create_table_entryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_entryContext() *Create_table_entryContext {
	var p = new(Create_table_entryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_create_table_entry
	return p
}

func InitEmptyCreate_table_entryContext(p *Create_table_entryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_create_table_entry
}

func (*Create_table_entryContext) IsCreate_table_entryContext() {}

func NewCreate_table_entryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_entryContext {
	var p = new(Create_table_entryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_create_table_entry

	return p
}

func (s *Create_table_entryContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_entryContext) Column_schema() IColumn_schemaContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_schemaContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_schemaContext)
}

func (s *Create_table_entryContext) Table_constraint() ITable_constraintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_constraintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_constraintContext)
}

func (s *Create_table_entryContext) Table_index() ITable_indexContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_indexContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_indexContext)
}

func (s *Create_table_entryContext) Family_entry() IFamily_entryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFamily_entryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFamily_entryContext)
}

func (s *Create_table_entryContext) Changefeed() IChangefeedContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChangefeedContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChangefeedContext)
}

func (s *Create_table_entryContext) An_id_schema() IAn_id_schemaContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_schemaContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_schemaContext)
}

func (s *Create_table_entryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_entryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_table_entryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterCreate_table_entry(s)
	}
}

func (s *Create_table_entryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitCreate_table_entry(s)
	}
}




func (p *YQLParser) Create_table_entry() (localctx ICreate_table_entryContext) {
	localctx = NewCreate_table_entryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, YQLParserRULE_create_table_entry)
	p.SetState(2880)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 286, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2874)
			p.Column_schema()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2875)
			p.Table_constraint()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2876)
			p.Table_index()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2877)
			p.Family_entry()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2878)
			p.Changefeed()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2879)
			p.An_id_schema()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_backup_collection_stmtContext is an interface to support dynamic dispatch.
type ICreate_backup_collection_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	Backup_collection() IBackup_collectionContext
	WITH() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Backup_collection_settings() IBackup_collection_settingsContext
	RPAREN() antlr.TerminalNode
	Create_backup_collection_entries() ICreate_backup_collection_entriesContext

	// IsCreate_backup_collection_stmtContext differentiates from other interfaces.
	IsCreate_backup_collection_stmtContext()
}

type Create_backup_collection_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_backup_collection_stmtContext() *Create_backup_collection_stmtContext {
	var p = new(Create_backup_collection_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_create_backup_collection_stmt
	return p
}

func InitEmptyCreate_backup_collection_stmtContext(p *Create_backup_collection_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_create_backup_collection_stmt
}

func (*Create_backup_collection_stmtContext) IsCreate_backup_collection_stmtContext() {}

func NewCreate_backup_collection_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_backup_collection_stmtContext {
	var p = new(Create_backup_collection_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_create_backup_collection_stmt

	return p
}

func (s *Create_backup_collection_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_backup_collection_stmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(YQLParserCREATE, 0)
}

func (s *Create_backup_collection_stmtContext) Backup_collection() IBackup_collectionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBackup_collectionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBackup_collectionContext)
}

func (s *Create_backup_collection_stmtContext) WITH() antlr.TerminalNode {
	return s.GetToken(YQLParserWITH, 0)
}

func (s *Create_backup_collection_stmtContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Create_backup_collection_stmtContext) Backup_collection_settings() IBackup_collection_settingsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBackup_collection_settingsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBackup_collection_settingsContext)
}

func (s *Create_backup_collection_stmtContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Create_backup_collection_stmtContext) Create_backup_collection_entries() ICreate_backup_collection_entriesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_backup_collection_entriesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_backup_collection_entriesContext)
}

func (s *Create_backup_collection_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_backup_collection_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_backup_collection_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterCreate_backup_collection_stmt(s)
	}
}

func (s *Create_backup_collection_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitCreate_backup_collection_stmt(s)
	}
}




func (p *YQLParser) Create_backup_collection_stmt() (localctx ICreate_backup_collection_stmtContext) {
	localctx = NewCreate_backup_collection_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, YQLParserRULE_create_backup_collection_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2882)
		p.Match(YQLParserCREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2883)
		p.Backup_collection()
	}
	p.SetState(2885)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserLPAREN || _la == YQLParserDATABASE {
		{
			p.SetState(2884)
			p.Create_backup_collection_entries()
		}

	}
	{
		p.SetState(2887)
		p.Match(YQLParserWITH)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2888)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2889)
		p.Backup_collection_settings()
	}
	{
		p.SetState(2890)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_backup_collection_stmtContext is an interface to support dynamic dispatch.
type IAlter_backup_collection_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	Backup_collection() IBackup_collectionContext
	Alter_backup_collection_actions() IAlter_backup_collection_actionsContext
	Alter_backup_collection_entries() IAlter_backup_collection_entriesContext

	// IsAlter_backup_collection_stmtContext differentiates from other interfaces.
	IsAlter_backup_collection_stmtContext()
}

type Alter_backup_collection_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_backup_collection_stmtContext() *Alter_backup_collection_stmtContext {
	var p = new(Alter_backup_collection_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_backup_collection_stmt
	return p
}

func InitEmptyAlter_backup_collection_stmtContext(p *Alter_backup_collection_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_backup_collection_stmt
}

func (*Alter_backup_collection_stmtContext) IsAlter_backup_collection_stmtContext() {}

func NewAlter_backup_collection_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_backup_collection_stmtContext {
	var p = new(Alter_backup_collection_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_backup_collection_stmt

	return p
}

func (s *Alter_backup_collection_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_backup_collection_stmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(YQLParserALTER, 0)
}

func (s *Alter_backup_collection_stmtContext) Backup_collection() IBackup_collectionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBackup_collectionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBackup_collectionContext)
}

func (s *Alter_backup_collection_stmtContext) Alter_backup_collection_actions() IAlter_backup_collection_actionsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_backup_collection_actionsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_backup_collection_actionsContext)
}

func (s *Alter_backup_collection_stmtContext) Alter_backup_collection_entries() IAlter_backup_collection_entriesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_backup_collection_entriesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_backup_collection_entriesContext)
}

func (s *Alter_backup_collection_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_backup_collection_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_backup_collection_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_backup_collection_stmt(s)
	}
}

func (s *Alter_backup_collection_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_backup_collection_stmt(s)
	}
}




func (p *YQLParser) Alter_backup_collection_stmt() (localctx IAlter_backup_collection_stmtContext) {
	localctx = NewAlter_backup_collection_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, YQLParserRULE_alter_backup_collection_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2892)
		p.Match(YQLParserALTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2893)
		p.Backup_collection()
	}
	p.SetState(2896)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserRESET, YQLParserSET:
		{
			p.SetState(2894)
			p.Alter_backup_collection_actions()
		}


	case YQLParserADD, YQLParserDROP:
		{
			p.SetState(2895)
			p.Alter_backup_collection_entries()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDrop_backup_collection_stmtContext is an interface to support dynamic dispatch.
type IDrop_backup_collection_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	Backup_collection() IBackup_collectionContext

	// IsDrop_backup_collection_stmtContext differentiates from other interfaces.
	IsDrop_backup_collection_stmtContext()
}

type Drop_backup_collection_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_backup_collection_stmtContext() *Drop_backup_collection_stmtContext {
	var p = new(Drop_backup_collection_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_drop_backup_collection_stmt
	return p
}

func InitEmptyDrop_backup_collection_stmtContext(p *Drop_backup_collection_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_drop_backup_collection_stmt
}

func (*Drop_backup_collection_stmtContext) IsDrop_backup_collection_stmtContext() {}

func NewDrop_backup_collection_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_backup_collection_stmtContext {
	var p = new(Drop_backup_collection_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_drop_backup_collection_stmt

	return p
}

func (s *Drop_backup_collection_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_backup_collection_stmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(YQLParserDROP, 0)
}

func (s *Drop_backup_collection_stmtContext) Backup_collection() IBackup_collectionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBackup_collectionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBackup_collectionContext)
}

func (s *Drop_backup_collection_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_backup_collection_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Drop_backup_collection_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterDrop_backup_collection_stmt(s)
	}
}

func (s *Drop_backup_collection_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitDrop_backup_collection_stmt(s)
	}
}




func (p *YQLParser) Drop_backup_collection_stmt() (localctx IDrop_backup_collection_stmtContext) {
	localctx = NewDrop_backup_collection_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, YQLParserRULE_drop_backup_collection_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2898)
		p.Match(YQLParserDROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2899)
		p.Backup_collection()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_backup_collection_entriesContext is an interface to support dynamic dispatch.
type ICreate_backup_collection_entriesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DATABASE() antlr.TerminalNode
	Create_backup_collection_entries_many() ICreate_backup_collection_entries_manyContext

	// IsCreate_backup_collection_entriesContext differentiates from other interfaces.
	IsCreate_backup_collection_entriesContext()
}

type Create_backup_collection_entriesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_backup_collection_entriesContext() *Create_backup_collection_entriesContext {
	var p = new(Create_backup_collection_entriesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_create_backup_collection_entries
	return p
}

func InitEmptyCreate_backup_collection_entriesContext(p *Create_backup_collection_entriesContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_create_backup_collection_entries
}

func (*Create_backup_collection_entriesContext) IsCreate_backup_collection_entriesContext() {}

func NewCreate_backup_collection_entriesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_backup_collection_entriesContext {
	var p = new(Create_backup_collection_entriesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_create_backup_collection_entries

	return p
}

func (s *Create_backup_collection_entriesContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_backup_collection_entriesContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(YQLParserDATABASE, 0)
}

func (s *Create_backup_collection_entriesContext) Create_backup_collection_entries_many() ICreate_backup_collection_entries_manyContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_backup_collection_entries_manyContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_backup_collection_entries_manyContext)
}

func (s *Create_backup_collection_entriesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_backup_collection_entriesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_backup_collection_entriesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterCreate_backup_collection_entries(s)
	}
}

func (s *Create_backup_collection_entriesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitCreate_backup_collection_entries(s)
	}
}




func (p *YQLParser) Create_backup_collection_entries() (localctx ICreate_backup_collection_entriesContext) {
	localctx = NewCreate_backup_collection_entriesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, YQLParserRULE_create_backup_collection_entries)
	p.SetState(2903)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserDATABASE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2901)
			p.Match(YQLParserDATABASE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2902)
			p.Create_backup_collection_entries_many()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_backup_collection_entries_manyContext is an interface to support dynamic dispatch.
type ICreate_backup_collection_entries_manyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	Table_list() ITable_listContext
	RPAREN() antlr.TerminalNode

	// IsCreate_backup_collection_entries_manyContext differentiates from other interfaces.
	IsCreate_backup_collection_entries_manyContext()
}

type Create_backup_collection_entries_manyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_backup_collection_entries_manyContext() *Create_backup_collection_entries_manyContext {
	var p = new(Create_backup_collection_entries_manyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_create_backup_collection_entries_many
	return p
}

func InitEmptyCreate_backup_collection_entries_manyContext(p *Create_backup_collection_entries_manyContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_create_backup_collection_entries_many
}

func (*Create_backup_collection_entries_manyContext) IsCreate_backup_collection_entries_manyContext() {}

func NewCreate_backup_collection_entries_manyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_backup_collection_entries_manyContext {
	var p = new(Create_backup_collection_entries_manyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_create_backup_collection_entries_many

	return p
}

func (s *Create_backup_collection_entries_manyContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_backup_collection_entries_manyContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Create_backup_collection_entries_manyContext) Table_list() ITable_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_listContext)
}

func (s *Create_backup_collection_entries_manyContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Create_backup_collection_entries_manyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_backup_collection_entries_manyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_backup_collection_entries_manyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterCreate_backup_collection_entries_many(s)
	}
}

func (s *Create_backup_collection_entries_manyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitCreate_backup_collection_entries_many(s)
	}
}




func (p *YQLParser) Create_backup_collection_entries_many() (localctx ICreate_backup_collection_entries_manyContext) {
	localctx = NewCreate_backup_collection_entries_manyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, YQLParserRULE_create_backup_collection_entries_many)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2905)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2906)
		p.Table_list()
	}
	{
		p.SetState(2907)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITable_listContext is an interface to support dynamic dispatch.
type ITable_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTABLE() []antlr.TerminalNode
	TABLE(i int) antlr.TerminalNode
	AllAn_id_table() []IAn_id_tableContext
	An_id_table(i int) IAn_id_tableContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTable_listContext differentiates from other interfaces.
	IsTable_listContext()
}

type Table_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_listContext() *Table_listContext {
	var p = new(Table_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_table_list
	return p
}

func InitEmptyTable_listContext(p *Table_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_table_list
}

func (*Table_listContext) IsTable_listContext() {}

func NewTable_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_listContext {
	var p = new(Table_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_table_list

	return p
}

func (s *Table_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_listContext) AllTABLE() []antlr.TerminalNode {
	return s.GetTokens(YQLParserTABLE)
}

func (s *Table_listContext) TABLE(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserTABLE, i)
}

func (s *Table_listContext) AllAn_id_table() []IAn_id_tableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAn_id_tableContext); ok {
			len++
		}
	}

	tst := make([]IAn_id_tableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAn_id_tableContext); ok {
			tst[i] = t.(IAn_id_tableContext)
			i++
		}
	}

	return tst
}

func (s *Table_listContext) An_id_table(i int) IAn_id_tableContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_tableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_tableContext)
}

func (s *Table_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Table_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Table_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Table_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterTable_list(s)
	}
}

func (s *Table_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitTable_list(s)
	}
}




func (p *YQLParser) Table_list() (localctx ITable_listContext) {
	localctx = NewTable_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, YQLParserRULE_table_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2909)
		p.Match(YQLParserTABLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2910)
		p.An_id_table()
	}
	p.SetState(2916)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(2911)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2912)
			p.Match(YQLParserTABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2913)
			p.An_id_table()
		}


		p.SetState(2918)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_backup_collection_actionsContext is an interface to support dynamic dispatch.
type IAlter_backup_collection_actionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAlter_backup_collection_action() []IAlter_backup_collection_actionContext
	Alter_backup_collection_action(i int) IAlter_backup_collection_actionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAlter_backup_collection_actionsContext differentiates from other interfaces.
	IsAlter_backup_collection_actionsContext()
}

type Alter_backup_collection_actionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_backup_collection_actionsContext() *Alter_backup_collection_actionsContext {
	var p = new(Alter_backup_collection_actionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_backup_collection_actions
	return p
}

func InitEmptyAlter_backup_collection_actionsContext(p *Alter_backup_collection_actionsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_backup_collection_actions
}

func (*Alter_backup_collection_actionsContext) IsAlter_backup_collection_actionsContext() {}

func NewAlter_backup_collection_actionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_backup_collection_actionsContext {
	var p = new(Alter_backup_collection_actionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_backup_collection_actions

	return p
}

func (s *Alter_backup_collection_actionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_backup_collection_actionsContext) AllAlter_backup_collection_action() []IAlter_backup_collection_actionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlter_backup_collection_actionContext); ok {
			len++
		}
	}

	tst := make([]IAlter_backup_collection_actionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlter_backup_collection_actionContext); ok {
			tst[i] = t.(IAlter_backup_collection_actionContext)
			i++
		}
	}

	return tst
}

func (s *Alter_backup_collection_actionsContext) Alter_backup_collection_action(i int) IAlter_backup_collection_actionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_backup_collection_actionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_backup_collection_actionContext)
}

func (s *Alter_backup_collection_actionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Alter_backup_collection_actionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Alter_backup_collection_actionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_backup_collection_actionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_backup_collection_actionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_backup_collection_actions(s)
	}
}

func (s *Alter_backup_collection_actionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_backup_collection_actions(s)
	}
}




func (p *YQLParser) Alter_backup_collection_actions() (localctx IAlter_backup_collection_actionsContext) {
	localctx = NewAlter_backup_collection_actionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, YQLParserRULE_alter_backup_collection_actions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2919)
		p.Alter_backup_collection_action()
	}
	p.SetState(2924)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(2920)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2921)
			p.Alter_backup_collection_action()
		}


		p.SetState(2926)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_backup_collection_actionContext is an interface to support dynamic dispatch.
type IAlter_backup_collection_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Alter_table_set_table_setting_compat() IAlter_table_set_table_setting_compatContext
	Alter_table_reset_table_setting() IAlter_table_reset_table_settingContext

	// IsAlter_backup_collection_actionContext differentiates from other interfaces.
	IsAlter_backup_collection_actionContext()
}

type Alter_backup_collection_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_backup_collection_actionContext() *Alter_backup_collection_actionContext {
	var p = new(Alter_backup_collection_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_backup_collection_action
	return p
}

func InitEmptyAlter_backup_collection_actionContext(p *Alter_backup_collection_actionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_backup_collection_action
}

func (*Alter_backup_collection_actionContext) IsAlter_backup_collection_actionContext() {}

func NewAlter_backup_collection_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_backup_collection_actionContext {
	var p = new(Alter_backup_collection_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_backup_collection_action

	return p
}

func (s *Alter_backup_collection_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_backup_collection_actionContext) Alter_table_set_table_setting_compat() IAlter_table_set_table_setting_compatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_set_table_setting_compatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_set_table_setting_compatContext)
}

func (s *Alter_backup_collection_actionContext) Alter_table_reset_table_setting() IAlter_table_reset_table_settingContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_reset_table_settingContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_reset_table_settingContext)
}

func (s *Alter_backup_collection_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_backup_collection_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_backup_collection_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_backup_collection_action(s)
	}
}

func (s *Alter_backup_collection_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_backup_collection_action(s)
	}
}




func (p *YQLParser) Alter_backup_collection_action() (localctx IAlter_backup_collection_actionContext) {
	localctx = NewAlter_backup_collection_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, YQLParserRULE_alter_backup_collection_action)
	p.SetState(2929)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserSET:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2927)
			p.Alter_table_set_table_setting_compat()
		}


	case YQLParserRESET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2928)
			p.Alter_table_reset_table_setting()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_backup_collection_entriesContext is an interface to support dynamic dispatch.
type IAlter_backup_collection_entriesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAlter_backup_collection_entry() []IAlter_backup_collection_entryContext
	Alter_backup_collection_entry(i int) IAlter_backup_collection_entryContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAlter_backup_collection_entriesContext differentiates from other interfaces.
	IsAlter_backup_collection_entriesContext()
}

type Alter_backup_collection_entriesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_backup_collection_entriesContext() *Alter_backup_collection_entriesContext {
	var p = new(Alter_backup_collection_entriesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_backup_collection_entries
	return p
}

func InitEmptyAlter_backup_collection_entriesContext(p *Alter_backup_collection_entriesContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_backup_collection_entries
}

func (*Alter_backup_collection_entriesContext) IsAlter_backup_collection_entriesContext() {}

func NewAlter_backup_collection_entriesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_backup_collection_entriesContext {
	var p = new(Alter_backup_collection_entriesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_backup_collection_entries

	return p
}

func (s *Alter_backup_collection_entriesContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_backup_collection_entriesContext) AllAlter_backup_collection_entry() []IAlter_backup_collection_entryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlter_backup_collection_entryContext); ok {
			len++
		}
	}

	tst := make([]IAlter_backup_collection_entryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlter_backup_collection_entryContext); ok {
			tst[i] = t.(IAlter_backup_collection_entryContext)
			i++
		}
	}

	return tst
}

func (s *Alter_backup_collection_entriesContext) Alter_backup_collection_entry(i int) IAlter_backup_collection_entryContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_backup_collection_entryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_backup_collection_entryContext)
}

func (s *Alter_backup_collection_entriesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Alter_backup_collection_entriesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Alter_backup_collection_entriesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_backup_collection_entriesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_backup_collection_entriesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_backup_collection_entries(s)
	}
}

func (s *Alter_backup_collection_entriesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_backup_collection_entries(s)
	}
}




func (p *YQLParser) Alter_backup_collection_entries() (localctx IAlter_backup_collection_entriesContext) {
	localctx = NewAlter_backup_collection_entriesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, YQLParserRULE_alter_backup_collection_entries)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2931)
		p.Alter_backup_collection_entry()
	}
	p.SetState(2936)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(2932)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2933)
			p.Alter_backup_collection_entry()
		}


		p.SetState(2938)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_backup_collection_entryContext is an interface to support dynamic dispatch.
type IAlter_backup_collection_entryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	DROP() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	An_id_table() IAn_id_tableContext

	// IsAlter_backup_collection_entryContext differentiates from other interfaces.
	IsAlter_backup_collection_entryContext()
}

type Alter_backup_collection_entryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_backup_collection_entryContext() *Alter_backup_collection_entryContext {
	var p = new(Alter_backup_collection_entryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_backup_collection_entry
	return p
}

func InitEmptyAlter_backup_collection_entryContext(p *Alter_backup_collection_entryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_backup_collection_entry
}

func (*Alter_backup_collection_entryContext) IsAlter_backup_collection_entryContext() {}

func NewAlter_backup_collection_entryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_backup_collection_entryContext {
	var p = new(Alter_backup_collection_entryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_backup_collection_entry

	return p
}

func (s *Alter_backup_collection_entryContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_backup_collection_entryContext) ADD() antlr.TerminalNode {
	return s.GetToken(YQLParserADD, 0)
}

func (s *Alter_backup_collection_entryContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(YQLParserDATABASE, 0)
}

func (s *Alter_backup_collection_entryContext) DROP() antlr.TerminalNode {
	return s.GetToken(YQLParserDROP, 0)
}

func (s *Alter_backup_collection_entryContext) TABLE() antlr.TerminalNode {
	return s.GetToken(YQLParserTABLE, 0)
}

func (s *Alter_backup_collection_entryContext) An_id_table() IAn_id_tableContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_tableContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_tableContext)
}

func (s *Alter_backup_collection_entryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_backup_collection_entryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_backup_collection_entryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_backup_collection_entry(s)
	}
}

func (s *Alter_backup_collection_entryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_backup_collection_entry(s)
	}
}




func (p *YQLParser) Alter_backup_collection_entry() (localctx IAlter_backup_collection_entryContext) {
	localctx = NewAlter_backup_collection_entryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, YQLParserRULE_alter_backup_collection_entry)
	p.SetState(2949)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 294, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2939)
			p.Match(YQLParserADD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2940)
			p.Match(YQLParserDATABASE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2941)
			p.Match(YQLParserDROP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2942)
			p.Match(YQLParserDATABASE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2943)
			p.Match(YQLParserADD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2944)
			p.Match(YQLParserTABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2945)
			p.An_id_table()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2946)
			p.Match(YQLParserDROP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2947)
			p.Match(YQLParserTABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2948)
			p.An_id_table()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBackup_collectionContext is an interface to support dynamic dispatch.
type IBackup_collectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BACKUP() antlr.TerminalNode
	COLLECTION() antlr.TerminalNode
	Object_ref() IObject_refContext

	// IsBackup_collectionContext differentiates from other interfaces.
	IsBackup_collectionContext()
}

type Backup_collectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBackup_collectionContext() *Backup_collectionContext {
	var p = new(Backup_collectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_backup_collection
	return p
}

func InitEmptyBackup_collectionContext(p *Backup_collectionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_backup_collection
}

func (*Backup_collectionContext) IsBackup_collectionContext() {}

func NewBackup_collectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Backup_collectionContext {
	var p = new(Backup_collectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_backup_collection

	return p
}

func (s *Backup_collectionContext) GetParser() antlr.Parser { return s.parser }

func (s *Backup_collectionContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(YQLParserBACKUP, 0)
}

func (s *Backup_collectionContext) COLLECTION() antlr.TerminalNode {
	return s.GetToken(YQLParserCOLLECTION, 0)
}

func (s *Backup_collectionContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Backup_collectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Backup_collectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Backup_collectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterBackup_collection(s)
	}
}

func (s *Backup_collectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitBackup_collection(s)
	}
}




func (p *YQLParser) Backup_collection() (localctx IBackup_collectionContext) {
	localctx = NewBackup_collectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, YQLParserRULE_backup_collection)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2951)
		p.Match(YQLParserBACKUP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2952)
		p.Match(YQLParserCOLLECTION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2953)
		p.Object_ref()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBackup_collection_settingsContext is an interface to support dynamic dispatch.
type IBackup_collection_settingsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllBackup_collection_settings_entry() []IBackup_collection_settings_entryContext
	Backup_collection_settings_entry(i int) IBackup_collection_settings_entryContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsBackup_collection_settingsContext differentiates from other interfaces.
	IsBackup_collection_settingsContext()
}

type Backup_collection_settingsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBackup_collection_settingsContext() *Backup_collection_settingsContext {
	var p = new(Backup_collection_settingsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_backup_collection_settings
	return p
}

func InitEmptyBackup_collection_settingsContext(p *Backup_collection_settingsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_backup_collection_settings
}

func (*Backup_collection_settingsContext) IsBackup_collection_settingsContext() {}

func NewBackup_collection_settingsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Backup_collection_settingsContext {
	var p = new(Backup_collection_settingsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_backup_collection_settings

	return p
}

func (s *Backup_collection_settingsContext) GetParser() antlr.Parser { return s.parser }

func (s *Backup_collection_settingsContext) AllBackup_collection_settings_entry() []IBackup_collection_settings_entryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBackup_collection_settings_entryContext); ok {
			len++
		}
	}

	tst := make([]IBackup_collection_settings_entryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBackup_collection_settings_entryContext); ok {
			tst[i] = t.(IBackup_collection_settings_entryContext)
			i++
		}
	}

	return tst
}

func (s *Backup_collection_settingsContext) Backup_collection_settings_entry(i int) IBackup_collection_settings_entryContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBackup_collection_settings_entryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBackup_collection_settings_entryContext)
}

func (s *Backup_collection_settingsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Backup_collection_settingsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Backup_collection_settingsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Backup_collection_settingsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Backup_collection_settingsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterBackup_collection_settings(s)
	}
}

func (s *Backup_collection_settingsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitBackup_collection_settings(s)
	}
}




func (p *YQLParser) Backup_collection_settings() (localctx IBackup_collection_settingsContext) {
	localctx = NewBackup_collection_settingsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, YQLParserRULE_backup_collection_settings)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2955)
		p.Backup_collection_settings_entry()
	}
	p.SetState(2960)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(2956)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2957)
			p.Backup_collection_settings_entry()
		}


		p.SetState(2962)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBackup_collection_settings_entryContext is an interface to support dynamic dispatch.
type IBackup_collection_settings_entryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id() IAn_idContext
	EQUALS() antlr.TerminalNode
	Table_setting_value() ITable_setting_valueContext

	// IsBackup_collection_settings_entryContext differentiates from other interfaces.
	IsBackup_collection_settings_entryContext()
}

type Backup_collection_settings_entryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBackup_collection_settings_entryContext() *Backup_collection_settings_entryContext {
	var p = new(Backup_collection_settings_entryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_backup_collection_settings_entry
	return p
}

func InitEmptyBackup_collection_settings_entryContext(p *Backup_collection_settings_entryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_backup_collection_settings_entry
}

func (*Backup_collection_settings_entryContext) IsBackup_collection_settings_entryContext() {}

func NewBackup_collection_settings_entryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Backup_collection_settings_entryContext {
	var p = new(Backup_collection_settings_entryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_backup_collection_settings_entry

	return p
}

func (s *Backup_collection_settings_entryContext) GetParser() antlr.Parser { return s.parser }

func (s *Backup_collection_settings_entryContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Backup_collection_settings_entryContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(YQLParserEQUALS, 0)
}

func (s *Backup_collection_settings_entryContext) Table_setting_value() ITable_setting_valueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_setting_valueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_setting_valueContext)
}

func (s *Backup_collection_settings_entryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Backup_collection_settings_entryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Backup_collection_settings_entryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterBackup_collection_settings_entry(s)
	}
}

func (s *Backup_collection_settings_entryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitBackup_collection_settings_entry(s)
	}
}




func (p *YQLParser) Backup_collection_settings_entry() (localctx IBackup_collection_settings_entryContext) {
	localctx = NewBackup_collection_settings_entryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, YQLParserRULE_backup_collection_settings_entry)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2963)
		p.An_id()
	}
	{
		p.SetState(2964)
		p.Match(YQLParserEQUALS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2965)
		p.Table_setting_value()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBackup_stmtContext is an interface to support dynamic dispatch.
type IBackup_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BACKUP() antlr.TerminalNode
	Object_ref() IObject_refContext
	INCREMENTAL() antlr.TerminalNode

	// IsBackup_stmtContext differentiates from other interfaces.
	IsBackup_stmtContext()
}

type Backup_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBackup_stmtContext() *Backup_stmtContext {
	var p = new(Backup_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_backup_stmt
	return p
}

func InitEmptyBackup_stmtContext(p *Backup_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_backup_stmt
}

func (*Backup_stmtContext) IsBackup_stmtContext() {}

func NewBackup_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Backup_stmtContext {
	var p = new(Backup_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_backup_stmt

	return p
}

func (s *Backup_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Backup_stmtContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(YQLParserBACKUP, 0)
}

func (s *Backup_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Backup_stmtContext) INCREMENTAL() antlr.TerminalNode {
	return s.GetToken(YQLParserINCREMENTAL, 0)
}

func (s *Backup_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Backup_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Backup_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterBackup_stmt(s)
	}
}

func (s *Backup_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitBackup_stmt(s)
	}
}




func (p *YQLParser) Backup_stmt() (localctx IBackup_stmtContext) {
	localctx = NewBackup_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, YQLParserRULE_backup_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2967)
		p.Match(YQLParserBACKUP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2968)
		p.Object_ref()
	}
	p.SetState(2970)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserINCREMENTAL {
		{
			p.SetState(2969)
			p.Match(YQLParserINCREMENTAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRestore_stmtContext is an interface to support dynamic dispatch.
type IRestore_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESTORE() antlr.TerminalNode
	Object_ref() IObject_refContext
	AT() antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode

	// IsRestore_stmtContext differentiates from other interfaces.
	IsRestore_stmtContext()
}

type Restore_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRestore_stmtContext() *Restore_stmtContext {
	var p = new(Restore_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_restore_stmt
	return p
}

func InitEmptyRestore_stmtContext(p *Restore_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_restore_stmt
}

func (*Restore_stmtContext) IsRestore_stmtContext() {}

func NewRestore_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Restore_stmtContext {
	var p = new(Restore_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_restore_stmt

	return p
}

func (s *Restore_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Restore_stmtContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(YQLParserRESTORE, 0)
}

func (s *Restore_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Restore_stmtContext) AT() antlr.TerminalNode {
	return s.GetToken(YQLParserAT, 0)
}

func (s *Restore_stmtContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(YQLParserSTRING_VALUE, 0)
}

func (s *Restore_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Restore_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Restore_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterRestore_stmt(s)
	}
}

func (s *Restore_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitRestore_stmt(s)
	}
}




func (p *YQLParser) Restore_stmt() (localctx IRestore_stmtContext) {
	localctx = NewRestore_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, YQLParserRULE_restore_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2972)
		p.Match(YQLParserRESTORE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2973)
		p.Object_ref()
	}
	p.SetState(2976)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserAT {
		{
			p.SetState(2974)
			p.Match(YQLParserAT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2975)
			p.Match(YQLParserSTRING_VALUE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITable_inheritsContext is an interface to support dynamic dispatch.
type ITable_inheritsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INHERITS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllSimple_table_ref_core() []ISimple_table_ref_coreContext
	Simple_table_ref_core(i int) ISimple_table_ref_coreContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTable_inheritsContext differentiates from other interfaces.
	IsTable_inheritsContext()
}

type Table_inheritsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_inheritsContext() *Table_inheritsContext {
	var p = new(Table_inheritsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_table_inherits
	return p
}

func InitEmptyTable_inheritsContext(p *Table_inheritsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_table_inherits
}

func (*Table_inheritsContext) IsTable_inheritsContext() {}

func NewTable_inheritsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_inheritsContext {
	var p = new(Table_inheritsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_table_inherits

	return p
}

func (s *Table_inheritsContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_inheritsContext) INHERITS() antlr.TerminalNode {
	return s.GetToken(YQLParserINHERITS, 0)
}

func (s *Table_inheritsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Table_inheritsContext) AllSimple_table_ref_core() []ISimple_table_ref_coreContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimple_table_ref_coreContext); ok {
			len++
		}
	}

	tst := make([]ISimple_table_ref_coreContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimple_table_ref_coreContext); ok {
			tst[i] = t.(ISimple_table_ref_coreContext)
			i++
		}
	}

	return tst
}

func (s *Table_inheritsContext) Simple_table_ref_core(i int) ISimple_table_ref_coreContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_table_ref_coreContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_table_ref_coreContext)
}

func (s *Table_inheritsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Table_inheritsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Table_inheritsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Table_inheritsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_inheritsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Table_inheritsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterTable_inherits(s)
	}
}

func (s *Table_inheritsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitTable_inherits(s)
	}
}




func (p *YQLParser) Table_inherits() (localctx ITable_inheritsContext) {
	localctx = NewTable_inheritsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 450, YQLParserRULE_table_inherits)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2978)
		p.Match(YQLParserINHERITS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2979)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2980)
		p.Simple_table_ref_core()
	}
	p.SetState(2985)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(2981)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2982)
			p.Simple_table_ref_core()
		}


		p.SetState(2987)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2988)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITable_partition_byContext is an interface to support dynamic dispatch.
type ITable_partition_byContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	HASH() antlr.TerminalNode
	Pure_column_list() IPure_column_listContext

	// IsTable_partition_byContext differentiates from other interfaces.
	IsTable_partition_byContext()
}

type Table_partition_byContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_partition_byContext() *Table_partition_byContext {
	var p = new(Table_partition_byContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_table_partition_by
	return p
}

func InitEmptyTable_partition_byContext(p *Table_partition_byContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_table_partition_by
}

func (*Table_partition_byContext) IsTable_partition_byContext() {}

func NewTable_partition_byContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_partition_byContext {
	var p = new(Table_partition_byContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_table_partition_by

	return p
}

func (s *Table_partition_byContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_partition_byContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(YQLParserPARTITION, 0)
}

func (s *Table_partition_byContext) BY() antlr.TerminalNode {
	return s.GetToken(YQLParserBY, 0)
}

func (s *Table_partition_byContext) HASH() antlr.TerminalNode {
	return s.GetToken(YQLParserHASH, 0)
}

func (s *Table_partition_byContext) Pure_column_list() IPure_column_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPure_column_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPure_column_listContext)
}

func (s *Table_partition_byContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_partition_byContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Table_partition_byContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterTable_partition_by(s)
	}
}

func (s *Table_partition_byContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitTable_partition_by(s)
	}
}




func (p *YQLParser) Table_partition_by() (localctx ITable_partition_byContext) {
	localctx = NewTable_partition_byContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 452, YQLParserRULE_table_partition_by)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2990)
		p.Match(YQLParserPARTITION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2991)
		p.Match(YQLParserBY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2992)
		p.Match(YQLParserHASH)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2993)
		p.Pure_column_list()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWith_table_settingsContext is an interface to support dynamic dispatch.
type IWith_table_settingsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllTable_settings_entry() []ITable_settings_entryContext
	Table_settings_entry(i int) ITable_settings_entryContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWith_table_settingsContext differentiates from other interfaces.
	IsWith_table_settingsContext()
}

type With_table_settingsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWith_table_settingsContext() *With_table_settingsContext {
	var p = new(With_table_settingsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_with_table_settings
	return p
}

func InitEmptyWith_table_settingsContext(p *With_table_settingsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_with_table_settings
}

func (*With_table_settingsContext) IsWith_table_settingsContext() {}

func NewWith_table_settingsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *With_table_settingsContext {
	var p = new(With_table_settingsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_with_table_settings

	return p
}

func (s *With_table_settingsContext) GetParser() antlr.Parser { return s.parser }

func (s *With_table_settingsContext) WITH() antlr.TerminalNode {
	return s.GetToken(YQLParserWITH, 0)
}

func (s *With_table_settingsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *With_table_settingsContext) AllTable_settings_entry() []ITable_settings_entryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITable_settings_entryContext); ok {
			len++
		}
	}

	tst := make([]ITable_settings_entryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITable_settings_entryContext); ok {
			tst[i] = t.(ITable_settings_entryContext)
			i++
		}
	}

	return tst
}

func (s *With_table_settingsContext) Table_settings_entry(i int) ITable_settings_entryContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_settings_entryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_settings_entryContext)
}

func (s *With_table_settingsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *With_table_settingsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *With_table_settingsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *With_table_settingsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *With_table_settingsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *With_table_settingsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterWith_table_settings(s)
	}
}

func (s *With_table_settingsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitWith_table_settings(s)
	}
}




func (p *YQLParser) With_table_settings() (localctx IWith_table_settingsContext) {
	localctx = NewWith_table_settingsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 454, YQLParserRULE_with_table_settings)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2995)
		p.Match(YQLParserWITH)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2996)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2997)
		p.Table_settings_entry()
	}
	p.SetState(3002)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(2998)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2999)
			p.Table_settings_entry()
		}


		p.SetState(3004)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3005)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITable_tablestoreContext is an interface to support dynamic dispatch.
type ITable_tablestoreContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLESTORE() antlr.TerminalNode
	Simple_table_ref_core() ISimple_table_ref_coreContext

	// IsTable_tablestoreContext differentiates from other interfaces.
	IsTable_tablestoreContext()
}

type Table_tablestoreContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_tablestoreContext() *Table_tablestoreContext {
	var p = new(Table_tablestoreContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_table_tablestore
	return p
}

func InitEmptyTable_tablestoreContext(p *Table_tablestoreContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_table_tablestore
}

func (*Table_tablestoreContext) IsTable_tablestoreContext() {}

func NewTable_tablestoreContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_tablestoreContext {
	var p = new(Table_tablestoreContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_table_tablestore

	return p
}

func (s *Table_tablestoreContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_tablestoreContext) TABLESTORE() antlr.TerminalNode {
	return s.GetToken(YQLParserTABLESTORE, 0)
}

func (s *Table_tablestoreContext) Simple_table_ref_core() ISimple_table_ref_coreContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_table_ref_coreContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_table_ref_coreContext)
}

func (s *Table_tablestoreContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_tablestoreContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Table_tablestoreContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterTable_tablestore(s)
	}
}

func (s *Table_tablestoreContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitTable_tablestore(s)
	}
}




func (p *YQLParser) Table_tablestore() (localctx ITable_tablestoreContext) {
	localctx = NewTable_tablestoreContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 456, YQLParserRULE_table_tablestore)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3007)
		p.Match(YQLParserTABLESTORE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3008)
		p.Simple_table_ref_core()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITable_settings_entryContext is an interface to support dynamic dispatch.
type ITable_settings_entryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id() IAn_idContext
	EQUALS() antlr.TerminalNode
	Table_setting_value() ITable_setting_valueContext

	// IsTable_settings_entryContext differentiates from other interfaces.
	IsTable_settings_entryContext()
}

type Table_settings_entryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_settings_entryContext() *Table_settings_entryContext {
	var p = new(Table_settings_entryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_table_settings_entry
	return p
}

func InitEmptyTable_settings_entryContext(p *Table_settings_entryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_table_settings_entry
}

func (*Table_settings_entryContext) IsTable_settings_entryContext() {}

func NewTable_settings_entryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_settings_entryContext {
	var p = new(Table_settings_entryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_table_settings_entry

	return p
}

func (s *Table_settings_entryContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_settings_entryContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Table_settings_entryContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(YQLParserEQUALS, 0)
}

func (s *Table_settings_entryContext) Table_setting_value() ITable_setting_valueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_setting_valueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_setting_valueContext)
}

func (s *Table_settings_entryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_settings_entryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Table_settings_entryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterTable_settings_entry(s)
	}
}

func (s *Table_settings_entryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitTable_settings_entry(s)
	}
}




func (p *YQLParser) Table_settings_entry() (localctx ITable_settings_entryContext) {
	localctx = NewTable_settings_entryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 458, YQLParserRULE_table_settings_entry)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3010)
		p.An_id()
	}
	{
		p.SetState(3011)
		p.Match(YQLParserEQUALS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3012)
		p.Table_setting_value()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITable_as_sourceContext is an interface to support dynamic dispatch.
type ITable_as_sourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS() antlr.TerminalNode
	Values_source() IValues_sourceContext

	// IsTable_as_sourceContext differentiates from other interfaces.
	IsTable_as_sourceContext()
}

type Table_as_sourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_as_sourceContext() *Table_as_sourceContext {
	var p = new(Table_as_sourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_table_as_source
	return p
}

func InitEmptyTable_as_sourceContext(p *Table_as_sourceContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_table_as_source
}

func (*Table_as_sourceContext) IsTable_as_sourceContext() {}

func NewTable_as_sourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_as_sourceContext {
	var p = new(Table_as_sourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_table_as_source

	return p
}

func (s *Table_as_sourceContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_as_sourceContext) AS() antlr.TerminalNode {
	return s.GetToken(YQLParserAS, 0)
}

func (s *Table_as_sourceContext) Values_source() IValues_sourceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValues_sourceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValues_sourceContext)
}

func (s *Table_as_sourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_as_sourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Table_as_sourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterTable_as_source(s)
	}
}

func (s *Table_as_sourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitTable_as_source(s)
	}
}




func (p *YQLParser) Table_as_source() (localctx ITable_as_sourceContext) {
	localctx = NewTable_as_sourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 460, YQLParserRULE_table_as_source)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3014)
		p.Match(YQLParserAS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3015)
		p.Values_source()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_table_stmtContext is an interface to support dynamic dispatch.
type IAlter_table_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	Simple_table_ref() ISimple_table_refContext
	AllAlter_table_action() []IAlter_table_actionContext
	Alter_table_action(i int) IAlter_table_actionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAlter_table_stmtContext differentiates from other interfaces.
	IsAlter_table_stmtContext()
}

type Alter_table_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_stmtContext() *Alter_table_stmtContext {
	var p = new(Alter_table_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_stmt
	return p
}

func InitEmptyAlter_table_stmtContext(p *Alter_table_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_stmt
}

func (*Alter_table_stmtContext) IsAlter_table_stmtContext() {}

func NewAlter_table_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_stmtContext {
	var p = new(Alter_table_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_table_stmt

	return p
}

func (s *Alter_table_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_stmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(YQLParserALTER, 0)
}

func (s *Alter_table_stmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(YQLParserTABLE, 0)
}

func (s *Alter_table_stmtContext) Simple_table_ref() ISimple_table_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_table_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_table_refContext)
}

func (s *Alter_table_stmtContext) AllAlter_table_action() []IAlter_table_actionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlter_table_actionContext); ok {
			len++
		}
	}

	tst := make([]IAlter_table_actionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlter_table_actionContext); ok {
			tst[i] = t.(IAlter_table_actionContext)
			i++
		}
	}

	return tst
}

func (s *Alter_table_stmtContext) Alter_table_action(i int) IAlter_table_actionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_actionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_actionContext)
}

func (s *Alter_table_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Alter_table_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Alter_table_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_table_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_table_stmt(s)
	}
}

func (s *Alter_table_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_table_stmt(s)
	}
}




func (p *YQLParser) Alter_table_stmt() (localctx IAlter_table_stmtContext) {
	localctx = NewAlter_table_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 462, YQLParserRULE_alter_table_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3017)
		p.Match(YQLParserALTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3018)
		p.Match(YQLParserTABLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3019)
		p.Simple_table_ref()
	}
	{
		p.SetState(3020)
		p.Alter_table_action()
	}
	p.SetState(3025)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(3021)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3022)
			p.Alter_table_action()
		}


		p.SetState(3027)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_table_actionContext is an interface to support dynamic dispatch.
type IAlter_table_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Alter_table_add_column() IAlter_table_add_columnContext
	Alter_table_drop_column() IAlter_table_drop_columnContext
	Alter_table_alter_column() IAlter_table_alter_columnContext
	Alter_table_add_column_family() IAlter_table_add_column_familyContext
	Alter_table_alter_column_family() IAlter_table_alter_column_familyContext
	Alter_table_set_table_setting_uncompat() IAlter_table_set_table_setting_uncompatContext
	Alter_table_set_table_setting_compat() IAlter_table_set_table_setting_compatContext
	Alter_table_reset_table_setting() IAlter_table_reset_table_settingContext
	Alter_table_add_index() IAlter_table_add_indexContext
	Alter_table_drop_index() IAlter_table_drop_indexContext
	Alter_table_rename_to() IAlter_table_rename_toContext
	Alter_table_add_changefeed() IAlter_table_add_changefeedContext
	Alter_table_alter_changefeed() IAlter_table_alter_changefeedContext
	Alter_table_drop_changefeed() IAlter_table_drop_changefeedContext
	Alter_table_rename_index_to() IAlter_table_rename_index_toContext
	Alter_table_alter_index() IAlter_table_alter_indexContext
	Alter_table_alter_column_drop_not_null() IAlter_table_alter_column_drop_not_nullContext

	// IsAlter_table_actionContext differentiates from other interfaces.
	IsAlter_table_actionContext()
}

type Alter_table_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_actionContext() *Alter_table_actionContext {
	var p = new(Alter_table_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_action
	return p
}

func InitEmptyAlter_table_actionContext(p *Alter_table_actionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_action
}

func (*Alter_table_actionContext) IsAlter_table_actionContext() {}

func NewAlter_table_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_actionContext {
	var p = new(Alter_table_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_table_action

	return p
}

func (s *Alter_table_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_actionContext) Alter_table_add_column() IAlter_table_add_columnContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_add_columnContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_add_columnContext)
}

func (s *Alter_table_actionContext) Alter_table_drop_column() IAlter_table_drop_columnContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_drop_columnContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_drop_columnContext)
}

func (s *Alter_table_actionContext) Alter_table_alter_column() IAlter_table_alter_columnContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_alter_columnContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_alter_columnContext)
}

func (s *Alter_table_actionContext) Alter_table_add_column_family() IAlter_table_add_column_familyContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_add_column_familyContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_add_column_familyContext)
}

func (s *Alter_table_actionContext) Alter_table_alter_column_family() IAlter_table_alter_column_familyContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_alter_column_familyContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_alter_column_familyContext)
}

func (s *Alter_table_actionContext) Alter_table_set_table_setting_uncompat() IAlter_table_set_table_setting_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_set_table_setting_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_set_table_setting_uncompatContext)
}

func (s *Alter_table_actionContext) Alter_table_set_table_setting_compat() IAlter_table_set_table_setting_compatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_set_table_setting_compatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_set_table_setting_compatContext)
}

func (s *Alter_table_actionContext) Alter_table_reset_table_setting() IAlter_table_reset_table_settingContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_reset_table_settingContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_reset_table_settingContext)
}

func (s *Alter_table_actionContext) Alter_table_add_index() IAlter_table_add_indexContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_add_indexContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_add_indexContext)
}

func (s *Alter_table_actionContext) Alter_table_drop_index() IAlter_table_drop_indexContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_drop_indexContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_drop_indexContext)
}

func (s *Alter_table_actionContext) Alter_table_rename_to() IAlter_table_rename_toContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_rename_toContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_rename_toContext)
}

func (s *Alter_table_actionContext) Alter_table_add_changefeed() IAlter_table_add_changefeedContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_add_changefeedContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_add_changefeedContext)
}

func (s *Alter_table_actionContext) Alter_table_alter_changefeed() IAlter_table_alter_changefeedContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_alter_changefeedContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_alter_changefeedContext)
}

func (s *Alter_table_actionContext) Alter_table_drop_changefeed() IAlter_table_drop_changefeedContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_drop_changefeedContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_drop_changefeedContext)
}

func (s *Alter_table_actionContext) Alter_table_rename_index_to() IAlter_table_rename_index_toContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_rename_index_toContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_rename_index_toContext)
}

func (s *Alter_table_actionContext) Alter_table_alter_index() IAlter_table_alter_indexContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_alter_indexContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_alter_indexContext)
}

func (s *Alter_table_actionContext) Alter_table_alter_column_drop_not_null() IAlter_table_alter_column_drop_not_nullContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_alter_column_drop_not_nullContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_alter_column_drop_not_nullContext)
}

func (s *Alter_table_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_table_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_table_action(s)
	}
}

func (s *Alter_table_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_table_action(s)
	}
}




func (p *YQLParser) Alter_table_action() (localctx IAlter_table_actionContext) {
	localctx = NewAlter_table_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 464, YQLParserRULE_alter_table_action)
	p.SetState(3045)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 301, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3028)
			p.Alter_table_add_column()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3029)
			p.Alter_table_drop_column()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3030)
			p.Alter_table_alter_column()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3031)
			p.Alter_table_add_column_family()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3032)
			p.Alter_table_alter_column_family()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3033)
			p.Alter_table_set_table_setting_uncompat()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3034)
			p.Alter_table_set_table_setting_compat()
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3035)
			p.Alter_table_reset_table_setting()
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3036)
			p.Alter_table_add_index()
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3037)
			p.Alter_table_drop_index()
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3038)
			p.Alter_table_rename_to()
		}


	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(3039)
			p.Alter_table_add_changefeed()
		}


	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(3040)
			p.Alter_table_alter_changefeed()
		}


	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(3041)
			p.Alter_table_drop_changefeed()
		}


	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(3042)
			p.Alter_table_rename_index_to()
		}


	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(3043)
			p.Alter_table_alter_index()
		}


	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(3044)
			p.Alter_table_alter_column_drop_not_null()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_external_table_stmtContext is an interface to support dynamic dispatch.
type IAlter_external_table_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	Simple_table_ref() ISimple_table_refContext
	AllAlter_external_table_action() []IAlter_external_table_actionContext
	Alter_external_table_action(i int) IAlter_external_table_actionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAlter_external_table_stmtContext differentiates from other interfaces.
	IsAlter_external_table_stmtContext()
}

type Alter_external_table_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_external_table_stmtContext() *Alter_external_table_stmtContext {
	var p = new(Alter_external_table_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_external_table_stmt
	return p
}

func InitEmptyAlter_external_table_stmtContext(p *Alter_external_table_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_external_table_stmt
}

func (*Alter_external_table_stmtContext) IsAlter_external_table_stmtContext() {}

func NewAlter_external_table_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_external_table_stmtContext {
	var p = new(Alter_external_table_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_external_table_stmt

	return p
}

func (s *Alter_external_table_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_external_table_stmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(YQLParserALTER, 0)
}

func (s *Alter_external_table_stmtContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(YQLParserEXTERNAL, 0)
}

func (s *Alter_external_table_stmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(YQLParserTABLE, 0)
}

func (s *Alter_external_table_stmtContext) Simple_table_ref() ISimple_table_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_table_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_table_refContext)
}

func (s *Alter_external_table_stmtContext) AllAlter_external_table_action() []IAlter_external_table_actionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlter_external_table_actionContext); ok {
			len++
		}
	}

	tst := make([]IAlter_external_table_actionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlter_external_table_actionContext); ok {
			tst[i] = t.(IAlter_external_table_actionContext)
			i++
		}
	}

	return tst
}

func (s *Alter_external_table_stmtContext) Alter_external_table_action(i int) IAlter_external_table_actionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_external_table_actionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_external_table_actionContext)
}

func (s *Alter_external_table_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Alter_external_table_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Alter_external_table_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_external_table_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_external_table_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_external_table_stmt(s)
	}
}

func (s *Alter_external_table_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_external_table_stmt(s)
	}
}




func (p *YQLParser) Alter_external_table_stmt() (localctx IAlter_external_table_stmtContext) {
	localctx = NewAlter_external_table_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 466, YQLParserRULE_alter_external_table_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3047)
		p.Match(YQLParserALTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3048)
		p.Match(YQLParserEXTERNAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3049)
		p.Match(YQLParserTABLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3050)
		p.Simple_table_ref()
	}
	{
		p.SetState(3051)
		p.Alter_external_table_action()
	}
	p.SetState(3056)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(3052)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3053)
			p.Alter_external_table_action()
		}


		p.SetState(3058)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_external_table_actionContext is an interface to support dynamic dispatch.
type IAlter_external_table_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Alter_table_add_column() IAlter_table_add_columnContext
	Alter_table_drop_column() IAlter_table_drop_columnContext
	Alter_table_set_table_setting_uncompat() IAlter_table_set_table_setting_uncompatContext
	Alter_table_set_table_setting_compat() IAlter_table_set_table_setting_compatContext
	Alter_table_reset_table_setting() IAlter_table_reset_table_settingContext

	// IsAlter_external_table_actionContext differentiates from other interfaces.
	IsAlter_external_table_actionContext()
}

type Alter_external_table_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_external_table_actionContext() *Alter_external_table_actionContext {
	var p = new(Alter_external_table_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_external_table_action
	return p
}

func InitEmptyAlter_external_table_actionContext(p *Alter_external_table_actionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_external_table_action
}

func (*Alter_external_table_actionContext) IsAlter_external_table_actionContext() {}

func NewAlter_external_table_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_external_table_actionContext {
	var p = new(Alter_external_table_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_external_table_action

	return p
}

func (s *Alter_external_table_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_external_table_actionContext) Alter_table_add_column() IAlter_table_add_columnContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_add_columnContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_add_columnContext)
}

func (s *Alter_external_table_actionContext) Alter_table_drop_column() IAlter_table_drop_columnContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_drop_columnContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_drop_columnContext)
}

func (s *Alter_external_table_actionContext) Alter_table_set_table_setting_uncompat() IAlter_table_set_table_setting_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_set_table_setting_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_set_table_setting_uncompatContext)
}

func (s *Alter_external_table_actionContext) Alter_table_set_table_setting_compat() IAlter_table_set_table_setting_compatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_set_table_setting_compatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_set_table_setting_compatContext)
}

func (s *Alter_external_table_actionContext) Alter_table_reset_table_setting() IAlter_table_reset_table_settingContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_reset_table_settingContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_reset_table_settingContext)
}

func (s *Alter_external_table_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_external_table_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_external_table_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_external_table_action(s)
	}
}

func (s *Alter_external_table_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_external_table_action(s)
	}
}




func (p *YQLParser) Alter_external_table_action() (localctx IAlter_external_table_actionContext) {
	localctx = NewAlter_external_table_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 468, YQLParserRULE_alter_external_table_action)
	p.SetState(3064)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 303, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3059)
			p.Alter_table_add_column()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3060)
			p.Alter_table_drop_column()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3061)
			p.Alter_table_set_table_setting_uncompat()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3062)
			p.Alter_table_set_table_setting_compat()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3063)
			p.Alter_table_reset_table_setting()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_table_store_stmtContext is an interface to support dynamic dispatch.
type IAlter_table_store_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	TABLESTORE() antlr.TerminalNode
	Object_ref() IObject_refContext
	AllAlter_table_store_action() []IAlter_table_store_actionContext
	Alter_table_store_action(i int) IAlter_table_store_actionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAlter_table_store_stmtContext differentiates from other interfaces.
	IsAlter_table_store_stmtContext()
}

type Alter_table_store_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_store_stmtContext() *Alter_table_store_stmtContext {
	var p = new(Alter_table_store_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_store_stmt
	return p
}

func InitEmptyAlter_table_store_stmtContext(p *Alter_table_store_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_store_stmt
}

func (*Alter_table_store_stmtContext) IsAlter_table_store_stmtContext() {}

func NewAlter_table_store_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_store_stmtContext {
	var p = new(Alter_table_store_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_table_store_stmt

	return p
}

func (s *Alter_table_store_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_store_stmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(YQLParserALTER, 0)
}

func (s *Alter_table_store_stmtContext) TABLESTORE() antlr.TerminalNode {
	return s.GetToken(YQLParserTABLESTORE, 0)
}

func (s *Alter_table_store_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Alter_table_store_stmtContext) AllAlter_table_store_action() []IAlter_table_store_actionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlter_table_store_actionContext); ok {
			len++
		}
	}

	tst := make([]IAlter_table_store_actionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlter_table_store_actionContext); ok {
			tst[i] = t.(IAlter_table_store_actionContext)
			i++
		}
	}

	return tst
}

func (s *Alter_table_store_stmtContext) Alter_table_store_action(i int) IAlter_table_store_actionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_store_actionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_store_actionContext)
}

func (s *Alter_table_store_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Alter_table_store_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Alter_table_store_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_store_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_table_store_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_table_store_stmt(s)
	}
}

func (s *Alter_table_store_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_table_store_stmt(s)
	}
}




func (p *YQLParser) Alter_table_store_stmt() (localctx IAlter_table_store_stmtContext) {
	localctx = NewAlter_table_store_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 470, YQLParserRULE_alter_table_store_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3066)
		p.Match(YQLParserALTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3067)
		p.Match(YQLParserTABLESTORE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3068)
		p.Object_ref()
	}
	{
		p.SetState(3069)
		p.Alter_table_store_action()
	}
	p.SetState(3074)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(3070)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3071)
			p.Alter_table_store_action()
		}


		p.SetState(3076)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_table_store_actionContext is an interface to support dynamic dispatch.
type IAlter_table_store_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Alter_table_add_column() IAlter_table_add_columnContext
	Alter_table_drop_column() IAlter_table_drop_columnContext

	// IsAlter_table_store_actionContext differentiates from other interfaces.
	IsAlter_table_store_actionContext()
}

type Alter_table_store_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_store_actionContext() *Alter_table_store_actionContext {
	var p = new(Alter_table_store_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_store_action
	return p
}

func InitEmptyAlter_table_store_actionContext(p *Alter_table_store_actionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_store_action
}

func (*Alter_table_store_actionContext) IsAlter_table_store_actionContext() {}

func NewAlter_table_store_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_store_actionContext {
	var p = new(Alter_table_store_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_table_store_action

	return p
}

func (s *Alter_table_store_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_store_actionContext) Alter_table_add_column() IAlter_table_add_columnContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_add_columnContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_add_columnContext)
}

func (s *Alter_table_store_actionContext) Alter_table_drop_column() IAlter_table_drop_columnContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_drop_columnContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_drop_columnContext)
}

func (s *Alter_table_store_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_store_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_table_store_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_table_store_action(s)
	}
}

func (s *Alter_table_store_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_table_store_action(s)
	}
}




func (p *YQLParser) Alter_table_store_action() (localctx IAlter_table_store_actionContext) {
	localctx = NewAlter_table_store_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, YQLParserRULE_alter_table_store_action)
	p.SetState(3079)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserADD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3077)
			p.Alter_table_add_column()
		}


	case YQLParserDROP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3078)
			p.Alter_table_drop_column()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_table_add_columnContext is an interface to support dynamic dispatch.
type IAlter_table_add_columnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	Column_schema() IColumn_schemaContext
	COLUMN() antlr.TerminalNode

	// IsAlter_table_add_columnContext differentiates from other interfaces.
	IsAlter_table_add_columnContext()
}

type Alter_table_add_columnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_add_columnContext() *Alter_table_add_columnContext {
	var p = new(Alter_table_add_columnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_add_column
	return p
}

func InitEmptyAlter_table_add_columnContext(p *Alter_table_add_columnContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_add_column
}

func (*Alter_table_add_columnContext) IsAlter_table_add_columnContext() {}

func NewAlter_table_add_columnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_add_columnContext {
	var p = new(Alter_table_add_columnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_table_add_column

	return p
}

func (s *Alter_table_add_columnContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_add_columnContext) ADD() antlr.TerminalNode {
	return s.GetToken(YQLParserADD, 0)
}

func (s *Alter_table_add_columnContext) Column_schema() IColumn_schemaContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_schemaContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_schemaContext)
}

func (s *Alter_table_add_columnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(YQLParserCOLUMN, 0)
}

func (s *Alter_table_add_columnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_add_columnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_table_add_columnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_table_add_column(s)
	}
}

func (s *Alter_table_add_columnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_table_add_column(s)
	}
}




func (p *YQLParser) Alter_table_add_column() (localctx IAlter_table_add_columnContext) {
	localctx = NewAlter_table_add_columnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, YQLParserRULE_alter_table_add_column)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3081)
		p.Match(YQLParserADD)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3083)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserCOLUMN {
		{
			p.SetState(3082)
			p.Match(YQLParserCOLUMN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(3085)
		p.Column_schema()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_table_drop_columnContext is an interface to support dynamic dispatch.
type IAlter_table_drop_columnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	An_id() IAn_idContext
	COLUMN() antlr.TerminalNode

	// IsAlter_table_drop_columnContext differentiates from other interfaces.
	IsAlter_table_drop_columnContext()
}

type Alter_table_drop_columnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_drop_columnContext() *Alter_table_drop_columnContext {
	var p = new(Alter_table_drop_columnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_drop_column
	return p
}

func InitEmptyAlter_table_drop_columnContext(p *Alter_table_drop_columnContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_drop_column
}

func (*Alter_table_drop_columnContext) IsAlter_table_drop_columnContext() {}

func NewAlter_table_drop_columnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_drop_columnContext {
	var p = new(Alter_table_drop_columnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_table_drop_column

	return p
}

func (s *Alter_table_drop_columnContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_drop_columnContext) DROP() antlr.TerminalNode {
	return s.GetToken(YQLParserDROP, 0)
}

func (s *Alter_table_drop_columnContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Alter_table_drop_columnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(YQLParserCOLUMN, 0)
}

func (s *Alter_table_drop_columnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_drop_columnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_table_drop_columnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_table_drop_column(s)
	}
}

func (s *Alter_table_drop_columnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_table_drop_column(s)
	}
}




func (p *YQLParser) Alter_table_drop_column() (localctx IAlter_table_drop_columnContext) {
	localctx = NewAlter_table_drop_columnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 476, YQLParserRULE_alter_table_drop_column)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3087)
		p.Match(YQLParserDROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3089)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 307, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3088)
			p.Match(YQLParserCOLUMN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(3091)
		p.An_id()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_table_alter_columnContext is an interface to support dynamic dispatch.
type IAlter_table_alter_columnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	An_id() IAn_idContext
	SET() antlr.TerminalNode
	Family_relation() IFamily_relationContext

	// IsAlter_table_alter_columnContext differentiates from other interfaces.
	IsAlter_table_alter_columnContext()
}

type Alter_table_alter_columnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_alter_columnContext() *Alter_table_alter_columnContext {
	var p = new(Alter_table_alter_columnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_alter_column
	return p
}

func InitEmptyAlter_table_alter_columnContext(p *Alter_table_alter_columnContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_alter_column
}

func (*Alter_table_alter_columnContext) IsAlter_table_alter_columnContext() {}

func NewAlter_table_alter_columnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_alter_columnContext {
	var p = new(Alter_table_alter_columnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_table_alter_column

	return p
}

func (s *Alter_table_alter_columnContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_alter_columnContext) ALTER() antlr.TerminalNode {
	return s.GetToken(YQLParserALTER, 0)
}

func (s *Alter_table_alter_columnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(YQLParserCOLUMN, 0)
}

func (s *Alter_table_alter_columnContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Alter_table_alter_columnContext) SET() antlr.TerminalNode {
	return s.GetToken(YQLParserSET, 0)
}

func (s *Alter_table_alter_columnContext) Family_relation() IFamily_relationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFamily_relationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFamily_relationContext)
}

func (s *Alter_table_alter_columnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_alter_columnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_table_alter_columnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_table_alter_column(s)
	}
}

func (s *Alter_table_alter_columnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_table_alter_column(s)
	}
}




func (p *YQLParser) Alter_table_alter_column() (localctx IAlter_table_alter_columnContext) {
	localctx = NewAlter_table_alter_columnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 478, YQLParserRULE_alter_table_alter_column)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3093)
		p.Match(YQLParserALTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3094)
		p.Match(YQLParserCOLUMN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3095)
		p.An_id()
	}
	{
		p.SetState(3096)
		p.Match(YQLParserSET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3097)
		p.Family_relation()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_table_alter_column_drop_not_nullContext is an interface to support dynamic dispatch.
type IAlter_table_alter_column_drop_not_nullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	An_id() IAn_idContext
	DROP() antlr.TerminalNode
	NOT() antlr.TerminalNode
	NULL() antlr.TerminalNode

	// IsAlter_table_alter_column_drop_not_nullContext differentiates from other interfaces.
	IsAlter_table_alter_column_drop_not_nullContext()
}

type Alter_table_alter_column_drop_not_nullContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_alter_column_drop_not_nullContext() *Alter_table_alter_column_drop_not_nullContext {
	var p = new(Alter_table_alter_column_drop_not_nullContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_alter_column_drop_not_null
	return p
}

func InitEmptyAlter_table_alter_column_drop_not_nullContext(p *Alter_table_alter_column_drop_not_nullContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_alter_column_drop_not_null
}

func (*Alter_table_alter_column_drop_not_nullContext) IsAlter_table_alter_column_drop_not_nullContext() {}

func NewAlter_table_alter_column_drop_not_nullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_alter_column_drop_not_nullContext {
	var p = new(Alter_table_alter_column_drop_not_nullContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_table_alter_column_drop_not_null

	return p
}

func (s *Alter_table_alter_column_drop_not_nullContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_alter_column_drop_not_nullContext) ALTER() antlr.TerminalNode {
	return s.GetToken(YQLParserALTER, 0)
}

func (s *Alter_table_alter_column_drop_not_nullContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(YQLParserCOLUMN, 0)
}

func (s *Alter_table_alter_column_drop_not_nullContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Alter_table_alter_column_drop_not_nullContext) DROP() antlr.TerminalNode {
	return s.GetToken(YQLParserDROP, 0)
}

func (s *Alter_table_alter_column_drop_not_nullContext) NOT() antlr.TerminalNode {
	return s.GetToken(YQLParserNOT, 0)
}

func (s *Alter_table_alter_column_drop_not_nullContext) NULL() antlr.TerminalNode {
	return s.GetToken(YQLParserNULL, 0)
}

func (s *Alter_table_alter_column_drop_not_nullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_alter_column_drop_not_nullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_table_alter_column_drop_not_nullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_table_alter_column_drop_not_null(s)
	}
}

func (s *Alter_table_alter_column_drop_not_nullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_table_alter_column_drop_not_null(s)
	}
}




func (p *YQLParser) Alter_table_alter_column_drop_not_null() (localctx IAlter_table_alter_column_drop_not_nullContext) {
	localctx = NewAlter_table_alter_column_drop_not_nullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 480, YQLParserRULE_alter_table_alter_column_drop_not_null)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3099)
		p.Match(YQLParserALTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3100)
		p.Match(YQLParserCOLUMN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3101)
		p.An_id()
	}
	{
		p.SetState(3102)
		p.Match(YQLParserDROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3103)
		p.Match(YQLParserNOT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3104)
		p.Match(YQLParserNULL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_table_add_column_familyContext is an interface to support dynamic dispatch.
type IAlter_table_add_column_familyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	Family_entry() IFamily_entryContext

	// IsAlter_table_add_column_familyContext differentiates from other interfaces.
	IsAlter_table_add_column_familyContext()
}

type Alter_table_add_column_familyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_add_column_familyContext() *Alter_table_add_column_familyContext {
	var p = new(Alter_table_add_column_familyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_add_column_family
	return p
}

func InitEmptyAlter_table_add_column_familyContext(p *Alter_table_add_column_familyContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_add_column_family
}

func (*Alter_table_add_column_familyContext) IsAlter_table_add_column_familyContext() {}

func NewAlter_table_add_column_familyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_add_column_familyContext {
	var p = new(Alter_table_add_column_familyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_table_add_column_family

	return p
}

func (s *Alter_table_add_column_familyContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_add_column_familyContext) ADD() antlr.TerminalNode {
	return s.GetToken(YQLParserADD, 0)
}

func (s *Alter_table_add_column_familyContext) Family_entry() IFamily_entryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFamily_entryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFamily_entryContext)
}

func (s *Alter_table_add_column_familyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_add_column_familyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_table_add_column_familyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_table_add_column_family(s)
	}
}

func (s *Alter_table_add_column_familyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_table_add_column_family(s)
	}
}




func (p *YQLParser) Alter_table_add_column_family() (localctx IAlter_table_add_column_familyContext) {
	localctx = NewAlter_table_add_column_familyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 482, YQLParserRULE_alter_table_add_column_family)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3106)
		p.Match(YQLParserADD)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3107)
		p.Family_entry()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_table_alter_column_familyContext is an interface to support dynamic dispatch.
type IAlter_table_alter_column_familyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	FAMILY() antlr.TerminalNode
	AllAn_id() []IAn_idContext
	An_id(i int) IAn_idContext
	SET() antlr.TerminalNode
	Family_setting_value() IFamily_setting_valueContext

	// IsAlter_table_alter_column_familyContext differentiates from other interfaces.
	IsAlter_table_alter_column_familyContext()
}

type Alter_table_alter_column_familyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_alter_column_familyContext() *Alter_table_alter_column_familyContext {
	var p = new(Alter_table_alter_column_familyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_alter_column_family
	return p
}

func InitEmptyAlter_table_alter_column_familyContext(p *Alter_table_alter_column_familyContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_alter_column_family
}

func (*Alter_table_alter_column_familyContext) IsAlter_table_alter_column_familyContext() {}

func NewAlter_table_alter_column_familyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_alter_column_familyContext {
	var p = new(Alter_table_alter_column_familyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_table_alter_column_family

	return p
}

func (s *Alter_table_alter_column_familyContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_alter_column_familyContext) ALTER() antlr.TerminalNode {
	return s.GetToken(YQLParserALTER, 0)
}

func (s *Alter_table_alter_column_familyContext) FAMILY() antlr.TerminalNode {
	return s.GetToken(YQLParserFAMILY, 0)
}

func (s *Alter_table_alter_column_familyContext) AllAn_id() []IAn_idContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAn_idContext); ok {
			len++
		}
	}

	tst := make([]IAn_idContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAn_idContext); ok {
			tst[i] = t.(IAn_idContext)
			i++
		}
	}

	return tst
}

func (s *Alter_table_alter_column_familyContext) An_id(i int) IAn_idContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Alter_table_alter_column_familyContext) SET() antlr.TerminalNode {
	return s.GetToken(YQLParserSET, 0)
}

func (s *Alter_table_alter_column_familyContext) Family_setting_value() IFamily_setting_valueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFamily_setting_valueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFamily_setting_valueContext)
}

func (s *Alter_table_alter_column_familyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_alter_column_familyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_table_alter_column_familyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_table_alter_column_family(s)
	}
}

func (s *Alter_table_alter_column_familyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_table_alter_column_family(s)
	}
}




func (p *YQLParser) Alter_table_alter_column_family() (localctx IAlter_table_alter_column_familyContext) {
	localctx = NewAlter_table_alter_column_familyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 484, YQLParserRULE_alter_table_alter_column_family)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3109)
		p.Match(YQLParserALTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3110)
		p.Match(YQLParserFAMILY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3111)
		p.An_id()
	}
	{
		p.SetState(3112)
		p.Match(YQLParserSET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3113)
		p.An_id()
	}
	{
		p.SetState(3114)
		p.Family_setting_value()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_table_set_table_setting_uncompatContext is an interface to support dynamic dispatch.
type IAlter_table_set_table_setting_uncompatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	An_id() IAn_idContext
	Table_setting_value() ITable_setting_valueContext

	// IsAlter_table_set_table_setting_uncompatContext differentiates from other interfaces.
	IsAlter_table_set_table_setting_uncompatContext()
}

type Alter_table_set_table_setting_uncompatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_set_table_setting_uncompatContext() *Alter_table_set_table_setting_uncompatContext {
	var p = new(Alter_table_set_table_setting_uncompatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_set_table_setting_uncompat
	return p
}

func InitEmptyAlter_table_set_table_setting_uncompatContext(p *Alter_table_set_table_setting_uncompatContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_set_table_setting_uncompat
}

func (*Alter_table_set_table_setting_uncompatContext) IsAlter_table_set_table_setting_uncompatContext() {}

func NewAlter_table_set_table_setting_uncompatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_set_table_setting_uncompatContext {
	var p = new(Alter_table_set_table_setting_uncompatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_table_set_table_setting_uncompat

	return p
}

func (s *Alter_table_set_table_setting_uncompatContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_set_table_setting_uncompatContext) SET() antlr.TerminalNode {
	return s.GetToken(YQLParserSET, 0)
}

func (s *Alter_table_set_table_setting_uncompatContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Alter_table_set_table_setting_uncompatContext) Table_setting_value() ITable_setting_valueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_setting_valueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_setting_valueContext)
}

func (s *Alter_table_set_table_setting_uncompatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_set_table_setting_uncompatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_table_set_table_setting_uncompatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_table_set_table_setting_uncompat(s)
	}
}

func (s *Alter_table_set_table_setting_uncompatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_table_set_table_setting_uncompat(s)
	}
}




func (p *YQLParser) Alter_table_set_table_setting_uncompat() (localctx IAlter_table_set_table_setting_uncompatContext) {
	localctx = NewAlter_table_set_table_setting_uncompatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 486, YQLParserRULE_alter_table_set_table_setting_uncompat)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3116)
		p.Match(YQLParserSET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3117)
		p.An_id()
	}
	{
		p.SetState(3118)
		p.Table_setting_value()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_table_set_table_setting_compatContext is an interface to support dynamic dispatch.
type IAlter_table_set_table_setting_compatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllAlter_table_setting_entry() []IAlter_table_setting_entryContext
	Alter_table_setting_entry(i int) IAlter_table_setting_entryContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAlter_table_set_table_setting_compatContext differentiates from other interfaces.
	IsAlter_table_set_table_setting_compatContext()
}

type Alter_table_set_table_setting_compatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_set_table_setting_compatContext() *Alter_table_set_table_setting_compatContext {
	var p = new(Alter_table_set_table_setting_compatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_set_table_setting_compat
	return p
}

func InitEmptyAlter_table_set_table_setting_compatContext(p *Alter_table_set_table_setting_compatContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_set_table_setting_compat
}

func (*Alter_table_set_table_setting_compatContext) IsAlter_table_set_table_setting_compatContext() {}

func NewAlter_table_set_table_setting_compatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_set_table_setting_compatContext {
	var p = new(Alter_table_set_table_setting_compatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_table_set_table_setting_compat

	return p
}

func (s *Alter_table_set_table_setting_compatContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_set_table_setting_compatContext) SET() antlr.TerminalNode {
	return s.GetToken(YQLParserSET, 0)
}

func (s *Alter_table_set_table_setting_compatContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Alter_table_set_table_setting_compatContext) AllAlter_table_setting_entry() []IAlter_table_setting_entryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlter_table_setting_entryContext); ok {
			len++
		}
	}

	tst := make([]IAlter_table_setting_entryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlter_table_setting_entryContext); ok {
			tst[i] = t.(IAlter_table_setting_entryContext)
			i++
		}
	}

	return tst
}

func (s *Alter_table_set_table_setting_compatContext) Alter_table_setting_entry(i int) IAlter_table_setting_entryContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_setting_entryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_setting_entryContext)
}

func (s *Alter_table_set_table_setting_compatContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Alter_table_set_table_setting_compatContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Alter_table_set_table_setting_compatContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Alter_table_set_table_setting_compatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_set_table_setting_compatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_table_set_table_setting_compatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_table_set_table_setting_compat(s)
	}
}

func (s *Alter_table_set_table_setting_compatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_table_set_table_setting_compat(s)
	}
}




func (p *YQLParser) Alter_table_set_table_setting_compat() (localctx IAlter_table_set_table_setting_compatContext) {
	localctx = NewAlter_table_set_table_setting_compatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 488, YQLParserRULE_alter_table_set_table_setting_compat)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3120)
		p.Match(YQLParserSET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3121)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3122)
		p.Alter_table_setting_entry()
	}
	p.SetState(3127)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(3123)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3124)
			p.Alter_table_setting_entry()
		}


		p.SetState(3129)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3130)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_table_reset_table_settingContext is an interface to support dynamic dispatch.
type IAlter_table_reset_table_settingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESET() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllAn_id() []IAn_idContext
	An_id(i int) IAn_idContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAlter_table_reset_table_settingContext differentiates from other interfaces.
	IsAlter_table_reset_table_settingContext()
}

type Alter_table_reset_table_settingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_reset_table_settingContext() *Alter_table_reset_table_settingContext {
	var p = new(Alter_table_reset_table_settingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_reset_table_setting
	return p
}

func InitEmptyAlter_table_reset_table_settingContext(p *Alter_table_reset_table_settingContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_reset_table_setting
}

func (*Alter_table_reset_table_settingContext) IsAlter_table_reset_table_settingContext() {}

func NewAlter_table_reset_table_settingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_reset_table_settingContext {
	var p = new(Alter_table_reset_table_settingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_table_reset_table_setting

	return p
}

func (s *Alter_table_reset_table_settingContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_reset_table_settingContext) RESET() antlr.TerminalNode {
	return s.GetToken(YQLParserRESET, 0)
}

func (s *Alter_table_reset_table_settingContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Alter_table_reset_table_settingContext) AllAn_id() []IAn_idContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAn_idContext); ok {
			len++
		}
	}

	tst := make([]IAn_idContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAn_idContext); ok {
			tst[i] = t.(IAn_idContext)
			i++
		}
	}

	return tst
}

func (s *Alter_table_reset_table_settingContext) An_id(i int) IAn_idContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Alter_table_reset_table_settingContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Alter_table_reset_table_settingContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Alter_table_reset_table_settingContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Alter_table_reset_table_settingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_reset_table_settingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_table_reset_table_settingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_table_reset_table_setting(s)
	}
}

func (s *Alter_table_reset_table_settingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_table_reset_table_setting(s)
	}
}




func (p *YQLParser) Alter_table_reset_table_setting() (localctx IAlter_table_reset_table_settingContext) {
	localctx = NewAlter_table_reset_table_settingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 490, YQLParserRULE_alter_table_reset_table_setting)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3132)
		p.Match(YQLParserRESET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3133)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3134)
		p.An_id()
	}
	p.SetState(3139)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(3135)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3136)
			p.An_id()
		}


		p.SetState(3141)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3142)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_table_add_indexContext is an interface to support dynamic dispatch.
type IAlter_table_add_indexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	Table_index() ITable_indexContext

	// IsAlter_table_add_indexContext differentiates from other interfaces.
	IsAlter_table_add_indexContext()
}

type Alter_table_add_indexContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_add_indexContext() *Alter_table_add_indexContext {
	var p = new(Alter_table_add_indexContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_add_index
	return p
}

func InitEmptyAlter_table_add_indexContext(p *Alter_table_add_indexContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_add_index
}

func (*Alter_table_add_indexContext) IsAlter_table_add_indexContext() {}

func NewAlter_table_add_indexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_add_indexContext {
	var p = new(Alter_table_add_indexContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_table_add_index

	return p
}

func (s *Alter_table_add_indexContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_add_indexContext) ADD() antlr.TerminalNode {
	return s.GetToken(YQLParserADD, 0)
}

func (s *Alter_table_add_indexContext) Table_index() ITable_indexContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_indexContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_indexContext)
}

func (s *Alter_table_add_indexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_add_indexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_table_add_indexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_table_add_index(s)
	}
}

func (s *Alter_table_add_indexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_table_add_index(s)
	}
}




func (p *YQLParser) Alter_table_add_index() (localctx IAlter_table_add_indexContext) {
	localctx = NewAlter_table_add_indexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 492, YQLParserRULE_alter_table_add_index)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3144)
		p.Match(YQLParserADD)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3145)
		p.Table_index()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_table_drop_indexContext is an interface to support dynamic dispatch.
type IAlter_table_drop_indexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	An_id() IAn_idContext

	// IsAlter_table_drop_indexContext differentiates from other interfaces.
	IsAlter_table_drop_indexContext()
}

type Alter_table_drop_indexContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_drop_indexContext() *Alter_table_drop_indexContext {
	var p = new(Alter_table_drop_indexContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_drop_index
	return p
}

func InitEmptyAlter_table_drop_indexContext(p *Alter_table_drop_indexContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_drop_index
}

func (*Alter_table_drop_indexContext) IsAlter_table_drop_indexContext() {}

func NewAlter_table_drop_indexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_drop_indexContext {
	var p = new(Alter_table_drop_indexContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_table_drop_index

	return p
}

func (s *Alter_table_drop_indexContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_drop_indexContext) DROP() antlr.TerminalNode {
	return s.GetToken(YQLParserDROP, 0)
}

func (s *Alter_table_drop_indexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(YQLParserINDEX, 0)
}

func (s *Alter_table_drop_indexContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Alter_table_drop_indexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_drop_indexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_table_drop_indexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_table_drop_index(s)
	}
}

func (s *Alter_table_drop_indexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_table_drop_index(s)
	}
}




func (p *YQLParser) Alter_table_drop_index() (localctx IAlter_table_drop_indexContext) {
	localctx = NewAlter_table_drop_indexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 494, YQLParserRULE_alter_table_drop_index)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3147)
		p.Match(YQLParserDROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3148)
		p.Match(YQLParserINDEX)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3149)
		p.An_id()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_table_rename_toContext is an interface to support dynamic dispatch.
type IAlter_table_rename_toContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RENAME() antlr.TerminalNode
	TO() antlr.TerminalNode
	An_id_table() IAn_id_tableContext

	// IsAlter_table_rename_toContext differentiates from other interfaces.
	IsAlter_table_rename_toContext()
}

type Alter_table_rename_toContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_rename_toContext() *Alter_table_rename_toContext {
	var p = new(Alter_table_rename_toContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_rename_to
	return p
}

func InitEmptyAlter_table_rename_toContext(p *Alter_table_rename_toContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_rename_to
}

func (*Alter_table_rename_toContext) IsAlter_table_rename_toContext() {}

func NewAlter_table_rename_toContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_rename_toContext {
	var p = new(Alter_table_rename_toContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_table_rename_to

	return p
}

func (s *Alter_table_rename_toContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_rename_toContext) RENAME() antlr.TerminalNode {
	return s.GetToken(YQLParserRENAME, 0)
}

func (s *Alter_table_rename_toContext) TO() antlr.TerminalNode {
	return s.GetToken(YQLParserTO, 0)
}

func (s *Alter_table_rename_toContext) An_id_table() IAn_id_tableContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_tableContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_tableContext)
}

func (s *Alter_table_rename_toContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_rename_toContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_table_rename_toContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_table_rename_to(s)
	}
}

func (s *Alter_table_rename_toContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_table_rename_to(s)
	}
}




func (p *YQLParser) Alter_table_rename_to() (localctx IAlter_table_rename_toContext) {
	localctx = NewAlter_table_rename_toContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 496, YQLParserRULE_alter_table_rename_to)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3151)
		p.Match(YQLParserRENAME)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3152)
		p.Match(YQLParserTO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3153)
		p.An_id_table()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_table_rename_index_toContext is an interface to support dynamic dispatch.
type IAlter_table_rename_index_toContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RENAME() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	AllAn_id() []IAn_idContext
	An_id(i int) IAn_idContext
	TO() antlr.TerminalNode

	// IsAlter_table_rename_index_toContext differentiates from other interfaces.
	IsAlter_table_rename_index_toContext()
}

type Alter_table_rename_index_toContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_rename_index_toContext() *Alter_table_rename_index_toContext {
	var p = new(Alter_table_rename_index_toContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_rename_index_to
	return p
}

func InitEmptyAlter_table_rename_index_toContext(p *Alter_table_rename_index_toContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_rename_index_to
}

func (*Alter_table_rename_index_toContext) IsAlter_table_rename_index_toContext() {}

func NewAlter_table_rename_index_toContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_rename_index_toContext {
	var p = new(Alter_table_rename_index_toContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_table_rename_index_to

	return p
}

func (s *Alter_table_rename_index_toContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_rename_index_toContext) RENAME() antlr.TerminalNode {
	return s.GetToken(YQLParserRENAME, 0)
}

func (s *Alter_table_rename_index_toContext) INDEX() antlr.TerminalNode {
	return s.GetToken(YQLParserINDEX, 0)
}

func (s *Alter_table_rename_index_toContext) AllAn_id() []IAn_idContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAn_idContext); ok {
			len++
		}
	}

	tst := make([]IAn_idContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAn_idContext); ok {
			tst[i] = t.(IAn_idContext)
			i++
		}
	}

	return tst
}

func (s *Alter_table_rename_index_toContext) An_id(i int) IAn_idContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Alter_table_rename_index_toContext) TO() antlr.TerminalNode {
	return s.GetToken(YQLParserTO, 0)
}

func (s *Alter_table_rename_index_toContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_rename_index_toContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_table_rename_index_toContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_table_rename_index_to(s)
	}
}

func (s *Alter_table_rename_index_toContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_table_rename_index_to(s)
	}
}




func (p *YQLParser) Alter_table_rename_index_to() (localctx IAlter_table_rename_index_toContext) {
	localctx = NewAlter_table_rename_index_toContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 498, YQLParserRULE_alter_table_rename_index_to)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3155)
		p.Match(YQLParserRENAME)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3156)
		p.Match(YQLParserINDEX)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3157)
		p.An_id()
	}
	{
		p.SetState(3158)
		p.Match(YQLParserTO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3159)
		p.An_id()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_table_add_changefeedContext is an interface to support dynamic dispatch.
type IAlter_table_add_changefeedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	Changefeed() IChangefeedContext

	// IsAlter_table_add_changefeedContext differentiates from other interfaces.
	IsAlter_table_add_changefeedContext()
}

type Alter_table_add_changefeedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_add_changefeedContext() *Alter_table_add_changefeedContext {
	var p = new(Alter_table_add_changefeedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_add_changefeed
	return p
}

func InitEmptyAlter_table_add_changefeedContext(p *Alter_table_add_changefeedContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_add_changefeed
}

func (*Alter_table_add_changefeedContext) IsAlter_table_add_changefeedContext() {}

func NewAlter_table_add_changefeedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_add_changefeedContext {
	var p = new(Alter_table_add_changefeedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_table_add_changefeed

	return p
}

func (s *Alter_table_add_changefeedContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_add_changefeedContext) ADD() antlr.TerminalNode {
	return s.GetToken(YQLParserADD, 0)
}

func (s *Alter_table_add_changefeedContext) Changefeed() IChangefeedContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChangefeedContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChangefeedContext)
}

func (s *Alter_table_add_changefeedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_add_changefeedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_table_add_changefeedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_table_add_changefeed(s)
	}
}

func (s *Alter_table_add_changefeedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_table_add_changefeed(s)
	}
}




func (p *YQLParser) Alter_table_add_changefeed() (localctx IAlter_table_add_changefeedContext) {
	localctx = NewAlter_table_add_changefeedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 500, YQLParserRULE_alter_table_add_changefeed)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3161)
		p.Match(YQLParserADD)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3162)
		p.Changefeed()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_table_alter_changefeedContext is an interface to support dynamic dispatch.
type IAlter_table_alter_changefeedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	CHANGEFEED() antlr.TerminalNode
	An_id() IAn_idContext
	Changefeed_alter_settings() IChangefeed_alter_settingsContext

	// IsAlter_table_alter_changefeedContext differentiates from other interfaces.
	IsAlter_table_alter_changefeedContext()
}

type Alter_table_alter_changefeedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_alter_changefeedContext() *Alter_table_alter_changefeedContext {
	var p = new(Alter_table_alter_changefeedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_alter_changefeed
	return p
}

func InitEmptyAlter_table_alter_changefeedContext(p *Alter_table_alter_changefeedContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_alter_changefeed
}

func (*Alter_table_alter_changefeedContext) IsAlter_table_alter_changefeedContext() {}

func NewAlter_table_alter_changefeedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_alter_changefeedContext {
	var p = new(Alter_table_alter_changefeedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_table_alter_changefeed

	return p
}

func (s *Alter_table_alter_changefeedContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_alter_changefeedContext) ALTER() antlr.TerminalNode {
	return s.GetToken(YQLParserALTER, 0)
}

func (s *Alter_table_alter_changefeedContext) CHANGEFEED() antlr.TerminalNode {
	return s.GetToken(YQLParserCHANGEFEED, 0)
}

func (s *Alter_table_alter_changefeedContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Alter_table_alter_changefeedContext) Changefeed_alter_settings() IChangefeed_alter_settingsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChangefeed_alter_settingsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChangefeed_alter_settingsContext)
}

func (s *Alter_table_alter_changefeedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_alter_changefeedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_table_alter_changefeedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_table_alter_changefeed(s)
	}
}

func (s *Alter_table_alter_changefeedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_table_alter_changefeed(s)
	}
}




func (p *YQLParser) Alter_table_alter_changefeed() (localctx IAlter_table_alter_changefeedContext) {
	localctx = NewAlter_table_alter_changefeedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 502, YQLParserRULE_alter_table_alter_changefeed)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3164)
		p.Match(YQLParserALTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3165)
		p.Match(YQLParserCHANGEFEED)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3166)
		p.An_id()
	}
	{
		p.SetState(3167)
		p.Changefeed_alter_settings()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_table_drop_changefeedContext is an interface to support dynamic dispatch.
type IAlter_table_drop_changefeedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	CHANGEFEED() antlr.TerminalNode
	An_id() IAn_idContext

	// IsAlter_table_drop_changefeedContext differentiates from other interfaces.
	IsAlter_table_drop_changefeedContext()
}

type Alter_table_drop_changefeedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_drop_changefeedContext() *Alter_table_drop_changefeedContext {
	var p = new(Alter_table_drop_changefeedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_drop_changefeed
	return p
}

func InitEmptyAlter_table_drop_changefeedContext(p *Alter_table_drop_changefeedContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_drop_changefeed
}

func (*Alter_table_drop_changefeedContext) IsAlter_table_drop_changefeedContext() {}

func NewAlter_table_drop_changefeedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_drop_changefeedContext {
	var p = new(Alter_table_drop_changefeedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_table_drop_changefeed

	return p
}

func (s *Alter_table_drop_changefeedContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_drop_changefeedContext) DROP() antlr.TerminalNode {
	return s.GetToken(YQLParserDROP, 0)
}

func (s *Alter_table_drop_changefeedContext) CHANGEFEED() antlr.TerminalNode {
	return s.GetToken(YQLParserCHANGEFEED, 0)
}

func (s *Alter_table_drop_changefeedContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Alter_table_drop_changefeedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_drop_changefeedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_table_drop_changefeedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_table_drop_changefeed(s)
	}
}

func (s *Alter_table_drop_changefeedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_table_drop_changefeed(s)
	}
}




func (p *YQLParser) Alter_table_drop_changefeed() (localctx IAlter_table_drop_changefeedContext) {
	localctx = NewAlter_table_drop_changefeedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 504, YQLParserRULE_alter_table_drop_changefeed)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3169)
		p.Match(YQLParserDROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3170)
		p.Match(YQLParserCHANGEFEED)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3171)
		p.An_id()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_table_alter_indexContext is an interface to support dynamic dispatch.
type IAlter_table_alter_indexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	An_id() IAn_idContext
	Alter_table_alter_index_action() IAlter_table_alter_index_actionContext

	// IsAlter_table_alter_indexContext differentiates from other interfaces.
	IsAlter_table_alter_indexContext()
}

type Alter_table_alter_indexContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_alter_indexContext() *Alter_table_alter_indexContext {
	var p = new(Alter_table_alter_indexContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_alter_index
	return p
}

func InitEmptyAlter_table_alter_indexContext(p *Alter_table_alter_indexContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_alter_index
}

func (*Alter_table_alter_indexContext) IsAlter_table_alter_indexContext() {}

func NewAlter_table_alter_indexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_alter_indexContext {
	var p = new(Alter_table_alter_indexContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_table_alter_index

	return p
}

func (s *Alter_table_alter_indexContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_alter_indexContext) ALTER() antlr.TerminalNode {
	return s.GetToken(YQLParserALTER, 0)
}

func (s *Alter_table_alter_indexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(YQLParserINDEX, 0)
}

func (s *Alter_table_alter_indexContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Alter_table_alter_indexContext) Alter_table_alter_index_action() IAlter_table_alter_index_actionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_alter_index_actionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_alter_index_actionContext)
}

func (s *Alter_table_alter_indexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_alter_indexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_table_alter_indexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_table_alter_index(s)
	}
}

func (s *Alter_table_alter_indexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_table_alter_index(s)
	}
}




func (p *YQLParser) Alter_table_alter_index() (localctx IAlter_table_alter_indexContext) {
	localctx = NewAlter_table_alter_indexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 506, YQLParserRULE_alter_table_alter_index)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3173)
		p.Match(YQLParserALTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3174)
		p.Match(YQLParserINDEX)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3175)
		p.An_id()
	}
	{
		p.SetState(3176)
		p.Alter_table_alter_index_action()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IColumn_schemaContext is an interface to support dynamic dispatch.
type IColumn_schemaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id_schema() IAn_id_schemaContext
	Type_name_or_bind() IType_name_or_bindContext
	Opt_column_constraints() IOpt_column_constraintsContext
	Family_relation() IFamily_relationContext

	// IsColumn_schemaContext differentiates from other interfaces.
	IsColumn_schemaContext()
}

type Column_schemaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumn_schemaContext() *Column_schemaContext {
	var p = new(Column_schemaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_column_schema
	return p
}

func InitEmptyColumn_schemaContext(p *Column_schemaContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_column_schema
}

func (*Column_schemaContext) IsColumn_schemaContext() {}

func NewColumn_schemaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_schemaContext {
	var p = new(Column_schemaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_column_schema

	return p
}

func (s *Column_schemaContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_schemaContext) An_id_schema() IAn_id_schemaContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_schemaContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_schemaContext)
}

func (s *Column_schemaContext) Type_name_or_bind() IType_name_or_bindContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_or_bindContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_or_bindContext)
}

func (s *Column_schemaContext) Opt_column_constraints() IOpt_column_constraintsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_column_constraintsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_column_constraintsContext)
}

func (s *Column_schemaContext) Family_relation() IFamily_relationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFamily_relationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFamily_relationContext)
}

func (s *Column_schemaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_schemaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Column_schemaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterColumn_schema(s)
	}
}

func (s *Column_schemaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitColumn_schema(s)
	}
}




func (p *YQLParser) Column_schema() (localctx IColumn_schemaContext) {
	localctx = NewColumn_schemaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 508, YQLParserRULE_column_schema)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3178)
		p.An_id_schema()
	}
	{
		p.SetState(3179)
		p.Type_name_or_bind()
	}
	p.SetState(3181)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserFAMILY {
		{
			p.SetState(3180)
			p.Family_relation()
		}

	}
	{
		p.SetState(3183)
		p.Opt_column_constraints()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFamily_relationContext is an interface to support dynamic dispatch.
type IFamily_relationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FAMILY() antlr.TerminalNode
	An_id() IAn_idContext

	// IsFamily_relationContext differentiates from other interfaces.
	IsFamily_relationContext()
}

type Family_relationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFamily_relationContext() *Family_relationContext {
	var p = new(Family_relationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_family_relation
	return p
}

func InitEmptyFamily_relationContext(p *Family_relationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_family_relation
}

func (*Family_relationContext) IsFamily_relationContext() {}

func NewFamily_relationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Family_relationContext {
	var p = new(Family_relationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_family_relation

	return p
}

func (s *Family_relationContext) GetParser() antlr.Parser { return s.parser }

func (s *Family_relationContext) FAMILY() antlr.TerminalNode {
	return s.GetToken(YQLParserFAMILY, 0)
}

func (s *Family_relationContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Family_relationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Family_relationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Family_relationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterFamily_relation(s)
	}
}

func (s *Family_relationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitFamily_relation(s)
	}
}




func (p *YQLParser) Family_relation() (localctx IFamily_relationContext) {
	localctx = NewFamily_relationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 510, YQLParserRULE_family_relation)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3185)
		p.Match(YQLParserFAMILY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3186)
		p.An_id()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOpt_column_constraintsContext is an interface to support dynamic dispatch.
type IOpt_column_constraintsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULL() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	Expr() IExprContext
	NOT() antlr.TerminalNode

	// IsOpt_column_constraintsContext differentiates from other interfaces.
	IsOpt_column_constraintsContext()
}

type Opt_column_constraintsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_column_constraintsContext() *Opt_column_constraintsContext {
	var p = new(Opt_column_constraintsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_opt_column_constraints
	return p
}

func InitEmptyOpt_column_constraintsContext(p *Opt_column_constraintsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_opt_column_constraints
}

func (*Opt_column_constraintsContext) IsOpt_column_constraintsContext() {}

func NewOpt_column_constraintsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_column_constraintsContext {
	var p = new(Opt_column_constraintsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_opt_column_constraints

	return p
}

func (s *Opt_column_constraintsContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_column_constraintsContext) NULL() antlr.TerminalNode {
	return s.GetToken(YQLParserNULL, 0)
}

func (s *Opt_column_constraintsContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(YQLParserDEFAULT, 0)
}

func (s *Opt_column_constraintsContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Opt_column_constraintsContext) NOT() antlr.TerminalNode {
	return s.GetToken(YQLParserNOT, 0)
}

func (s *Opt_column_constraintsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_column_constraintsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Opt_column_constraintsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterOpt_column_constraints(s)
	}
}

func (s *Opt_column_constraintsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitOpt_column_constraints(s)
	}
}




func (p *YQLParser) Opt_column_constraints() (localctx IOpt_column_constraintsContext) {
	localctx = NewOpt_column_constraintsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 512, YQLParserRULE_opt_column_constraints)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3192)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserNOT || _la == YQLParserNULL {
		p.SetState(3189)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserNOT {
			{
				p.SetState(3188)
				p.Match(YQLParserNOT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(3191)
			p.Match(YQLParserNULL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(3196)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserDEFAULT {
		{
			p.SetState(3194)
			p.Match(YQLParserDEFAULT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3195)
			p.Expr()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IColumn_order_by_specificationContext is an interface to support dynamic dispatch.
type IColumn_order_by_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id() IAn_idContext
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode

	// IsColumn_order_by_specificationContext differentiates from other interfaces.
	IsColumn_order_by_specificationContext()
}

type Column_order_by_specificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumn_order_by_specificationContext() *Column_order_by_specificationContext {
	var p = new(Column_order_by_specificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_column_order_by_specification
	return p
}

func InitEmptyColumn_order_by_specificationContext(p *Column_order_by_specificationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_column_order_by_specification
}

func (*Column_order_by_specificationContext) IsColumn_order_by_specificationContext() {}

func NewColumn_order_by_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_order_by_specificationContext {
	var p = new(Column_order_by_specificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_column_order_by_specification

	return p
}

func (s *Column_order_by_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_order_by_specificationContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Column_order_by_specificationContext) ASC() antlr.TerminalNode {
	return s.GetToken(YQLParserASC, 0)
}

func (s *Column_order_by_specificationContext) DESC() antlr.TerminalNode {
	return s.GetToken(YQLParserDESC, 0)
}

func (s *Column_order_by_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_order_by_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Column_order_by_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterColumn_order_by_specification(s)
	}
}

func (s *Column_order_by_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitColumn_order_by_specification(s)
	}
}




func (p *YQLParser) Column_order_by_specification() (localctx IColumn_order_by_specificationContext) {
	localctx = NewColumn_order_by_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 514, YQLParserRULE_column_order_by_specification)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3198)
		p.An_id()
	}
	p.SetState(3200)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserASC || _la == YQLParserDESC {
		{
			p.SetState(3199)
			_la = p.GetTokenStream().LA(1)

			if !(_la == YQLParserASC || _la == YQLParserDESC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITable_constraintContext is an interface to support dynamic dispatch.
type ITable_constraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PRIMARY() antlr.TerminalNode
	KEY() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllAn_id() []IAn_idContext
	An_id(i int) IAn_idContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	AllColumn_order_by_specification() []IColumn_order_by_specificationContext
	Column_order_by_specification(i int) IColumn_order_by_specificationContext

	// IsTable_constraintContext differentiates from other interfaces.
	IsTable_constraintContext()
}

type Table_constraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_constraintContext() *Table_constraintContext {
	var p = new(Table_constraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_table_constraint
	return p
}

func InitEmptyTable_constraintContext(p *Table_constraintContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_table_constraint
}

func (*Table_constraintContext) IsTable_constraintContext() {}

func NewTable_constraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_constraintContext {
	var p = new(Table_constraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_table_constraint

	return p
}

func (s *Table_constraintContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_constraintContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(YQLParserPRIMARY, 0)
}

func (s *Table_constraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(YQLParserKEY, 0)
}

func (s *Table_constraintContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Table_constraintContext) AllAn_id() []IAn_idContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAn_idContext); ok {
			len++
		}
	}

	tst := make([]IAn_idContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAn_idContext); ok {
			tst[i] = t.(IAn_idContext)
			i++
		}
	}

	return tst
}

func (s *Table_constraintContext) An_id(i int) IAn_idContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Table_constraintContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Table_constraintContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Table_constraintContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Table_constraintContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(YQLParserPARTITION, 0)
}

func (s *Table_constraintContext) BY() antlr.TerminalNode {
	return s.GetToken(YQLParserBY, 0)
}

func (s *Table_constraintContext) ORDER() antlr.TerminalNode {
	return s.GetToken(YQLParserORDER, 0)
}

func (s *Table_constraintContext) AllColumn_order_by_specification() []IColumn_order_by_specificationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumn_order_by_specificationContext); ok {
			len++
		}
	}

	tst := make([]IColumn_order_by_specificationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumn_order_by_specificationContext); ok {
			tst[i] = t.(IColumn_order_by_specificationContext)
			i++
		}
	}

	return tst
}

func (s *Table_constraintContext) Column_order_by_specification(i int) IColumn_order_by_specificationContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_order_by_specificationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_order_by_specificationContext)
}

func (s *Table_constraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_constraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Table_constraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterTable_constraint(s)
	}
}

func (s *Table_constraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitTable_constraint(s)
	}
}




func (p *YQLParser) Table_constraint() (localctx ITable_constraintContext) {
	localctx = NewTable_constraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 516, YQLParserRULE_table_constraint)
	var _la int

	p.SetState(3241)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserPRIMARY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3202)
			p.Match(YQLParserPRIMARY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3203)
			p.Match(YQLParserKEY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3204)
			p.Match(YQLParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3205)
			p.An_id()
		}
		p.SetState(3210)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == YQLParserCOMMA {
			{
				p.SetState(3206)
				p.Match(YQLParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3207)
				p.An_id()
			}


			p.SetState(3212)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3213)
			p.Match(YQLParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserPARTITION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3215)
			p.Match(YQLParserPARTITION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3216)
			p.Match(YQLParserBY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3217)
			p.Match(YQLParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3218)
			p.An_id()
		}
		p.SetState(3223)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == YQLParserCOMMA {
			{
				p.SetState(3219)
				p.Match(YQLParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3220)
				p.An_id()
			}


			p.SetState(3225)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3226)
			p.Match(YQLParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserORDER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3228)
			p.Match(YQLParserORDER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3229)
			p.Match(YQLParserBY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3230)
			p.Match(YQLParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3231)
			p.Column_order_by_specification()
		}
		p.SetState(3236)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == YQLParserCOMMA {
			{
				p.SetState(3232)
				p.Match(YQLParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3233)
				p.Column_order_by_specification()
			}


			p.SetState(3238)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3239)
			p.Match(YQLParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITable_indexContext is an interface to support dynamic dispatch.
type ITable_indexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INDEX() antlr.TerminalNode
	An_id() IAn_idContext
	Table_index_type() ITable_index_typeContext
	ON() antlr.TerminalNode
	AllLPAREN() []antlr.TerminalNode
	LPAREN(i int) antlr.TerminalNode
	AllAn_id_schema() []IAn_id_schemaContext
	An_id_schema(i int) IAn_id_schemaContext
	AllRPAREN() []antlr.TerminalNode
	RPAREN(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	COVER() antlr.TerminalNode
	With_index_settings() IWith_index_settingsContext

	// IsTable_indexContext differentiates from other interfaces.
	IsTable_indexContext()
}

type Table_indexContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_indexContext() *Table_indexContext {
	var p = new(Table_indexContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_table_index
	return p
}

func InitEmptyTable_indexContext(p *Table_indexContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_table_index
}

func (*Table_indexContext) IsTable_indexContext() {}

func NewTable_indexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_indexContext {
	var p = new(Table_indexContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_table_index

	return p
}

func (s *Table_indexContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_indexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(YQLParserINDEX, 0)
}

func (s *Table_indexContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Table_indexContext) Table_index_type() ITable_index_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_index_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_index_typeContext)
}

func (s *Table_indexContext) ON() antlr.TerminalNode {
	return s.GetToken(YQLParserON, 0)
}

func (s *Table_indexContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(YQLParserLPAREN)
}

func (s *Table_indexContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, i)
}

func (s *Table_indexContext) AllAn_id_schema() []IAn_id_schemaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAn_id_schemaContext); ok {
			len++
		}
	}

	tst := make([]IAn_id_schemaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAn_id_schemaContext); ok {
			tst[i] = t.(IAn_id_schemaContext)
			i++
		}
	}

	return tst
}

func (s *Table_indexContext) An_id_schema(i int) IAn_id_schemaContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_schemaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_schemaContext)
}

func (s *Table_indexContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(YQLParserRPAREN)
}

func (s *Table_indexContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, i)
}

func (s *Table_indexContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Table_indexContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Table_indexContext) COVER() antlr.TerminalNode {
	return s.GetToken(YQLParserCOVER, 0)
}

func (s *Table_indexContext) With_index_settings() IWith_index_settingsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWith_index_settingsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWith_index_settingsContext)
}

func (s *Table_indexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_indexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Table_indexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterTable_index(s)
	}
}

func (s *Table_indexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitTable_index(s)
	}
}




func (p *YQLParser) Table_index() (localctx ITable_indexContext) {
	localctx = NewTable_indexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 518, YQLParserRULE_table_index)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3243)
		p.Match(YQLParserINDEX)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3244)
		p.An_id()
	}
	{
		p.SetState(3245)
		p.Table_index_type()
	}
	{
		p.SetState(3246)
		p.Match(YQLParserON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3247)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3248)
		p.An_id_schema()
	}
	p.SetState(3253)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(3249)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3250)
			p.An_id_schema()
		}


		p.SetState(3255)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3256)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3269)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserCOVER {
		{
			p.SetState(3257)
			p.Match(YQLParserCOVER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3258)
			p.Match(YQLParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3259)
			p.An_id_schema()
		}
		p.SetState(3264)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == YQLParserCOMMA {
			{
				p.SetState(3260)
				p.Match(YQLParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3261)
				p.An_id_schema()
			}


			p.SetState(3266)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3267)
			p.Match(YQLParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(3272)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserWITH {
		{
			p.SetState(3271)
			p.With_index_settings()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITable_index_typeContext is an interface to support dynamic dispatch.
type ITable_index_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Global_index() IGlobal_indexContext
	Local_index() ILocal_indexContext
	USING() antlr.TerminalNode
	Index_subtype() IIndex_subtypeContext

	// IsTable_index_typeContext differentiates from other interfaces.
	IsTable_index_typeContext()
}

type Table_index_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_index_typeContext() *Table_index_typeContext {
	var p = new(Table_index_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_table_index_type
	return p
}

func InitEmptyTable_index_typeContext(p *Table_index_typeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_table_index_type
}

func (*Table_index_typeContext) IsTable_index_typeContext() {}

func NewTable_index_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_index_typeContext {
	var p = new(Table_index_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_table_index_type

	return p
}

func (s *Table_index_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_index_typeContext) Global_index() IGlobal_indexContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGlobal_indexContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGlobal_indexContext)
}

func (s *Table_index_typeContext) Local_index() ILocal_indexContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocal_indexContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocal_indexContext)
}

func (s *Table_index_typeContext) USING() antlr.TerminalNode {
	return s.GetToken(YQLParserUSING, 0)
}

func (s *Table_index_typeContext) Index_subtype() IIndex_subtypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndex_subtypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndex_subtypeContext)
}

func (s *Table_index_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_index_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Table_index_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterTable_index_type(s)
	}
}

func (s *Table_index_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitTable_index_type(s)
	}
}




func (p *YQLParser) Table_index_type() (localctx ITable_index_typeContext) {
	localctx = NewTable_index_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 520, YQLParserRULE_table_index_type)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3276)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserGLOBAL:
		{
			p.SetState(3274)
			p.Global_index()
		}


	case YQLParserLOCAL:
		{
			p.SetState(3275)
			p.Local_index()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(3280)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserUSING {
		{
			p.SetState(3278)
			p.Match(YQLParserUSING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3279)
			p.Index_subtype()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGlobal_indexContext is an interface to support dynamic dispatch.
type IGlobal_indexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GLOBAL() antlr.TerminalNode
	UNIQUE() antlr.TerminalNode
	SYNC() antlr.TerminalNode
	ASYNC() antlr.TerminalNode

	// IsGlobal_indexContext differentiates from other interfaces.
	IsGlobal_indexContext()
}

type Global_indexContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGlobal_indexContext() *Global_indexContext {
	var p = new(Global_indexContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_global_index
	return p
}

func InitEmptyGlobal_indexContext(p *Global_indexContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_global_index
}

func (*Global_indexContext) IsGlobal_indexContext() {}

func NewGlobal_indexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Global_indexContext {
	var p = new(Global_indexContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_global_index

	return p
}

func (s *Global_indexContext) GetParser() antlr.Parser { return s.parser }

func (s *Global_indexContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(YQLParserGLOBAL, 0)
}

func (s *Global_indexContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(YQLParserUNIQUE, 0)
}

func (s *Global_indexContext) SYNC() antlr.TerminalNode {
	return s.GetToken(YQLParserSYNC, 0)
}

func (s *Global_indexContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(YQLParserASYNC, 0)
}

func (s *Global_indexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Global_indexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Global_indexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterGlobal_index(s)
	}
}

func (s *Global_indexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitGlobal_index(s)
	}
}




func (p *YQLParser) Global_index() (localctx IGlobal_indexContext) {
	localctx = NewGlobal_indexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 522, YQLParserRULE_global_index)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3282)
		p.Match(YQLParserGLOBAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3284)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserUNIQUE {
		{
			p.SetState(3283)
			p.Match(YQLParserUNIQUE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(3287)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserASYNC || _la == YQLParserSYNC {
		{
			p.SetState(3286)
			_la = p.GetTokenStream().LA(1)

			if !(_la == YQLParserASYNC || _la == YQLParserSYNC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILocal_indexContext is an interface to support dynamic dispatch.
type ILocal_indexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCAL() antlr.TerminalNode

	// IsLocal_indexContext differentiates from other interfaces.
	IsLocal_indexContext()
}

type Local_indexContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocal_indexContext() *Local_indexContext {
	var p = new(Local_indexContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_local_index
	return p
}

func InitEmptyLocal_indexContext(p *Local_indexContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_local_index
}

func (*Local_indexContext) IsLocal_indexContext() {}

func NewLocal_indexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Local_indexContext {
	var p = new(Local_indexContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_local_index

	return p
}

func (s *Local_indexContext) GetParser() antlr.Parser { return s.parser }

func (s *Local_indexContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(YQLParserLOCAL, 0)
}

func (s *Local_indexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Local_indexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Local_indexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterLocal_index(s)
	}
}

func (s *Local_indexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitLocal_index(s)
	}
}




func (p *YQLParser) Local_index() (localctx ILocal_indexContext) {
	localctx = NewLocal_indexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 524, YQLParserRULE_local_index)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3289)
		p.Match(YQLParserLOCAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIndex_subtypeContext is an interface to support dynamic dispatch.
type IIndex_subtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id() IAn_idContext

	// IsIndex_subtypeContext differentiates from other interfaces.
	IsIndex_subtypeContext()
}

type Index_subtypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndex_subtypeContext() *Index_subtypeContext {
	var p = new(Index_subtypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_index_subtype
	return p
}

func InitEmptyIndex_subtypeContext(p *Index_subtypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_index_subtype
}

func (*Index_subtypeContext) IsIndex_subtypeContext() {}

func NewIndex_subtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Index_subtypeContext {
	var p = new(Index_subtypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_index_subtype

	return p
}

func (s *Index_subtypeContext) GetParser() antlr.Parser { return s.parser }

func (s *Index_subtypeContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Index_subtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Index_subtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Index_subtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterIndex_subtype(s)
	}
}

func (s *Index_subtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitIndex_subtype(s)
	}
}




func (p *YQLParser) Index_subtype() (localctx IIndex_subtypeContext) {
	localctx = NewIndex_subtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 526, YQLParserRULE_index_subtype)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3291)
		p.An_id()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWith_index_settingsContext is an interface to support dynamic dispatch.
type IWith_index_settingsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllIndex_setting_entry() []IIndex_setting_entryContext
	Index_setting_entry(i int) IIndex_setting_entryContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWith_index_settingsContext differentiates from other interfaces.
	IsWith_index_settingsContext()
}

type With_index_settingsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWith_index_settingsContext() *With_index_settingsContext {
	var p = new(With_index_settingsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_with_index_settings
	return p
}

func InitEmptyWith_index_settingsContext(p *With_index_settingsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_with_index_settings
}

func (*With_index_settingsContext) IsWith_index_settingsContext() {}

func NewWith_index_settingsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *With_index_settingsContext {
	var p = new(With_index_settingsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_with_index_settings

	return p
}

func (s *With_index_settingsContext) GetParser() antlr.Parser { return s.parser }

func (s *With_index_settingsContext) WITH() antlr.TerminalNode {
	return s.GetToken(YQLParserWITH, 0)
}

func (s *With_index_settingsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *With_index_settingsContext) AllIndex_setting_entry() []IIndex_setting_entryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndex_setting_entryContext); ok {
			len++
		}
	}

	tst := make([]IIndex_setting_entryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndex_setting_entryContext); ok {
			tst[i] = t.(IIndex_setting_entryContext)
			i++
		}
	}

	return tst
}

func (s *With_index_settingsContext) Index_setting_entry(i int) IIndex_setting_entryContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndex_setting_entryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndex_setting_entryContext)
}

func (s *With_index_settingsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *With_index_settingsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *With_index_settingsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *With_index_settingsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *With_index_settingsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *With_index_settingsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterWith_index_settings(s)
	}
}

func (s *With_index_settingsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitWith_index_settings(s)
	}
}




func (p *YQLParser) With_index_settings() (localctx IWith_index_settingsContext) {
	localctx = NewWith_index_settingsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 528, YQLParserRULE_with_index_settings)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3293)
		p.Match(YQLParserWITH)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3294)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3295)
		p.Index_setting_entry()
	}
	p.SetState(3300)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 327, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3296)
				p.Match(YQLParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3297)
				p.Index_setting_entry()
			}


		}
		p.SetState(3302)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 327, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(3304)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserCOMMA {
		{
			p.SetState(3303)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(3306)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIndex_setting_entryContext is an interface to support dynamic dispatch.
type IIndex_setting_entryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id() IAn_idContext
	EQUALS() antlr.TerminalNode
	Index_setting_value() IIndex_setting_valueContext

	// IsIndex_setting_entryContext differentiates from other interfaces.
	IsIndex_setting_entryContext()
}

type Index_setting_entryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndex_setting_entryContext() *Index_setting_entryContext {
	var p = new(Index_setting_entryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_index_setting_entry
	return p
}

func InitEmptyIndex_setting_entryContext(p *Index_setting_entryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_index_setting_entry
}

func (*Index_setting_entryContext) IsIndex_setting_entryContext() {}

func NewIndex_setting_entryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Index_setting_entryContext {
	var p = new(Index_setting_entryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_index_setting_entry

	return p
}

func (s *Index_setting_entryContext) GetParser() antlr.Parser { return s.parser }

func (s *Index_setting_entryContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Index_setting_entryContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(YQLParserEQUALS, 0)
}

func (s *Index_setting_entryContext) Index_setting_value() IIndex_setting_valueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndex_setting_valueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndex_setting_valueContext)
}

func (s *Index_setting_entryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Index_setting_entryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Index_setting_entryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterIndex_setting_entry(s)
	}
}

func (s *Index_setting_entryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitIndex_setting_entry(s)
	}
}




func (p *YQLParser) Index_setting_entry() (localctx IIndex_setting_entryContext) {
	localctx = NewIndex_setting_entryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 530, YQLParserRULE_index_setting_entry)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3308)
		p.An_id()
	}
	{
		p.SetState(3309)
		p.Match(YQLParserEQUALS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3310)
		p.Index_setting_value()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIndex_setting_valueContext is an interface to support dynamic dispatch.
type IIndex_setting_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_or_type() IId_or_typeContext
	STRING_VALUE() antlr.TerminalNode
	Integer() IIntegerContext
	Bool_value() IBool_valueContext

	// IsIndex_setting_valueContext differentiates from other interfaces.
	IsIndex_setting_valueContext()
}

type Index_setting_valueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndex_setting_valueContext() *Index_setting_valueContext {
	var p = new(Index_setting_valueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_index_setting_value
	return p
}

func InitEmptyIndex_setting_valueContext(p *Index_setting_valueContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_index_setting_value
}

func (*Index_setting_valueContext) IsIndex_setting_valueContext() {}

func NewIndex_setting_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Index_setting_valueContext {
	var p = new(Index_setting_valueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_index_setting_value

	return p
}

func (s *Index_setting_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Index_setting_valueContext) Id_or_type() IId_or_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_or_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_or_typeContext)
}

func (s *Index_setting_valueContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(YQLParserSTRING_VALUE, 0)
}

func (s *Index_setting_valueContext) Integer() IIntegerContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerContext)
}

func (s *Index_setting_valueContext) Bool_value() IBool_valueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_valueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_valueContext)
}

func (s *Index_setting_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Index_setting_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Index_setting_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterIndex_setting_value(s)
	}
}

func (s *Index_setting_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitIndex_setting_value(s)
	}
}




func (p *YQLParser) Index_setting_value() (localctx IIndex_setting_valueContext) {
	localctx = NewIndex_setting_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 532, YQLParserRULE_index_setting_value)
	p.SetState(3316)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALL, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserANY, YQLParserARRAY, YQLParserAS, YQLParserASC, YQLParserASSUME, YQLParserASYMMETRIC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBETWEEN, YQLParserBITCAST, YQLParserBY, YQLParserCALLABLE, YQLParserCASCADE, YQLParserCASE, YQLParserCAST, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOLUMN, YQLParserCOLUMNS, YQLParserCOMMIT, YQLParserCOMPACT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCUBE, YQLParserCURRENT, YQLParserCURRENT_DATE, YQLParserCURRENT_TIME, YQLParserCURRENT_TIMESTAMP, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDICT, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDISTINCT, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserEMPTY_ACTION, YQLParserENCRYPTED, YQLParserEND, YQLParserENUM, YQLParserERASE, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCEPT, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXISTS, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFLOW, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFROM, YQLParserFULL, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserGROUPS, YQLParserHASH, YQLParserHAVING, YQLParserHOP, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTERSECT, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserJSON_EXISTS, YQLParserJSON_QUERY, YQLParserJSON_VALUE, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLIMIT, YQLParserLIST, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOT, YQLParserNOTNULL, YQLParserNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOPTIONAL, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserPROCESS, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserRANGE, YQLParserREDUCE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESOURCE, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserRETURN, YQLParserRETURNING, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROLLUP, YQLParserROW, YQLParserROWS, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSCHEMA, YQLParserSECONDS, YQLParserSEEK, YQLParserSELECT, YQLParserSEMI, YQLParserSET, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSTREAM, YQLParserSTRUCT, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYMMETRIC, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTAGGED, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTUPLE, YQLParserTYPE, YQLParserUNBOUNDED, YQLParserUNCONDITIONAL, YQLParserUNION, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVARIANT, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWHEN, YQLParserWHERE, YQLParserWINDOW, YQLParserWITH, YQLParserWITHOUT, YQLParserWRAPPER, YQLParserXOR, YQLParserID_PLAIN, YQLParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3312)
			p.Id_or_type()
		}


	case YQLParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3313)
			p.Match(YQLParserSTRING_VALUE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserDIGITS, YQLParserINTEGER_VALUE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3314)
			p.Integer()
		}


	case YQLParserFALSE, YQLParserTRUE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3315)
			p.Bool_value()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IChangefeedContext is an interface to support dynamic dispatch.
type IChangefeedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHANGEFEED() antlr.TerminalNode
	An_id() IAn_idContext
	WITH() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Changefeed_settings() IChangefeed_settingsContext
	RPAREN() antlr.TerminalNode

	// IsChangefeedContext differentiates from other interfaces.
	IsChangefeedContext()
}

type ChangefeedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChangefeedContext() *ChangefeedContext {
	var p = new(ChangefeedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_changefeed
	return p
}

func InitEmptyChangefeedContext(p *ChangefeedContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_changefeed
}

func (*ChangefeedContext) IsChangefeedContext() {}

func NewChangefeedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChangefeedContext {
	var p = new(ChangefeedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_changefeed

	return p
}

func (s *ChangefeedContext) GetParser() antlr.Parser { return s.parser }

func (s *ChangefeedContext) CHANGEFEED() antlr.TerminalNode {
	return s.GetToken(YQLParserCHANGEFEED, 0)
}

func (s *ChangefeedContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *ChangefeedContext) WITH() antlr.TerminalNode {
	return s.GetToken(YQLParserWITH, 0)
}

func (s *ChangefeedContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *ChangefeedContext) Changefeed_settings() IChangefeed_settingsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChangefeed_settingsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChangefeed_settingsContext)
}

func (s *ChangefeedContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *ChangefeedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChangefeedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ChangefeedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterChangefeed(s)
	}
}

func (s *ChangefeedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitChangefeed(s)
	}
}




func (p *YQLParser) Changefeed() (localctx IChangefeedContext) {
	localctx = NewChangefeedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 534, YQLParserRULE_changefeed)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3318)
		p.Match(YQLParserCHANGEFEED)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3319)
		p.An_id()
	}
	{
		p.SetState(3320)
		p.Match(YQLParserWITH)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3321)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3322)
		p.Changefeed_settings()
	}
	{
		p.SetState(3323)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IChangefeed_settingsContext is an interface to support dynamic dispatch.
type IChangefeed_settingsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllChangefeed_settings_entry() []IChangefeed_settings_entryContext
	Changefeed_settings_entry(i int) IChangefeed_settings_entryContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsChangefeed_settingsContext differentiates from other interfaces.
	IsChangefeed_settingsContext()
}

type Changefeed_settingsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChangefeed_settingsContext() *Changefeed_settingsContext {
	var p = new(Changefeed_settingsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_changefeed_settings
	return p
}

func InitEmptyChangefeed_settingsContext(p *Changefeed_settingsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_changefeed_settings
}

func (*Changefeed_settingsContext) IsChangefeed_settingsContext() {}

func NewChangefeed_settingsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Changefeed_settingsContext {
	var p = new(Changefeed_settingsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_changefeed_settings

	return p
}

func (s *Changefeed_settingsContext) GetParser() antlr.Parser { return s.parser }

func (s *Changefeed_settingsContext) AllChangefeed_settings_entry() []IChangefeed_settings_entryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IChangefeed_settings_entryContext); ok {
			len++
		}
	}

	tst := make([]IChangefeed_settings_entryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IChangefeed_settings_entryContext); ok {
			tst[i] = t.(IChangefeed_settings_entryContext)
			i++
		}
	}

	return tst
}

func (s *Changefeed_settingsContext) Changefeed_settings_entry(i int) IChangefeed_settings_entryContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChangefeed_settings_entryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChangefeed_settings_entryContext)
}

func (s *Changefeed_settingsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Changefeed_settingsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Changefeed_settingsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Changefeed_settingsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Changefeed_settingsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterChangefeed_settings(s)
	}
}

func (s *Changefeed_settingsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitChangefeed_settings(s)
	}
}




func (p *YQLParser) Changefeed_settings() (localctx IChangefeed_settingsContext) {
	localctx = NewChangefeed_settingsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 536, YQLParserRULE_changefeed_settings)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3325)
		p.Changefeed_settings_entry()
	}
	p.SetState(3330)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(3326)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3327)
			p.Changefeed_settings_entry()
		}


		p.SetState(3332)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IChangefeed_settings_entryContext is an interface to support dynamic dispatch.
type IChangefeed_settings_entryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id() IAn_idContext
	EQUALS() antlr.TerminalNode
	Changefeed_setting_value() IChangefeed_setting_valueContext

	// IsChangefeed_settings_entryContext differentiates from other interfaces.
	IsChangefeed_settings_entryContext()
}

type Changefeed_settings_entryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChangefeed_settings_entryContext() *Changefeed_settings_entryContext {
	var p = new(Changefeed_settings_entryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_changefeed_settings_entry
	return p
}

func InitEmptyChangefeed_settings_entryContext(p *Changefeed_settings_entryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_changefeed_settings_entry
}

func (*Changefeed_settings_entryContext) IsChangefeed_settings_entryContext() {}

func NewChangefeed_settings_entryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Changefeed_settings_entryContext {
	var p = new(Changefeed_settings_entryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_changefeed_settings_entry

	return p
}

func (s *Changefeed_settings_entryContext) GetParser() antlr.Parser { return s.parser }

func (s *Changefeed_settings_entryContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Changefeed_settings_entryContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(YQLParserEQUALS, 0)
}

func (s *Changefeed_settings_entryContext) Changefeed_setting_value() IChangefeed_setting_valueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChangefeed_setting_valueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChangefeed_setting_valueContext)
}

func (s *Changefeed_settings_entryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Changefeed_settings_entryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Changefeed_settings_entryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterChangefeed_settings_entry(s)
	}
}

func (s *Changefeed_settings_entryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitChangefeed_settings_entry(s)
	}
}




func (p *YQLParser) Changefeed_settings_entry() (localctx IChangefeed_settings_entryContext) {
	localctx = NewChangefeed_settings_entryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 538, YQLParserRULE_changefeed_settings_entry)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3333)
		p.An_id()
	}
	{
		p.SetState(3334)
		p.Match(YQLParserEQUALS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3335)
		p.Changefeed_setting_value()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IChangefeed_setting_valueContext is an interface to support dynamic dispatch.
type IChangefeed_setting_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext

	// IsChangefeed_setting_valueContext differentiates from other interfaces.
	IsChangefeed_setting_valueContext()
}

type Changefeed_setting_valueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChangefeed_setting_valueContext() *Changefeed_setting_valueContext {
	var p = new(Changefeed_setting_valueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_changefeed_setting_value
	return p
}

func InitEmptyChangefeed_setting_valueContext(p *Changefeed_setting_valueContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_changefeed_setting_value
}

func (*Changefeed_setting_valueContext) IsChangefeed_setting_valueContext() {}

func NewChangefeed_setting_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Changefeed_setting_valueContext {
	var p = new(Changefeed_setting_valueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_changefeed_setting_value

	return p
}

func (s *Changefeed_setting_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Changefeed_setting_valueContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Changefeed_setting_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Changefeed_setting_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Changefeed_setting_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterChangefeed_setting_value(s)
	}
}

func (s *Changefeed_setting_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitChangefeed_setting_value(s)
	}
}




func (p *YQLParser) Changefeed_setting_value() (localctx IChangefeed_setting_valueContext) {
	localctx = NewChangefeed_setting_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 540, YQLParserRULE_changefeed_setting_value)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3337)
		p.Expr()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IChangefeed_alter_settingsContext is an interface to support dynamic dispatch.
type IChangefeed_alter_settingsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISABLE() antlr.TerminalNode
	SET() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Changefeed_settings() IChangefeed_settingsContext
	RPAREN() antlr.TerminalNode

	// IsChangefeed_alter_settingsContext differentiates from other interfaces.
	IsChangefeed_alter_settingsContext()
}

type Changefeed_alter_settingsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChangefeed_alter_settingsContext() *Changefeed_alter_settingsContext {
	var p = new(Changefeed_alter_settingsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_changefeed_alter_settings
	return p
}

func InitEmptyChangefeed_alter_settingsContext(p *Changefeed_alter_settingsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_changefeed_alter_settings
}

func (*Changefeed_alter_settingsContext) IsChangefeed_alter_settingsContext() {}

func NewChangefeed_alter_settingsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Changefeed_alter_settingsContext {
	var p = new(Changefeed_alter_settingsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_changefeed_alter_settings

	return p
}

func (s *Changefeed_alter_settingsContext) GetParser() antlr.Parser { return s.parser }

func (s *Changefeed_alter_settingsContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(YQLParserDISABLE, 0)
}

func (s *Changefeed_alter_settingsContext) SET() antlr.TerminalNode {
	return s.GetToken(YQLParserSET, 0)
}

func (s *Changefeed_alter_settingsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Changefeed_alter_settingsContext) Changefeed_settings() IChangefeed_settingsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChangefeed_settingsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChangefeed_settingsContext)
}

func (s *Changefeed_alter_settingsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Changefeed_alter_settingsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Changefeed_alter_settingsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Changefeed_alter_settingsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterChangefeed_alter_settings(s)
	}
}

func (s *Changefeed_alter_settingsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitChangefeed_alter_settings(s)
	}
}




func (p *YQLParser) Changefeed_alter_settings() (localctx IChangefeed_alter_settingsContext) {
	localctx = NewChangefeed_alter_settingsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 542, YQLParserRULE_changefeed_alter_settings)
	p.SetState(3345)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserDISABLE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3339)
			p.Match(YQLParserDISABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserSET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3340)
			p.Match(YQLParserSET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3341)
			p.Match(YQLParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3342)
			p.Changefeed_settings()
		}
		{
			p.SetState(3343)
			p.Match(YQLParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_table_setting_entryContext is an interface to support dynamic dispatch.
type IAlter_table_setting_entryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id() IAn_idContext
	EQUALS() antlr.TerminalNode
	Table_setting_value() ITable_setting_valueContext

	// IsAlter_table_setting_entryContext differentiates from other interfaces.
	IsAlter_table_setting_entryContext()
}

type Alter_table_setting_entryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_setting_entryContext() *Alter_table_setting_entryContext {
	var p = new(Alter_table_setting_entryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_setting_entry
	return p
}

func InitEmptyAlter_table_setting_entryContext(p *Alter_table_setting_entryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_setting_entry
}

func (*Alter_table_setting_entryContext) IsAlter_table_setting_entryContext() {}

func NewAlter_table_setting_entryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_setting_entryContext {
	var p = new(Alter_table_setting_entryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_table_setting_entry

	return p
}

func (s *Alter_table_setting_entryContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_setting_entryContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Alter_table_setting_entryContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(YQLParserEQUALS, 0)
}

func (s *Alter_table_setting_entryContext) Table_setting_value() ITable_setting_valueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_setting_valueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_setting_valueContext)
}

func (s *Alter_table_setting_entryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_setting_entryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_table_setting_entryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_table_setting_entry(s)
	}
}

func (s *Alter_table_setting_entryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_table_setting_entry(s)
	}
}




func (p *YQLParser) Alter_table_setting_entry() (localctx IAlter_table_setting_entryContext) {
	localctx = NewAlter_table_setting_entryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 544, YQLParserRULE_alter_table_setting_entry)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3347)
		p.An_id()
	}
	{
		p.SetState(3348)
		p.Match(YQLParserEQUALS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3349)
		p.Table_setting_value()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITable_setting_valueContext is an interface to support dynamic dispatch.
type ITable_setting_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id() IIdContext
	STRING_VALUE() antlr.TerminalNode
	Integer() IIntegerContext
	Split_boundaries() ISplit_boundariesContext
	Ttl_tier_list() ITtl_tier_listContext
	ON() antlr.TerminalNode
	An_id() IAn_idContext
	AS() antlr.TerminalNode
	SECONDS() antlr.TerminalNode
	MILLISECONDS() antlr.TerminalNode
	MICROSECONDS() antlr.TerminalNode
	NANOSECONDS() antlr.TerminalNode
	Bool_value() IBool_valueContext

	// IsTable_setting_valueContext differentiates from other interfaces.
	IsTable_setting_valueContext()
}

type Table_setting_valueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_setting_valueContext() *Table_setting_valueContext {
	var p = new(Table_setting_valueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_table_setting_value
	return p
}

func InitEmptyTable_setting_valueContext(p *Table_setting_valueContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_table_setting_value
}

func (*Table_setting_valueContext) IsTable_setting_valueContext() {}

func NewTable_setting_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_setting_valueContext {
	var p = new(Table_setting_valueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_table_setting_value

	return p
}

func (s *Table_setting_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_setting_valueContext) Id() IIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *Table_setting_valueContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(YQLParserSTRING_VALUE, 0)
}

func (s *Table_setting_valueContext) Integer() IIntegerContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerContext)
}

func (s *Table_setting_valueContext) Split_boundaries() ISplit_boundariesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISplit_boundariesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISplit_boundariesContext)
}

func (s *Table_setting_valueContext) Ttl_tier_list() ITtl_tier_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITtl_tier_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITtl_tier_listContext)
}

func (s *Table_setting_valueContext) ON() antlr.TerminalNode {
	return s.GetToken(YQLParserON, 0)
}

func (s *Table_setting_valueContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Table_setting_valueContext) AS() antlr.TerminalNode {
	return s.GetToken(YQLParserAS, 0)
}

func (s *Table_setting_valueContext) SECONDS() antlr.TerminalNode {
	return s.GetToken(YQLParserSECONDS, 0)
}

func (s *Table_setting_valueContext) MILLISECONDS() antlr.TerminalNode {
	return s.GetToken(YQLParserMILLISECONDS, 0)
}

func (s *Table_setting_valueContext) MICROSECONDS() antlr.TerminalNode {
	return s.GetToken(YQLParserMICROSECONDS, 0)
}

func (s *Table_setting_valueContext) NANOSECONDS() antlr.TerminalNode {
	return s.GetToken(YQLParserNANOSECONDS, 0)
}

func (s *Table_setting_valueContext) Bool_value() IBool_valueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_valueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_valueContext)
}

func (s *Table_setting_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_setting_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Table_setting_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterTable_setting_value(s)
	}
}

func (s *Table_setting_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitTable_setting_value(s)
	}
}




func (p *YQLParser) Table_setting_value() (localctx ITable_setting_valueContext) {
	localctx = NewTable_setting_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 546, YQLParserRULE_table_setting_value)
	var _la int

	p.SetState(3363)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 333, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3351)
			p.Id()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3352)
			p.Match(YQLParserSTRING_VALUE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3353)
			p.Integer()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3354)
			p.Split_boundaries()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3355)
			p.Ttl_tier_list()
		}
		{
			p.SetState(3356)
			p.Match(YQLParserON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3357)
			p.An_id()
		}
		p.SetState(3360)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserAS {
			{
				p.SetState(3358)
				p.Match(YQLParserAS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3359)
				_la = p.GetTokenStream().LA(1)

				if !(((int64((_la - 190)) & ^0x3f) == 0 && ((int64(1) << (_la - 190)) & 11) != 0) || _la == YQLParserSECONDS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3362)
			p.Bool_value()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITtl_tier_listContext is an interface to support dynamic dispatch.
type ITtl_tier_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllTtl_tier_action() []ITtl_tier_actionContext
	Ttl_tier_action(i int) ITtl_tier_actionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTtl_tier_listContext differentiates from other interfaces.
	IsTtl_tier_listContext()
}

type Ttl_tier_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTtl_tier_listContext() *Ttl_tier_listContext {
	var p = new(Ttl_tier_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_ttl_tier_list
	return p
}

func InitEmptyTtl_tier_listContext(p *Ttl_tier_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_ttl_tier_list
}

func (*Ttl_tier_listContext) IsTtl_tier_listContext() {}

func NewTtl_tier_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ttl_tier_listContext {
	var p = new(Ttl_tier_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_ttl_tier_list

	return p
}

func (s *Ttl_tier_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Ttl_tier_listContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Ttl_tier_listContext) Expr(i int) IExprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Ttl_tier_listContext) AllTtl_tier_action() []ITtl_tier_actionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITtl_tier_actionContext); ok {
			len++
		}
	}

	tst := make([]ITtl_tier_actionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITtl_tier_actionContext); ok {
			tst[i] = t.(ITtl_tier_actionContext)
			i++
		}
	}

	return tst
}

func (s *Ttl_tier_listContext) Ttl_tier_action(i int) ITtl_tier_actionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITtl_tier_actionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITtl_tier_actionContext)
}

func (s *Ttl_tier_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Ttl_tier_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Ttl_tier_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ttl_tier_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Ttl_tier_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterTtl_tier_list(s)
	}
}

func (s *Ttl_tier_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitTtl_tier_list(s)
	}
}




func (p *YQLParser) Ttl_tier_list() (localctx ITtl_tier_listContext) {
	localctx = NewTtl_tier_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 548, YQLParserRULE_ttl_tier_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3365)
		p.Expr()
	}
	p.SetState(3376)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserDELETE || _la == YQLParserTO {
		{
			p.SetState(3366)
			p.Ttl_tier_action()
		}
		p.SetState(3373)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == YQLParserCOMMA {
			{
				p.SetState(3367)
				p.Match(YQLParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3368)
				p.Expr()
			}
			{
				p.SetState(3369)
				p.Ttl_tier_action()
			}


			p.SetState(3375)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITtl_tier_actionContext is an interface to support dynamic dispatch.
type ITtl_tier_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TO() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	DATA() antlr.TerminalNode
	SOURCE() antlr.TerminalNode
	An_id() IAn_idContext
	DELETE() antlr.TerminalNode

	// IsTtl_tier_actionContext differentiates from other interfaces.
	IsTtl_tier_actionContext()
}

type Ttl_tier_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTtl_tier_actionContext() *Ttl_tier_actionContext {
	var p = new(Ttl_tier_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_ttl_tier_action
	return p
}

func InitEmptyTtl_tier_actionContext(p *Ttl_tier_actionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_ttl_tier_action
}

func (*Ttl_tier_actionContext) IsTtl_tier_actionContext() {}

func NewTtl_tier_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ttl_tier_actionContext {
	var p = new(Ttl_tier_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_ttl_tier_action

	return p
}

func (s *Ttl_tier_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Ttl_tier_actionContext) TO() antlr.TerminalNode {
	return s.GetToken(YQLParserTO, 0)
}

func (s *Ttl_tier_actionContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(YQLParserEXTERNAL, 0)
}

func (s *Ttl_tier_actionContext) DATA() antlr.TerminalNode {
	return s.GetToken(YQLParserDATA, 0)
}

func (s *Ttl_tier_actionContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(YQLParserSOURCE, 0)
}

func (s *Ttl_tier_actionContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Ttl_tier_actionContext) DELETE() antlr.TerminalNode {
	return s.GetToken(YQLParserDELETE, 0)
}

func (s *Ttl_tier_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ttl_tier_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Ttl_tier_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterTtl_tier_action(s)
	}
}

func (s *Ttl_tier_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitTtl_tier_action(s)
	}
}




func (p *YQLParser) Ttl_tier_action() (localctx ITtl_tier_actionContext) {
	localctx = NewTtl_tier_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 550, YQLParserRULE_ttl_tier_action)
	p.SetState(3384)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserTO:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3378)
			p.Match(YQLParserTO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3379)
			p.Match(YQLParserEXTERNAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3380)
			p.Match(YQLParserDATA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3381)
			p.Match(YQLParserSOURCE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3382)
			p.An_id()
		}


	case YQLParserDELETE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3383)
			p.Match(YQLParserDELETE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFamily_entryContext is an interface to support dynamic dispatch.
type IFamily_entryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FAMILY() antlr.TerminalNode
	An_id() IAn_idContext
	Family_settings() IFamily_settingsContext

	// IsFamily_entryContext differentiates from other interfaces.
	IsFamily_entryContext()
}

type Family_entryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFamily_entryContext() *Family_entryContext {
	var p = new(Family_entryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_family_entry
	return p
}

func InitEmptyFamily_entryContext(p *Family_entryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_family_entry
}

func (*Family_entryContext) IsFamily_entryContext() {}

func NewFamily_entryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Family_entryContext {
	var p = new(Family_entryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_family_entry

	return p
}

func (s *Family_entryContext) GetParser() antlr.Parser { return s.parser }

func (s *Family_entryContext) FAMILY() antlr.TerminalNode {
	return s.GetToken(YQLParserFAMILY, 0)
}

func (s *Family_entryContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Family_entryContext) Family_settings() IFamily_settingsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFamily_settingsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFamily_settingsContext)
}

func (s *Family_entryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Family_entryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Family_entryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterFamily_entry(s)
	}
}

func (s *Family_entryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitFamily_entry(s)
	}
}




func (p *YQLParser) Family_entry() (localctx IFamily_entryContext) {
	localctx = NewFamily_entryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 552, YQLParserRULE_family_entry)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3386)
		p.Match(YQLParserFAMILY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3387)
		p.An_id()
	}
	{
		p.SetState(3388)
		p.Family_settings()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFamily_settingsContext is an interface to support dynamic dispatch.
type IFamily_settingsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllFamily_settings_entry() []IFamily_settings_entryContext
	Family_settings_entry(i int) IFamily_settings_entryContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFamily_settingsContext differentiates from other interfaces.
	IsFamily_settingsContext()
}

type Family_settingsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFamily_settingsContext() *Family_settingsContext {
	var p = new(Family_settingsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_family_settings
	return p
}

func InitEmptyFamily_settingsContext(p *Family_settingsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_family_settings
}

func (*Family_settingsContext) IsFamily_settingsContext() {}

func NewFamily_settingsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Family_settingsContext {
	var p = new(Family_settingsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_family_settings

	return p
}

func (s *Family_settingsContext) GetParser() antlr.Parser { return s.parser }

func (s *Family_settingsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Family_settingsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Family_settingsContext) AllFamily_settings_entry() []IFamily_settings_entryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFamily_settings_entryContext); ok {
			len++
		}
	}

	tst := make([]IFamily_settings_entryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFamily_settings_entryContext); ok {
			tst[i] = t.(IFamily_settings_entryContext)
			i++
		}
	}

	return tst
}

func (s *Family_settingsContext) Family_settings_entry(i int) IFamily_settings_entryContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFamily_settings_entryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFamily_settings_entryContext)
}

func (s *Family_settingsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Family_settingsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Family_settingsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Family_settingsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Family_settingsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterFamily_settings(s)
	}
}

func (s *Family_settingsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitFamily_settings(s)
	}
}




func (p *YQLParser) Family_settings() (localctx IFamily_settingsContext) {
	localctx = NewFamily_settingsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 554, YQLParserRULE_family_settings)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3390)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3399)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64((_la - 38)) & ^0x3f) == 0 && ((int64(1) << (_la - 38)) & -537919489) != 0) || ((int64((_la - 102)) & ^0x3f) == 0 && ((int64(1) << (_la - 102)) & -17716772869) != 0) || ((int64((_la - 166)) & ^0x3f) == 0 && ((int64(1) << (_la - 166)) & -17592186109953) != 0) || ((int64((_la - 230)) & ^0x3f) == 0 && ((int64(1) << (_la - 230)) & -576743326791901185) != 0) || ((int64((_la - 294)) & ^0x3f) == 0 && ((int64(1) << (_la - 294)) & 8588885967) != 0) {
		{
			p.SetState(3391)
			p.Family_settings_entry()
		}
		p.SetState(3396)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == YQLParserCOMMA {
			{
				p.SetState(3392)
				p.Match(YQLParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3393)
				p.Family_settings_entry()
			}


			p.SetState(3398)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(3401)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFamily_settings_entryContext is an interface to support dynamic dispatch.
type IFamily_settings_entryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id() IAn_idContext
	EQUALS() antlr.TerminalNode
	Family_setting_value() IFamily_setting_valueContext

	// IsFamily_settings_entryContext differentiates from other interfaces.
	IsFamily_settings_entryContext()
}

type Family_settings_entryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFamily_settings_entryContext() *Family_settings_entryContext {
	var p = new(Family_settings_entryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_family_settings_entry
	return p
}

func InitEmptyFamily_settings_entryContext(p *Family_settings_entryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_family_settings_entry
}

func (*Family_settings_entryContext) IsFamily_settings_entryContext() {}

func NewFamily_settings_entryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Family_settings_entryContext {
	var p = new(Family_settings_entryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_family_settings_entry

	return p
}

func (s *Family_settings_entryContext) GetParser() antlr.Parser { return s.parser }

func (s *Family_settings_entryContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Family_settings_entryContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(YQLParserEQUALS, 0)
}

func (s *Family_settings_entryContext) Family_setting_value() IFamily_setting_valueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFamily_setting_valueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFamily_setting_valueContext)
}

func (s *Family_settings_entryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Family_settings_entryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Family_settings_entryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterFamily_settings_entry(s)
	}
}

func (s *Family_settings_entryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitFamily_settings_entry(s)
	}
}




func (p *YQLParser) Family_settings_entry() (localctx IFamily_settings_entryContext) {
	localctx = NewFamily_settings_entryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 556, YQLParserRULE_family_settings_entry)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3403)
		p.An_id()
	}
	{
		p.SetState(3404)
		p.Match(YQLParserEQUALS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3405)
		p.Family_setting_value()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFamily_setting_valueContext is an interface to support dynamic dispatch.
type IFamily_setting_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_VALUE() antlr.TerminalNode
	Integer() IIntegerContext

	// IsFamily_setting_valueContext differentiates from other interfaces.
	IsFamily_setting_valueContext()
}

type Family_setting_valueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFamily_setting_valueContext() *Family_setting_valueContext {
	var p = new(Family_setting_valueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_family_setting_value
	return p
}

func InitEmptyFamily_setting_valueContext(p *Family_setting_valueContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_family_setting_value
}

func (*Family_setting_valueContext) IsFamily_setting_valueContext() {}

func NewFamily_setting_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Family_setting_valueContext {
	var p = new(Family_setting_valueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_family_setting_value

	return p
}

func (s *Family_setting_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Family_setting_valueContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(YQLParserSTRING_VALUE, 0)
}

func (s *Family_setting_valueContext) Integer() IIntegerContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerContext)
}

func (s *Family_setting_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Family_setting_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Family_setting_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterFamily_setting_value(s)
	}
}

func (s *Family_setting_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitFamily_setting_value(s)
	}
}




func (p *YQLParser) Family_setting_value() (localctx IFamily_setting_valueContext) {
	localctx = NewFamily_setting_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 558, YQLParserRULE_family_setting_value)
	p.SetState(3409)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3407)
			p.Match(YQLParserSTRING_VALUE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserDIGITS, YQLParserINTEGER_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3408)
			p.Integer()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISplit_boundariesContext is an interface to support dynamic dispatch.
type ISplit_boundariesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllLiteral_value_list() []ILiteral_value_listContext
	Literal_value_list(i int) ILiteral_value_listContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSplit_boundariesContext differentiates from other interfaces.
	IsSplit_boundariesContext()
}

type Split_boundariesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySplit_boundariesContext() *Split_boundariesContext {
	var p = new(Split_boundariesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_split_boundaries
	return p
}

func InitEmptySplit_boundariesContext(p *Split_boundariesContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_split_boundaries
}

func (*Split_boundariesContext) IsSplit_boundariesContext() {}

func NewSplit_boundariesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Split_boundariesContext {
	var p = new(Split_boundariesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_split_boundaries

	return p
}

func (s *Split_boundariesContext) GetParser() antlr.Parser { return s.parser }

func (s *Split_boundariesContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Split_boundariesContext) AllLiteral_value_list() []ILiteral_value_listContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILiteral_value_listContext); ok {
			len++
		}
	}

	tst := make([]ILiteral_value_listContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILiteral_value_listContext); ok {
			tst[i] = t.(ILiteral_value_listContext)
			i++
		}
	}

	return tst
}

func (s *Split_boundariesContext) Literal_value_list(i int) ILiteral_value_listContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteral_value_listContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteral_value_listContext)
}

func (s *Split_boundariesContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Split_boundariesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Split_boundariesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Split_boundariesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Split_boundariesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Split_boundariesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterSplit_boundaries(s)
	}
}

func (s *Split_boundariesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitSplit_boundaries(s)
	}
}




func (p *YQLParser) Split_boundaries() (localctx ISplit_boundariesContext) {
	localctx = NewSplit_boundariesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 560, YQLParserRULE_split_boundaries)
	var _la int

	p.SetState(3423)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 341, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3411)
			p.Match(YQLParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3412)
			p.Literal_value_list()
		}
		p.SetState(3417)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == YQLParserCOMMA {
			{
				p.SetState(3413)
				p.Match(YQLParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3414)
				p.Literal_value_list()
			}


			p.SetState(3419)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3420)
			p.Match(YQLParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3422)
			p.Literal_value_list()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILiteral_value_listContext is an interface to support dynamic dispatch.
type ILiteral_value_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllLiteral_value() []ILiteral_valueContext
	Literal_value(i int) ILiteral_valueContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsLiteral_value_listContext differentiates from other interfaces.
	IsLiteral_value_listContext()
}

type Literal_value_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteral_value_listContext() *Literal_value_listContext {
	var p = new(Literal_value_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_literal_value_list
	return p
}

func InitEmptyLiteral_value_listContext(p *Literal_value_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_literal_value_list
}

func (*Literal_value_listContext) IsLiteral_value_listContext() {}

func NewLiteral_value_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Literal_value_listContext {
	var p = new(Literal_value_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_literal_value_list

	return p
}

func (s *Literal_value_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Literal_value_listContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Literal_value_listContext) AllLiteral_value() []ILiteral_valueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILiteral_valueContext); ok {
			len++
		}
	}

	tst := make([]ILiteral_valueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILiteral_valueContext); ok {
			tst[i] = t.(ILiteral_valueContext)
			i++
		}
	}

	return tst
}

func (s *Literal_value_listContext) Literal_value(i int) ILiteral_valueContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteral_valueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteral_valueContext)
}

func (s *Literal_value_listContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Literal_value_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Literal_value_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Literal_value_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Literal_value_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Literal_value_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterLiteral_value_list(s)
	}
}

func (s *Literal_value_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitLiteral_value_list(s)
	}
}




func (p *YQLParser) Literal_value_list() (localctx ILiteral_value_listContext) {
	localctx = NewLiteral_value_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 562, YQLParserRULE_literal_value_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3425)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3426)
		p.Literal_value()
	}
	p.SetState(3431)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(3427)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3428)
			p.Literal_value()
		}


		p.SetState(3433)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3434)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_table_alter_index_actionContext is an interface to support dynamic dispatch.
type IAlter_table_alter_index_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Alter_table_set_table_setting_uncompat() IAlter_table_set_table_setting_uncompatContext
	Alter_table_set_table_setting_compat() IAlter_table_set_table_setting_compatContext
	Alter_table_reset_table_setting() IAlter_table_reset_table_settingContext

	// IsAlter_table_alter_index_actionContext differentiates from other interfaces.
	IsAlter_table_alter_index_actionContext()
}

type Alter_table_alter_index_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_alter_index_actionContext() *Alter_table_alter_index_actionContext {
	var p = new(Alter_table_alter_index_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_alter_index_action
	return p
}

func InitEmptyAlter_table_alter_index_actionContext(p *Alter_table_alter_index_actionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_table_alter_index_action
}

func (*Alter_table_alter_index_actionContext) IsAlter_table_alter_index_actionContext() {}

func NewAlter_table_alter_index_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_alter_index_actionContext {
	var p = new(Alter_table_alter_index_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_table_alter_index_action

	return p
}

func (s *Alter_table_alter_index_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_alter_index_actionContext) Alter_table_set_table_setting_uncompat() IAlter_table_set_table_setting_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_set_table_setting_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_set_table_setting_uncompatContext)
}

func (s *Alter_table_alter_index_actionContext) Alter_table_set_table_setting_compat() IAlter_table_set_table_setting_compatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_set_table_setting_compatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_set_table_setting_compatContext)
}

func (s *Alter_table_alter_index_actionContext) Alter_table_reset_table_setting() IAlter_table_reset_table_settingContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_reset_table_settingContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_reset_table_settingContext)
}

func (s *Alter_table_alter_index_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_alter_index_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_table_alter_index_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_table_alter_index_action(s)
	}
}

func (s *Alter_table_alter_index_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_table_alter_index_action(s)
	}
}




func (p *YQLParser) Alter_table_alter_index_action() (localctx IAlter_table_alter_index_actionContext) {
	localctx = NewAlter_table_alter_index_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 564, YQLParserRULE_alter_table_alter_index_action)
	p.SetState(3439)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 343, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3436)
			p.Alter_table_set_table_setting_uncompat()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3437)
			p.Alter_table_set_table_setting_compat()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3438)
			p.Alter_table_reset_table_setting()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDrop_table_stmtContext is an interface to support dynamic dispatch.
type IDrop_table_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	Simple_table_ref() ISimple_table_refContext
	TABLE() antlr.TerminalNode
	TABLESTORE() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDrop_table_stmtContext differentiates from other interfaces.
	IsDrop_table_stmtContext()
}

type Drop_table_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_table_stmtContext() *Drop_table_stmtContext {
	var p = new(Drop_table_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_drop_table_stmt
	return p
}

func InitEmptyDrop_table_stmtContext(p *Drop_table_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_drop_table_stmt
}

func (*Drop_table_stmtContext) IsDrop_table_stmtContext() {}

func NewDrop_table_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_table_stmtContext {
	var p = new(Drop_table_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_drop_table_stmt

	return p
}

func (s *Drop_table_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_table_stmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(YQLParserDROP, 0)
}

func (s *Drop_table_stmtContext) Simple_table_ref() ISimple_table_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_table_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_table_refContext)
}

func (s *Drop_table_stmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(YQLParserTABLE, 0)
}

func (s *Drop_table_stmtContext) TABLESTORE() antlr.TerminalNode {
	return s.GetToken(YQLParserTABLESTORE, 0)
}

func (s *Drop_table_stmtContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(YQLParserEXTERNAL, 0)
}

func (s *Drop_table_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(YQLParserIF, 0)
}

func (s *Drop_table_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(YQLParserEXISTS, 0)
}

func (s *Drop_table_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_table_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Drop_table_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterDrop_table_stmt(s)
	}
}

func (s *Drop_table_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitDrop_table_stmt(s)
	}
}




func (p *YQLParser) Drop_table_stmt() (localctx IDrop_table_stmtContext) {
	localctx = NewDrop_table_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 566, YQLParserRULE_drop_table_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3441)
		p.Match(YQLParserDROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3446)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserTABLE:
		{
			p.SetState(3442)
			p.Match(YQLParserTABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserTABLESTORE:
		{
			p.SetState(3443)
			p.Match(YQLParserTABLESTORE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserEXTERNAL:
		{
			p.SetState(3444)
			p.Match(YQLParserEXTERNAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3445)
			p.Match(YQLParserTABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(3450)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 345, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3448)
			p.Match(YQLParserIF)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3449)
			p.Match(YQLParserEXISTS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(3452)
		p.Simple_table_ref()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_user_stmtContext is an interface to support dynamic dispatch.
type ICreate_user_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	USER() antlr.TerminalNode
	Role_name() IRole_nameContext
	AllCreate_user_option() []ICreate_user_optionContext
	Create_user_option(i int) ICreate_user_optionContext

	// IsCreate_user_stmtContext differentiates from other interfaces.
	IsCreate_user_stmtContext()
}

type Create_user_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_user_stmtContext() *Create_user_stmtContext {
	var p = new(Create_user_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_create_user_stmt
	return p
}

func InitEmptyCreate_user_stmtContext(p *Create_user_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_create_user_stmt
}

func (*Create_user_stmtContext) IsCreate_user_stmtContext() {}

func NewCreate_user_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_user_stmtContext {
	var p = new(Create_user_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_create_user_stmt

	return p
}

func (s *Create_user_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_user_stmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(YQLParserCREATE, 0)
}

func (s *Create_user_stmtContext) USER() antlr.TerminalNode {
	return s.GetToken(YQLParserUSER, 0)
}

func (s *Create_user_stmtContext) Role_name() IRole_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRole_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRole_nameContext)
}

func (s *Create_user_stmtContext) AllCreate_user_option() []ICreate_user_optionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_user_optionContext); ok {
			len++
		}
	}

	tst := make([]ICreate_user_optionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_user_optionContext); ok {
			tst[i] = t.(ICreate_user_optionContext)
			i++
		}
	}

	return tst
}

func (s *Create_user_stmtContext) Create_user_option(i int) ICreate_user_optionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_user_optionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_user_optionContext)
}

func (s *Create_user_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_user_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_user_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterCreate_user_stmt(s)
	}
}

func (s *Create_user_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitCreate_user_stmt(s)
	}
}




func (p *YQLParser) Create_user_stmt() (localctx ICreate_user_stmtContext) {
	localctx = NewCreate_user_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 568, YQLParserRULE_create_user_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3454)
		p.Match(YQLParserCREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3455)
		p.Match(YQLParserUSER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3456)
		p.Role_name()
	}
	p.SetState(3460)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserENCRYPTED || ((int64((_la - 184)) & ^0x3f) == 0 && ((int64(1) << (_la - 184)) & 34359746561) != 0) {
		{
			p.SetState(3457)
			p.Create_user_option()
		}


		p.SetState(3462)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_user_stmtContext is an interface to support dynamic dispatch.
type IAlter_user_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	USER() antlr.TerminalNode
	AllRole_name() []IRole_nameContext
	Role_name(i int) IRole_nameContext
	RENAME() antlr.TerminalNode
	TO() antlr.TerminalNode
	WITH() antlr.TerminalNode
	AllCreate_user_option() []ICreate_user_optionContext
	Create_user_option(i int) ICreate_user_optionContext

	// IsAlter_user_stmtContext differentiates from other interfaces.
	IsAlter_user_stmtContext()
}

type Alter_user_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_user_stmtContext() *Alter_user_stmtContext {
	var p = new(Alter_user_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_user_stmt
	return p
}

func InitEmptyAlter_user_stmtContext(p *Alter_user_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_user_stmt
}

func (*Alter_user_stmtContext) IsAlter_user_stmtContext() {}

func NewAlter_user_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_user_stmtContext {
	var p = new(Alter_user_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_user_stmt

	return p
}

func (s *Alter_user_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_user_stmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(YQLParserALTER, 0)
}

func (s *Alter_user_stmtContext) USER() antlr.TerminalNode {
	return s.GetToken(YQLParserUSER, 0)
}

func (s *Alter_user_stmtContext) AllRole_name() []IRole_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRole_nameContext); ok {
			len++
		}
	}

	tst := make([]IRole_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRole_nameContext); ok {
			tst[i] = t.(IRole_nameContext)
			i++
		}
	}

	return tst
}

func (s *Alter_user_stmtContext) Role_name(i int) IRole_nameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRole_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRole_nameContext)
}

func (s *Alter_user_stmtContext) RENAME() antlr.TerminalNode {
	return s.GetToken(YQLParserRENAME, 0)
}

func (s *Alter_user_stmtContext) TO() antlr.TerminalNode {
	return s.GetToken(YQLParserTO, 0)
}

func (s *Alter_user_stmtContext) WITH() antlr.TerminalNode {
	return s.GetToken(YQLParserWITH, 0)
}

func (s *Alter_user_stmtContext) AllCreate_user_option() []ICreate_user_optionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_user_optionContext); ok {
			len++
		}
	}

	tst := make([]ICreate_user_optionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_user_optionContext); ok {
			tst[i] = t.(ICreate_user_optionContext)
			i++
		}
	}

	return tst
}

func (s *Alter_user_stmtContext) Create_user_option(i int) ICreate_user_optionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_user_optionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_user_optionContext)
}

func (s *Alter_user_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_user_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_user_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_user_stmt(s)
	}
}

func (s *Alter_user_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_user_stmt(s)
	}
}




func (p *YQLParser) Alter_user_stmt() (localctx IAlter_user_stmtContext) {
	localctx = NewAlter_user_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 570, YQLParserRULE_alter_user_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3463)
		p.Match(YQLParserALTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3464)
		p.Match(YQLParserUSER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3465)
		p.Role_name()
	}
	p.SetState(3477)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserENCRYPTED, YQLParserLOGIN, YQLParserNOLOGIN, YQLParserPASSWORD, YQLParserWITH:
		p.SetState(3467)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserWITH {
			{
				p.SetState(3466)
				p.Match(YQLParserWITH)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		p.SetState(3470)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = _la == YQLParserENCRYPTED || ((int64((_la - 184)) & ^0x3f) == 0 && ((int64(1) << (_la - 184)) & 34359746561) != 0) {
			{
				p.SetState(3469)
				p.Create_user_option()
			}


			p.SetState(3472)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}


	case YQLParserRENAME:
		{
			p.SetState(3474)
			p.Match(YQLParserRENAME)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3475)
			p.Match(YQLParserTO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3476)
			p.Role_name()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_group_stmtContext is an interface to support dynamic dispatch.
type ICreate_group_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	AllRole_name() []IRole_nameContext
	Role_name(i int) IRole_nameContext
	WITH() antlr.TerminalNode
	USER() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCreate_group_stmtContext differentiates from other interfaces.
	IsCreate_group_stmtContext()
}

type Create_group_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_group_stmtContext() *Create_group_stmtContext {
	var p = new(Create_group_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_create_group_stmt
	return p
}

func InitEmptyCreate_group_stmtContext(p *Create_group_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_create_group_stmt
}

func (*Create_group_stmtContext) IsCreate_group_stmtContext() {}

func NewCreate_group_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_group_stmtContext {
	var p = new(Create_group_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_create_group_stmt

	return p
}

func (s *Create_group_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_group_stmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(YQLParserCREATE, 0)
}

func (s *Create_group_stmtContext) GROUP() antlr.TerminalNode {
	return s.GetToken(YQLParserGROUP, 0)
}

func (s *Create_group_stmtContext) AllRole_name() []IRole_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRole_nameContext); ok {
			len++
		}
	}

	tst := make([]IRole_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRole_nameContext); ok {
			tst[i] = t.(IRole_nameContext)
			i++
		}
	}

	return tst
}

func (s *Create_group_stmtContext) Role_name(i int) IRole_nameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRole_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRole_nameContext)
}

func (s *Create_group_stmtContext) WITH() antlr.TerminalNode {
	return s.GetToken(YQLParserWITH, 0)
}

func (s *Create_group_stmtContext) USER() antlr.TerminalNode {
	return s.GetToken(YQLParserUSER, 0)
}

func (s *Create_group_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Create_group_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Create_group_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_group_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_group_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterCreate_group_stmt(s)
	}
}

func (s *Create_group_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitCreate_group_stmt(s)
	}
}




func (p *YQLParser) Create_group_stmt() (localctx ICreate_group_stmtContext) {
	localctx = NewCreate_group_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 572, YQLParserRULE_create_group_stmt)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3479)
		p.Match(YQLParserCREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3480)
		p.Match(YQLParserGROUP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3481)
		p.Role_name()
	}
	p.SetState(3495)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserWITH {
		{
			p.SetState(3482)
			p.Match(YQLParserWITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3483)
			p.Match(YQLParserUSER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3484)
			p.Role_name()
		}
		p.SetState(3489)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 350, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3485)
					p.Match(YQLParserCOMMA)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(3486)
					p.Role_name()
				}


			}
			p.SetState(3491)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 350, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(3493)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserCOMMA {
			{
				p.SetState(3492)
				p.Match(YQLParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_group_stmtContext is an interface to support dynamic dispatch.
type IAlter_group_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	AllRole_name() []IRole_nameContext
	Role_name(i int) IRole_nameContext
	USER() antlr.TerminalNode
	RENAME() antlr.TerminalNode
	TO() antlr.TerminalNode
	ADD() antlr.TerminalNode
	DROP() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAlter_group_stmtContext differentiates from other interfaces.
	IsAlter_group_stmtContext()
}

type Alter_group_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_group_stmtContext() *Alter_group_stmtContext {
	var p = new(Alter_group_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_group_stmt
	return p
}

func InitEmptyAlter_group_stmtContext(p *Alter_group_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_group_stmt
}

func (*Alter_group_stmtContext) IsAlter_group_stmtContext() {}

func NewAlter_group_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_group_stmtContext {
	var p = new(Alter_group_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_group_stmt

	return p
}

func (s *Alter_group_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_group_stmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(YQLParserALTER, 0)
}

func (s *Alter_group_stmtContext) GROUP() antlr.TerminalNode {
	return s.GetToken(YQLParserGROUP, 0)
}

func (s *Alter_group_stmtContext) AllRole_name() []IRole_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRole_nameContext); ok {
			len++
		}
	}

	tst := make([]IRole_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRole_nameContext); ok {
			tst[i] = t.(IRole_nameContext)
			i++
		}
	}

	return tst
}

func (s *Alter_group_stmtContext) Role_name(i int) IRole_nameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRole_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRole_nameContext)
}

func (s *Alter_group_stmtContext) USER() antlr.TerminalNode {
	return s.GetToken(YQLParserUSER, 0)
}

func (s *Alter_group_stmtContext) RENAME() antlr.TerminalNode {
	return s.GetToken(YQLParserRENAME, 0)
}

func (s *Alter_group_stmtContext) TO() antlr.TerminalNode {
	return s.GetToken(YQLParserTO, 0)
}

func (s *Alter_group_stmtContext) ADD() antlr.TerminalNode {
	return s.GetToken(YQLParserADD, 0)
}

func (s *Alter_group_stmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(YQLParserDROP, 0)
}

func (s *Alter_group_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Alter_group_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Alter_group_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_group_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_group_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_group_stmt(s)
	}
}

func (s *Alter_group_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_group_stmt(s)
	}
}




func (p *YQLParser) Alter_group_stmt() (localctx IAlter_group_stmtContext) {
	localctx = NewAlter_group_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 574, YQLParserRULE_alter_group_stmt)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3497)
		p.Match(YQLParserALTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3498)
		p.Match(YQLParserGROUP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3499)
		p.Role_name()
	}
	p.SetState(3516)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserADD, YQLParserDROP:
		{
			p.SetState(3500)
			_la = p.GetTokenStream().LA(1)

			if !(_la == YQLParserADD || _la == YQLParserDROP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3501)
			p.Match(YQLParserUSER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3502)
			p.Role_name()
		}
		p.SetState(3507)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 353, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3503)
					p.Match(YQLParserCOMMA)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(3504)
					p.Role_name()
				}


			}
			p.SetState(3509)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 353, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(3511)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserCOMMA {
			{
				p.SetState(3510)
				p.Match(YQLParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}


	case YQLParserRENAME:
		{
			p.SetState(3513)
			p.Match(YQLParserRENAME)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3514)
			p.Match(YQLParserTO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3515)
			p.Role_name()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDrop_role_stmtContext is an interface to support dynamic dispatch.
type IDrop_role_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	AllRole_name() []IRole_nameContext
	Role_name(i int) IRole_nameContext
	USER() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDrop_role_stmtContext differentiates from other interfaces.
	IsDrop_role_stmtContext()
}

type Drop_role_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_role_stmtContext() *Drop_role_stmtContext {
	var p = new(Drop_role_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_drop_role_stmt
	return p
}

func InitEmptyDrop_role_stmtContext(p *Drop_role_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_drop_role_stmt
}

func (*Drop_role_stmtContext) IsDrop_role_stmtContext() {}

func NewDrop_role_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_role_stmtContext {
	var p = new(Drop_role_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_drop_role_stmt

	return p
}

func (s *Drop_role_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_role_stmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(YQLParserDROP, 0)
}

func (s *Drop_role_stmtContext) AllRole_name() []IRole_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRole_nameContext); ok {
			len++
		}
	}

	tst := make([]IRole_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRole_nameContext); ok {
			tst[i] = t.(IRole_nameContext)
			i++
		}
	}

	return tst
}

func (s *Drop_role_stmtContext) Role_name(i int) IRole_nameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRole_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRole_nameContext)
}

func (s *Drop_role_stmtContext) USER() antlr.TerminalNode {
	return s.GetToken(YQLParserUSER, 0)
}

func (s *Drop_role_stmtContext) GROUP() antlr.TerminalNode {
	return s.GetToken(YQLParserGROUP, 0)
}

func (s *Drop_role_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(YQLParserIF, 0)
}

func (s *Drop_role_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(YQLParserEXISTS, 0)
}

func (s *Drop_role_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Drop_role_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Drop_role_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_role_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Drop_role_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterDrop_role_stmt(s)
	}
}

func (s *Drop_role_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitDrop_role_stmt(s)
	}
}




func (p *YQLParser) Drop_role_stmt() (localctx IDrop_role_stmtContext) {
	localctx = NewDrop_role_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 576, YQLParserRULE_drop_role_stmt)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3518)
		p.Match(YQLParserDROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3519)
		_la = p.GetTokenStream().LA(1)

		if !(_la == YQLParserGROUP || _la == YQLParserUSER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3522)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 356, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3520)
			p.Match(YQLParserIF)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3521)
			p.Match(YQLParserEXISTS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(3524)
		p.Role_name()
	}
	p.SetState(3529)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 357, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3525)
				p.Match(YQLParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3526)
				p.Role_name()
			}


		}
		p.SetState(3531)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 357, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(3533)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserCOMMA {
		{
			p.SetState(3532)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRole_nameContext is an interface to support dynamic dispatch.
type IRole_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id_or_type() IAn_id_or_typeContext
	Bind_parameter() IBind_parameterContext

	// IsRole_nameContext differentiates from other interfaces.
	IsRole_nameContext()
}

type Role_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRole_nameContext() *Role_nameContext {
	var p = new(Role_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_role_name
	return p
}

func InitEmptyRole_nameContext(p *Role_nameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_role_name
}

func (*Role_nameContext) IsRole_nameContext() {}

func NewRole_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Role_nameContext {
	var p = new(Role_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_role_name

	return p
}

func (s *Role_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Role_nameContext) An_id_or_type() IAn_id_or_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_or_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_or_typeContext)
}

func (s *Role_nameContext) Bind_parameter() IBind_parameterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *Role_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Role_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Role_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterRole_name(s)
	}
}

func (s *Role_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitRole_name(s)
	}
}




func (p *YQLParser) Role_name() (localctx IRole_nameContext) {
	localctx = NewRole_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 578, YQLParserRULE_role_name)
	p.SetState(3537)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALL, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserANY, YQLParserARRAY, YQLParserAS, YQLParserASC, YQLParserASSUME, YQLParserASYMMETRIC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBETWEEN, YQLParserBITCAST, YQLParserBY, YQLParserCALLABLE, YQLParserCASCADE, YQLParserCASE, YQLParserCAST, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOLUMN, YQLParserCOLUMNS, YQLParserCOMMIT, YQLParserCOMPACT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCUBE, YQLParserCURRENT, YQLParserCURRENT_DATE, YQLParserCURRENT_TIME, YQLParserCURRENT_TIMESTAMP, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDICT, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDISTINCT, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserEMPTY_ACTION, YQLParserENCRYPTED, YQLParserEND, YQLParserENUM, YQLParserERASE, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCEPT, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXISTS, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFLOW, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFROM, YQLParserFULL, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserGROUPS, YQLParserHASH, YQLParserHAVING, YQLParserHOP, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTERSECT, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserJSON_EXISTS, YQLParserJSON_QUERY, YQLParserJSON_VALUE, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLIMIT, YQLParserLIST, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOT, YQLParserNOTNULL, YQLParserNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOPTIONAL, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserPROCESS, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserRANGE, YQLParserREDUCE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESOURCE, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserRETURN, YQLParserRETURNING, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROLLUP, YQLParserROW, YQLParserROWS, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSCHEMA, YQLParserSECONDS, YQLParserSEEK, YQLParserSELECT, YQLParserSEMI, YQLParserSET, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSTREAM, YQLParserSTRUCT, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYMMETRIC, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTAGGED, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTUPLE, YQLParserTYPE, YQLParserUNBOUNDED, YQLParserUNCONDITIONAL, YQLParserUNION, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVARIANT, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWHEN, YQLParserWHERE, YQLParserWINDOW, YQLParserWITH, YQLParserWITHOUT, YQLParserWRAPPER, YQLParserXOR, YQLParserSTRING_VALUE, YQLParserID_PLAIN, YQLParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3535)
			p.An_id_or_type()
		}


	case YQLParserDOLLAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3536)
			p.Bind_parameter()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_user_optionContext is an interface to support dynamic dispatch.
type ICreate_user_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Password_option() IPassword_optionContext
	Login_option() ILogin_optionContext

	// IsCreate_user_optionContext differentiates from other interfaces.
	IsCreate_user_optionContext()
}

type Create_user_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_user_optionContext() *Create_user_optionContext {
	var p = new(Create_user_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_create_user_option
	return p
}

func InitEmptyCreate_user_optionContext(p *Create_user_optionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_create_user_option
}

func (*Create_user_optionContext) IsCreate_user_optionContext() {}

func NewCreate_user_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_user_optionContext {
	var p = new(Create_user_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_create_user_option

	return p
}

func (s *Create_user_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_user_optionContext) Password_option() IPassword_optionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPassword_optionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPassword_optionContext)
}

func (s *Create_user_optionContext) Login_option() ILogin_optionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogin_optionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogin_optionContext)
}

func (s *Create_user_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_user_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_user_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterCreate_user_option(s)
	}
}

func (s *Create_user_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitCreate_user_option(s)
	}
}




func (p *YQLParser) Create_user_option() (localctx ICreate_user_optionContext) {
	localctx = NewCreate_user_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 580, YQLParserRULE_create_user_option)
	p.SetState(3541)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserENCRYPTED, YQLParserPASSWORD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3539)
			p.Password_option()
		}


	case YQLParserLOGIN, YQLParserNOLOGIN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3540)
			p.Login_option()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPassword_optionContext is an interface to support dynamic dispatch.
type IPassword_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PASSWORD() antlr.TerminalNode
	Expr() IExprContext
	ENCRYPTED() antlr.TerminalNode

	// IsPassword_optionContext differentiates from other interfaces.
	IsPassword_optionContext()
}

type Password_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPassword_optionContext() *Password_optionContext {
	var p = new(Password_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_password_option
	return p
}

func InitEmptyPassword_optionContext(p *Password_optionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_password_option
}

func (*Password_optionContext) IsPassword_optionContext() {}

func NewPassword_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Password_optionContext {
	var p = new(Password_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_password_option

	return p
}

func (s *Password_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Password_optionContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(YQLParserPASSWORD, 0)
}

func (s *Password_optionContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Password_optionContext) ENCRYPTED() antlr.TerminalNode {
	return s.GetToken(YQLParserENCRYPTED, 0)
}

func (s *Password_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Password_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Password_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterPassword_option(s)
	}
}

func (s *Password_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitPassword_option(s)
	}
}




func (p *YQLParser) Password_option() (localctx IPassword_optionContext) {
	localctx = NewPassword_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 582, YQLParserRULE_password_option)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3544)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserENCRYPTED {
		{
			p.SetState(3543)
			p.Match(YQLParserENCRYPTED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(3546)
		p.Match(YQLParserPASSWORD)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3547)
		p.Expr()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILogin_optionContext is an interface to support dynamic dispatch.
type ILogin_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOGIN() antlr.TerminalNode
	NOLOGIN() antlr.TerminalNode

	// IsLogin_optionContext differentiates from other interfaces.
	IsLogin_optionContext()
}

type Login_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogin_optionContext() *Login_optionContext {
	var p = new(Login_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_login_option
	return p
}

func InitEmptyLogin_optionContext(p *Login_optionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_login_option
}

func (*Login_optionContext) IsLogin_optionContext() {}

func NewLogin_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Login_optionContext {
	var p = new(Login_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_login_option

	return p
}

func (s *Login_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Login_optionContext) LOGIN() antlr.TerminalNode {
	return s.GetToken(YQLParserLOGIN, 0)
}

func (s *Login_optionContext) NOLOGIN() antlr.TerminalNode {
	return s.GetToken(YQLParserNOLOGIN, 0)
}

func (s *Login_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Login_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Login_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterLogin_option(s)
	}
}

func (s *Login_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitLogin_option(s)
	}
}




func (p *YQLParser) Login_option() (localctx ILogin_optionContext) {
	localctx = NewLogin_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 584, YQLParserRULE_login_option)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3549)
		_la = p.GetTokenStream().LA(1)

		if !(_la == YQLParserLOGIN || _la == YQLParserNOLOGIN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGrant_permissions_stmtContext is an interface to support dynamic dispatch.
type IGrant_permissions_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllGRANT() []antlr.TerminalNode
	GRANT(i int) antlr.TerminalNode
	Permission_name_target() IPermission_name_targetContext
	ON() antlr.TerminalNode
	AllAn_id_schema() []IAn_id_schemaContext
	An_id_schema(i int) IAn_id_schemaContext
	TO() antlr.TerminalNode
	AllRole_name() []IRole_nameContext
	Role_name(i int) IRole_nameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	WITH() antlr.TerminalNode
	OPTION() antlr.TerminalNode

	// IsGrant_permissions_stmtContext differentiates from other interfaces.
	IsGrant_permissions_stmtContext()
}

type Grant_permissions_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrant_permissions_stmtContext() *Grant_permissions_stmtContext {
	var p = new(Grant_permissions_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_grant_permissions_stmt
	return p
}

func InitEmptyGrant_permissions_stmtContext(p *Grant_permissions_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_grant_permissions_stmt
}

func (*Grant_permissions_stmtContext) IsGrant_permissions_stmtContext() {}

func NewGrant_permissions_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Grant_permissions_stmtContext {
	var p = new(Grant_permissions_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_grant_permissions_stmt

	return p
}

func (s *Grant_permissions_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Grant_permissions_stmtContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(YQLParserGRANT)
}

func (s *Grant_permissions_stmtContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserGRANT, i)
}

func (s *Grant_permissions_stmtContext) Permission_name_target() IPermission_name_targetContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPermission_name_targetContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPermission_name_targetContext)
}

func (s *Grant_permissions_stmtContext) ON() antlr.TerminalNode {
	return s.GetToken(YQLParserON, 0)
}

func (s *Grant_permissions_stmtContext) AllAn_id_schema() []IAn_id_schemaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAn_id_schemaContext); ok {
			len++
		}
	}

	tst := make([]IAn_id_schemaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAn_id_schemaContext); ok {
			tst[i] = t.(IAn_id_schemaContext)
			i++
		}
	}

	return tst
}

func (s *Grant_permissions_stmtContext) An_id_schema(i int) IAn_id_schemaContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_schemaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_schemaContext)
}

func (s *Grant_permissions_stmtContext) TO() antlr.TerminalNode {
	return s.GetToken(YQLParserTO, 0)
}

func (s *Grant_permissions_stmtContext) AllRole_name() []IRole_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRole_nameContext); ok {
			len++
		}
	}

	tst := make([]IRole_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRole_nameContext); ok {
			tst[i] = t.(IRole_nameContext)
			i++
		}
	}

	return tst
}

func (s *Grant_permissions_stmtContext) Role_name(i int) IRole_nameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRole_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRole_nameContext)
}

func (s *Grant_permissions_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Grant_permissions_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Grant_permissions_stmtContext) WITH() antlr.TerminalNode {
	return s.GetToken(YQLParserWITH, 0)
}

func (s *Grant_permissions_stmtContext) OPTION() antlr.TerminalNode {
	return s.GetToken(YQLParserOPTION, 0)
}

func (s *Grant_permissions_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Grant_permissions_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Grant_permissions_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterGrant_permissions_stmt(s)
	}
}

func (s *Grant_permissions_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitGrant_permissions_stmt(s)
	}
}




func (p *YQLParser) Grant_permissions_stmt() (localctx IGrant_permissions_stmtContext) {
	localctx = NewGrant_permissions_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 586, YQLParserRULE_grant_permissions_stmt)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3551)
		p.Match(YQLParserGRANT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3552)
		p.Permission_name_target()
	}
	{
		p.SetState(3553)
		p.Match(YQLParserON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3554)
		p.An_id_schema()
	}
	p.SetState(3559)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(3555)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3556)
			p.An_id_schema()
		}


		p.SetState(3561)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3562)
		p.Match(YQLParserTO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3563)
		p.Role_name()
	}
	p.SetState(3568)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 363, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3564)
				p.Match(YQLParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3565)
				p.Role_name()
			}


		}
		p.SetState(3570)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 363, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(3572)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserCOMMA {
		{
			p.SetState(3571)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(3577)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserWITH {
		{
			p.SetState(3574)
			p.Match(YQLParserWITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3575)
			p.Match(YQLParserGRANT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3576)
			p.Match(YQLParserOPTION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRevoke_permissions_stmtContext is an interface to support dynamic dispatch.
type IRevoke_permissions_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REVOKE() antlr.TerminalNode
	Permission_name_target() IPermission_name_targetContext
	ON() antlr.TerminalNode
	AllAn_id_schema() []IAn_id_schemaContext
	An_id_schema(i int) IAn_id_schemaContext
	FROM() antlr.TerminalNode
	AllRole_name() []IRole_nameContext
	Role_name(i int) IRole_nameContext
	GRANT() antlr.TerminalNode
	OPTION() antlr.TerminalNode
	FOR() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRevoke_permissions_stmtContext differentiates from other interfaces.
	IsRevoke_permissions_stmtContext()
}

type Revoke_permissions_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRevoke_permissions_stmtContext() *Revoke_permissions_stmtContext {
	var p = new(Revoke_permissions_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_revoke_permissions_stmt
	return p
}

func InitEmptyRevoke_permissions_stmtContext(p *Revoke_permissions_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_revoke_permissions_stmt
}

func (*Revoke_permissions_stmtContext) IsRevoke_permissions_stmtContext() {}

func NewRevoke_permissions_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Revoke_permissions_stmtContext {
	var p = new(Revoke_permissions_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_revoke_permissions_stmt

	return p
}

func (s *Revoke_permissions_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Revoke_permissions_stmtContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(YQLParserREVOKE, 0)
}

func (s *Revoke_permissions_stmtContext) Permission_name_target() IPermission_name_targetContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPermission_name_targetContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPermission_name_targetContext)
}

func (s *Revoke_permissions_stmtContext) ON() antlr.TerminalNode {
	return s.GetToken(YQLParserON, 0)
}

func (s *Revoke_permissions_stmtContext) AllAn_id_schema() []IAn_id_schemaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAn_id_schemaContext); ok {
			len++
		}
	}

	tst := make([]IAn_id_schemaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAn_id_schemaContext); ok {
			tst[i] = t.(IAn_id_schemaContext)
			i++
		}
	}

	return tst
}

func (s *Revoke_permissions_stmtContext) An_id_schema(i int) IAn_id_schemaContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_schemaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_schemaContext)
}

func (s *Revoke_permissions_stmtContext) FROM() antlr.TerminalNode {
	return s.GetToken(YQLParserFROM, 0)
}

func (s *Revoke_permissions_stmtContext) AllRole_name() []IRole_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRole_nameContext); ok {
			len++
		}
	}

	tst := make([]IRole_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRole_nameContext); ok {
			tst[i] = t.(IRole_nameContext)
			i++
		}
	}

	return tst
}

func (s *Revoke_permissions_stmtContext) Role_name(i int) IRole_nameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRole_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRole_nameContext)
}

func (s *Revoke_permissions_stmtContext) GRANT() antlr.TerminalNode {
	return s.GetToken(YQLParserGRANT, 0)
}

func (s *Revoke_permissions_stmtContext) OPTION() antlr.TerminalNode {
	return s.GetToken(YQLParserOPTION, 0)
}

func (s *Revoke_permissions_stmtContext) FOR() antlr.TerminalNode {
	return s.GetToken(YQLParserFOR, 0)
}

func (s *Revoke_permissions_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Revoke_permissions_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Revoke_permissions_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Revoke_permissions_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Revoke_permissions_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterRevoke_permissions_stmt(s)
	}
}

func (s *Revoke_permissions_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitRevoke_permissions_stmt(s)
	}
}




func (p *YQLParser) Revoke_permissions_stmt() (localctx IRevoke_permissions_stmtContext) {
	localctx = NewRevoke_permissions_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 588, YQLParserRULE_revoke_permissions_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3579)
		p.Match(YQLParserREVOKE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3583)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 366, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3580)
			p.Match(YQLParserGRANT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3581)
			p.Match(YQLParserOPTION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3582)
			p.Match(YQLParserFOR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(3585)
		p.Permission_name_target()
	}
	{
		p.SetState(3586)
		p.Match(YQLParserON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3587)
		p.An_id_schema()
	}
	p.SetState(3592)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(3588)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3589)
			p.An_id_schema()
		}


		p.SetState(3594)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3595)
		p.Match(YQLParserFROM)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3596)
		p.Role_name()
	}
	p.SetState(3601)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(3597)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3598)
			p.Role_name()
		}


		p.SetState(3603)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPermission_idContext is an interface to support dynamic dispatch.
type IPermission_idContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONNECT() antlr.TerminalNode
	LIST() antlr.TerminalNode
	INSERT() antlr.TerminalNode
	MANAGE() antlr.TerminalNode
	DROP() antlr.TerminalNode
	GRANT() antlr.TerminalNode
	MODIFY() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	ATTRIBUTES() antlr.TerminalNode
	ROW() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	ERASE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	REMOVE() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode
	ALTER() antlr.TerminalNode
	SELECT() antlr.TerminalNode
	USE() antlr.TerminalNode
	FULL() antlr.TerminalNode
	LEGACY() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	DIRECTORY() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QUEUE() antlr.TerminalNode

	// IsPermission_idContext differentiates from other interfaces.
	IsPermission_idContext()
}

type Permission_idContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPermission_idContext() *Permission_idContext {
	var p = new(Permission_idContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_permission_id
	return p
}

func InitEmptyPermission_idContext(p *Permission_idContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_permission_id
}

func (*Permission_idContext) IsPermission_idContext() {}

func NewPermission_idContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Permission_idContext {
	var p = new(Permission_idContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_permission_id

	return p
}

func (s *Permission_idContext) GetParser() antlr.Parser { return s.parser }

func (s *Permission_idContext) CONNECT() antlr.TerminalNode {
	return s.GetToken(YQLParserCONNECT, 0)
}

func (s *Permission_idContext) LIST() antlr.TerminalNode {
	return s.GetToken(YQLParserLIST, 0)
}

func (s *Permission_idContext) INSERT() antlr.TerminalNode {
	return s.GetToken(YQLParserINSERT, 0)
}

func (s *Permission_idContext) MANAGE() antlr.TerminalNode {
	return s.GetToken(YQLParserMANAGE, 0)
}

func (s *Permission_idContext) DROP() antlr.TerminalNode {
	return s.GetToken(YQLParserDROP, 0)
}

func (s *Permission_idContext) GRANT() antlr.TerminalNode {
	return s.GetToken(YQLParserGRANT, 0)
}

func (s *Permission_idContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(YQLParserMODIFY, 0)
}

func (s *Permission_idContext) TABLES() antlr.TerminalNode {
	return s.GetToken(YQLParserTABLES, 0)
}

func (s *Permission_idContext) ATTRIBUTES() antlr.TerminalNode {
	return s.GetToken(YQLParserATTRIBUTES, 0)
}

func (s *Permission_idContext) ROW() antlr.TerminalNode {
	return s.GetToken(YQLParserROW, 0)
}

func (s *Permission_idContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(YQLParserUPDATE, 0)
}

func (s *Permission_idContext) ERASE() antlr.TerminalNode {
	return s.GetToken(YQLParserERASE, 0)
}

func (s *Permission_idContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(YQLParserSCHEMA, 0)
}

func (s *Permission_idContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(YQLParserREMOVE, 0)
}

func (s *Permission_idContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(YQLParserDESCRIBE, 0)
}

func (s *Permission_idContext) ALTER() antlr.TerminalNode {
	return s.GetToken(YQLParserALTER, 0)
}

func (s *Permission_idContext) SELECT() antlr.TerminalNode {
	return s.GetToken(YQLParserSELECT, 0)
}

func (s *Permission_idContext) USE() antlr.TerminalNode {
	return s.GetToken(YQLParserUSE, 0)
}

func (s *Permission_idContext) FULL() antlr.TerminalNode {
	return s.GetToken(YQLParserFULL, 0)
}

func (s *Permission_idContext) LEGACY() antlr.TerminalNode {
	return s.GetToken(YQLParserLEGACY, 0)
}

func (s *Permission_idContext) CREATE() antlr.TerminalNode {
	return s.GetToken(YQLParserCREATE, 0)
}

func (s *Permission_idContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(YQLParserDIRECTORY, 0)
}

func (s *Permission_idContext) TABLE() antlr.TerminalNode {
	return s.GetToken(YQLParserTABLE, 0)
}

func (s *Permission_idContext) QUEUE() antlr.TerminalNode {
	return s.GetToken(YQLParserQUEUE, 0)
}

func (s *Permission_idContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Permission_idContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Permission_idContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterPermission_id(s)
	}
}

func (s *Permission_idContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitPermission_id(s)
	}
}




func (p *YQLParser) Permission_id() (localctx IPermission_idContext) {
	localctx = NewPermission_idContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 590, YQLParserRULE_permission_id)
	var _la int

	p.SetState(3628)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserCONNECT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3604)
			p.Match(YQLParserCONNECT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserLIST:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3605)
			p.Match(YQLParserLIST)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserINSERT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3606)
			p.Match(YQLParserINSERT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserMANAGE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3607)
			p.Match(YQLParserMANAGE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserDROP:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3608)
			p.Match(YQLParserDROP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserGRANT:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3609)
			p.Match(YQLParserGRANT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserMODIFY:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3610)
			p.Match(YQLParserMODIFY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3611)
			_la = p.GetTokenStream().LA(1)

			if !(_la == YQLParserATTRIBUTES || _la == YQLParserTABLES) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case YQLParserERASE, YQLParserUPDATE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3612)
			_la = p.GetTokenStream().LA(1)

			if !(_la == YQLParserERASE || _la == YQLParserUPDATE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3613)
			p.Match(YQLParserROW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserALTER, YQLParserDESCRIBE, YQLParserREMOVE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3614)
			_la = p.GetTokenStream().LA(1)

			if !(_la == YQLParserALTER || _la == YQLParserDESCRIBE || _la == YQLParserREMOVE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3615)
			p.Match(YQLParserSCHEMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserSELECT:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3616)
			p.Match(YQLParserSELECT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3618)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserATTRIBUTES || _la == YQLParserROW || _la == YQLParserTABLES {
			{
				p.SetState(3617)
				_la = p.GetTokenStream().LA(1)

				if !(_la == YQLParserATTRIBUTES || _la == YQLParserROW || _la == YQLParserTABLES) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}


	case YQLParserFULL, YQLParserUSE:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3620)
			_la = p.GetTokenStream().LA(1)

			if !(_la == YQLParserFULL || _la == YQLParserUSE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(3622)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserLEGACY {
			{
				p.SetState(3621)
				p.Match(YQLParserLEGACY)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}


	case YQLParserCREATE:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(3624)
			p.Match(YQLParserCREATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3626)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserDIRECTORY || _la == YQLParserQUEUE || _la == YQLParserTABLE {
			{
				p.SetState(3625)
				_la = p.GetTokenStream().LA(1)

				if !(_la == YQLParserDIRECTORY || _la == YQLParserQUEUE || _la == YQLParserTABLE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPermission_nameContext is an interface to support dynamic dispatch.
type IPermission_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Permission_id() IPermission_idContext
	STRING_VALUE() antlr.TerminalNode

	// IsPermission_nameContext differentiates from other interfaces.
	IsPermission_nameContext()
}

type Permission_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPermission_nameContext() *Permission_nameContext {
	var p = new(Permission_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_permission_name
	return p
}

func InitEmptyPermission_nameContext(p *Permission_nameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_permission_name
}

func (*Permission_nameContext) IsPermission_nameContext() {}

func NewPermission_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Permission_nameContext {
	var p = new(Permission_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_permission_name

	return p
}

func (s *Permission_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Permission_nameContext) Permission_id() IPermission_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPermission_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPermission_idContext)
}

func (s *Permission_nameContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(YQLParserSTRING_VALUE, 0)
}

func (s *Permission_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Permission_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Permission_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterPermission_name(s)
	}
}

func (s *Permission_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitPermission_name(s)
	}
}




func (p *YQLParser) Permission_name() (localctx IPermission_nameContext) {
	localctx = NewPermission_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 592, YQLParserRULE_permission_name)
	p.SetState(3632)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserALTER, YQLParserCONNECT, YQLParserCREATE, YQLParserDESCRIBE, YQLParserDROP, YQLParserERASE, YQLParserFULL, YQLParserGRANT, YQLParserINSERT, YQLParserLIST, YQLParserMANAGE, YQLParserMODIFY, YQLParserREMOVE, YQLParserSELECT, YQLParserUPDATE, YQLParserUSE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3630)
			p.Permission_id()
		}


	case YQLParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3631)
			p.Match(YQLParserSTRING_VALUE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPermission_name_targetContext is an interface to support dynamic dispatch.
type IPermission_name_targetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPermission_name() []IPermission_nameContext
	Permission_name(i int) IPermission_nameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	ALL() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode

	// IsPermission_name_targetContext differentiates from other interfaces.
	IsPermission_name_targetContext()
}

type Permission_name_targetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPermission_name_targetContext() *Permission_name_targetContext {
	var p = new(Permission_name_targetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_permission_name_target
	return p
}

func InitEmptyPermission_name_targetContext(p *Permission_name_targetContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_permission_name_target
}

func (*Permission_name_targetContext) IsPermission_name_targetContext() {}

func NewPermission_name_targetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Permission_name_targetContext {
	var p = new(Permission_name_targetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_permission_name_target

	return p
}

func (s *Permission_name_targetContext) GetParser() antlr.Parser { return s.parser }

func (s *Permission_name_targetContext) AllPermission_name() []IPermission_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPermission_nameContext); ok {
			len++
		}
	}

	tst := make([]IPermission_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPermission_nameContext); ok {
			tst[i] = t.(IPermission_nameContext)
			i++
		}
	}

	return tst
}

func (s *Permission_name_targetContext) Permission_name(i int) IPermission_nameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPermission_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPermission_nameContext)
}

func (s *Permission_name_targetContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Permission_name_targetContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Permission_name_targetContext) ALL() antlr.TerminalNode {
	return s.GetToken(YQLParserALL, 0)
}

func (s *Permission_name_targetContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(YQLParserPRIVILEGES, 0)
}

func (s *Permission_name_targetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Permission_name_targetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Permission_name_targetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterPermission_name_target(s)
	}
}

func (s *Permission_name_targetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitPermission_name_target(s)
	}
}




func (p *YQLParser) Permission_name_target() (localctx IPermission_name_targetContext) {
	localctx = NewPermission_name_targetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 594, YQLParserRULE_permission_name_target)
	var _la int

	var _alt int

	p.SetState(3649)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserALTER, YQLParserCONNECT, YQLParserCREATE, YQLParserDESCRIBE, YQLParserDROP, YQLParserERASE, YQLParserFULL, YQLParserGRANT, YQLParserINSERT, YQLParserLIST, YQLParserMANAGE, YQLParserMODIFY, YQLParserREMOVE, YQLParserSELECT, YQLParserUPDATE, YQLParserUSE, YQLParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3634)
			p.Permission_name()
		}
		p.SetState(3639)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 374, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3635)
					p.Match(YQLParserCOMMA)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(3636)
					p.Permission_name()
				}


			}
			p.SetState(3641)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 374, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(3643)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserCOMMA {
			{
				p.SetState(3642)
				p.Match(YQLParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}


	case YQLParserALL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3645)
			p.Match(YQLParserALL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3647)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserPRIVILEGES {
			{
				p.SetState(3646)
				p.Match(YQLParserPRIVILEGES)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_resource_pool_stmtContext is an interface to support dynamic dispatch.
type ICreate_resource_pool_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	POOL() antlr.TerminalNode
	Object_ref() IObject_refContext
	With_table_settings() IWith_table_settingsContext

	// IsCreate_resource_pool_stmtContext differentiates from other interfaces.
	IsCreate_resource_pool_stmtContext()
}

type Create_resource_pool_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_resource_pool_stmtContext() *Create_resource_pool_stmtContext {
	var p = new(Create_resource_pool_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_create_resource_pool_stmt
	return p
}

func InitEmptyCreate_resource_pool_stmtContext(p *Create_resource_pool_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_create_resource_pool_stmt
}

func (*Create_resource_pool_stmtContext) IsCreate_resource_pool_stmtContext() {}

func NewCreate_resource_pool_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_resource_pool_stmtContext {
	var p = new(Create_resource_pool_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_create_resource_pool_stmt

	return p
}

func (s *Create_resource_pool_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_resource_pool_stmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(YQLParserCREATE, 0)
}

func (s *Create_resource_pool_stmtContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(YQLParserRESOURCE, 0)
}

func (s *Create_resource_pool_stmtContext) POOL() antlr.TerminalNode {
	return s.GetToken(YQLParserPOOL, 0)
}

func (s *Create_resource_pool_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Create_resource_pool_stmtContext) With_table_settings() IWith_table_settingsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWith_table_settingsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWith_table_settingsContext)
}

func (s *Create_resource_pool_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_resource_pool_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_resource_pool_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterCreate_resource_pool_stmt(s)
	}
}

func (s *Create_resource_pool_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitCreate_resource_pool_stmt(s)
	}
}




func (p *YQLParser) Create_resource_pool_stmt() (localctx ICreate_resource_pool_stmtContext) {
	localctx = NewCreate_resource_pool_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 596, YQLParserRULE_create_resource_pool_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3651)
		p.Match(YQLParserCREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3652)
		p.Match(YQLParserRESOURCE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3653)
		p.Match(YQLParserPOOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3654)
		p.Object_ref()
	}
	{
		p.SetState(3655)
		p.With_table_settings()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_resource_pool_stmtContext is an interface to support dynamic dispatch.
type IAlter_resource_pool_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	POOL() antlr.TerminalNode
	Object_ref() IObject_refContext
	AllAlter_resource_pool_action() []IAlter_resource_pool_actionContext
	Alter_resource_pool_action(i int) IAlter_resource_pool_actionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAlter_resource_pool_stmtContext differentiates from other interfaces.
	IsAlter_resource_pool_stmtContext()
}

type Alter_resource_pool_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_resource_pool_stmtContext() *Alter_resource_pool_stmtContext {
	var p = new(Alter_resource_pool_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_resource_pool_stmt
	return p
}

func InitEmptyAlter_resource_pool_stmtContext(p *Alter_resource_pool_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_resource_pool_stmt
}

func (*Alter_resource_pool_stmtContext) IsAlter_resource_pool_stmtContext() {}

func NewAlter_resource_pool_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_resource_pool_stmtContext {
	var p = new(Alter_resource_pool_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_resource_pool_stmt

	return p
}

func (s *Alter_resource_pool_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_resource_pool_stmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(YQLParserALTER, 0)
}

func (s *Alter_resource_pool_stmtContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(YQLParserRESOURCE, 0)
}

func (s *Alter_resource_pool_stmtContext) POOL() antlr.TerminalNode {
	return s.GetToken(YQLParserPOOL, 0)
}

func (s *Alter_resource_pool_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Alter_resource_pool_stmtContext) AllAlter_resource_pool_action() []IAlter_resource_pool_actionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlter_resource_pool_actionContext); ok {
			len++
		}
	}

	tst := make([]IAlter_resource_pool_actionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlter_resource_pool_actionContext); ok {
			tst[i] = t.(IAlter_resource_pool_actionContext)
			i++
		}
	}

	return tst
}

func (s *Alter_resource_pool_stmtContext) Alter_resource_pool_action(i int) IAlter_resource_pool_actionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_resource_pool_actionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_resource_pool_actionContext)
}

func (s *Alter_resource_pool_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Alter_resource_pool_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Alter_resource_pool_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_resource_pool_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_resource_pool_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_resource_pool_stmt(s)
	}
}

func (s *Alter_resource_pool_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_resource_pool_stmt(s)
	}
}




func (p *YQLParser) Alter_resource_pool_stmt() (localctx IAlter_resource_pool_stmtContext) {
	localctx = NewAlter_resource_pool_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 598, YQLParserRULE_alter_resource_pool_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3657)
		p.Match(YQLParserALTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3658)
		p.Match(YQLParserRESOURCE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3659)
		p.Match(YQLParserPOOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3660)
		p.Object_ref()
	}
	{
		p.SetState(3661)
		p.Alter_resource_pool_action()
	}
	p.SetState(3666)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(3662)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3663)
			p.Alter_resource_pool_action()
		}


		p.SetState(3668)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_resource_pool_actionContext is an interface to support dynamic dispatch.
type IAlter_resource_pool_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Alter_table_set_table_setting_compat() IAlter_table_set_table_setting_compatContext
	Alter_table_reset_table_setting() IAlter_table_reset_table_settingContext

	// IsAlter_resource_pool_actionContext differentiates from other interfaces.
	IsAlter_resource_pool_actionContext()
}

type Alter_resource_pool_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_resource_pool_actionContext() *Alter_resource_pool_actionContext {
	var p = new(Alter_resource_pool_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_resource_pool_action
	return p
}

func InitEmptyAlter_resource_pool_actionContext(p *Alter_resource_pool_actionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_resource_pool_action
}

func (*Alter_resource_pool_actionContext) IsAlter_resource_pool_actionContext() {}

func NewAlter_resource_pool_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_resource_pool_actionContext {
	var p = new(Alter_resource_pool_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_resource_pool_action

	return p
}

func (s *Alter_resource_pool_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_resource_pool_actionContext) Alter_table_set_table_setting_compat() IAlter_table_set_table_setting_compatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_set_table_setting_compatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_set_table_setting_compatContext)
}

func (s *Alter_resource_pool_actionContext) Alter_table_reset_table_setting() IAlter_table_reset_table_settingContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_reset_table_settingContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_reset_table_settingContext)
}

func (s *Alter_resource_pool_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_resource_pool_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_resource_pool_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_resource_pool_action(s)
	}
}

func (s *Alter_resource_pool_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_resource_pool_action(s)
	}
}




func (p *YQLParser) Alter_resource_pool_action() (localctx IAlter_resource_pool_actionContext) {
	localctx = NewAlter_resource_pool_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 600, YQLParserRULE_alter_resource_pool_action)
	p.SetState(3671)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserSET:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3669)
			p.Alter_table_set_table_setting_compat()
		}


	case YQLParserRESET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3670)
			p.Alter_table_reset_table_setting()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDrop_resource_pool_stmtContext is an interface to support dynamic dispatch.
type IDrop_resource_pool_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	POOL() antlr.TerminalNode
	Object_ref() IObject_refContext

	// IsDrop_resource_pool_stmtContext differentiates from other interfaces.
	IsDrop_resource_pool_stmtContext()
}

type Drop_resource_pool_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_resource_pool_stmtContext() *Drop_resource_pool_stmtContext {
	var p = new(Drop_resource_pool_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_drop_resource_pool_stmt
	return p
}

func InitEmptyDrop_resource_pool_stmtContext(p *Drop_resource_pool_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_drop_resource_pool_stmt
}

func (*Drop_resource_pool_stmtContext) IsDrop_resource_pool_stmtContext() {}

func NewDrop_resource_pool_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_resource_pool_stmtContext {
	var p = new(Drop_resource_pool_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_drop_resource_pool_stmt

	return p
}

func (s *Drop_resource_pool_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_resource_pool_stmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(YQLParserDROP, 0)
}

func (s *Drop_resource_pool_stmtContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(YQLParserRESOURCE, 0)
}

func (s *Drop_resource_pool_stmtContext) POOL() antlr.TerminalNode {
	return s.GetToken(YQLParserPOOL, 0)
}

func (s *Drop_resource_pool_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Drop_resource_pool_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_resource_pool_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Drop_resource_pool_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterDrop_resource_pool_stmt(s)
	}
}

func (s *Drop_resource_pool_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitDrop_resource_pool_stmt(s)
	}
}




func (p *YQLParser) Drop_resource_pool_stmt() (localctx IDrop_resource_pool_stmtContext) {
	localctx = NewDrop_resource_pool_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 602, YQLParserRULE_drop_resource_pool_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3673)
		p.Match(YQLParserDROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3674)
		p.Match(YQLParserRESOURCE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3675)
		p.Match(YQLParserPOOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3676)
		p.Object_ref()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_resource_pool_classifier_stmtContext is an interface to support dynamic dispatch.
type ICreate_resource_pool_classifier_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	POOL() antlr.TerminalNode
	CLASSIFIER() antlr.TerminalNode
	Object_ref() IObject_refContext
	With_table_settings() IWith_table_settingsContext

	// IsCreate_resource_pool_classifier_stmtContext differentiates from other interfaces.
	IsCreate_resource_pool_classifier_stmtContext()
}

type Create_resource_pool_classifier_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_resource_pool_classifier_stmtContext() *Create_resource_pool_classifier_stmtContext {
	var p = new(Create_resource_pool_classifier_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_create_resource_pool_classifier_stmt
	return p
}

func InitEmptyCreate_resource_pool_classifier_stmtContext(p *Create_resource_pool_classifier_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_create_resource_pool_classifier_stmt
}

func (*Create_resource_pool_classifier_stmtContext) IsCreate_resource_pool_classifier_stmtContext() {}

func NewCreate_resource_pool_classifier_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_resource_pool_classifier_stmtContext {
	var p = new(Create_resource_pool_classifier_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_create_resource_pool_classifier_stmt

	return p
}

func (s *Create_resource_pool_classifier_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_resource_pool_classifier_stmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(YQLParserCREATE, 0)
}

func (s *Create_resource_pool_classifier_stmtContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(YQLParserRESOURCE, 0)
}

func (s *Create_resource_pool_classifier_stmtContext) POOL() antlr.TerminalNode {
	return s.GetToken(YQLParserPOOL, 0)
}

func (s *Create_resource_pool_classifier_stmtContext) CLASSIFIER() antlr.TerminalNode {
	return s.GetToken(YQLParserCLASSIFIER, 0)
}

func (s *Create_resource_pool_classifier_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Create_resource_pool_classifier_stmtContext) With_table_settings() IWith_table_settingsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWith_table_settingsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWith_table_settingsContext)
}

func (s *Create_resource_pool_classifier_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_resource_pool_classifier_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_resource_pool_classifier_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterCreate_resource_pool_classifier_stmt(s)
	}
}

func (s *Create_resource_pool_classifier_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitCreate_resource_pool_classifier_stmt(s)
	}
}




func (p *YQLParser) Create_resource_pool_classifier_stmt() (localctx ICreate_resource_pool_classifier_stmtContext) {
	localctx = NewCreate_resource_pool_classifier_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 604, YQLParserRULE_create_resource_pool_classifier_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3678)
		p.Match(YQLParserCREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3679)
		p.Match(YQLParserRESOURCE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3680)
		p.Match(YQLParserPOOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3681)
		p.Match(YQLParserCLASSIFIER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3682)
		p.Object_ref()
	}
	{
		p.SetState(3683)
		p.With_table_settings()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_resource_pool_classifier_stmtContext is an interface to support dynamic dispatch.
type IAlter_resource_pool_classifier_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	POOL() antlr.TerminalNode
	CLASSIFIER() antlr.TerminalNode
	Object_ref() IObject_refContext
	AllAlter_resource_pool_classifier_action() []IAlter_resource_pool_classifier_actionContext
	Alter_resource_pool_classifier_action(i int) IAlter_resource_pool_classifier_actionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAlter_resource_pool_classifier_stmtContext differentiates from other interfaces.
	IsAlter_resource_pool_classifier_stmtContext()
}

type Alter_resource_pool_classifier_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_resource_pool_classifier_stmtContext() *Alter_resource_pool_classifier_stmtContext {
	var p = new(Alter_resource_pool_classifier_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_resource_pool_classifier_stmt
	return p
}

func InitEmptyAlter_resource_pool_classifier_stmtContext(p *Alter_resource_pool_classifier_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_resource_pool_classifier_stmt
}

func (*Alter_resource_pool_classifier_stmtContext) IsAlter_resource_pool_classifier_stmtContext() {}

func NewAlter_resource_pool_classifier_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_resource_pool_classifier_stmtContext {
	var p = new(Alter_resource_pool_classifier_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_resource_pool_classifier_stmt

	return p
}

func (s *Alter_resource_pool_classifier_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_resource_pool_classifier_stmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(YQLParserALTER, 0)
}

func (s *Alter_resource_pool_classifier_stmtContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(YQLParserRESOURCE, 0)
}

func (s *Alter_resource_pool_classifier_stmtContext) POOL() antlr.TerminalNode {
	return s.GetToken(YQLParserPOOL, 0)
}

func (s *Alter_resource_pool_classifier_stmtContext) CLASSIFIER() antlr.TerminalNode {
	return s.GetToken(YQLParserCLASSIFIER, 0)
}

func (s *Alter_resource_pool_classifier_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Alter_resource_pool_classifier_stmtContext) AllAlter_resource_pool_classifier_action() []IAlter_resource_pool_classifier_actionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlter_resource_pool_classifier_actionContext); ok {
			len++
		}
	}

	tst := make([]IAlter_resource_pool_classifier_actionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlter_resource_pool_classifier_actionContext); ok {
			tst[i] = t.(IAlter_resource_pool_classifier_actionContext)
			i++
		}
	}

	return tst
}

func (s *Alter_resource_pool_classifier_stmtContext) Alter_resource_pool_classifier_action(i int) IAlter_resource_pool_classifier_actionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_resource_pool_classifier_actionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_resource_pool_classifier_actionContext)
}

func (s *Alter_resource_pool_classifier_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Alter_resource_pool_classifier_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Alter_resource_pool_classifier_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_resource_pool_classifier_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_resource_pool_classifier_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_resource_pool_classifier_stmt(s)
	}
}

func (s *Alter_resource_pool_classifier_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_resource_pool_classifier_stmt(s)
	}
}




func (p *YQLParser) Alter_resource_pool_classifier_stmt() (localctx IAlter_resource_pool_classifier_stmtContext) {
	localctx = NewAlter_resource_pool_classifier_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 606, YQLParserRULE_alter_resource_pool_classifier_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3685)
		p.Match(YQLParserALTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3686)
		p.Match(YQLParserRESOURCE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3687)
		p.Match(YQLParserPOOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3688)
		p.Match(YQLParserCLASSIFIER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3689)
		p.Object_ref()
	}
	{
		p.SetState(3690)
		p.Alter_resource_pool_classifier_action()
	}
	p.SetState(3695)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(3691)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3692)
			p.Alter_resource_pool_classifier_action()
		}


		p.SetState(3697)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_resource_pool_classifier_actionContext is an interface to support dynamic dispatch.
type IAlter_resource_pool_classifier_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Alter_table_set_table_setting_compat() IAlter_table_set_table_setting_compatContext
	Alter_table_reset_table_setting() IAlter_table_reset_table_settingContext

	// IsAlter_resource_pool_classifier_actionContext differentiates from other interfaces.
	IsAlter_resource_pool_classifier_actionContext()
}

type Alter_resource_pool_classifier_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_resource_pool_classifier_actionContext() *Alter_resource_pool_classifier_actionContext {
	var p = new(Alter_resource_pool_classifier_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_resource_pool_classifier_action
	return p
}

func InitEmptyAlter_resource_pool_classifier_actionContext(p *Alter_resource_pool_classifier_actionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_resource_pool_classifier_action
}

func (*Alter_resource_pool_classifier_actionContext) IsAlter_resource_pool_classifier_actionContext() {}

func NewAlter_resource_pool_classifier_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_resource_pool_classifier_actionContext {
	var p = new(Alter_resource_pool_classifier_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_resource_pool_classifier_action

	return p
}

func (s *Alter_resource_pool_classifier_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_resource_pool_classifier_actionContext) Alter_table_set_table_setting_compat() IAlter_table_set_table_setting_compatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_set_table_setting_compatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_set_table_setting_compatContext)
}

func (s *Alter_resource_pool_classifier_actionContext) Alter_table_reset_table_setting() IAlter_table_reset_table_settingContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_reset_table_settingContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_reset_table_settingContext)
}

func (s *Alter_resource_pool_classifier_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_resource_pool_classifier_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_resource_pool_classifier_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_resource_pool_classifier_action(s)
	}
}

func (s *Alter_resource_pool_classifier_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_resource_pool_classifier_action(s)
	}
}




func (p *YQLParser) Alter_resource_pool_classifier_action() (localctx IAlter_resource_pool_classifier_actionContext) {
	localctx = NewAlter_resource_pool_classifier_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 608, YQLParserRULE_alter_resource_pool_classifier_action)
	p.SetState(3700)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserSET:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3698)
			p.Alter_table_set_table_setting_compat()
		}


	case YQLParserRESET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3699)
			p.Alter_table_reset_table_setting()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDrop_resource_pool_classifier_stmtContext is an interface to support dynamic dispatch.
type IDrop_resource_pool_classifier_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	POOL() antlr.TerminalNode
	CLASSIFIER() antlr.TerminalNode
	Object_ref() IObject_refContext

	// IsDrop_resource_pool_classifier_stmtContext differentiates from other interfaces.
	IsDrop_resource_pool_classifier_stmtContext()
}

type Drop_resource_pool_classifier_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_resource_pool_classifier_stmtContext() *Drop_resource_pool_classifier_stmtContext {
	var p = new(Drop_resource_pool_classifier_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_drop_resource_pool_classifier_stmt
	return p
}

func InitEmptyDrop_resource_pool_classifier_stmtContext(p *Drop_resource_pool_classifier_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_drop_resource_pool_classifier_stmt
}

func (*Drop_resource_pool_classifier_stmtContext) IsDrop_resource_pool_classifier_stmtContext() {}

func NewDrop_resource_pool_classifier_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_resource_pool_classifier_stmtContext {
	var p = new(Drop_resource_pool_classifier_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_drop_resource_pool_classifier_stmt

	return p
}

func (s *Drop_resource_pool_classifier_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_resource_pool_classifier_stmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(YQLParserDROP, 0)
}

func (s *Drop_resource_pool_classifier_stmtContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(YQLParserRESOURCE, 0)
}

func (s *Drop_resource_pool_classifier_stmtContext) POOL() antlr.TerminalNode {
	return s.GetToken(YQLParserPOOL, 0)
}

func (s *Drop_resource_pool_classifier_stmtContext) CLASSIFIER() antlr.TerminalNode {
	return s.GetToken(YQLParserCLASSIFIER, 0)
}

func (s *Drop_resource_pool_classifier_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Drop_resource_pool_classifier_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_resource_pool_classifier_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Drop_resource_pool_classifier_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterDrop_resource_pool_classifier_stmt(s)
	}
}

func (s *Drop_resource_pool_classifier_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitDrop_resource_pool_classifier_stmt(s)
	}
}




func (p *YQLParser) Drop_resource_pool_classifier_stmt() (localctx IDrop_resource_pool_classifier_stmtContext) {
	localctx = NewDrop_resource_pool_classifier_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 610, YQLParserRULE_drop_resource_pool_classifier_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3702)
		p.Match(YQLParserDROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3703)
		p.Match(YQLParserRESOURCE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3704)
		p.Match(YQLParserPOOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3705)
		p.Match(YQLParserCLASSIFIER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3706)
		p.Object_ref()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_replication_stmtContext is an interface to support dynamic dispatch.
type ICreate_replication_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	ASYNC() antlr.TerminalNode
	REPLICATION() antlr.TerminalNode
	Object_ref() IObject_refContext
	FOR() antlr.TerminalNode
	AllReplication_target() []IReplication_targetContext
	Replication_target(i int) IReplication_targetContext
	WITH() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Replication_settings() IReplication_settingsContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCreate_replication_stmtContext differentiates from other interfaces.
	IsCreate_replication_stmtContext()
}

type Create_replication_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_replication_stmtContext() *Create_replication_stmtContext {
	var p = new(Create_replication_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_create_replication_stmt
	return p
}

func InitEmptyCreate_replication_stmtContext(p *Create_replication_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_create_replication_stmt
}

func (*Create_replication_stmtContext) IsCreate_replication_stmtContext() {}

func NewCreate_replication_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_replication_stmtContext {
	var p = new(Create_replication_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_create_replication_stmt

	return p
}

func (s *Create_replication_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_replication_stmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(YQLParserCREATE, 0)
}

func (s *Create_replication_stmtContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(YQLParserASYNC, 0)
}

func (s *Create_replication_stmtContext) REPLICATION() antlr.TerminalNode {
	return s.GetToken(YQLParserREPLICATION, 0)
}

func (s *Create_replication_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Create_replication_stmtContext) FOR() antlr.TerminalNode {
	return s.GetToken(YQLParserFOR, 0)
}

func (s *Create_replication_stmtContext) AllReplication_target() []IReplication_targetContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReplication_targetContext); ok {
			len++
		}
	}

	tst := make([]IReplication_targetContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReplication_targetContext); ok {
			tst[i] = t.(IReplication_targetContext)
			i++
		}
	}

	return tst
}

func (s *Create_replication_stmtContext) Replication_target(i int) IReplication_targetContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplication_targetContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplication_targetContext)
}

func (s *Create_replication_stmtContext) WITH() antlr.TerminalNode {
	return s.GetToken(YQLParserWITH, 0)
}

func (s *Create_replication_stmtContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Create_replication_stmtContext) Replication_settings() IReplication_settingsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplication_settingsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplication_settingsContext)
}

func (s *Create_replication_stmtContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Create_replication_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Create_replication_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Create_replication_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_replication_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_replication_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterCreate_replication_stmt(s)
	}
}

func (s *Create_replication_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitCreate_replication_stmt(s)
	}
}




func (p *YQLParser) Create_replication_stmt() (localctx ICreate_replication_stmtContext) {
	localctx = NewCreate_replication_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 612, YQLParserRULE_create_replication_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3708)
		p.Match(YQLParserCREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3709)
		p.Match(YQLParserASYNC)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3710)
		p.Match(YQLParserREPLICATION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3711)
		p.Object_ref()
	}
	{
		p.SetState(3712)
		p.Match(YQLParserFOR)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3713)
		p.Replication_target()
	}
	p.SetState(3718)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(3714)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3715)
			p.Replication_target()
		}


		p.SetState(3720)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3721)
		p.Match(YQLParserWITH)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3722)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3723)
		p.Replication_settings()
	}
	{
		p.SetState(3724)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IReplication_targetContext is an interface to support dynamic dispatch.
type IReplication_targetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllObject_ref() []IObject_refContext
	Object_ref(i int) IObject_refContext
	AS() antlr.TerminalNode

	// IsReplication_targetContext differentiates from other interfaces.
	IsReplication_targetContext()
}

type Replication_targetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplication_targetContext() *Replication_targetContext {
	var p = new(Replication_targetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_replication_target
	return p
}

func InitEmptyReplication_targetContext(p *Replication_targetContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_replication_target
}

func (*Replication_targetContext) IsReplication_targetContext() {}

func NewReplication_targetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Replication_targetContext {
	var p = new(Replication_targetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_replication_target

	return p
}

func (s *Replication_targetContext) GetParser() antlr.Parser { return s.parser }

func (s *Replication_targetContext) AllObject_ref() []IObject_refContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IObject_refContext); ok {
			len++
		}
	}

	tst := make([]IObject_refContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IObject_refContext); ok {
			tst[i] = t.(IObject_refContext)
			i++
		}
	}

	return tst
}

func (s *Replication_targetContext) Object_ref(i int) IObject_refContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Replication_targetContext) AS() antlr.TerminalNode {
	return s.GetToken(YQLParserAS, 0)
}

func (s *Replication_targetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Replication_targetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Replication_targetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterReplication_target(s)
	}
}

func (s *Replication_targetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitReplication_target(s)
	}
}




func (p *YQLParser) Replication_target() (localctx IReplication_targetContext) {
	localctx = NewReplication_targetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 614, YQLParserRULE_replication_target)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3726)
		p.Object_ref()
	}
	{
		p.SetState(3727)
		p.Match(YQLParserAS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3728)
		p.Object_ref()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IReplication_settingsContext is an interface to support dynamic dispatch.
type IReplication_settingsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllReplication_settings_entry() []IReplication_settings_entryContext
	Replication_settings_entry(i int) IReplication_settings_entryContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsReplication_settingsContext differentiates from other interfaces.
	IsReplication_settingsContext()
}

type Replication_settingsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplication_settingsContext() *Replication_settingsContext {
	var p = new(Replication_settingsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_replication_settings
	return p
}

func InitEmptyReplication_settingsContext(p *Replication_settingsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_replication_settings
}

func (*Replication_settingsContext) IsReplication_settingsContext() {}

func NewReplication_settingsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Replication_settingsContext {
	var p = new(Replication_settingsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_replication_settings

	return p
}

func (s *Replication_settingsContext) GetParser() antlr.Parser { return s.parser }

func (s *Replication_settingsContext) AllReplication_settings_entry() []IReplication_settings_entryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReplication_settings_entryContext); ok {
			len++
		}
	}

	tst := make([]IReplication_settings_entryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReplication_settings_entryContext); ok {
			tst[i] = t.(IReplication_settings_entryContext)
			i++
		}
	}

	return tst
}

func (s *Replication_settingsContext) Replication_settings_entry(i int) IReplication_settings_entryContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplication_settings_entryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplication_settings_entryContext)
}

func (s *Replication_settingsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Replication_settingsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Replication_settingsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Replication_settingsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Replication_settingsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterReplication_settings(s)
	}
}

func (s *Replication_settingsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitReplication_settings(s)
	}
}




func (p *YQLParser) Replication_settings() (localctx IReplication_settingsContext) {
	localctx = NewReplication_settingsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 616, YQLParserRULE_replication_settings)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3730)
		p.Replication_settings_entry()
	}
	p.SetState(3735)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(3731)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3732)
			p.Replication_settings_entry()
		}


		p.SetState(3737)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IReplication_settings_entryContext is an interface to support dynamic dispatch.
type IReplication_settings_entryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id() IAn_idContext
	EQUALS() antlr.TerminalNode
	Expr() IExprContext

	// IsReplication_settings_entryContext differentiates from other interfaces.
	IsReplication_settings_entryContext()
}

type Replication_settings_entryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplication_settings_entryContext() *Replication_settings_entryContext {
	var p = new(Replication_settings_entryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_replication_settings_entry
	return p
}

func InitEmptyReplication_settings_entryContext(p *Replication_settings_entryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_replication_settings_entry
}

func (*Replication_settings_entryContext) IsReplication_settings_entryContext() {}

func NewReplication_settings_entryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Replication_settings_entryContext {
	var p = new(Replication_settings_entryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_replication_settings_entry

	return p
}

func (s *Replication_settings_entryContext) GetParser() antlr.Parser { return s.parser }

func (s *Replication_settings_entryContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Replication_settings_entryContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(YQLParserEQUALS, 0)
}

func (s *Replication_settings_entryContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Replication_settings_entryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Replication_settings_entryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Replication_settings_entryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterReplication_settings_entry(s)
	}
}

func (s *Replication_settings_entryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitReplication_settings_entry(s)
	}
}




func (p *YQLParser) Replication_settings_entry() (localctx IReplication_settings_entryContext) {
	localctx = NewReplication_settings_entryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 618, YQLParserRULE_replication_settings_entry)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3738)
		p.An_id()
	}
	{
		p.SetState(3739)
		p.Match(YQLParserEQUALS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3740)
		p.Expr()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_replication_stmtContext is an interface to support dynamic dispatch.
type IAlter_replication_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	ASYNC() antlr.TerminalNode
	REPLICATION() antlr.TerminalNode
	Object_ref() IObject_refContext
	AllAlter_replication_action() []IAlter_replication_actionContext
	Alter_replication_action(i int) IAlter_replication_actionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAlter_replication_stmtContext differentiates from other interfaces.
	IsAlter_replication_stmtContext()
}

type Alter_replication_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_replication_stmtContext() *Alter_replication_stmtContext {
	var p = new(Alter_replication_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_replication_stmt
	return p
}

func InitEmptyAlter_replication_stmtContext(p *Alter_replication_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_replication_stmt
}

func (*Alter_replication_stmtContext) IsAlter_replication_stmtContext() {}

func NewAlter_replication_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_replication_stmtContext {
	var p = new(Alter_replication_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_replication_stmt

	return p
}

func (s *Alter_replication_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_replication_stmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(YQLParserALTER, 0)
}

func (s *Alter_replication_stmtContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(YQLParserASYNC, 0)
}

func (s *Alter_replication_stmtContext) REPLICATION() antlr.TerminalNode {
	return s.GetToken(YQLParserREPLICATION, 0)
}

func (s *Alter_replication_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Alter_replication_stmtContext) AllAlter_replication_action() []IAlter_replication_actionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlter_replication_actionContext); ok {
			len++
		}
	}

	tst := make([]IAlter_replication_actionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlter_replication_actionContext); ok {
			tst[i] = t.(IAlter_replication_actionContext)
			i++
		}
	}

	return tst
}

func (s *Alter_replication_stmtContext) Alter_replication_action(i int) IAlter_replication_actionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_replication_actionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_replication_actionContext)
}

func (s *Alter_replication_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Alter_replication_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Alter_replication_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_replication_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_replication_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_replication_stmt(s)
	}
}

func (s *Alter_replication_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_replication_stmt(s)
	}
}




func (p *YQLParser) Alter_replication_stmt() (localctx IAlter_replication_stmtContext) {
	localctx = NewAlter_replication_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 620, YQLParserRULE_alter_replication_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3742)
		p.Match(YQLParserALTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3743)
		p.Match(YQLParserASYNC)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3744)
		p.Match(YQLParserREPLICATION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3745)
		p.Object_ref()
	}
	{
		p.SetState(3746)
		p.Alter_replication_action()
	}
	p.SetState(3751)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(3747)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3748)
			p.Alter_replication_action()
		}


		p.SetState(3753)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_replication_actionContext is an interface to support dynamic dispatch.
type IAlter_replication_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Alter_replication_set_setting() IAlter_replication_set_settingContext

	// IsAlter_replication_actionContext differentiates from other interfaces.
	IsAlter_replication_actionContext()
}

type Alter_replication_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_replication_actionContext() *Alter_replication_actionContext {
	var p = new(Alter_replication_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_replication_action
	return p
}

func InitEmptyAlter_replication_actionContext(p *Alter_replication_actionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_replication_action
}

func (*Alter_replication_actionContext) IsAlter_replication_actionContext() {}

func NewAlter_replication_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_replication_actionContext {
	var p = new(Alter_replication_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_replication_action

	return p
}

func (s *Alter_replication_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_replication_actionContext) Alter_replication_set_setting() IAlter_replication_set_settingContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_replication_set_settingContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_replication_set_settingContext)
}

func (s *Alter_replication_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_replication_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_replication_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_replication_action(s)
	}
}

func (s *Alter_replication_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_replication_action(s)
	}
}




func (p *YQLParser) Alter_replication_action() (localctx IAlter_replication_actionContext) {
	localctx = NewAlter_replication_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 622, YQLParserRULE_alter_replication_action)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3754)
		p.Alter_replication_set_setting()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_replication_set_settingContext is an interface to support dynamic dispatch.
type IAlter_replication_set_settingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Replication_settings() IReplication_settingsContext
	RPAREN() antlr.TerminalNode

	// IsAlter_replication_set_settingContext differentiates from other interfaces.
	IsAlter_replication_set_settingContext()
}

type Alter_replication_set_settingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_replication_set_settingContext() *Alter_replication_set_settingContext {
	var p = new(Alter_replication_set_settingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_replication_set_setting
	return p
}

func InitEmptyAlter_replication_set_settingContext(p *Alter_replication_set_settingContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_replication_set_setting
}

func (*Alter_replication_set_settingContext) IsAlter_replication_set_settingContext() {}

func NewAlter_replication_set_settingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_replication_set_settingContext {
	var p = new(Alter_replication_set_settingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_replication_set_setting

	return p
}

func (s *Alter_replication_set_settingContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_replication_set_settingContext) SET() antlr.TerminalNode {
	return s.GetToken(YQLParserSET, 0)
}

func (s *Alter_replication_set_settingContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Alter_replication_set_settingContext) Replication_settings() IReplication_settingsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplication_settingsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplication_settingsContext)
}

func (s *Alter_replication_set_settingContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Alter_replication_set_settingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_replication_set_settingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_replication_set_settingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_replication_set_setting(s)
	}
}

func (s *Alter_replication_set_settingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_replication_set_setting(s)
	}
}




func (p *YQLParser) Alter_replication_set_setting() (localctx IAlter_replication_set_settingContext) {
	localctx = NewAlter_replication_set_settingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 624, YQLParserRULE_alter_replication_set_setting)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3756)
		p.Match(YQLParserSET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3757)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3758)
		p.Replication_settings()
	}
	{
		p.SetState(3759)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDrop_replication_stmtContext is an interface to support dynamic dispatch.
type IDrop_replication_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	ASYNC() antlr.TerminalNode
	REPLICATION() antlr.TerminalNode
	Object_ref() IObject_refContext
	CASCADE() antlr.TerminalNode

	// IsDrop_replication_stmtContext differentiates from other interfaces.
	IsDrop_replication_stmtContext()
}

type Drop_replication_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_replication_stmtContext() *Drop_replication_stmtContext {
	var p = new(Drop_replication_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_drop_replication_stmt
	return p
}

func InitEmptyDrop_replication_stmtContext(p *Drop_replication_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_drop_replication_stmt
}

func (*Drop_replication_stmtContext) IsDrop_replication_stmtContext() {}

func NewDrop_replication_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_replication_stmtContext {
	var p = new(Drop_replication_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_drop_replication_stmt

	return p
}

func (s *Drop_replication_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_replication_stmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(YQLParserDROP, 0)
}

func (s *Drop_replication_stmtContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(YQLParserASYNC, 0)
}

func (s *Drop_replication_stmtContext) REPLICATION() antlr.TerminalNode {
	return s.GetToken(YQLParserREPLICATION, 0)
}

func (s *Drop_replication_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Drop_replication_stmtContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(YQLParserCASCADE, 0)
}

func (s *Drop_replication_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_replication_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Drop_replication_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterDrop_replication_stmt(s)
	}
}

func (s *Drop_replication_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitDrop_replication_stmt(s)
	}
}




func (p *YQLParser) Drop_replication_stmt() (localctx IDrop_replication_stmtContext) {
	localctx = NewDrop_replication_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 626, YQLParserRULE_drop_replication_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3761)
		p.Match(YQLParserDROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3762)
		p.Match(YQLParserASYNC)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3763)
		p.Match(YQLParserREPLICATION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3764)
		p.Object_ref()
	}
	p.SetState(3766)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserCASCADE {
		{
			p.SetState(3765)
			p.Match(YQLParserCASCADE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAction_or_subquery_argsContext is an interface to support dynamic dispatch.
type IAction_or_subquery_argsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllOpt_bind_parameter() []IOpt_bind_parameterContext
	Opt_bind_parameter(i int) IOpt_bind_parameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAction_or_subquery_argsContext differentiates from other interfaces.
	IsAction_or_subquery_argsContext()
}

type Action_or_subquery_argsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAction_or_subquery_argsContext() *Action_or_subquery_argsContext {
	var p = new(Action_or_subquery_argsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_action_or_subquery_args
	return p
}

func InitEmptyAction_or_subquery_argsContext(p *Action_or_subquery_argsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_action_or_subquery_args
}

func (*Action_or_subquery_argsContext) IsAction_or_subquery_argsContext() {}

func NewAction_or_subquery_argsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Action_or_subquery_argsContext {
	var p = new(Action_or_subquery_argsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_action_or_subquery_args

	return p
}

func (s *Action_or_subquery_argsContext) GetParser() antlr.Parser { return s.parser }

func (s *Action_or_subquery_argsContext) AllOpt_bind_parameter() []IOpt_bind_parameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOpt_bind_parameterContext); ok {
			len++
		}
	}

	tst := make([]IOpt_bind_parameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOpt_bind_parameterContext); ok {
			tst[i] = t.(IOpt_bind_parameterContext)
			i++
		}
	}

	return tst
}

func (s *Action_or_subquery_argsContext) Opt_bind_parameter(i int) IOpt_bind_parameterContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_bind_parameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_bind_parameterContext)
}

func (s *Action_or_subquery_argsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Action_or_subquery_argsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Action_or_subquery_argsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Action_or_subquery_argsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Action_or_subquery_argsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAction_or_subquery_args(s)
	}
}

func (s *Action_or_subquery_argsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAction_or_subquery_args(s)
	}
}




func (p *YQLParser) Action_or_subquery_args() (localctx IAction_or_subquery_argsContext) {
	localctx = NewAction_or_subquery_argsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 628, YQLParserRULE_action_or_subquery_args)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3768)
		p.Opt_bind_parameter()
	}
	p.SetState(3773)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(3769)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3770)
			p.Opt_bind_parameter()
		}


		p.SetState(3775)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDefine_action_or_subquery_stmtContext is an interface to support dynamic dispatch.
type IDefine_action_or_subquery_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDEFINE() []antlr.TerminalNode
	DEFINE(i int) antlr.TerminalNode
	Bind_parameter() IBind_parameterContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AS() antlr.TerminalNode
	Define_action_or_subquery_body() IDefine_action_or_subquery_bodyContext
	END() antlr.TerminalNode
	ACTION() antlr.TerminalNode
	SUBQUERY() antlr.TerminalNode
	Action_or_subquery_args() IAction_or_subquery_argsContext

	// IsDefine_action_or_subquery_stmtContext differentiates from other interfaces.
	IsDefine_action_or_subquery_stmtContext()
}

type Define_action_or_subquery_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefine_action_or_subquery_stmtContext() *Define_action_or_subquery_stmtContext {
	var p = new(Define_action_or_subquery_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_define_action_or_subquery_stmt
	return p
}

func InitEmptyDefine_action_or_subquery_stmtContext(p *Define_action_or_subquery_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_define_action_or_subquery_stmt
}

func (*Define_action_or_subquery_stmtContext) IsDefine_action_or_subquery_stmtContext() {}

func NewDefine_action_or_subquery_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Define_action_or_subquery_stmtContext {
	var p = new(Define_action_or_subquery_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_define_action_or_subquery_stmt

	return p
}

func (s *Define_action_or_subquery_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Define_action_or_subquery_stmtContext) AllDEFINE() []antlr.TerminalNode {
	return s.GetTokens(YQLParserDEFINE)
}

func (s *Define_action_or_subquery_stmtContext) DEFINE(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserDEFINE, i)
}

func (s *Define_action_or_subquery_stmtContext) Bind_parameter() IBind_parameterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *Define_action_or_subquery_stmtContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Define_action_or_subquery_stmtContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Define_action_or_subquery_stmtContext) AS() antlr.TerminalNode {
	return s.GetToken(YQLParserAS, 0)
}

func (s *Define_action_or_subquery_stmtContext) Define_action_or_subquery_body() IDefine_action_or_subquery_bodyContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefine_action_or_subquery_bodyContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefine_action_or_subquery_bodyContext)
}

func (s *Define_action_or_subquery_stmtContext) END() antlr.TerminalNode {
	return s.GetToken(YQLParserEND, 0)
}

func (s *Define_action_or_subquery_stmtContext) ACTION() antlr.TerminalNode {
	return s.GetToken(YQLParserACTION, 0)
}

func (s *Define_action_or_subquery_stmtContext) SUBQUERY() antlr.TerminalNode {
	return s.GetToken(YQLParserSUBQUERY, 0)
}

func (s *Define_action_or_subquery_stmtContext) Action_or_subquery_args() IAction_or_subquery_argsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAction_or_subquery_argsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAction_or_subquery_argsContext)
}

func (s *Define_action_or_subquery_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Define_action_or_subquery_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Define_action_or_subquery_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterDefine_action_or_subquery_stmt(s)
	}
}

func (s *Define_action_or_subquery_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitDefine_action_or_subquery_stmt(s)
	}
}




func (p *YQLParser) Define_action_or_subquery_stmt() (localctx IDefine_action_or_subquery_stmtContext) {
	localctx = NewDefine_action_or_subquery_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 630, YQLParserRULE_define_action_or_subquery_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3776)
		p.Match(YQLParserDEFINE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3777)
		_la = p.GetTokenStream().LA(1)

		if !(_la == YQLParserACTION || _la == YQLParserSUBQUERY) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(3778)
		p.Bind_parameter()
	}
	{
		p.SetState(3779)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3781)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserDOLLAR {
		{
			p.SetState(3780)
			p.Action_or_subquery_args()
		}

	}
	{
		p.SetState(3783)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3784)
		p.Match(YQLParserAS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3785)
		p.Define_action_or_subquery_body()
	}
	{
		p.SetState(3786)
		p.Match(YQLParserEND)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3787)
		p.Match(YQLParserDEFINE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDefine_action_or_subquery_bodyContext is an interface to support dynamic dispatch.
type IDefine_action_or_subquery_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSEMICOLON() []antlr.TerminalNode
	SEMICOLON(i int) antlr.TerminalNode
	AllSql_stmt_core() []ISql_stmt_coreContext
	Sql_stmt_core(i int) ISql_stmt_coreContext

	// IsDefine_action_or_subquery_bodyContext differentiates from other interfaces.
	IsDefine_action_or_subquery_bodyContext()
}

type Define_action_or_subquery_bodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefine_action_or_subquery_bodyContext() *Define_action_or_subquery_bodyContext {
	var p = new(Define_action_or_subquery_bodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_define_action_or_subquery_body
	return p
}

func InitEmptyDefine_action_or_subquery_bodyContext(p *Define_action_or_subquery_bodyContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_define_action_or_subquery_body
}

func (*Define_action_or_subquery_bodyContext) IsDefine_action_or_subquery_bodyContext() {}

func NewDefine_action_or_subquery_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Define_action_or_subquery_bodyContext {
	var p = new(Define_action_or_subquery_bodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_define_action_or_subquery_body

	return p
}

func (s *Define_action_or_subquery_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Define_action_or_subquery_bodyContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(YQLParserSEMICOLON)
}

func (s *Define_action_or_subquery_bodyContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserSEMICOLON, i)
}

func (s *Define_action_or_subquery_bodyContext) AllSql_stmt_core() []ISql_stmt_coreContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISql_stmt_coreContext); ok {
			len++
		}
	}

	tst := make([]ISql_stmt_coreContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISql_stmt_coreContext); ok {
			tst[i] = t.(ISql_stmt_coreContext)
			i++
		}
	}

	return tst
}

func (s *Define_action_or_subquery_bodyContext) Sql_stmt_core(i int) ISql_stmt_coreContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_stmt_coreContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_stmt_coreContext)
}

func (s *Define_action_or_subquery_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Define_action_or_subquery_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Define_action_or_subquery_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterDefine_action_or_subquery_body(s)
	}
}

func (s *Define_action_or_subquery_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitDefine_action_or_subquery_body(s)
	}
}




func (p *YQLParser) Define_action_or_subquery_body() (localctx IDefine_action_or_subquery_bodyContext) {
	localctx = NewDefine_action_or_subquery_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 632, YQLParserRULE_define_action_or_subquery_body)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3792)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserSEMICOLON {
		{
			p.SetState(3789)
			p.Match(YQLParserSEMICOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


		p.SetState(3794)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3813)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 576487141689786368) != 0) || ((int64((_la - 77)) & ^0x3f) == 0 && ((int64(1) << (_la - 77)) & -6915259621669863167) != 0) || ((int64((_la - 145)) & ^0x3f) == 0 && ((int64(1) << (_la - 145)) & 2099329) != 0) || ((int64((_la - 216)) & ^0x3f) == 0 && ((int64(1) << (_la - 216)) & 4513512681407489) != 0) || ((int64((_la - 307)) & ^0x3f) == 0 && ((int64(1) << (_la - 307)) & 71) != 0) {
		{
			p.SetState(3795)
			p.Sql_stmt_core()
		}
		p.SetState(3804)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 390, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(3797)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)


				for ok := true; ok; ok = _la == YQLParserSEMICOLON {
					{
						p.SetState(3796)
						p.Match(YQLParserSEMICOLON)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}


					p.SetState(3799)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
				    	goto errorExit
				    }
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(3801)
					p.Sql_stmt_core()
				}


			}
			p.SetState(3806)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 390, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(3810)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == YQLParserSEMICOLON {
			{
				p.SetState(3807)
				p.Match(YQLParserSEMICOLON)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


			p.SetState(3812)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIf_stmtContext is an interface to support dynamic dispatch.
type IIf_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	Expr() IExprContext
	AllDo_stmt() []IDo_stmtContext
	Do_stmt(i int) IDo_stmtContext
	EVALUATE() antlr.TerminalNode
	ELSE() antlr.TerminalNode

	// IsIf_stmtContext differentiates from other interfaces.
	IsIf_stmtContext()
}

type If_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_stmtContext() *If_stmtContext {
	var p = new(If_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_if_stmt
	return p
}

func InitEmptyIf_stmtContext(p *If_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_if_stmt
}

func (*If_stmtContext) IsIf_stmtContext() {}

func NewIf_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_stmtContext {
	var p = new(If_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_if_stmt

	return p
}

func (s *If_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *If_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(YQLParserIF, 0)
}

func (s *If_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *If_stmtContext) AllDo_stmt() []IDo_stmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDo_stmtContext); ok {
			len++
		}
	}

	tst := make([]IDo_stmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDo_stmtContext); ok {
			tst[i] = t.(IDo_stmtContext)
			i++
		}
	}

	return tst
}

func (s *If_stmtContext) Do_stmt(i int) IDo_stmtContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDo_stmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDo_stmtContext)
}

func (s *If_stmtContext) EVALUATE() antlr.TerminalNode {
	return s.GetToken(YQLParserEVALUATE, 0)
}

func (s *If_stmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(YQLParserELSE, 0)
}

func (s *If_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *If_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterIf_stmt(s)
	}
}

func (s *If_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitIf_stmt(s)
	}
}




func (p *YQLParser) If_stmt() (localctx IIf_stmtContext) {
	localctx = NewIf_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 634, YQLParserRULE_if_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3816)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserEVALUATE {
		{
			p.SetState(3815)
			p.Match(YQLParserEVALUATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(3818)
		p.Match(YQLParserIF)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3819)
		p.Expr()
	}
	{
		p.SetState(3820)
		p.Do_stmt()
	}
	p.SetState(3823)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserELSE {
		{
			p.SetState(3821)
			p.Match(YQLParserELSE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3822)
			p.Do_stmt()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFor_stmtContext is an interface to support dynamic dispatch.
type IFor_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	Bind_parameter() IBind_parameterContext
	IN() antlr.TerminalNode
	Expr() IExprContext
	AllDo_stmt() []IDo_stmtContext
	Do_stmt(i int) IDo_stmtContext
	EVALUATE() antlr.TerminalNode
	PARALLEL() antlr.TerminalNode
	ELSE() antlr.TerminalNode

	// IsFor_stmtContext differentiates from other interfaces.
	IsFor_stmtContext()
}

type For_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_stmtContext() *For_stmtContext {
	var p = new(For_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_for_stmt
	return p
}

func InitEmptyFor_stmtContext(p *For_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_for_stmt
}

func (*For_stmtContext) IsFor_stmtContext() {}

func NewFor_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_stmtContext {
	var p = new(For_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_for_stmt

	return p
}

func (s *For_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *For_stmtContext) FOR() antlr.TerminalNode {
	return s.GetToken(YQLParserFOR, 0)
}

func (s *For_stmtContext) Bind_parameter() IBind_parameterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *For_stmtContext) IN() antlr.TerminalNode {
	return s.GetToken(YQLParserIN, 0)
}

func (s *For_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *For_stmtContext) AllDo_stmt() []IDo_stmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDo_stmtContext); ok {
			len++
		}
	}

	tst := make([]IDo_stmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDo_stmtContext); ok {
			tst[i] = t.(IDo_stmtContext)
			i++
		}
	}

	return tst
}

func (s *For_stmtContext) Do_stmt(i int) IDo_stmtContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDo_stmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDo_stmtContext)
}

func (s *For_stmtContext) EVALUATE() antlr.TerminalNode {
	return s.GetToken(YQLParserEVALUATE, 0)
}

func (s *For_stmtContext) PARALLEL() antlr.TerminalNode {
	return s.GetToken(YQLParserPARALLEL, 0)
}

func (s *For_stmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(YQLParserELSE, 0)
}

func (s *For_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *For_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterFor_stmt(s)
	}
}

func (s *For_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitFor_stmt(s)
	}
}




func (p *YQLParser) For_stmt() (localctx IFor_stmtContext) {
	localctx = NewFor_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 636, YQLParserRULE_for_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3826)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserEVALUATE {
		{
			p.SetState(3825)
			p.Match(YQLParserEVALUATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(3829)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserPARALLEL {
		{
			p.SetState(3828)
			p.Match(YQLParserPARALLEL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(3831)
		p.Match(YQLParserFOR)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3832)
		p.Bind_parameter()
	}
	{
		p.SetState(3833)
		p.Match(YQLParserIN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3834)
		p.Expr()
	}
	{
		p.SetState(3835)
		p.Do_stmt()
	}
	p.SetState(3838)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserELSE {
		{
			p.SetState(3836)
			p.Match(YQLParserELSE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3837)
			p.Do_stmt()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITable_refContext is an interface to support dynamic dispatch.
type ITable_refContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Table_key() ITable_keyContext
	An_id_expr() IAn_id_exprContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Bind_parameter() IBind_parameterContext
	Cluster_expr() ICluster_exprContext
	DOT() antlr.TerminalNode
	COMMAT() antlr.TerminalNode
	Table_hints() ITable_hintsContext
	AllTable_arg() []ITable_argContext
	Table_arg(i int) ITable_argContext
	VIEW() antlr.TerminalNode
	View_name() IView_nameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	Expr_list() IExpr_listContext

	// IsTable_refContext differentiates from other interfaces.
	IsTable_refContext()
}

type Table_refContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_refContext() *Table_refContext {
	var p = new(Table_refContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_table_ref
	return p
}

func InitEmptyTable_refContext(p *Table_refContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_table_ref
}

func (*Table_refContext) IsTable_refContext() {}

func NewTable_refContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_refContext {
	var p = new(Table_refContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_table_ref

	return p
}

func (s *Table_refContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_refContext) Table_key() ITable_keyContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_keyContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_keyContext)
}

func (s *Table_refContext) An_id_expr() IAn_id_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_exprContext)
}

func (s *Table_refContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Table_refContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Table_refContext) Bind_parameter() IBind_parameterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *Table_refContext) Cluster_expr() ICluster_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICluster_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICluster_exprContext)
}

func (s *Table_refContext) DOT() antlr.TerminalNode {
	return s.GetToken(YQLParserDOT, 0)
}

func (s *Table_refContext) COMMAT() antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMAT, 0)
}

func (s *Table_refContext) Table_hints() ITable_hintsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_hintsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_hintsContext)
}

func (s *Table_refContext) AllTable_arg() []ITable_argContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITable_argContext); ok {
			len++
		}
	}

	tst := make([]ITable_argContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITable_argContext); ok {
			tst[i] = t.(ITable_argContext)
			i++
		}
	}

	return tst
}

func (s *Table_refContext) Table_arg(i int) ITable_argContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_argContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_argContext)
}

func (s *Table_refContext) VIEW() antlr.TerminalNode {
	return s.GetToken(YQLParserVIEW, 0)
}

func (s *Table_refContext) View_name() IView_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IView_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IView_nameContext)
}

func (s *Table_refContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Table_refContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Table_refContext) Expr_list() IExpr_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_listContext)
}

func (s *Table_refContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_refContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Table_refContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterTable_ref(s)
	}
}

func (s *Table_refContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitTable_ref(s)
	}
}




func (p *YQLParser) Table_ref() (localctx ITable_refContext) {
	localctx = NewTable_refContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 638, YQLParserRULE_table_ref)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3843)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 398, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3840)
			p.Cluster_expr()
		}
		{
			p.SetState(3841)
			p.Match(YQLParserDOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(3846)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserCOMMAT {
		{
			p.SetState(3845)
			p.Match(YQLParserCOMMAT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(3878)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 406, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3848)
			p.Table_key()
		}


	case 2:
		{
			p.SetState(3849)
			p.An_id_expr()
		}
		{
			p.SetState(3850)
			p.Match(YQLParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3862)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64((_la - 14)) & ^0x3f) == 0 && ((int64(1) << (_la - 14)) & -17592194201571) != 0) || ((int64((_la - 78)) & ^0x3f) == 0 && ((int64(1) << (_la - 78)) & -1) != 0) || ((int64((_la - 142)) & ^0x3f) == 0 && ((int64(1) << (_la - 142)) & -1) != 0) || ((int64((_la - 206)) & ^0x3f) == 0 && ((int64(1) << (_la - 206)) & -137438953473) != 0) || ((int64((_la - 270)) & ^0x3f) == 0 && ((int64(1) << (_la - 270)) & 2305843009213693951) != 0) {
			{
				p.SetState(3851)
				p.Table_arg()
			}
			p.SetState(3856)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 400, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(3852)
						p.Match(YQLParserCOMMA)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}
					{
						p.SetState(3853)
						p.Table_arg()
					}


				}
				p.SetState(3858)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
			    	goto errorExit
			    }
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 400, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			p.SetState(3860)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == YQLParserCOMMA {
				{
					p.SetState(3859)
					p.Match(YQLParserCOMMA)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			}

		}
		{
			p.SetState(3864)
			p.Match(YQLParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		{
			p.SetState(3866)
			p.Bind_parameter()
		}
		p.SetState(3872)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserLPAREN {
			{
				p.SetState(3867)
				p.Match(YQLParserLPAREN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(3869)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if ((int64((_la - 14)) & ^0x3f) == 0 && ((int64(1) << (_la - 14)) & -17592194234339) != 0) || ((int64((_la - 78)) & ^0x3f) == 0 && ((int64(1) << (_la - 78)) & -1) != 0) || ((int64((_la - 142)) & ^0x3f) == 0 && ((int64(1) << (_la - 142)) & -1) != 0) || ((int64((_la - 206)) & ^0x3f) == 0 && ((int64(1) << (_la - 206)) & -137438953473) != 0) || ((int64((_la - 270)) & ^0x3f) == 0 && ((int64(1) << (_la - 270)) & 2305843009213693951) != 0) {
				{
					p.SetState(3868)
					p.Expr_list()
				}

			}
			{
				p.SetState(3871)
				p.Match(YQLParserRPAREN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		p.SetState(3876)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserVIEW {
			{
				p.SetState(3874)
				p.Match(YQLParserVIEW)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3875)
				p.View_name()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(3881)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserWITH {
		{
			p.SetState(3880)
			p.Table_hints()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITable_keyContext is an interface to support dynamic dispatch.
type ITable_keyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_table_or_type() IId_table_or_typeContext
	VIEW() antlr.TerminalNode
	View_name() IView_nameContext

	// IsTable_keyContext differentiates from other interfaces.
	IsTable_keyContext()
}

type Table_keyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_keyContext() *Table_keyContext {
	var p = new(Table_keyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_table_key
	return p
}

func InitEmptyTable_keyContext(p *Table_keyContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_table_key
}

func (*Table_keyContext) IsTable_keyContext() {}

func NewTable_keyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_keyContext {
	var p = new(Table_keyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_table_key

	return p
}

func (s *Table_keyContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_keyContext) Id_table_or_type() IId_table_or_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_table_or_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_table_or_typeContext)
}

func (s *Table_keyContext) VIEW() antlr.TerminalNode {
	return s.GetToken(YQLParserVIEW, 0)
}

func (s *Table_keyContext) View_name() IView_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IView_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IView_nameContext)
}

func (s *Table_keyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_keyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Table_keyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterTable_key(s)
	}
}

func (s *Table_keyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitTable_key(s)
	}
}




func (p *YQLParser) Table_key() (localctx ITable_keyContext) {
	localctx = NewTable_keyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 640, YQLParserRULE_table_key)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3883)
		p.Id_table_or_type()
	}
	p.SetState(3886)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserVIEW {
		{
			p.SetState(3884)
			p.Match(YQLParserVIEW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3885)
			p.View_name()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITable_argContext is an interface to support dynamic dispatch.
type ITable_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Named_expr() INamed_exprContext
	COMMAT() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	View_name() IView_nameContext

	// IsTable_argContext differentiates from other interfaces.
	IsTable_argContext()
}

type Table_argContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_argContext() *Table_argContext {
	var p = new(Table_argContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_table_arg
	return p
}

func InitEmptyTable_argContext(p *Table_argContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_table_arg
}

func (*Table_argContext) IsTable_argContext() {}

func NewTable_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_argContext {
	var p = new(Table_argContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_table_arg

	return p
}

func (s *Table_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_argContext) Named_expr() INamed_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_exprContext)
}

func (s *Table_argContext) COMMAT() antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMAT, 0)
}

func (s *Table_argContext) VIEW() antlr.TerminalNode {
	return s.GetToken(YQLParserVIEW, 0)
}

func (s *Table_argContext) View_name() IView_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IView_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IView_nameContext)
}

func (s *Table_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Table_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterTable_arg(s)
	}
}

func (s *Table_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitTable_arg(s)
	}
}




func (p *YQLParser) Table_arg() (localctx ITable_argContext) {
	localctx = NewTable_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 642, YQLParserRULE_table_arg)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3889)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserCOMMAT {
		{
			p.SetState(3888)
			p.Match(YQLParserCOMMAT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(3891)
		p.Named_expr()
	}
	p.SetState(3894)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserVIEW {
		{
			p.SetState(3892)
			p.Match(YQLParserVIEW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3893)
			p.View_name()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITable_hintsContext is an interface to support dynamic dispatch.
type ITable_hintsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	AllTable_hint() []ITable_hintContext
	Table_hint(i int) ITable_hintContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTable_hintsContext differentiates from other interfaces.
	IsTable_hintsContext()
}

type Table_hintsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_hintsContext() *Table_hintsContext {
	var p = new(Table_hintsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_table_hints
	return p
}

func InitEmptyTable_hintsContext(p *Table_hintsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_table_hints
}

func (*Table_hintsContext) IsTable_hintsContext() {}

func NewTable_hintsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_hintsContext {
	var p = new(Table_hintsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_table_hints

	return p
}

func (s *Table_hintsContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_hintsContext) WITH() antlr.TerminalNode {
	return s.GetToken(YQLParserWITH, 0)
}

func (s *Table_hintsContext) AllTable_hint() []ITable_hintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITable_hintContext); ok {
			len++
		}
	}

	tst := make([]ITable_hintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITable_hintContext); ok {
			tst[i] = t.(ITable_hintContext)
			i++
		}
	}

	return tst
}

func (s *Table_hintsContext) Table_hint(i int) ITable_hintContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_hintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_hintContext)
}

func (s *Table_hintsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Table_hintsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Table_hintsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Table_hintsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Table_hintsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_hintsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Table_hintsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterTable_hints(s)
	}
}

func (s *Table_hintsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitTable_hints(s)
	}
}




func (p *YQLParser) Table_hints() (localctx ITable_hintsContext) {
	localctx = NewTable_hintsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 644, YQLParserRULE_table_hints)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3896)
		p.Match(YQLParserWITH)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3909)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALL, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserANY, YQLParserARRAY, YQLParserAS, YQLParserASC, YQLParserASSUME, YQLParserASYMMETRIC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBETWEEN, YQLParserBITCAST, YQLParserBY, YQLParserCASCADE, YQLParserCASE, YQLParserCAST, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOLUMN, YQLParserCOLUMNS, YQLParserCOMMIT, YQLParserCOMPACT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCUBE, YQLParserCURRENT, YQLParserCURRENT_DATE, YQLParserCURRENT_TIME, YQLParserCURRENT_TIMESTAMP, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDISTINCT, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserEMPTY_ACTION, YQLParserENCRYPTED, YQLParserEND, YQLParserERASE, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCEPT, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXISTS, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFROM, YQLParserFULL, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserGROUPS, YQLParserHASH, YQLParserHAVING, YQLParserHOP, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTERSECT, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserJSON_EXISTS, YQLParserJSON_QUERY, YQLParserJSON_VALUE, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLIMIT, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOT, YQLParserNOTNULL, YQLParserNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserPROCESS, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserRANGE, YQLParserREDUCE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserRETURN, YQLParserRETURNING, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROLLUP, YQLParserROW, YQLParserROWS, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSCHEMA, YQLParserSECONDS, YQLParserSEEK, YQLParserSELECT, YQLParserSEMI, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSTREAM, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYMMETRIC, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTYPE, YQLParserUNBOUNDED, YQLParserUNCONDITIONAL, YQLParserUNION, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWHEN, YQLParserWHERE, YQLParserWINDOW, YQLParserWITH, YQLParserWITHOUT, YQLParserWRAPPER, YQLParserXOR, YQLParserSTRING_VALUE, YQLParserID_PLAIN, YQLParserID_QUOTED:
		{
			p.SetState(3897)
			p.Table_hint()
		}


	case YQLParserLPAREN:
		{
			p.SetState(3898)
			p.Match(YQLParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3899)
			p.Table_hint()
		}
		p.SetState(3904)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == YQLParserCOMMA {
			{
				p.SetState(3900)
				p.Match(YQLParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3901)
				p.Table_hint()
			}


			p.SetState(3906)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3907)
			p.Match(YQLParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITable_hintContext is an interface to support dynamic dispatch.
type ITable_hintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id_hint() IAn_id_hintContext
	EQUALS() antlr.TerminalNode
	AllType_name_tag() []IType_name_tagContext
	Type_name_tag(i int) IType_name_tagContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	Type_name_or_bind() IType_name_or_bindContext
	SCHEMA() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	AllStruct_arg_positional() []IStruct_arg_positionalContext
	Struct_arg_positional(i int) IStruct_arg_positionalContext

	// IsTable_hintContext differentiates from other interfaces.
	IsTable_hintContext()
}

type Table_hintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_hintContext() *Table_hintContext {
	var p = new(Table_hintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_table_hint
	return p
}

func InitEmptyTable_hintContext(p *Table_hintContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_table_hint
}

func (*Table_hintContext) IsTable_hintContext() {}

func NewTable_hintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_hintContext {
	var p = new(Table_hintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_table_hint

	return p
}

func (s *Table_hintContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_hintContext) An_id_hint() IAn_id_hintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_hintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_hintContext)
}

func (s *Table_hintContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(YQLParserEQUALS, 0)
}

func (s *Table_hintContext) AllType_name_tag() []IType_name_tagContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IType_name_tagContext); ok {
			len++
		}
	}

	tst := make([]IType_name_tagContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IType_name_tagContext); ok {
			tst[i] = t.(IType_name_tagContext)
			i++
		}
	}

	return tst
}

func (s *Table_hintContext) Type_name_tag(i int) IType_name_tagContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_tagContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_tagContext)
}

func (s *Table_hintContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Table_hintContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Table_hintContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Table_hintContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Table_hintContext) Type_name_or_bind() IType_name_or_bindContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_or_bindContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_or_bindContext)
}

func (s *Table_hintContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(YQLParserSCHEMA, 0)
}

func (s *Table_hintContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(YQLParserCOLUMNS, 0)
}

func (s *Table_hintContext) AllStruct_arg_positional() []IStruct_arg_positionalContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStruct_arg_positionalContext); ok {
			len++
		}
	}

	tst := make([]IStruct_arg_positionalContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStruct_arg_positionalContext); ok {
			tst[i] = t.(IStruct_arg_positionalContext)
			i++
		}
	}

	return tst
}

func (s *Table_hintContext) Struct_arg_positional(i int) IStruct_arg_positionalContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStruct_arg_positionalContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStruct_arg_positionalContext)
}

func (s *Table_hintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_hintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Table_hintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterTable_hint(s)
	}
}

func (s *Table_hintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitTable_hint(s)
	}
}




func (p *YQLParser) Table_hint() (localctx ITable_hintContext) {
	localctx = NewTable_hintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 646, YQLParserRULE_table_hint)
	var _la int

	var _alt int

	p.SetState(3956)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 422, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3911)
			p.An_id_hint()
		}
		p.SetState(3930)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserEQUALS {
			{
				p.SetState(3912)
				p.Match(YQLParserEQUALS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(3928)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case YQLParserDOLLAR, YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALL, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserANY, YQLParserARRAY, YQLParserAS, YQLParserASC, YQLParserASSUME, YQLParserASYMMETRIC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBETWEEN, YQLParserBITCAST, YQLParserBY, YQLParserCASCADE, YQLParserCASE, YQLParserCAST, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOLUMN, YQLParserCOLUMNS, YQLParserCOMMIT, YQLParserCOMPACT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCUBE, YQLParserCURRENT, YQLParserCURRENT_DATE, YQLParserCURRENT_TIME, YQLParserCURRENT_TIMESTAMP, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDISTINCT, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserEMPTY_ACTION, YQLParserENCRYPTED, YQLParserEND, YQLParserERASE, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCEPT, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXISTS, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFROM, YQLParserFULL, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserGROUPS, YQLParserHASH, YQLParserHAVING, YQLParserHOP, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTERSECT, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserJSON_EXISTS, YQLParserJSON_QUERY, YQLParserJSON_VALUE, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLIMIT, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOT, YQLParserNOTNULL, YQLParserNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserPROCESS, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserRANGE, YQLParserREDUCE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserRETURN, YQLParserRETURNING, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROLLUP, YQLParserROW, YQLParserROWS, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSCHEMA, YQLParserSECONDS, YQLParserSEEK, YQLParserSELECT, YQLParserSEMI, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSTREAM, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYMMETRIC, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTYPE, YQLParserUNBOUNDED, YQLParserUNCONDITIONAL, YQLParserUNION, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWHEN, YQLParserWHERE, YQLParserWINDOW, YQLParserWITH, YQLParserWITHOUT, YQLParserWRAPPER, YQLParserXOR, YQLParserSTRING_VALUE, YQLParserID_PLAIN, YQLParserID_QUOTED:
				{
					p.SetState(3913)
					p.Type_name_tag()
				}


			case YQLParserLPAREN:
				{
					p.SetState(3914)
					p.Match(YQLParserLPAREN)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(3915)
					p.Type_name_tag()
				}
				p.SetState(3920)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 413, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(3916)
							p.Match(YQLParserCOMMA)
							if p.HasError() {
									// Recognition error - abort rule
									goto errorExit
							}
						}
						{
							p.SetState(3917)
							p.Type_name_tag()
						}


					}
					p.SetState(3922)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
				    	goto errorExit
				    }
					_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 413, p.GetParserRuleContext())
					if p.HasError() {
						goto errorExit
					}
				}
				p.SetState(3924)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)


				if _la == YQLParserCOMMA {
					{
						p.SetState(3923)
						p.Match(YQLParserCOMMA)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}

				}
				{
					p.SetState(3926)
					p.Match(YQLParserRPAREN)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}



			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3932)
			_la = p.GetTokenStream().LA(1)

			if !(_la == YQLParserCOLUMNS || _la == YQLParserSCHEMA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(3934)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserEQUALS {
			{
				p.SetState(3933)
				p.Match(YQLParserEQUALS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(3936)
			p.Type_name_or_bind()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3937)
			p.Match(YQLParserSCHEMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3939)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserEQUALS {
			{
				p.SetState(3938)
				p.Match(YQLParserEQUALS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(3941)
			p.Match(YQLParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3950)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64((_la - 30)) & ^0x3f) == 0 && ((int64(1) << (_la - 30)) & -268435711) != 0) || ((int64((_la - 94)) & ^0x3f) == 0 && ((int64(1) << (_la - 94)) & -137438953473) != 0) || ((int64((_la - 158)) & ^0x3f) == 0 && ((int64(1) << (_la - 158)) & -1) != 0) || ((int64((_la - 222)) & ^0x3f) == 0 && ((int64(1) << (_la - 222)) & -2097153) != 0) || ((int64((_la - 286)) & ^0x3f) == 0 && ((int64(1) << (_la - 286)) & 2199023251455) != 0) {
			{
				p.SetState(3942)
				p.Struct_arg_positional()
			}
			p.SetState(3947)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 419, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(3943)
						p.Match(YQLParserCOMMA)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}
					{
						p.SetState(3944)
						p.Struct_arg_positional()
					}


				}
				p.SetState(3949)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
			    	goto errorExit
			    }
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 419, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}

		}
		p.SetState(3953)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserCOMMA {
			{
				p.SetState(3952)
				p.Match(YQLParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(3955)
			p.Match(YQLParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IObject_refContext is an interface to support dynamic dispatch.
type IObject_refContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_or_at() IId_or_atContext
	Cluster_expr() ICluster_exprContext
	DOT() antlr.TerminalNode

	// IsObject_refContext differentiates from other interfaces.
	IsObject_refContext()
}

type Object_refContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObject_refContext() *Object_refContext {
	var p = new(Object_refContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_object_ref
	return p
}

func InitEmptyObject_refContext(p *Object_refContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_object_ref
}

func (*Object_refContext) IsObject_refContext() {}

func NewObject_refContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Object_refContext {
	var p = new(Object_refContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_object_ref

	return p
}

func (s *Object_refContext) GetParser() antlr.Parser { return s.parser }

func (s *Object_refContext) Id_or_at() IId_or_atContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_or_atContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_or_atContext)
}

func (s *Object_refContext) Cluster_expr() ICluster_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICluster_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICluster_exprContext)
}

func (s *Object_refContext) DOT() antlr.TerminalNode {
	return s.GetToken(YQLParserDOT, 0)
}

func (s *Object_refContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Object_refContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Object_refContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterObject_ref(s)
	}
}

func (s *Object_refContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitObject_ref(s)
	}
}




func (p *YQLParser) Object_ref() (localctx IObject_refContext) {
	localctx = NewObject_refContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 648, YQLParserRULE_object_ref)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(3961)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 423, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3958)
			p.Cluster_expr()
		}
		{
			p.SetState(3959)
			p.Match(YQLParserDOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(3963)
		p.Id_or_at()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISimple_table_ref_coreContext is an interface to support dynamic dispatch.
type ISimple_table_ref_coreContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Object_ref() IObject_refContext
	Bind_parameter() IBind_parameterContext
	COMMAT() antlr.TerminalNode

	// IsSimple_table_ref_coreContext differentiates from other interfaces.
	IsSimple_table_ref_coreContext()
}

type Simple_table_ref_coreContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_table_ref_coreContext() *Simple_table_ref_coreContext {
	var p = new(Simple_table_ref_coreContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_simple_table_ref_core
	return p
}

func InitEmptySimple_table_ref_coreContext(p *Simple_table_ref_coreContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_simple_table_ref_core
}

func (*Simple_table_ref_coreContext) IsSimple_table_ref_coreContext() {}

func NewSimple_table_ref_coreContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_table_ref_coreContext {
	var p = new(Simple_table_ref_coreContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_simple_table_ref_core

	return p
}

func (s *Simple_table_ref_coreContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_table_ref_coreContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Simple_table_ref_coreContext) Bind_parameter() IBind_parameterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *Simple_table_ref_coreContext) COMMAT() antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMAT, 0)
}

func (s *Simple_table_ref_coreContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_table_ref_coreContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Simple_table_ref_coreContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterSimple_table_ref_core(s)
	}
}

func (s *Simple_table_ref_coreContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitSimple_table_ref_core(s)
	}
}




func (p *YQLParser) Simple_table_ref_core() (localctx ISimple_table_ref_coreContext) {
	localctx = NewSimple_table_ref_coreContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 650, YQLParserRULE_simple_table_ref_core)
	var _la int

	p.SetState(3970)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 425, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3965)
			p.Object_ref()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(3967)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserCOMMAT {
			{
				p.SetState(3966)
				p.Match(YQLParserCOMMAT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(3969)
			p.Bind_parameter()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISimple_table_refContext is an interface to support dynamic dispatch.
type ISimple_table_refContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Simple_table_ref_core() ISimple_table_ref_coreContext
	Table_hints() ITable_hintsContext

	// IsSimple_table_refContext differentiates from other interfaces.
	IsSimple_table_refContext()
}

type Simple_table_refContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_table_refContext() *Simple_table_refContext {
	var p = new(Simple_table_refContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_simple_table_ref
	return p
}

func InitEmptySimple_table_refContext(p *Simple_table_refContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_simple_table_ref
}

func (*Simple_table_refContext) IsSimple_table_refContext() {}

func NewSimple_table_refContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_table_refContext {
	var p = new(Simple_table_refContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_simple_table_ref

	return p
}

func (s *Simple_table_refContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_table_refContext) Simple_table_ref_core() ISimple_table_ref_coreContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_table_ref_coreContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_table_ref_coreContext)
}

func (s *Simple_table_refContext) Table_hints() ITable_hintsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_hintsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_hintsContext)
}

func (s *Simple_table_refContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_table_refContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Simple_table_refContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterSimple_table_ref(s)
	}
}

func (s *Simple_table_refContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitSimple_table_ref(s)
	}
}




func (p *YQLParser) Simple_table_ref() (localctx ISimple_table_refContext) {
	localctx = NewSimple_table_refContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 652, YQLParserRULE_simple_table_ref)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3972)
		p.Simple_table_ref_core()
	}
	p.SetState(3974)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserWITH {
		{
			p.SetState(3973)
			p.Table_hints()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IInto_simple_table_refContext is an interface to support dynamic dispatch.
type IInto_simple_table_refContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Simple_table_ref() ISimple_table_refContext
	ERASE() antlr.TerminalNode
	BY() antlr.TerminalNode
	Pure_column_list() IPure_column_listContext

	// IsInto_simple_table_refContext differentiates from other interfaces.
	IsInto_simple_table_refContext()
}

type Into_simple_table_refContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInto_simple_table_refContext() *Into_simple_table_refContext {
	var p = new(Into_simple_table_refContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_into_simple_table_ref
	return p
}

func InitEmptyInto_simple_table_refContext(p *Into_simple_table_refContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_into_simple_table_ref
}

func (*Into_simple_table_refContext) IsInto_simple_table_refContext() {}

func NewInto_simple_table_refContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Into_simple_table_refContext {
	var p = new(Into_simple_table_refContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_into_simple_table_ref

	return p
}

func (s *Into_simple_table_refContext) GetParser() antlr.Parser { return s.parser }

func (s *Into_simple_table_refContext) Simple_table_ref() ISimple_table_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_table_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_table_refContext)
}

func (s *Into_simple_table_refContext) ERASE() antlr.TerminalNode {
	return s.GetToken(YQLParserERASE, 0)
}

func (s *Into_simple_table_refContext) BY() antlr.TerminalNode {
	return s.GetToken(YQLParserBY, 0)
}

func (s *Into_simple_table_refContext) Pure_column_list() IPure_column_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPure_column_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPure_column_listContext)
}

func (s *Into_simple_table_refContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Into_simple_table_refContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Into_simple_table_refContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterInto_simple_table_ref(s)
	}
}

func (s *Into_simple_table_refContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitInto_simple_table_ref(s)
	}
}




func (p *YQLParser) Into_simple_table_ref() (localctx IInto_simple_table_refContext) {
	localctx = NewInto_simple_table_refContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 654, YQLParserRULE_into_simple_table_ref)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3976)
		p.Simple_table_ref()
	}
	p.SetState(3980)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserERASE {
		{
			p.SetState(3977)
			p.Match(YQLParserERASE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3978)
			p.Match(YQLParserBY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3979)
			p.Pure_column_list()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDelete_stmtContext is an interface to support dynamic dispatch.
type IDelete_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DELETE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	Simple_table_ref() ISimple_table_refContext
	WHERE() antlr.TerminalNode
	Expr() IExprContext
	ON() antlr.TerminalNode
	Into_values_source() IInto_values_sourceContext
	Returning_columns_list() IReturning_columns_listContext

	// IsDelete_stmtContext differentiates from other interfaces.
	IsDelete_stmtContext()
}

type Delete_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelete_stmtContext() *Delete_stmtContext {
	var p = new(Delete_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_delete_stmt
	return p
}

func InitEmptyDelete_stmtContext(p *Delete_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_delete_stmt
}

func (*Delete_stmtContext) IsDelete_stmtContext() {}

func NewDelete_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delete_stmtContext {
	var p = new(Delete_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_delete_stmt

	return p
}

func (s *Delete_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Delete_stmtContext) DELETE() antlr.TerminalNode {
	return s.GetToken(YQLParserDELETE, 0)
}

func (s *Delete_stmtContext) FROM() antlr.TerminalNode {
	return s.GetToken(YQLParserFROM, 0)
}

func (s *Delete_stmtContext) Simple_table_ref() ISimple_table_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_table_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_table_refContext)
}

func (s *Delete_stmtContext) WHERE() antlr.TerminalNode {
	return s.GetToken(YQLParserWHERE, 0)
}

func (s *Delete_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Delete_stmtContext) ON() antlr.TerminalNode {
	return s.GetToken(YQLParserON, 0)
}

func (s *Delete_stmtContext) Into_values_source() IInto_values_sourceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInto_values_sourceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInto_values_sourceContext)
}

func (s *Delete_stmtContext) Returning_columns_list() IReturning_columns_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturning_columns_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturning_columns_listContext)
}

func (s *Delete_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delete_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Delete_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterDelete_stmt(s)
	}
}

func (s *Delete_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitDelete_stmt(s)
	}
}




func (p *YQLParser) Delete_stmt() (localctx IDelete_stmtContext) {
	localctx = NewDelete_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 656, YQLParserRULE_delete_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3982)
		p.Match(YQLParserDELETE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3983)
		p.Match(YQLParserFROM)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3984)
		p.Simple_table_ref()
	}
	p.SetState(3989)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case YQLParserWHERE:
		{
			p.SetState(3985)
			p.Match(YQLParserWHERE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3986)
			p.Expr()
		}


	case YQLParserON:
		{
			p.SetState(3987)
			p.Match(YQLParserON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3988)
			p.Into_values_source()
		}


	case YQLParserEOF, YQLParserSEMICOLON, YQLParserEND, YQLParserRETURNING:



	default:
	}
	p.SetState(3992)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserRETURNING {
		{
			p.SetState(3991)
			p.Returning_columns_list()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUpdate_stmtContext is an interface to support dynamic dispatch.
type IUpdate_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UPDATE() antlr.TerminalNode
	Simple_table_ref() ISimple_table_refContext
	SET() antlr.TerminalNode
	Set_clause_choice() ISet_clause_choiceContext
	ON() antlr.TerminalNode
	Into_values_source() IInto_values_sourceContext
	Returning_columns_list() IReturning_columns_listContext
	WHERE() antlr.TerminalNode
	Expr() IExprContext

	// IsUpdate_stmtContext differentiates from other interfaces.
	IsUpdate_stmtContext()
}

type Update_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdate_stmtContext() *Update_stmtContext {
	var p = new(Update_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_update_stmt
	return p
}

func InitEmptyUpdate_stmtContext(p *Update_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_update_stmt
}

func (*Update_stmtContext) IsUpdate_stmtContext() {}

func NewUpdate_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Update_stmtContext {
	var p = new(Update_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_update_stmt

	return p
}

func (s *Update_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Update_stmtContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(YQLParserUPDATE, 0)
}

func (s *Update_stmtContext) Simple_table_ref() ISimple_table_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_table_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_table_refContext)
}

func (s *Update_stmtContext) SET() antlr.TerminalNode {
	return s.GetToken(YQLParserSET, 0)
}

func (s *Update_stmtContext) Set_clause_choice() ISet_clause_choiceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_clause_choiceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_clause_choiceContext)
}

func (s *Update_stmtContext) ON() antlr.TerminalNode {
	return s.GetToken(YQLParserON, 0)
}

func (s *Update_stmtContext) Into_values_source() IInto_values_sourceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInto_values_sourceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInto_values_sourceContext)
}

func (s *Update_stmtContext) Returning_columns_list() IReturning_columns_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturning_columns_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturning_columns_listContext)
}

func (s *Update_stmtContext) WHERE() antlr.TerminalNode {
	return s.GetToken(YQLParserWHERE, 0)
}

func (s *Update_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Update_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Update_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Update_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterUpdate_stmt(s)
	}
}

func (s *Update_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitUpdate_stmt(s)
	}
}




func (p *YQLParser) Update_stmt() (localctx IUpdate_stmtContext) {
	localctx = NewUpdate_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 658, YQLParserRULE_update_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3994)
		p.Match(YQLParserUPDATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3995)
		p.Simple_table_ref()
	}
	p.SetState(4004)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserSET:
		{
			p.SetState(3996)
			p.Match(YQLParserSET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3997)
			p.Set_clause_choice()
		}
		p.SetState(4000)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserWHERE {
			{
				p.SetState(3998)
				p.Match(YQLParserWHERE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3999)
				p.Expr()
			}

		}


	case YQLParserON:
		{
			p.SetState(4002)
			p.Match(YQLParserON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4003)
			p.Into_values_source()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(4007)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserRETURNING {
		{
			p.SetState(4006)
			p.Returning_columns_list()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISet_clause_choiceContext is an interface to support dynamic dispatch.
type ISet_clause_choiceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Set_clause_list() ISet_clause_listContext
	Multiple_column_assignment() IMultiple_column_assignmentContext

	// IsSet_clause_choiceContext differentiates from other interfaces.
	IsSet_clause_choiceContext()
}

type Set_clause_choiceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_clause_choiceContext() *Set_clause_choiceContext {
	var p = new(Set_clause_choiceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_set_clause_choice
	return p
}

func InitEmptySet_clause_choiceContext(p *Set_clause_choiceContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_set_clause_choice
}

func (*Set_clause_choiceContext) IsSet_clause_choiceContext() {}

func NewSet_clause_choiceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_clause_choiceContext {
	var p = new(Set_clause_choiceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_set_clause_choice

	return p
}

func (s *Set_clause_choiceContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_clause_choiceContext) Set_clause_list() ISet_clause_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_clause_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_clause_listContext)
}

func (s *Set_clause_choiceContext) Multiple_column_assignment() IMultiple_column_assignmentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiple_column_assignmentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiple_column_assignmentContext)
}

func (s *Set_clause_choiceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_clause_choiceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Set_clause_choiceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterSet_clause_choice(s)
	}
}

func (s *Set_clause_choiceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitSet_clause_choice(s)
	}
}




func (p *YQLParser) Set_clause_choice() (localctx ISet_clause_choiceContext) {
	localctx = NewSet_clause_choiceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 660, YQLParserRULE_set_clause_choice)
	p.SetState(4011)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALL, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserANY, YQLParserARRAY, YQLParserAS, YQLParserASC, YQLParserASSUME, YQLParserASYMMETRIC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBETWEEN, YQLParserBITCAST, YQLParserBY, YQLParserCASCADE, YQLParserCASE, YQLParserCAST, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOLUMN, YQLParserCOLUMNS, YQLParserCOMMIT, YQLParserCOMPACT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCUBE, YQLParserCURRENT, YQLParserCURRENT_DATE, YQLParserCURRENT_TIME, YQLParserCURRENT_TIMESTAMP, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDISTINCT, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserEMPTY_ACTION, YQLParserENCRYPTED, YQLParserEND, YQLParserERASE, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCEPT, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXISTS, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFROM, YQLParserFULL, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserGROUPS, YQLParserHASH, YQLParserHAVING, YQLParserHOP, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTERSECT, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserJSON_EXISTS, YQLParserJSON_QUERY, YQLParserJSON_VALUE, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLIMIT, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOT, YQLParserNOTNULL, YQLParserNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserPROCESS, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserRANGE, YQLParserREDUCE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserRETURN, YQLParserRETURNING, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROLLUP, YQLParserROW, YQLParserROWS, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSCHEMA, YQLParserSECONDS, YQLParserSEEK, YQLParserSELECT, YQLParserSEMI, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSTREAM, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYMMETRIC, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTYPE, YQLParserUNBOUNDED, YQLParserUNCONDITIONAL, YQLParserUNION, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWHEN, YQLParserWHERE, YQLParserWINDOW, YQLParserWITH, YQLParserWITHOUT, YQLParserWRAPPER, YQLParserXOR, YQLParserSTRING_VALUE, YQLParserID_PLAIN, YQLParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4009)
			p.Set_clause_list()
		}


	case YQLParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4010)
			p.Multiple_column_assignment()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISet_clause_listContext is an interface to support dynamic dispatch.
type ISet_clause_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSet_clause() []ISet_clauseContext
	Set_clause(i int) ISet_clauseContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSet_clause_listContext differentiates from other interfaces.
	IsSet_clause_listContext()
}

type Set_clause_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_clause_listContext() *Set_clause_listContext {
	var p = new(Set_clause_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_set_clause_list
	return p
}

func InitEmptySet_clause_listContext(p *Set_clause_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_set_clause_list
}

func (*Set_clause_listContext) IsSet_clause_listContext() {}

func NewSet_clause_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_clause_listContext {
	var p = new(Set_clause_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_set_clause_list

	return p
}

func (s *Set_clause_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_clause_listContext) AllSet_clause() []ISet_clauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISet_clauseContext); ok {
			len++
		}
	}

	tst := make([]ISet_clauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISet_clauseContext); ok {
			tst[i] = t.(ISet_clauseContext)
			i++
		}
	}

	return tst
}

func (s *Set_clause_listContext) Set_clause(i int) ISet_clauseContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_clauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_clauseContext)
}

func (s *Set_clause_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Set_clause_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Set_clause_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_clause_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Set_clause_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterSet_clause_list(s)
	}
}

func (s *Set_clause_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitSet_clause_list(s)
	}
}




func (p *YQLParser) Set_clause_list() (localctx ISet_clause_listContext) {
	localctx = NewSet_clause_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 662, YQLParserRULE_set_clause_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4013)
		p.Set_clause()
	}
	p.SetState(4018)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(4014)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4015)
			p.Set_clause()
		}


		p.SetState(4020)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISet_clauseContext is an interface to support dynamic dispatch.
type ISet_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Set_target() ISet_targetContext
	EQUALS() antlr.TerminalNode
	Expr() IExprContext

	// IsSet_clauseContext differentiates from other interfaces.
	IsSet_clauseContext()
}

type Set_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_clauseContext() *Set_clauseContext {
	var p = new(Set_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_set_clause
	return p
}

func InitEmptySet_clauseContext(p *Set_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_set_clause
}

func (*Set_clauseContext) IsSet_clauseContext() {}

func NewSet_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_clauseContext {
	var p = new(Set_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_set_clause

	return p
}

func (s *Set_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_clauseContext) Set_target() ISet_targetContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_targetContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_targetContext)
}

func (s *Set_clauseContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(YQLParserEQUALS, 0)
}

func (s *Set_clauseContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Set_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Set_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterSet_clause(s)
	}
}

func (s *Set_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitSet_clause(s)
	}
}




func (p *YQLParser) Set_clause() (localctx ISet_clauseContext) {
	localctx = NewSet_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 664, YQLParserRULE_set_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4021)
		p.Set_target()
	}
	{
		p.SetState(4022)
		p.Match(YQLParserEQUALS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4023)
		p.Expr()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISet_targetContext is an interface to support dynamic dispatch.
type ISet_targetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Column_name() IColumn_nameContext

	// IsSet_targetContext differentiates from other interfaces.
	IsSet_targetContext()
}

type Set_targetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_targetContext() *Set_targetContext {
	var p = new(Set_targetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_set_target
	return p
}

func InitEmptySet_targetContext(p *Set_targetContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_set_target
}

func (*Set_targetContext) IsSet_targetContext() {}

func NewSet_targetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_targetContext {
	var p = new(Set_targetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_set_target

	return p
}

func (s *Set_targetContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_targetContext) Column_name() IColumn_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Set_targetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_targetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Set_targetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterSet_target(s)
	}
}

func (s *Set_targetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitSet_target(s)
	}
}




func (p *YQLParser) Set_target() (localctx ISet_targetContext) {
	localctx = NewSet_targetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 666, YQLParserRULE_set_target)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4025)
		p.Column_name()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IMultiple_column_assignmentContext is an interface to support dynamic dispatch.
type IMultiple_column_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Set_target_list() ISet_target_listContext
	EQUALS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Simple_values_source() ISimple_values_sourceContext
	RPAREN() antlr.TerminalNode

	// IsMultiple_column_assignmentContext differentiates from other interfaces.
	IsMultiple_column_assignmentContext()
}

type Multiple_column_assignmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiple_column_assignmentContext() *Multiple_column_assignmentContext {
	var p = new(Multiple_column_assignmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_multiple_column_assignment
	return p
}

func InitEmptyMultiple_column_assignmentContext(p *Multiple_column_assignmentContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_multiple_column_assignment
}

func (*Multiple_column_assignmentContext) IsMultiple_column_assignmentContext() {}

func NewMultiple_column_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Multiple_column_assignmentContext {
	var p = new(Multiple_column_assignmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_multiple_column_assignment

	return p
}

func (s *Multiple_column_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Multiple_column_assignmentContext) Set_target_list() ISet_target_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_target_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_target_listContext)
}

func (s *Multiple_column_assignmentContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(YQLParserEQUALS, 0)
}

func (s *Multiple_column_assignmentContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Multiple_column_assignmentContext) Simple_values_source() ISimple_values_sourceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_values_sourceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_values_sourceContext)
}

func (s *Multiple_column_assignmentContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Multiple_column_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Multiple_column_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Multiple_column_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterMultiple_column_assignment(s)
	}
}

func (s *Multiple_column_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitMultiple_column_assignment(s)
	}
}




func (p *YQLParser) Multiple_column_assignment() (localctx IMultiple_column_assignmentContext) {
	localctx = NewMultiple_column_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 668, YQLParserRULE_multiple_column_assignment)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4027)
		p.Set_target_list()
	}
	{
		p.SetState(4028)
		p.Match(YQLParserEQUALS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4029)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4030)
		p.Simple_values_source()
	}
	{
		p.SetState(4031)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISet_target_listContext is an interface to support dynamic dispatch.
type ISet_target_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllSet_target() []ISet_targetContext
	Set_target(i int) ISet_targetContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSet_target_listContext differentiates from other interfaces.
	IsSet_target_listContext()
}

type Set_target_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_target_listContext() *Set_target_listContext {
	var p = new(Set_target_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_set_target_list
	return p
}

func InitEmptySet_target_listContext(p *Set_target_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_set_target_list
}

func (*Set_target_listContext) IsSet_target_listContext() {}

func NewSet_target_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_target_listContext {
	var p = new(Set_target_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_set_target_list

	return p
}

func (s *Set_target_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_target_listContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Set_target_listContext) AllSet_target() []ISet_targetContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISet_targetContext); ok {
			len++
		}
	}

	tst := make([]ISet_targetContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISet_targetContext); ok {
			tst[i] = t.(ISet_targetContext)
			i++
		}
	}

	return tst
}

func (s *Set_target_listContext) Set_target(i int) ISet_targetContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_targetContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_targetContext)
}

func (s *Set_target_listContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Set_target_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Set_target_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Set_target_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_target_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Set_target_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterSet_target_list(s)
	}
}

func (s *Set_target_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitSet_target_list(s)
	}
}




func (p *YQLParser) Set_target_list() (localctx ISet_target_listContext) {
	localctx = NewSet_target_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 670, YQLParserRULE_set_target_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4033)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4034)
		p.Set_target()
	}
	p.SetState(4039)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(4035)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4036)
			p.Set_target()
		}


		p.SetState(4041)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4042)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_topic_stmtContext is an interface to support dynamic dispatch.
type ICreate_topic_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	TOPIC() antlr.TerminalNode
	Topic_ref() ITopic_refContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	Create_topic_entries() ICreate_topic_entriesContext
	With_topic_settings() IWith_topic_settingsContext

	// IsCreate_topic_stmtContext differentiates from other interfaces.
	IsCreate_topic_stmtContext()
}

type Create_topic_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_topic_stmtContext() *Create_topic_stmtContext {
	var p = new(Create_topic_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_create_topic_stmt
	return p
}

func InitEmptyCreate_topic_stmtContext(p *Create_topic_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_create_topic_stmt
}

func (*Create_topic_stmtContext) IsCreate_topic_stmtContext() {}

func NewCreate_topic_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_topic_stmtContext {
	var p = new(Create_topic_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_create_topic_stmt

	return p
}

func (s *Create_topic_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_topic_stmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(YQLParserCREATE, 0)
}

func (s *Create_topic_stmtContext) TOPIC() antlr.TerminalNode {
	return s.GetToken(YQLParserTOPIC, 0)
}

func (s *Create_topic_stmtContext) Topic_ref() ITopic_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopic_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopic_refContext)
}

func (s *Create_topic_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(YQLParserIF, 0)
}

func (s *Create_topic_stmtContext) NOT() antlr.TerminalNode {
	return s.GetToken(YQLParserNOT, 0)
}

func (s *Create_topic_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(YQLParserEXISTS, 0)
}

func (s *Create_topic_stmtContext) Create_topic_entries() ICreate_topic_entriesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_topic_entriesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_topic_entriesContext)
}

func (s *Create_topic_stmtContext) With_topic_settings() IWith_topic_settingsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWith_topic_settingsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWith_topic_settingsContext)
}

func (s *Create_topic_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_topic_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_topic_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterCreate_topic_stmt(s)
	}
}

func (s *Create_topic_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitCreate_topic_stmt(s)
	}
}




func (p *YQLParser) Create_topic_stmt() (localctx ICreate_topic_stmtContext) {
	localctx = NewCreate_topic_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 672, YQLParserRULE_create_topic_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4044)
		p.Match(YQLParserCREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4045)
		p.Match(YQLParserTOPIC)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4049)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 436, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4046)
			p.Match(YQLParserIF)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4047)
			p.Match(YQLParserNOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4048)
			p.Match(YQLParserEXISTS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(4051)
		p.Topic_ref()
	}
	p.SetState(4053)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserLPAREN {
		{
			p.SetState(4052)
			p.Create_topic_entries()
		}

	}
	p.SetState(4056)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserWITH {
		{
			p.SetState(4055)
			p.With_topic_settings()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_topic_entriesContext is an interface to support dynamic dispatch.
type ICreate_topic_entriesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllCreate_topic_entry() []ICreate_topic_entryContext
	Create_topic_entry(i int) ICreate_topic_entryContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCreate_topic_entriesContext differentiates from other interfaces.
	IsCreate_topic_entriesContext()
}

type Create_topic_entriesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_topic_entriesContext() *Create_topic_entriesContext {
	var p = new(Create_topic_entriesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_create_topic_entries
	return p
}

func InitEmptyCreate_topic_entriesContext(p *Create_topic_entriesContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_create_topic_entries
}

func (*Create_topic_entriesContext) IsCreate_topic_entriesContext() {}

func NewCreate_topic_entriesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_topic_entriesContext {
	var p = new(Create_topic_entriesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_create_topic_entries

	return p
}

func (s *Create_topic_entriesContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_topic_entriesContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Create_topic_entriesContext) AllCreate_topic_entry() []ICreate_topic_entryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_topic_entryContext); ok {
			len++
		}
	}

	tst := make([]ICreate_topic_entryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_topic_entryContext); ok {
			tst[i] = t.(ICreate_topic_entryContext)
			i++
		}
	}

	return tst
}

func (s *Create_topic_entriesContext) Create_topic_entry(i int) ICreate_topic_entryContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_topic_entryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_topic_entryContext)
}

func (s *Create_topic_entriesContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Create_topic_entriesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Create_topic_entriesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Create_topic_entriesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_topic_entriesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_topic_entriesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterCreate_topic_entries(s)
	}
}

func (s *Create_topic_entriesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitCreate_topic_entries(s)
	}
}




func (p *YQLParser) Create_topic_entries() (localctx ICreate_topic_entriesContext) {
	localctx = NewCreate_topic_entriesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 674, YQLParserRULE_create_topic_entries)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4058)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4059)
		p.Create_topic_entry()
	}
	p.SetState(4064)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(4060)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4061)
			p.Create_topic_entry()
		}


		p.SetState(4066)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4067)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_topic_entryContext is an interface to support dynamic dispatch.
type ICreate_topic_entryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Topic_create_consumer_entry() ITopic_create_consumer_entryContext

	// IsCreate_topic_entryContext differentiates from other interfaces.
	IsCreate_topic_entryContext()
}

type Create_topic_entryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_topic_entryContext() *Create_topic_entryContext {
	var p = new(Create_topic_entryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_create_topic_entry
	return p
}

func InitEmptyCreate_topic_entryContext(p *Create_topic_entryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_create_topic_entry
}

func (*Create_topic_entryContext) IsCreate_topic_entryContext() {}

func NewCreate_topic_entryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_topic_entryContext {
	var p = new(Create_topic_entryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_create_topic_entry

	return p
}

func (s *Create_topic_entryContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_topic_entryContext) Topic_create_consumer_entry() ITopic_create_consumer_entryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopic_create_consumer_entryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopic_create_consumer_entryContext)
}

func (s *Create_topic_entryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_topic_entryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_topic_entryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterCreate_topic_entry(s)
	}
}

func (s *Create_topic_entryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitCreate_topic_entry(s)
	}
}




func (p *YQLParser) Create_topic_entry() (localctx ICreate_topic_entryContext) {
	localctx = NewCreate_topic_entryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 676, YQLParserRULE_create_topic_entry)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4069)
		p.Topic_create_consumer_entry()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWith_topic_settingsContext is an interface to support dynamic dispatch.
type IWith_topic_settingsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Topic_settings() ITopic_settingsContext
	RPAREN() antlr.TerminalNode

	// IsWith_topic_settingsContext differentiates from other interfaces.
	IsWith_topic_settingsContext()
}

type With_topic_settingsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWith_topic_settingsContext() *With_topic_settingsContext {
	var p = new(With_topic_settingsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_with_topic_settings
	return p
}

func InitEmptyWith_topic_settingsContext(p *With_topic_settingsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_with_topic_settings
}

func (*With_topic_settingsContext) IsWith_topic_settingsContext() {}

func NewWith_topic_settingsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *With_topic_settingsContext {
	var p = new(With_topic_settingsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_with_topic_settings

	return p
}

func (s *With_topic_settingsContext) GetParser() antlr.Parser { return s.parser }

func (s *With_topic_settingsContext) WITH() antlr.TerminalNode {
	return s.GetToken(YQLParserWITH, 0)
}

func (s *With_topic_settingsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *With_topic_settingsContext) Topic_settings() ITopic_settingsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopic_settingsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopic_settingsContext)
}

func (s *With_topic_settingsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *With_topic_settingsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *With_topic_settingsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *With_topic_settingsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterWith_topic_settings(s)
	}
}

func (s *With_topic_settingsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitWith_topic_settings(s)
	}
}




func (p *YQLParser) With_topic_settings() (localctx IWith_topic_settingsContext) {
	localctx = NewWith_topic_settingsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 678, YQLParserRULE_with_topic_settings)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4071)
		p.Match(YQLParserWITH)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4072)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4073)
		p.Topic_settings()
	}
	{
		p.SetState(4074)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_topic_stmtContext is an interface to support dynamic dispatch.
type IAlter_topic_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	TOPIC() antlr.TerminalNode
	Topic_ref() ITopic_refContext
	AllAlter_topic_action() []IAlter_topic_actionContext
	Alter_topic_action(i int) IAlter_topic_actionContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAlter_topic_stmtContext differentiates from other interfaces.
	IsAlter_topic_stmtContext()
}

type Alter_topic_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_topic_stmtContext() *Alter_topic_stmtContext {
	var p = new(Alter_topic_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_topic_stmt
	return p
}

func InitEmptyAlter_topic_stmtContext(p *Alter_topic_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_topic_stmt
}

func (*Alter_topic_stmtContext) IsAlter_topic_stmtContext() {}

func NewAlter_topic_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_topic_stmtContext {
	var p = new(Alter_topic_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_topic_stmt

	return p
}

func (s *Alter_topic_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_topic_stmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(YQLParserALTER, 0)
}

func (s *Alter_topic_stmtContext) TOPIC() antlr.TerminalNode {
	return s.GetToken(YQLParserTOPIC, 0)
}

func (s *Alter_topic_stmtContext) Topic_ref() ITopic_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopic_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopic_refContext)
}

func (s *Alter_topic_stmtContext) AllAlter_topic_action() []IAlter_topic_actionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlter_topic_actionContext); ok {
			len++
		}
	}

	tst := make([]IAlter_topic_actionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlter_topic_actionContext); ok {
			tst[i] = t.(IAlter_topic_actionContext)
			i++
		}
	}

	return tst
}

func (s *Alter_topic_stmtContext) Alter_topic_action(i int) IAlter_topic_actionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_topic_actionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_topic_actionContext)
}

func (s *Alter_topic_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(YQLParserIF, 0)
}

func (s *Alter_topic_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(YQLParserEXISTS, 0)
}

func (s *Alter_topic_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Alter_topic_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Alter_topic_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_topic_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_topic_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_topic_stmt(s)
	}
}

func (s *Alter_topic_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_topic_stmt(s)
	}
}




func (p *YQLParser) Alter_topic_stmt() (localctx IAlter_topic_stmtContext) {
	localctx = NewAlter_topic_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 680, YQLParserRULE_alter_topic_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4076)
		p.Match(YQLParserALTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4077)
		p.Match(YQLParserTOPIC)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4080)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 440, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4078)
			p.Match(YQLParserIF)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4079)
			p.Match(YQLParserEXISTS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(4082)
		p.Topic_ref()
	}
	{
		p.SetState(4083)
		p.Alter_topic_action()
	}
	p.SetState(4088)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(4084)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4085)
			p.Alter_topic_action()
		}


		p.SetState(4090)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_topic_actionContext is an interface to support dynamic dispatch.
type IAlter_topic_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Alter_topic_add_consumer() IAlter_topic_add_consumerContext
	Alter_topic_alter_consumer() IAlter_topic_alter_consumerContext
	Alter_topic_drop_consumer() IAlter_topic_drop_consumerContext
	Alter_topic_set_settings() IAlter_topic_set_settingsContext
	Alter_topic_reset_settings() IAlter_topic_reset_settingsContext

	// IsAlter_topic_actionContext differentiates from other interfaces.
	IsAlter_topic_actionContext()
}

type Alter_topic_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_topic_actionContext() *Alter_topic_actionContext {
	var p = new(Alter_topic_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_topic_action
	return p
}

func InitEmptyAlter_topic_actionContext(p *Alter_topic_actionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_topic_action
}

func (*Alter_topic_actionContext) IsAlter_topic_actionContext() {}

func NewAlter_topic_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_topic_actionContext {
	var p = new(Alter_topic_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_topic_action

	return p
}

func (s *Alter_topic_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_topic_actionContext) Alter_topic_add_consumer() IAlter_topic_add_consumerContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_topic_add_consumerContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_topic_add_consumerContext)
}

func (s *Alter_topic_actionContext) Alter_topic_alter_consumer() IAlter_topic_alter_consumerContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_topic_alter_consumerContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_topic_alter_consumerContext)
}

func (s *Alter_topic_actionContext) Alter_topic_drop_consumer() IAlter_topic_drop_consumerContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_topic_drop_consumerContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_topic_drop_consumerContext)
}

func (s *Alter_topic_actionContext) Alter_topic_set_settings() IAlter_topic_set_settingsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_topic_set_settingsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_topic_set_settingsContext)
}

func (s *Alter_topic_actionContext) Alter_topic_reset_settings() IAlter_topic_reset_settingsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_topic_reset_settingsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_topic_reset_settingsContext)
}

func (s *Alter_topic_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_topic_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_topic_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_topic_action(s)
	}
}

func (s *Alter_topic_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_topic_action(s)
	}
}




func (p *YQLParser) Alter_topic_action() (localctx IAlter_topic_actionContext) {
	localctx = NewAlter_topic_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 682, YQLParserRULE_alter_topic_action)
	p.SetState(4096)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserADD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4091)
			p.Alter_topic_add_consumer()
		}


	case YQLParserALTER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4092)
			p.Alter_topic_alter_consumer()
		}


	case YQLParserDROP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4093)
			p.Alter_topic_drop_consumer()
		}


	case YQLParserSET:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4094)
			p.Alter_topic_set_settings()
		}


	case YQLParserRESET:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4095)
			p.Alter_topic_reset_settings()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_topic_add_consumerContext is an interface to support dynamic dispatch.
type IAlter_topic_add_consumerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	Topic_create_consumer_entry() ITopic_create_consumer_entryContext

	// IsAlter_topic_add_consumerContext differentiates from other interfaces.
	IsAlter_topic_add_consumerContext()
}

type Alter_topic_add_consumerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_topic_add_consumerContext() *Alter_topic_add_consumerContext {
	var p = new(Alter_topic_add_consumerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_topic_add_consumer
	return p
}

func InitEmptyAlter_topic_add_consumerContext(p *Alter_topic_add_consumerContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_topic_add_consumer
}

func (*Alter_topic_add_consumerContext) IsAlter_topic_add_consumerContext() {}

func NewAlter_topic_add_consumerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_topic_add_consumerContext {
	var p = new(Alter_topic_add_consumerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_topic_add_consumer

	return p
}

func (s *Alter_topic_add_consumerContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_topic_add_consumerContext) ADD() antlr.TerminalNode {
	return s.GetToken(YQLParserADD, 0)
}

func (s *Alter_topic_add_consumerContext) Topic_create_consumer_entry() ITopic_create_consumer_entryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopic_create_consumer_entryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopic_create_consumer_entryContext)
}

func (s *Alter_topic_add_consumerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_topic_add_consumerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_topic_add_consumerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_topic_add_consumer(s)
	}
}

func (s *Alter_topic_add_consumerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_topic_add_consumer(s)
	}
}




func (p *YQLParser) Alter_topic_add_consumer() (localctx IAlter_topic_add_consumerContext) {
	localctx = NewAlter_topic_add_consumerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 684, YQLParserRULE_alter_topic_add_consumer)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4098)
		p.Match(YQLParserADD)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4099)
		p.Topic_create_consumer_entry()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITopic_create_consumer_entryContext is an interface to support dynamic dispatch.
type ITopic_create_consumer_entryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONSUMER() antlr.TerminalNode
	An_id() IAn_idContext
	Topic_consumer_with_settings() ITopic_consumer_with_settingsContext

	// IsTopic_create_consumer_entryContext differentiates from other interfaces.
	IsTopic_create_consumer_entryContext()
}

type Topic_create_consumer_entryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopic_create_consumer_entryContext() *Topic_create_consumer_entryContext {
	var p = new(Topic_create_consumer_entryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_topic_create_consumer_entry
	return p
}

func InitEmptyTopic_create_consumer_entryContext(p *Topic_create_consumer_entryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_topic_create_consumer_entry
}

func (*Topic_create_consumer_entryContext) IsTopic_create_consumer_entryContext() {}

func NewTopic_create_consumer_entryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Topic_create_consumer_entryContext {
	var p = new(Topic_create_consumer_entryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_topic_create_consumer_entry

	return p
}

func (s *Topic_create_consumer_entryContext) GetParser() antlr.Parser { return s.parser }

func (s *Topic_create_consumer_entryContext) CONSUMER() antlr.TerminalNode {
	return s.GetToken(YQLParserCONSUMER, 0)
}

func (s *Topic_create_consumer_entryContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Topic_create_consumer_entryContext) Topic_consumer_with_settings() ITopic_consumer_with_settingsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopic_consumer_with_settingsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopic_consumer_with_settingsContext)
}

func (s *Topic_create_consumer_entryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Topic_create_consumer_entryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Topic_create_consumer_entryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterTopic_create_consumer_entry(s)
	}
}

func (s *Topic_create_consumer_entryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitTopic_create_consumer_entry(s)
	}
}




func (p *YQLParser) Topic_create_consumer_entry() (localctx ITopic_create_consumer_entryContext) {
	localctx = NewTopic_create_consumer_entryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 686, YQLParserRULE_topic_create_consumer_entry)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4101)
		p.Match(YQLParserCONSUMER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4102)
		p.An_id()
	}
	p.SetState(4104)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserWITH {
		{
			p.SetState(4103)
			p.Topic_consumer_with_settings()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_topic_alter_consumerContext is an interface to support dynamic dispatch.
type IAlter_topic_alter_consumerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	CONSUMER() antlr.TerminalNode
	Topic_consumer_ref() ITopic_consumer_refContext
	Alter_topic_alter_consumer_entry() IAlter_topic_alter_consumer_entryContext

	// IsAlter_topic_alter_consumerContext differentiates from other interfaces.
	IsAlter_topic_alter_consumerContext()
}

type Alter_topic_alter_consumerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_topic_alter_consumerContext() *Alter_topic_alter_consumerContext {
	var p = new(Alter_topic_alter_consumerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_topic_alter_consumer
	return p
}

func InitEmptyAlter_topic_alter_consumerContext(p *Alter_topic_alter_consumerContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_topic_alter_consumer
}

func (*Alter_topic_alter_consumerContext) IsAlter_topic_alter_consumerContext() {}

func NewAlter_topic_alter_consumerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_topic_alter_consumerContext {
	var p = new(Alter_topic_alter_consumerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_topic_alter_consumer

	return p
}

func (s *Alter_topic_alter_consumerContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_topic_alter_consumerContext) ALTER() antlr.TerminalNode {
	return s.GetToken(YQLParserALTER, 0)
}

func (s *Alter_topic_alter_consumerContext) CONSUMER() antlr.TerminalNode {
	return s.GetToken(YQLParserCONSUMER, 0)
}

func (s *Alter_topic_alter_consumerContext) Topic_consumer_ref() ITopic_consumer_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopic_consumer_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopic_consumer_refContext)
}

func (s *Alter_topic_alter_consumerContext) Alter_topic_alter_consumer_entry() IAlter_topic_alter_consumer_entryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_topic_alter_consumer_entryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_topic_alter_consumer_entryContext)
}

func (s *Alter_topic_alter_consumerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_topic_alter_consumerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_topic_alter_consumerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_topic_alter_consumer(s)
	}
}

func (s *Alter_topic_alter_consumerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_topic_alter_consumer(s)
	}
}




func (p *YQLParser) Alter_topic_alter_consumer() (localctx IAlter_topic_alter_consumerContext) {
	localctx = NewAlter_topic_alter_consumerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 688, YQLParserRULE_alter_topic_alter_consumer)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4106)
		p.Match(YQLParserALTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4107)
		p.Match(YQLParserCONSUMER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4108)
		p.Topic_consumer_ref()
	}
	{
		p.SetState(4109)
		p.Alter_topic_alter_consumer_entry()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_topic_alter_consumer_entryContext is an interface to support dynamic dispatch.
type IAlter_topic_alter_consumer_entryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Topic_alter_consumer_set() ITopic_alter_consumer_setContext
	Topic_alter_consumer_reset() ITopic_alter_consumer_resetContext

	// IsAlter_topic_alter_consumer_entryContext differentiates from other interfaces.
	IsAlter_topic_alter_consumer_entryContext()
}

type Alter_topic_alter_consumer_entryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_topic_alter_consumer_entryContext() *Alter_topic_alter_consumer_entryContext {
	var p = new(Alter_topic_alter_consumer_entryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_topic_alter_consumer_entry
	return p
}

func InitEmptyAlter_topic_alter_consumer_entryContext(p *Alter_topic_alter_consumer_entryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_topic_alter_consumer_entry
}

func (*Alter_topic_alter_consumer_entryContext) IsAlter_topic_alter_consumer_entryContext() {}

func NewAlter_topic_alter_consumer_entryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_topic_alter_consumer_entryContext {
	var p = new(Alter_topic_alter_consumer_entryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_topic_alter_consumer_entry

	return p
}

func (s *Alter_topic_alter_consumer_entryContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_topic_alter_consumer_entryContext) Topic_alter_consumer_set() ITopic_alter_consumer_setContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopic_alter_consumer_setContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopic_alter_consumer_setContext)
}

func (s *Alter_topic_alter_consumer_entryContext) Topic_alter_consumer_reset() ITopic_alter_consumer_resetContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopic_alter_consumer_resetContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopic_alter_consumer_resetContext)
}

func (s *Alter_topic_alter_consumer_entryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_topic_alter_consumer_entryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_topic_alter_consumer_entryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_topic_alter_consumer_entry(s)
	}
}

func (s *Alter_topic_alter_consumer_entryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_topic_alter_consumer_entry(s)
	}
}




func (p *YQLParser) Alter_topic_alter_consumer_entry() (localctx IAlter_topic_alter_consumer_entryContext) {
	localctx = NewAlter_topic_alter_consumer_entryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 690, YQLParserRULE_alter_topic_alter_consumer_entry)
	p.SetState(4113)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserSET:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4111)
			p.Topic_alter_consumer_set()
		}


	case YQLParserRESET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4112)
			p.Topic_alter_consumer_reset()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_topic_drop_consumerContext is an interface to support dynamic dispatch.
type IAlter_topic_drop_consumerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	CONSUMER() antlr.TerminalNode
	Topic_consumer_ref() ITopic_consumer_refContext

	// IsAlter_topic_drop_consumerContext differentiates from other interfaces.
	IsAlter_topic_drop_consumerContext()
}

type Alter_topic_drop_consumerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_topic_drop_consumerContext() *Alter_topic_drop_consumerContext {
	var p = new(Alter_topic_drop_consumerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_topic_drop_consumer
	return p
}

func InitEmptyAlter_topic_drop_consumerContext(p *Alter_topic_drop_consumerContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_topic_drop_consumer
}

func (*Alter_topic_drop_consumerContext) IsAlter_topic_drop_consumerContext() {}

func NewAlter_topic_drop_consumerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_topic_drop_consumerContext {
	var p = new(Alter_topic_drop_consumerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_topic_drop_consumer

	return p
}

func (s *Alter_topic_drop_consumerContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_topic_drop_consumerContext) DROP() antlr.TerminalNode {
	return s.GetToken(YQLParserDROP, 0)
}

func (s *Alter_topic_drop_consumerContext) CONSUMER() antlr.TerminalNode {
	return s.GetToken(YQLParserCONSUMER, 0)
}

func (s *Alter_topic_drop_consumerContext) Topic_consumer_ref() ITopic_consumer_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopic_consumer_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopic_consumer_refContext)
}

func (s *Alter_topic_drop_consumerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_topic_drop_consumerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_topic_drop_consumerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_topic_drop_consumer(s)
	}
}

func (s *Alter_topic_drop_consumerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_topic_drop_consumer(s)
	}
}




func (p *YQLParser) Alter_topic_drop_consumer() (localctx IAlter_topic_drop_consumerContext) {
	localctx = NewAlter_topic_drop_consumerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 692, YQLParserRULE_alter_topic_drop_consumer)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4115)
		p.Match(YQLParserDROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4116)
		p.Match(YQLParserCONSUMER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4117)
		p.Topic_consumer_ref()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITopic_alter_consumer_setContext is an interface to support dynamic dispatch.
type ITopic_alter_consumer_setContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Topic_consumer_settings() ITopic_consumer_settingsContext
	RPAREN() antlr.TerminalNode

	// IsTopic_alter_consumer_setContext differentiates from other interfaces.
	IsTopic_alter_consumer_setContext()
}

type Topic_alter_consumer_setContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopic_alter_consumer_setContext() *Topic_alter_consumer_setContext {
	var p = new(Topic_alter_consumer_setContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_topic_alter_consumer_set
	return p
}

func InitEmptyTopic_alter_consumer_setContext(p *Topic_alter_consumer_setContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_topic_alter_consumer_set
}

func (*Topic_alter_consumer_setContext) IsTopic_alter_consumer_setContext() {}

func NewTopic_alter_consumer_setContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Topic_alter_consumer_setContext {
	var p = new(Topic_alter_consumer_setContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_topic_alter_consumer_set

	return p
}

func (s *Topic_alter_consumer_setContext) GetParser() antlr.Parser { return s.parser }

func (s *Topic_alter_consumer_setContext) SET() antlr.TerminalNode {
	return s.GetToken(YQLParserSET, 0)
}

func (s *Topic_alter_consumer_setContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Topic_alter_consumer_setContext) Topic_consumer_settings() ITopic_consumer_settingsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopic_consumer_settingsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopic_consumer_settingsContext)
}

func (s *Topic_alter_consumer_setContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Topic_alter_consumer_setContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Topic_alter_consumer_setContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Topic_alter_consumer_setContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterTopic_alter_consumer_set(s)
	}
}

func (s *Topic_alter_consumer_setContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitTopic_alter_consumer_set(s)
	}
}




func (p *YQLParser) Topic_alter_consumer_set() (localctx ITopic_alter_consumer_setContext) {
	localctx = NewTopic_alter_consumer_setContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 694, YQLParserRULE_topic_alter_consumer_set)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4119)
		p.Match(YQLParserSET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4120)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4121)
		p.Topic_consumer_settings()
	}
	{
		p.SetState(4122)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITopic_alter_consumer_resetContext is an interface to support dynamic dispatch.
type ITopic_alter_consumer_resetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESET() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllAn_id() []IAn_idContext
	An_id(i int) IAn_idContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTopic_alter_consumer_resetContext differentiates from other interfaces.
	IsTopic_alter_consumer_resetContext()
}

type Topic_alter_consumer_resetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopic_alter_consumer_resetContext() *Topic_alter_consumer_resetContext {
	var p = new(Topic_alter_consumer_resetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_topic_alter_consumer_reset
	return p
}

func InitEmptyTopic_alter_consumer_resetContext(p *Topic_alter_consumer_resetContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_topic_alter_consumer_reset
}

func (*Topic_alter_consumer_resetContext) IsTopic_alter_consumer_resetContext() {}

func NewTopic_alter_consumer_resetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Topic_alter_consumer_resetContext {
	var p = new(Topic_alter_consumer_resetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_topic_alter_consumer_reset

	return p
}

func (s *Topic_alter_consumer_resetContext) GetParser() antlr.Parser { return s.parser }

func (s *Topic_alter_consumer_resetContext) RESET() antlr.TerminalNode {
	return s.GetToken(YQLParserRESET, 0)
}

func (s *Topic_alter_consumer_resetContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Topic_alter_consumer_resetContext) AllAn_id() []IAn_idContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAn_idContext); ok {
			len++
		}
	}

	tst := make([]IAn_idContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAn_idContext); ok {
			tst[i] = t.(IAn_idContext)
			i++
		}
	}

	return tst
}

func (s *Topic_alter_consumer_resetContext) An_id(i int) IAn_idContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Topic_alter_consumer_resetContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Topic_alter_consumer_resetContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Topic_alter_consumer_resetContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Topic_alter_consumer_resetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Topic_alter_consumer_resetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Topic_alter_consumer_resetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterTopic_alter_consumer_reset(s)
	}
}

func (s *Topic_alter_consumer_resetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitTopic_alter_consumer_reset(s)
	}
}




func (p *YQLParser) Topic_alter_consumer_reset() (localctx ITopic_alter_consumer_resetContext) {
	localctx = NewTopic_alter_consumer_resetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 696, YQLParserRULE_topic_alter_consumer_reset)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4124)
		p.Match(YQLParserRESET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4125)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4126)
		p.An_id()
	}
	p.SetState(4131)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(4127)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4128)
			p.An_id()
		}


		p.SetState(4133)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4134)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_topic_set_settingsContext is an interface to support dynamic dispatch.
type IAlter_topic_set_settingsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Topic_settings() ITopic_settingsContext
	RPAREN() antlr.TerminalNode

	// IsAlter_topic_set_settingsContext differentiates from other interfaces.
	IsAlter_topic_set_settingsContext()
}

type Alter_topic_set_settingsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_topic_set_settingsContext() *Alter_topic_set_settingsContext {
	var p = new(Alter_topic_set_settingsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_topic_set_settings
	return p
}

func InitEmptyAlter_topic_set_settingsContext(p *Alter_topic_set_settingsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_topic_set_settings
}

func (*Alter_topic_set_settingsContext) IsAlter_topic_set_settingsContext() {}

func NewAlter_topic_set_settingsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_topic_set_settingsContext {
	var p = new(Alter_topic_set_settingsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_topic_set_settings

	return p
}

func (s *Alter_topic_set_settingsContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_topic_set_settingsContext) SET() antlr.TerminalNode {
	return s.GetToken(YQLParserSET, 0)
}

func (s *Alter_topic_set_settingsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Alter_topic_set_settingsContext) Topic_settings() ITopic_settingsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopic_settingsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopic_settingsContext)
}

func (s *Alter_topic_set_settingsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Alter_topic_set_settingsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_topic_set_settingsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_topic_set_settingsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_topic_set_settings(s)
	}
}

func (s *Alter_topic_set_settingsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_topic_set_settings(s)
	}
}




func (p *YQLParser) Alter_topic_set_settings() (localctx IAlter_topic_set_settingsContext) {
	localctx = NewAlter_topic_set_settingsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 698, YQLParserRULE_alter_topic_set_settings)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4136)
		p.Match(YQLParserSET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4137)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4138)
		p.Topic_settings()
	}
	{
		p.SetState(4139)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_topic_reset_settingsContext is an interface to support dynamic dispatch.
type IAlter_topic_reset_settingsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESET() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	An_id() IAn_idContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllAn_id_pure() []IAn_id_pureContext
	An_id_pure(i int) IAn_id_pureContext

	// IsAlter_topic_reset_settingsContext differentiates from other interfaces.
	IsAlter_topic_reset_settingsContext()
}

type Alter_topic_reset_settingsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_topic_reset_settingsContext() *Alter_topic_reset_settingsContext {
	var p = new(Alter_topic_reset_settingsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_topic_reset_settings
	return p
}

func InitEmptyAlter_topic_reset_settingsContext(p *Alter_topic_reset_settingsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_topic_reset_settings
}

func (*Alter_topic_reset_settingsContext) IsAlter_topic_reset_settingsContext() {}

func NewAlter_topic_reset_settingsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_topic_reset_settingsContext {
	var p = new(Alter_topic_reset_settingsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_topic_reset_settings

	return p
}

func (s *Alter_topic_reset_settingsContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_topic_reset_settingsContext) RESET() antlr.TerminalNode {
	return s.GetToken(YQLParserRESET, 0)
}

func (s *Alter_topic_reset_settingsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Alter_topic_reset_settingsContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Alter_topic_reset_settingsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Alter_topic_reset_settingsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Alter_topic_reset_settingsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Alter_topic_reset_settingsContext) AllAn_id_pure() []IAn_id_pureContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAn_id_pureContext); ok {
			len++
		}
	}

	tst := make([]IAn_id_pureContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAn_id_pureContext); ok {
			tst[i] = t.(IAn_id_pureContext)
			i++
		}
	}

	return tst
}

func (s *Alter_topic_reset_settingsContext) An_id_pure(i int) IAn_id_pureContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_pureContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_pureContext)
}

func (s *Alter_topic_reset_settingsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_topic_reset_settingsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_topic_reset_settingsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_topic_reset_settings(s)
	}
}

func (s *Alter_topic_reset_settingsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_topic_reset_settings(s)
	}
}




func (p *YQLParser) Alter_topic_reset_settings() (localctx IAlter_topic_reset_settingsContext) {
	localctx = NewAlter_topic_reset_settingsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 700, YQLParserRULE_alter_topic_reset_settings)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4141)
		p.Match(YQLParserRESET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4142)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4143)
		p.An_id()
	}
	p.SetState(4148)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(4144)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4145)
			p.An_id_pure()
		}


		p.SetState(4150)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4151)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDrop_topic_stmtContext is an interface to support dynamic dispatch.
type IDrop_topic_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	TOPIC() antlr.TerminalNode
	Topic_ref() ITopic_refContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDrop_topic_stmtContext differentiates from other interfaces.
	IsDrop_topic_stmtContext()
}

type Drop_topic_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_topic_stmtContext() *Drop_topic_stmtContext {
	var p = new(Drop_topic_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_drop_topic_stmt
	return p
}

func InitEmptyDrop_topic_stmtContext(p *Drop_topic_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_drop_topic_stmt
}

func (*Drop_topic_stmtContext) IsDrop_topic_stmtContext() {}

func NewDrop_topic_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_topic_stmtContext {
	var p = new(Drop_topic_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_drop_topic_stmt

	return p
}

func (s *Drop_topic_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_topic_stmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(YQLParserDROP, 0)
}

func (s *Drop_topic_stmtContext) TOPIC() antlr.TerminalNode {
	return s.GetToken(YQLParserTOPIC, 0)
}

func (s *Drop_topic_stmtContext) Topic_ref() ITopic_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopic_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopic_refContext)
}

func (s *Drop_topic_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(YQLParserIF, 0)
}

func (s *Drop_topic_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(YQLParserEXISTS, 0)
}

func (s *Drop_topic_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_topic_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Drop_topic_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterDrop_topic_stmt(s)
	}
}

func (s *Drop_topic_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitDrop_topic_stmt(s)
	}
}




func (p *YQLParser) Drop_topic_stmt() (localctx IDrop_topic_stmtContext) {
	localctx = NewDrop_topic_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 702, YQLParserRULE_drop_topic_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4153)
		p.Match(YQLParserDROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4154)
		p.Match(YQLParserTOPIC)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4157)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 447, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4155)
			p.Match(YQLParserIF)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4156)
			p.Match(YQLParserEXISTS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(4159)
		p.Topic_ref()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITopic_settingsContext is an interface to support dynamic dispatch.
type ITopic_settingsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTopic_settings_entry() []ITopic_settings_entryContext
	Topic_settings_entry(i int) ITopic_settings_entryContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTopic_settingsContext differentiates from other interfaces.
	IsTopic_settingsContext()
}

type Topic_settingsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopic_settingsContext() *Topic_settingsContext {
	var p = new(Topic_settingsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_topic_settings
	return p
}

func InitEmptyTopic_settingsContext(p *Topic_settingsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_topic_settings
}

func (*Topic_settingsContext) IsTopic_settingsContext() {}

func NewTopic_settingsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Topic_settingsContext {
	var p = new(Topic_settingsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_topic_settings

	return p
}

func (s *Topic_settingsContext) GetParser() antlr.Parser { return s.parser }

func (s *Topic_settingsContext) AllTopic_settings_entry() []ITopic_settings_entryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITopic_settings_entryContext); ok {
			len++
		}
	}

	tst := make([]ITopic_settings_entryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITopic_settings_entryContext); ok {
			tst[i] = t.(ITopic_settings_entryContext)
			i++
		}
	}

	return tst
}

func (s *Topic_settingsContext) Topic_settings_entry(i int) ITopic_settings_entryContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopic_settings_entryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopic_settings_entryContext)
}

func (s *Topic_settingsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Topic_settingsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Topic_settingsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Topic_settingsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Topic_settingsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterTopic_settings(s)
	}
}

func (s *Topic_settingsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitTopic_settings(s)
	}
}




func (p *YQLParser) Topic_settings() (localctx ITopic_settingsContext) {
	localctx = NewTopic_settingsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 704, YQLParserRULE_topic_settings)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4161)
		p.Topic_settings_entry()
	}
	p.SetState(4166)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(4162)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4163)
			p.Topic_settings_entry()
		}


		p.SetState(4168)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITopic_settings_entryContext is an interface to support dynamic dispatch.
type ITopic_settings_entryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id() IAn_idContext
	EQUALS() antlr.TerminalNode
	Topic_setting_value() ITopic_setting_valueContext

	// IsTopic_settings_entryContext differentiates from other interfaces.
	IsTopic_settings_entryContext()
}

type Topic_settings_entryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopic_settings_entryContext() *Topic_settings_entryContext {
	var p = new(Topic_settings_entryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_topic_settings_entry
	return p
}

func InitEmptyTopic_settings_entryContext(p *Topic_settings_entryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_topic_settings_entry
}

func (*Topic_settings_entryContext) IsTopic_settings_entryContext() {}

func NewTopic_settings_entryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Topic_settings_entryContext {
	var p = new(Topic_settings_entryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_topic_settings_entry

	return p
}

func (s *Topic_settings_entryContext) GetParser() antlr.Parser { return s.parser }

func (s *Topic_settings_entryContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Topic_settings_entryContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(YQLParserEQUALS, 0)
}

func (s *Topic_settings_entryContext) Topic_setting_value() ITopic_setting_valueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopic_setting_valueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopic_setting_valueContext)
}

func (s *Topic_settings_entryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Topic_settings_entryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Topic_settings_entryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterTopic_settings_entry(s)
	}
}

func (s *Topic_settings_entryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitTopic_settings_entry(s)
	}
}




func (p *YQLParser) Topic_settings_entry() (localctx ITopic_settings_entryContext) {
	localctx = NewTopic_settings_entryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 706, YQLParserRULE_topic_settings_entry)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4169)
		p.An_id()
	}
	{
		p.SetState(4170)
		p.Match(YQLParserEQUALS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4171)
		p.Topic_setting_value()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITopic_setting_valueContext is an interface to support dynamic dispatch.
type ITopic_setting_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext

	// IsTopic_setting_valueContext differentiates from other interfaces.
	IsTopic_setting_valueContext()
}

type Topic_setting_valueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopic_setting_valueContext() *Topic_setting_valueContext {
	var p = new(Topic_setting_valueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_topic_setting_value
	return p
}

func InitEmptyTopic_setting_valueContext(p *Topic_setting_valueContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_topic_setting_value
}

func (*Topic_setting_valueContext) IsTopic_setting_valueContext() {}

func NewTopic_setting_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Topic_setting_valueContext {
	var p = new(Topic_setting_valueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_topic_setting_value

	return p
}

func (s *Topic_setting_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Topic_setting_valueContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Topic_setting_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Topic_setting_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Topic_setting_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterTopic_setting_value(s)
	}
}

func (s *Topic_setting_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitTopic_setting_value(s)
	}
}




func (p *YQLParser) Topic_setting_value() (localctx ITopic_setting_valueContext) {
	localctx = NewTopic_setting_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 708, YQLParserRULE_topic_setting_value)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4173)
		p.Expr()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITopic_consumer_with_settingsContext is an interface to support dynamic dispatch.
type ITopic_consumer_with_settingsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Topic_consumer_settings() ITopic_consumer_settingsContext
	RPAREN() antlr.TerminalNode

	// IsTopic_consumer_with_settingsContext differentiates from other interfaces.
	IsTopic_consumer_with_settingsContext()
}

type Topic_consumer_with_settingsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopic_consumer_with_settingsContext() *Topic_consumer_with_settingsContext {
	var p = new(Topic_consumer_with_settingsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_topic_consumer_with_settings
	return p
}

func InitEmptyTopic_consumer_with_settingsContext(p *Topic_consumer_with_settingsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_topic_consumer_with_settings
}

func (*Topic_consumer_with_settingsContext) IsTopic_consumer_with_settingsContext() {}

func NewTopic_consumer_with_settingsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Topic_consumer_with_settingsContext {
	var p = new(Topic_consumer_with_settingsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_topic_consumer_with_settings

	return p
}

func (s *Topic_consumer_with_settingsContext) GetParser() antlr.Parser { return s.parser }

func (s *Topic_consumer_with_settingsContext) WITH() antlr.TerminalNode {
	return s.GetToken(YQLParserWITH, 0)
}

func (s *Topic_consumer_with_settingsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Topic_consumer_with_settingsContext) Topic_consumer_settings() ITopic_consumer_settingsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopic_consumer_settingsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopic_consumer_settingsContext)
}

func (s *Topic_consumer_with_settingsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Topic_consumer_with_settingsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Topic_consumer_with_settingsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Topic_consumer_with_settingsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterTopic_consumer_with_settings(s)
	}
}

func (s *Topic_consumer_with_settingsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitTopic_consumer_with_settings(s)
	}
}




func (p *YQLParser) Topic_consumer_with_settings() (localctx ITopic_consumer_with_settingsContext) {
	localctx = NewTopic_consumer_with_settingsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 710, YQLParserRULE_topic_consumer_with_settings)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4175)
		p.Match(YQLParserWITH)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4176)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4177)
		p.Topic_consumer_settings()
	}
	{
		p.SetState(4178)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITopic_consumer_settingsContext is an interface to support dynamic dispatch.
type ITopic_consumer_settingsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTopic_consumer_settings_entry() []ITopic_consumer_settings_entryContext
	Topic_consumer_settings_entry(i int) ITopic_consumer_settings_entryContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTopic_consumer_settingsContext differentiates from other interfaces.
	IsTopic_consumer_settingsContext()
}

type Topic_consumer_settingsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopic_consumer_settingsContext() *Topic_consumer_settingsContext {
	var p = new(Topic_consumer_settingsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_topic_consumer_settings
	return p
}

func InitEmptyTopic_consumer_settingsContext(p *Topic_consumer_settingsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_topic_consumer_settings
}

func (*Topic_consumer_settingsContext) IsTopic_consumer_settingsContext() {}

func NewTopic_consumer_settingsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Topic_consumer_settingsContext {
	var p = new(Topic_consumer_settingsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_topic_consumer_settings

	return p
}

func (s *Topic_consumer_settingsContext) GetParser() antlr.Parser { return s.parser }

func (s *Topic_consumer_settingsContext) AllTopic_consumer_settings_entry() []ITopic_consumer_settings_entryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITopic_consumer_settings_entryContext); ok {
			len++
		}
	}

	tst := make([]ITopic_consumer_settings_entryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITopic_consumer_settings_entryContext); ok {
			tst[i] = t.(ITopic_consumer_settings_entryContext)
			i++
		}
	}

	return tst
}

func (s *Topic_consumer_settingsContext) Topic_consumer_settings_entry(i int) ITopic_consumer_settings_entryContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopic_consumer_settings_entryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopic_consumer_settings_entryContext)
}

func (s *Topic_consumer_settingsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Topic_consumer_settingsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Topic_consumer_settingsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Topic_consumer_settingsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Topic_consumer_settingsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterTopic_consumer_settings(s)
	}
}

func (s *Topic_consumer_settingsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitTopic_consumer_settings(s)
	}
}




func (p *YQLParser) Topic_consumer_settings() (localctx ITopic_consumer_settingsContext) {
	localctx = NewTopic_consumer_settingsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 712, YQLParserRULE_topic_consumer_settings)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4180)
		p.Topic_consumer_settings_entry()
	}
	p.SetState(4185)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(4181)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4182)
			p.Topic_consumer_settings_entry()
		}


		p.SetState(4187)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITopic_consumer_settings_entryContext is an interface to support dynamic dispatch.
type ITopic_consumer_settings_entryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id() IAn_idContext
	EQUALS() antlr.TerminalNode
	Topic_consumer_setting_value() ITopic_consumer_setting_valueContext

	// IsTopic_consumer_settings_entryContext differentiates from other interfaces.
	IsTopic_consumer_settings_entryContext()
}

type Topic_consumer_settings_entryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopic_consumer_settings_entryContext() *Topic_consumer_settings_entryContext {
	var p = new(Topic_consumer_settings_entryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_topic_consumer_settings_entry
	return p
}

func InitEmptyTopic_consumer_settings_entryContext(p *Topic_consumer_settings_entryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_topic_consumer_settings_entry
}

func (*Topic_consumer_settings_entryContext) IsTopic_consumer_settings_entryContext() {}

func NewTopic_consumer_settings_entryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Topic_consumer_settings_entryContext {
	var p = new(Topic_consumer_settings_entryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_topic_consumer_settings_entry

	return p
}

func (s *Topic_consumer_settings_entryContext) GetParser() antlr.Parser { return s.parser }

func (s *Topic_consumer_settings_entryContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Topic_consumer_settings_entryContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(YQLParserEQUALS, 0)
}

func (s *Topic_consumer_settings_entryContext) Topic_consumer_setting_value() ITopic_consumer_setting_valueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopic_consumer_setting_valueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopic_consumer_setting_valueContext)
}

func (s *Topic_consumer_settings_entryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Topic_consumer_settings_entryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Topic_consumer_settings_entryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterTopic_consumer_settings_entry(s)
	}
}

func (s *Topic_consumer_settings_entryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitTopic_consumer_settings_entry(s)
	}
}




func (p *YQLParser) Topic_consumer_settings_entry() (localctx ITopic_consumer_settings_entryContext) {
	localctx = NewTopic_consumer_settings_entryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 714, YQLParserRULE_topic_consumer_settings_entry)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4188)
		p.An_id()
	}
	{
		p.SetState(4189)
		p.Match(YQLParserEQUALS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4190)
		p.Topic_consumer_setting_value()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITopic_consumer_setting_valueContext is an interface to support dynamic dispatch.
type ITopic_consumer_setting_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext

	// IsTopic_consumer_setting_valueContext differentiates from other interfaces.
	IsTopic_consumer_setting_valueContext()
}

type Topic_consumer_setting_valueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopic_consumer_setting_valueContext() *Topic_consumer_setting_valueContext {
	var p = new(Topic_consumer_setting_valueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_topic_consumer_setting_value
	return p
}

func InitEmptyTopic_consumer_setting_valueContext(p *Topic_consumer_setting_valueContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_topic_consumer_setting_value
}

func (*Topic_consumer_setting_valueContext) IsTopic_consumer_setting_valueContext() {}

func NewTopic_consumer_setting_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Topic_consumer_setting_valueContext {
	var p = new(Topic_consumer_setting_valueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_topic_consumer_setting_value

	return p
}

func (s *Topic_consumer_setting_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Topic_consumer_setting_valueContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Topic_consumer_setting_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Topic_consumer_setting_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Topic_consumer_setting_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterTopic_consumer_setting_value(s)
	}
}

func (s *Topic_consumer_setting_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitTopic_consumer_setting_value(s)
	}
}




func (p *YQLParser) Topic_consumer_setting_value() (localctx ITopic_consumer_setting_valueContext) {
	localctx = NewTopic_consumer_setting_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 716, YQLParserRULE_topic_consumer_setting_value)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4192)
		p.Expr()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITopic_refContext is an interface to support dynamic dispatch.
type ITopic_refContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id() IAn_idContext
	Cluster_expr() ICluster_exprContext
	DOT() antlr.TerminalNode

	// IsTopic_refContext differentiates from other interfaces.
	IsTopic_refContext()
}

type Topic_refContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopic_refContext() *Topic_refContext {
	var p = new(Topic_refContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_topic_ref
	return p
}

func InitEmptyTopic_refContext(p *Topic_refContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_topic_ref
}

func (*Topic_refContext) IsTopic_refContext() {}

func NewTopic_refContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Topic_refContext {
	var p = new(Topic_refContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_topic_ref

	return p
}

func (s *Topic_refContext) GetParser() antlr.Parser { return s.parser }

func (s *Topic_refContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Topic_refContext) Cluster_expr() ICluster_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICluster_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICluster_exprContext)
}

func (s *Topic_refContext) DOT() antlr.TerminalNode {
	return s.GetToken(YQLParserDOT, 0)
}

func (s *Topic_refContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Topic_refContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Topic_refContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterTopic_ref(s)
	}
}

func (s *Topic_refContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitTopic_ref(s)
	}
}




func (p *YQLParser) Topic_ref() (localctx ITopic_refContext) {
	localctx = NewTopic_refContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 718, YQLParserRULE_topic_ref)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(4197)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 450, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4194)
			p.Cluster_expr()
		}
		{
			p.SetState(4195)
			p.Match(YQLParserDOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(4199)
		p.An_id()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITopic_consumer_refContext is an interface to support dynamic dispatch.
type ITopic_consumer_refContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id_pure() IAn_id_pureContext

	// IsTopic_consumer_refContext differentiates from other interfaces.
	IsTopic_consumer_refContext()
}

type Topic_consumer_refContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopic_consumer_refContext() *Topic_consumer_refContext {
	var p = new(Topic_consumer_refContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_topic_consumer_ref
	return p
}

func InitEmptyTopic_consumer_refContext(p *Topic_consumer_refContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_topic_consumer_ref
}

func (*Topic_consumer_refContext) IsTopic_consumer_refContext() {}

func NewTopic_consumer_refContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Topic_consumer_refContext {
	var p = new(Topic_consumer_refContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_topic_consumer_ref

	return p
}

func (s *Topic_consumer_refContext) GetParser() antlr.Parser { return s.parser }

func (s *Topic_consumer_refContext) An_id_pure() IAn_id_pureContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_pureContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_pureContext)
}

func (s *Topic_consumer_refContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Topic_consumer_refContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Topic_consumer_refContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterTopic_consumer_ref(s)
	}
}

func (s *Topic_consumer_refContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitTopic_consumer_ref(s)
	}
}




func (p *YQLParser) Topic_consumer_ref() (localctx ITopic_consumer_refContext) {
	localctx = NewTopic_consumer_refContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 720, YQLParserRULE_topic_consumer_ref)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4201)
		p.An_id_pure()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// INull_treatmentContext is an interface to support dynamic dispatch.
type INull_treatmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESPECT() antlr.TerminalNode
	NULLS() antlr.TerminalNode
	IGNORE() antlr.TerminalNode

	// IsNull_treatmentContext differentiates from other interfaces.
	IsNull_treatmentContext()
}

type Null_treatmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNull_treatmentContext() *Null_treatmentContext {
	var p = new(Null_treatmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_null_treatment
	return p
}

func InitEmptyNull_treatmentContext(p *Null_treatmentContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_null_treatment
}

func (*Null_treatmentContext) IsNull_treatmentContext() {}

func NewNull_treatmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Null_treatmentContext {
	var p = new(Null_treatmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_null_treatment

	return p
}

func (s *Null_treatmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Null_treatmentContext) RESPECT() antlr.TerminalNode {
	return s.GetToken(YQLParserRESPECT, 0)
}

func (s *Null_treatmentContext) NULLS() antlr.TerminalNode {
	return s.GetToken(YQLParserNULLS, 0)
}

func (s *Null_treatmentContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(YQLParserIGNORE, 0)
}

func (s *Null_treatmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Null_treatmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Null_treatmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterNull_treatment(s)
	}
}

func (s *Null_treatmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitNull_treatment(s)
	}
}




func (p *YQLParser) Null_treatment() (localctx INull_treatmentContext) {
	localctx = NewNull_treatmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 722, YQLParserRULE_null_treatment)
	p.SetState(4207)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserRESPECT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4203)
			p.Match(YQLParserRESPECT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4204)
			p.Match(YQLParserNULLS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserIGNORE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4205)
			p.Match(YQLParserIGNORE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4206)
			p.Match(YQLParserNULLS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFilter_clauseContext is an interface to support dynamic dispatch.
type IFilter_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FILTER() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expr() IExprContext
	RPAREN() antlr.TerminalNode

	// IsFilter_clauseContext differentiates from other interfaces.
	IsFilter_clauseContext()
}

type Filter_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilter_clauseContext() *Filter_clauseContext {
	var p = new(Filter_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_filter_clause
	return p
}

func InitEmptyFilter_clauseContext(p *Filter_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_filter_clause
}

func (*Filter_clauseContext) IsFilter_clauseContext() {}

func NewFilter_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Filter_clauseContext {
	var p = new(Filter_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_filter_clause

	return p
}

func (s *Filter_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Filter_clauseContext) FILTER() antlr.TerminalNode {
	return s.GetToken(YQLParserFILTER, 0)
}

func (s *Filter_clauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Filter_clauseContext) WHERE() antlr.TerminalNode {
	return s.GetToken(YQLParserWHERE, 0)
}

func (s *Filter_clauseContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Filter_clauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Filter_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Filter_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Filter_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterFilter_clause(s)
	}
}

func (s *Filter_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitFilter_clause(s)
	}
}




func (p *YQLParser) Filter_clause() (localctx IFilter_clauseContext) {
	localctx = NewFilter_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 724, YQLParserRULE_filter_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4209)
		p.Match(YQLParserFILTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4210)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4211)
		p.Match(YQLParserWHERE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4212)
		p.Expr()
	}
	{
		p.SetState(4213)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWindow_name_or_specificationContext is an interface to support dynamic dispatch.
type IWindow_name_or_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Window_name() IWindow_nameContext
	Window_specification() IWindow_specificationContext

	// IsWindow_name_or_specificationContext differentiates from other interfaces.
	IsWindow_name_or_specificationContext()
}

type Window_name_or_specificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_name_or_specificationContext() *Window_name_or_specificationContext {
	var p = new(Window_name_or_specificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_window_name_or_specification
	return p
}

func InitEmptyWindow_name_or_specificationContext(p *Window_name_or_specificationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_window_name_or_specification
}

func (*Window_name_or_specificationContext) IsWindow_name_or_specificationContext() {}

func NewWindow_name_or_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_name_or_specificationContext {
	var p = new(Window_name_or_specificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_window_name_or_specification

	return p
}

func (s *Window_name_or_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_name_or_specificationContext) Window_name() IWindow_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_nameContext)
}

func (s *Window_name_or_specificationContext) Window_specification() IWindow_specificationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_specificationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_specificationContext)
}

func (s *Window_name_or_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_name_or_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Window_name_or_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterWindow_name_or_specification(s)
	}
}

func (s *Window_name_or_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitWindow_name_or_specification(s)
	}
}




func (p *YQLParser) Window_name_or_specification() (localctx IWindow_name_or_specificationContext) {
	localctx = NewWindow_name_or_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 726, YQLParserRULE_window_name_or_specification)
	p.SetState(4217)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALL, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserANY, YQLParserARRAY, YQLParserAS, YQLParserASC, YQLParserASSUME, YQLParserASYMMETRIC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBETWEEN, YQLParserBITCAST, YQLParserBY, YQLParserCASCADE, YQLParserCASE, YQLParserCAST, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOLUMN, YQLParserCOLUMNS, YQLParserCOMMIT, YQLParserCOMPACT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCUBE, YQLParserCURRENT, YQLParserCURRENT_DATE, YQLParserCURRENT_TIME, YQLParserCURRENT_TIMESTAMP, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDISTINCT, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserEMPTY_ACTION, YQLParserENCRYPTED, YQLParserEND, YQLParserERASE, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCEPT, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXISTS, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFROM, YQLParserFULL, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserHASH, YQLParserHAVING, YQLParserHOP, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTERSECT, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserJSON_EXISTS, YQLParserJSON_QUERY, YQLParserJSON_VALUE, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLIMIT, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOT, YQLParserNOTNULL, YQLParserNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserPROCESS, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserREDUCE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserRETURN, YQLParserRETURNING, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROLLUP, YQLParserROW, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSCHEMA, YQLParserSECONDS, YQLParserSEEK, YQLParserSELECT, YQLParserSEMI, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSTREAM, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYMMETRIC, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTYPE, YQLParserUNBOUNDED, YQLParserUNCONDITIONAL, YQLParserUNION, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWHEN, YQLParserWHERE, YQLParserWINDOW, YQLParserWITH, YQLParserWITHOUT, YQLParserWRAPPER, YQLParserXOR, YQLParserSTRING_VALUE, YQLParserID_PLAIN, YQLParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4215)
			p.Window_name()
		}


	case YQLParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4216)
			p.Window_specification()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWindow_nameContext is an interface to support dynamic dispatch.
type IWindow_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id_window() IAn_id_windowContext

	// IsWindow_nameContext differentiates from other interfaces.
	IsWindow_nameContext()
}

type Window_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_nameContext() *Window_nameContext {
	var p = new(Window_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_window_name
	return p
}

func InitEmptyWindow_nameContext(p *Window_nameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_window_name
}

func (*Window_nameContext) IsWindow_nameContext() {}

func NewWindow_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_nameContext {
	var p = new(Window_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_window_name

	return p
}

func (s *Window_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_nameContext) An_id_window() IAn_id_windowContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_windowContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_windowContext)
}

func (s *Window_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Window_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterWindow_name(s)
	}
}

func (s *Window_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitWindow_name(s)
	}
}




func (p *YQLParser) Window_name() (localctx IWindow_nameContext) {
	localctx = NewWindow_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 728, YQLParserRULE_window_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4219)
		p.An_id_window()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWindow_clauseContext is an interface to support dynamic dispatch.
type IWindow_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WINDOW() antlr.TerminalNode
	Window_definition_list() IWindow_definition_listContext

	// IsWindow_clauseContext differentiates from other interfaces.
	IsWindow_clauseContext()
}

type Window_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_clauseContext() *Window_clauseContext {
	var p = new(Window_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_window_clause
	return p
}

func InitEmptyWindow_clauseContext(p *Window_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_window_clause
}

func (*Window_clauseContext) IsWindow_clauseContext() {}

func NewWindow_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_clauseContext {
	var p = new(Window_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_window_clause

	return p
}

func (s *Window_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_clauseContext) WINDOW() antlr.TerminalNode {
	return s.GetToken(YQLParserWINDOW, 0)
}

func (s *Window_clauseContext) Window_definition_list() IWindow_definition_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_definition_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_definition_listContext)
}

func (s *Window_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Window_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterWindow_clause(s)
	}
}

func (s *Window_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitWindow_clause(s)
	}
}




func (p *YQLParser) Window_clause() (localctx IWindow_clauseContext) {
	localctx = NewWindow_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 730, YQLParserRULE_window_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4221)
		p.Match(YQLParserWINDOW)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4222)
		p.Window_definition_list()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWindow_definition_listContext is an interface to support dynamic dispatch.
type IWindow_definition_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllWindow_definition() []IWindow_definitionContext
	Window_definition(i int) IWindow_definitionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWindow_definition_listContext differentiates from other interfaces.
	IsWindow_definition_listContext()
}

type Window_definition_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_definition_listContext() *Window_definition_listContext {
	var p = new(Window_definition_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_window_definition_list
	return p
}

func InitEmptyWindow_definition_listContext(p *Window_definition_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_window_definition_list
}

func (*Window_definition_listContext) IsWindow_definition_listContext() {}

func NewWindow_definition_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_definition_listContext {
	var p = new(Window_definition_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_window_definition_list

	return p
}

func (s *Window_definition_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_definition_listContext) AllWindow_definition() []IWindow_definitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWindow_definitionContext); ok {
			len++
		}
	}

	tst := make([]IWindow_definitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWindow_definitionContext); ok {
			tst[i] = t.(IWindow_definitionContext)
			i++
		}
	}

	return tst
}

func (s *Window_definition_listContext) Window_definition(i int) IWindow_definitionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_definitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_definitionContext)
}

func (s *Window_definition_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Window_definition_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Window_definition_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_definition_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Window_definition_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterWindow_definition_list(s)
	}
}

func (s *Window_definition_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitWindow_definition_list(s)
	}
}




func (p *YQLParser) Window_definition_list() (localctx IWindow_definition_listContext) {
	localctx = NewWindow_definition_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 732, YQLParserRULE_window_definition_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4224)
		p.Window_definition()
	}
	p.SetState(4229)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == YQLParserCOMMA {
		{
			p.SetState(4225)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4226)
			p.Window_definition()
		}


		p.SetState(4231)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWindow_definitionContext is an interface to support dynamic dispatch.
type IWindow_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	New_window_name() INew_window_nameContext
	AS() antlr.TerminalNode
	Window_specification() IWindow_specificationContext

	// IsWindow_definitionContext differentiates from other interfaces.
	IsWindow_definitionContext()
}

type Window_definitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_definitionContext() *Window_definitionContext {
	var p = new(Window_definitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_window_definition
	return p
}

func InitEmptyWindow_definitionContext(p *Window_definitionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_window_definition
}

func (*Window_definitionContext) IsWindow_definitionContext() {}

func NewWindow_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_definitionContext {
	var p = new(Window_definitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_window_definition

	return p
}

func (s *Window_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_definitionContext) New_window_name() INew_window_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INew_window_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INew_window_nameContext)
}

func (s *Window_definitionContext) AS() antlr.TerminalNode {
	return s.GetToken(YQLParserAS, 0)
}

func (s *Window_definitionContext) Window_specification() IWindow_specificationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_specificationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_specificationContext)
}

func (s *Window_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Window_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterWindow_definition(s)
	}
}

func (s *Window_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitWindow_definition(s)
	}
}




func (p *YQLParser) Window_definition() (localctx IWindow_definitionContext) {
	localctx = NewWindow_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 734, YQLParserRULE_window_definition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4232)
		p.New_window_name()
	}
	{
		p.SetState(4233)
		p.Match(YQLParserAS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4234)
		p.Window_specification()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// INew_window_nameContext is an interface to support dynamic dispatch.
type INew_window_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Window_name() IWindow_nameContext

	// IsNew_window_nameContext differentiates from other interfaces.
	IsNew_window_nameContext()
}

type New_window_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNew_window_nameContext() *New_window_nameContext {
	var p = new(New_window_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_new_window_name
	return p
}

func InitEmptyNew_window_nameContext(p *New_window_nameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_new_window_name
}

func (*New_window_nameContext) IsNew_window_nameContext() {}

func NewNew_window_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *New_window_nameContext {
	var p = new(New_window_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_new_window_name

	return p
}

func (s *New_window_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *New_window_nameContext) Window_name() IWindow_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_nameContext)
}

func (s *New_window_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *New_window_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *New_window_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterNew_window_name(s)
	}
}

func (s *New_window_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitNew_window_name(s)
	}
}




func (p *YQLParser) New_window_name() (localctx INew_window_nameContext) {
	localctx = NewNew_window_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 736, YQLParserRULE_new_window_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4236)
		p.Window_name()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWindow_specificationContext is an interface to support dynamic dispatch.
type IWindow_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	Window_specification_details() IWindow_specification_detailsContext
	RPAREN() antlr.TerminalNode

	// IsWindow_specificationContext differentiates from other interfaces.
	IsWindow_specificationContext()
}

type Window_specificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_specificationContext() *Window_specificationContext {
	var p = new(Window_specificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_window_specification
	return p
}

func InitEmptyWindow_specificationContext(p *Window_specificationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_window_specification
}

func (*Window_specificationContext) IsWindow_specificationContext() {}

func NewWindow_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_specificationContext {
	var p = new(Window_specificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_window_specification

	return p
}

func (s *Window_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_specificationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Window_specificationContext) Window_specification_details() IWindow_specification_detailsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_specification_detailsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_specification_detailsContext)
}

func (s *Window_specificationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Window_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Window_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterWindow_specification(s)
	}
}

func (s *Window_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitWindow_specification(s)
	}
}




func (p *YQLParser) Window_specification() (localctx IWindow_specificationContext) {
	localctx = NewWindow_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 738, YQLParserRULE_window_specification)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4238)
		p.Match(YQLParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4239)
		p.Window_specification_details()
	}
	{
		p.SetState(4240)
		p.Match(YQLParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWindow_specification_detailsContext is an interface to support dynamic dispatch.
type IWindow_specification_detailsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Existing_window_name() IExisting_window_nameContext
	Window_partition_clause() IWindow_partition_clauseContext
	Window_order_clause() IWindow_order_clauseContext
	Window_frame_clause() IWindow_frame_clauseContext

	// IsWindow_specification_detailsContext differentiates from other interfaces.
	IsWindow_specification_detailsContext()
}

type Window_specification_detailsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_specification_detailsContext() *Window_specification_detailsContext {
	var p = new(Window_specification_detailsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_window_specification_details
	return p
}

func InitEmptyWindow_specification_detailsContext(p *Window_specification_detailsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_window_specification_details
}

func (*Window_specification_detailsContext) IsWindow_specification_detailsContext() {}

func NewWindow_specification_detailsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_specification_detailsContext {
	var p = new(Window_specification_detailsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_window_specification_details

	return p
}

func (s *Window_specification_detailsContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_specification_detailsContext) Existing_window_name() IExisting_window_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExisting_window_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExisting_window_nameContext)
}

func (s *Window_specification_detailsContext) Window_partition_clause() IWindow_partition_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_partition_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_partition_clauseContext)
}

func (s *Window_specification_detailsContext) Window_order_clause() IWindow_order_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_order_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_order_clauseContext)
}

func (s *Window_specification_detailsContext) Window_frame_clause() IWindow_frame_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_frame_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_frame_clauseContext)
}

func (s *Window_specification_detailsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_specification_detailsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Window_specification_detailsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterWindow_specification_details(s)
	}
}

func (s *Window_specification_detailsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitWindow_specification_details(s)
	}
}




func (p *YQLParser) Window_specification_details() (localctx IWindow_specification_detailsContext) {
	localctx = NewWindow_specification_detailsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 740, YQLParserRULE_window_specification_details)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4243)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 454, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4242)
			p.Existing_window_name()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(4246)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserPARTITION {
		{
			p.SetState(4245)
			p.Window_partition_clause()
		}

	}
	p.SetState(4249)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserORDER {
		{
			p.SetState(4248)
			p.Window_order_clause()
		}

	}
	p.SetState(4252)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserGROUPS || _la == YQLParserRANGE || _la == YQLParserROWS {
		{
			p.SetState(4251)
			p.Window_frame_clause()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExisting_window_nameContext is an interface to support dynamic dispatch.
type IExisting_window_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Window_name() IWindow_nameContext

	// IsExisting_window_nameContext differentiates from other interfaces.
	IsExisting_window_nameContext()
}

type Existing_window_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExisting_window_nameContext() *Existing_window_nameContext {
	var p = new(Existing_window_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_existing_window_name
	return p
}

func InitEmptyExisting_window_nameContext(p *Existing_window_nameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_existing_window_name
}

func (*Existing_window_nameContext) IsExisting_window_nameContext() {}

func NewExisting_window_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Existing_window_nameContext {
	var p = new(Existing_window_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_existing_window_name

	return p
}

func (s *Existing_window_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Existing_window_nameContext) Window_name() IWindow_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_nameContext)
}

func (s *Existing_window_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Existing_window_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Existing_window_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterExisting_window_name(s)
	}
}

func (s *Existing_window_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitExisting_window_name(s)
	}
}




func (p *YQLParser) Existing_window_name() (localctx IExisting_window_nameContext) {
	localctx = NewExisting_window_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 742, YQLParserRULE_existing_window_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4254)
		p.Window_name()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWindow_partition_clauseContext is an interface to support dynamic dispatch.
type IWindow_partition_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	Named_expr_list() INamed_expr_listContext
	COMPACT() antlr.TerminalNode

	// IsWindow_partition_clauseContext differentiates from other interfaces.
	IsWindow_partition_clauseContext()
}

type Window_partition_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_partition_clauseContext() *Window_partition_clauseContext {
	var p = new(Window_partition_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_window_partition_clause
	return p
}

func InitEmptyWindow_partition_clauseContext(p *Window_partition_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_window_partition_clause
}

func (*Window_partition_clauseContext) IsWindow_partition_clauseContext() {}

func NewWindow_partition_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_partition_clauseContext {
	var p = new(Window_partition_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_window_partition_clause

	return p
}

func (s *Window_partition_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_partition_clauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(YQLParserPARTITION, 0)
}

func (s *Window_partition_clauseContext) BY() antlr.TerminalNode {
	return s.GetToken(YQLParserBY, 0)
}

func (s *Window_partition_clauseContext) Named_expr_list() INamed_expr_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_expr_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_expr_listContext)
}

func (s *Window_partition_clauseContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(YQLParserCOMPACT, 0)
}

func (s *Window_partition_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_partition_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Window_partition_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterWindow_partition_clause(s)
	}
}

func (s *Window_partition_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitWindow_partition_clause(s)
	}
}




func (p *YQLParser) Window_partition_clause() (localctx IWindow_partition_clauseContext) {
	localctx = NewWindow_partition_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 744, YQLParserRULE_window_partition_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4256)
		p.Match(YQLParserPARTITION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4258)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserCOMPACT {
		{
			p.SetState(4257)
			p.Match(YQLParserCOMPACT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(4260)
		p.Match(YQLParserBY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4261)
		p.Named_expr_list()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWindow_order_clauseContext is an interface to support dynamic dispatch.
type IWindow_order_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Order_by_clause() IOrder_by_clauseContext

	// IsWindow_order_clauseContext differentiates from other interfaces.
	IsWindow_order_clauseContext()
}

type Window_order_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_order_clauseContext() *Window_order_clauseContext {
	var p = new(Window_order_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_window_order_clause
	return p
}

func InitEmptyWindow_order_clauseContext(p *Window_order_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_window_order_clause
}

func (*Window_order_clauseContext) IsWindow_order_clauseContext() {}

func NewWindow_order_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_order_clauseContext {
	var p = new(Window_order_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_window_order_clause

	return p
}

func (s *Window_order_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_order_clauseContext) Order_by_clause() IOrder_by_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrder_by_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrder_by_clauseContext)
}

func (s *Window_order_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_order_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Window_order_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterWindow_order_clause(s)
	}
}

func (s *Window_order_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitWindow_order_clause(s)
	}
}




func (p *YQLParser) Window_order_clause() (localctx IWindow_order_clauseContext) {
	localctx = NewWindow_order_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 746, YQLParserRULE_window_order_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4263)
		p.Order_by_clause()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWindow_frame_clauseContext is an interface to support dynamic dispatch.
type IWindow_frame_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Window_frame_units() IWindow_frame_unitsContext
	Window_frame_extent() IWindow_frame_extentContext
	Window_frame_exclusion() IWindow_frame_exclusionContext

	// IsWindow_frame_clauseContext differentiates from other interfaces.
	IsWindow_frame_clauseContext()
}

type Window_frame_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_frame_clauseContext() *Window_frame_clauseContext {
	var p = new(Window_frame_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_window_frame_clause
	return p
}

func InitEmptyWindow_frame_clauseContext(p *Window_frame_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_window_frame_clause
}

func (*Window_frame_clauseContext) IsWindow_frame_clauseContext() {}

func NewWindow_frame_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_frame_clauseContext {
	var p = new(Window_frame_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_window_frame_clause

	return p
}

func (s *Window_frame_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_frame_clauseContext) Window_frame_units() IWindow_frame_unitsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_frame_unitsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_frame_unitsContext)
}

func (s *Window_frame_clauseContext) Window_frame_extent() IWindow_frame_extentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_frame_extentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_frame_extentContext)
}

func (s *Window_frame_clauseContext) Window_frame_exclusion() IWindow_frame_exclusionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_frame_exclusionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_frame_exclusionContext)
}

func (s *Window_frame_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_frame_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Window_frame_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterWindow_frame_clause(s)
	}
}

func (s *Window_frame_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitWindow_frame_clause(s)
	}
}




func (p *YQLParser) Window_frame_clause() (localctx IWindow_frame_clauseContext) {
	localctx = NewWindow_frame_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 748, YQLParserRULE_window_frame_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4265)
		p.Window_frame_units()
	}
	{
		p.SetState(4266)
		p.Window_frame_extent()
	}
	p.SetState(4268)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserEXCLUDE {
		{
			p.SetState(4267)
			p.Window_frame_exclusion()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWindow_frame_unitsContext is an interface to support dynamic dispatch.
type IWindow_frame_unitsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROWS() antlr.TerminalNode
	RANGE() antlr.TerminalNode
	GROUPS() antlr.TerminalNode

	// IsWindow_frame_unitsContext differentiates from other interfaces.
	IsWindow_frame_unitsContext()
}

type Window_frame_unitsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_frame_unitsContext() *Window_frame_unitsContext {
	var p = new(Window_frame_unitsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_window_frame_units
	return p
}

func InitEmptyWindow_frame_unitsContext(p *Window_frame_unitsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_window_frame_units
}

func (*Window_frame_unitsContext) IsWindow_frame_unitsContext() {}

func NewWindow_frame_unitsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_frame_unitsContext {
	var p = new(Window_frame_unitsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_window_frame_units

	return p
}

func (s *Window_frame_unitsContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_frame_unitsContext) ROWS() antlr.TerminalNode {
	return s.GetToken(YQLParserROWS, 0)
}

func (s *Window_frame_unitsContext) RANGE() antlr.TerminalNode {
	return s.GetToken(YQLParserRANGE, 0)
}

func (s *Window_frame_unitsContext) GROUPS() antlr.TerminalNode {
	return s.GetToken(YQLParserGROUPS, 0)
}

func (s *Window_frame_unitsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_frame_unitsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Window_frame_unitsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterWindow_frame_units(s)
	}
}

func (s *Window_frame_unitsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitWindow_frame_units(s)
	}
}




func (p *YQLParser) Window_frame_units() (localctx IWindow_frame_unitsContext) {
	localctx = NewWindow_frame_unitsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 750, YQLParserRULE_window_frame_units)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4270)
		_la = p.GetTokenStream().LA(1)

		if !(_la == YQLParserGROUPS || _la == YQLParserRANGE || _la == YQLParserROWS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWindow_frame_extentContext is an interface to support dynamic dispatch.
type IWindow_frame_extentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Window_frame_bound() IWindow_frame_boundContext
	Window_frame_between() IWindow_frame_betweenContext

	// IsWindow_frame_extentContext differentiates from other interfaces.
	IsWindow_frame_extentContext()
}

type Window_frame_extentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_frame_extentContext() *Window_frame_extentContext {
	var p = new(Window_frame_extentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_window_frame_extent
	return p
}

func InitEmptyWindow_frame_extentContext(p *Window_frame_extentContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_window_frame_extent
}

func (*Window_frame_extentContext) IsWindow_frame_extentContext() {}

func NewWindow_frame_extentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_frame_extentContext {
	var p = new(Window_frame_extentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_window_frame_extent

	return p
}

func (s *Window_frame_extentContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_frame_extentContext) Window_frame_bound() IWindow_frame_boundContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_frame_boundContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_frame_boundContext)
}

func (s *Window_frame_extentContext) Window_frame_between() IWindow_frame_betweenContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_frame_betweenContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_frame_betweenContext)
}

func (s *Window_frame_extentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_frame_extentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Window_frame_extentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterWindow_frame_extent(s)
	}
}

func (s *Window_frame_extentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitWindow_frame_extent(s)
	}
}




func (p *YQLParser) Window_frame_extent() (localctx IWindow_frame_extentContext) {
	localctx = NewWindow_frame_extentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 752, YQLParserRULE_window_frame_extent)
	p.SetState(4274)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 460, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4272)
			p.Window_frame_bound()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4273)
			p.Window_frame_between()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWindow_frame_betweenContext is an interface to support dynamic dispatch.
type IWindow_frame_betweenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BETWEEN() antlr.TerminalNode
	AllWindow_frame_bound() []IWindow_frame_boundContext
	Window_frame_bound(i int) IWindow_frame_boundContext
	AND() antlr.TerminalNode

	// IsWindow_frame_betweenContext differentiates from other interfaces.
	IsWindow_frame_betweenContext()
}

type Window_frame_betweenContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_frame_betweenContext() *Window_frame_betweenContext {
	var p = new(Window_frame_betweenContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_window_frame_between
	return p
}

func InitEmptyWindow_frame_betweenContext(p *Window_frame_betweenContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_window_frame_between
}

func (*Window_frame_betweenContext) IsWindow_frame_betweenContext() {}

func NewWindow_frame_betweenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_frame_betweenContext {
	var p = new(Window_frame_betweenContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_window_frame_between

	return p
}

func (s *Window_frame_betweenContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_frame_betweenContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(YQLParserBETWEEN, 0)
}

func (s *Window_frame_betweenContext) AllWindow_frame_bound() []IWindow_frame_boundContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWindow_frame_boundContext); ok {
			len++
		}
	}

	tst := make([]IWindow_frame_boundContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWindow_frame_boundContext); ok {
			tst[i] = t.(IWindow_frame_boundContext)
			i++
		}
	}

	return tst
}

func (s *Window_frame_betweenContext) Window_frame_bound(i int) IWindow_frame_boundContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_frame_boundContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_frame_boundContext)
}

func (s *Window_frame_betweenContext) AND() antlr.TerminalNode {
	return s.GetToken(YQLParserAND, 0)
}

func (s *Window_frame_betweenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_frame_betweenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Window_frame_betweenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterWindow_frame_between(s)
	}
}

func (s *Window_frame_betweenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitWindow_frame_between(s)
	}
}




func (p *YQLParser) Window_frame_between() (localctx IWindow_frame_betweenContext) {
	localctx = NewWindow_frame_betweenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 754, YQLParserRULE_window_frame_between)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4276)
		p.Match(YQLParserBETWEEN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4277)
		p.Window_frame_bound()
	}
	{
		p.SetState(4278)
		p.Match(YQLParserAND)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4279)
		p.Window_frame_bound()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWindow_frame_boundContext is an interface to support dynamic dispatch.
type IWindow_frame_boundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CURRENT() antlr.TerminalNode
	ROW() antlr.TerminalNode
	PRECEDING() antlr.TerminalNode
	FOLLOWING() antlr.TerminalNode
	Expr() IExprContext
	UNBOUNDED() antlr.TerminalNode

	// IsWindow_frame_boundContext differentiates from other interfaces.
	IsWindow_frame_boundContext()
}

type Window_frame_boundContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_frame_boundContext() *Window_frame_boundContext {
	var p = new(Window_frame_boundContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_window_frame_bound
	return p
}

func InitEmptyWindow_frame_boundContext(p *Window_frame_boundContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_window_frame_bound
}

func (*Window_frame_boundContext) IsWindow_frame_boundContext() {}

func NewWindow_frame_boundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_frame_boundContext {
	var p = new(Window_frame_boundContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_window_frame_bound

	return p
}

func (s *Window_frame_boundContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_frame_boundContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(YQLParserCURRENT, 0)
}

func (s *Window_frame_boundContext) ROW() antlr.TerminalNode {
	return s.GetToken(YQLParserROW, 0)
}

func (s *Window_frame_boundContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(YQLParserPRECEDING, 0)
}

func (s *Window_frame_boundContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(YQLParserFOLLOWING, 0)
}

func (s *Window_frame_boundContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Window_frame_boundContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(YQLParserUNBOUNDED, 0)
}

func (s *Window_frame_boundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_frame_boundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Window_frame_boundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterWindow_frame_bound(s)
	}
}

func (s *Window_frame_boundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitWindow_frame_bound(s)
	}
}




func (p *YQLParser) Window_frame_bound() (localctx IWindow_frame_boundContext) {
	localctx = NewWindow_frame_boundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 756, YQLParserRULE_window_frame_bound)
	var _la int

	p.SetState(4288)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 462, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4281)
			p.Match(YQLParserCURRENT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4282)
			p.Match(YQLParserROW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4285)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 461, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4283)
				p.Expr()
			}


		case 2:
			{
				p.SetState(4284)
				p.Match(YQLParserUNBOUNDED)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(4287)
			_la = p.GetTokenStream().LA(1)

			if !(_la == YQLParserFOLLOWING || _la == YQLParserPRECEDING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWindow_frame_exclusionContext is an interface to support dynamic dispatch.
type IWindow_frame_exclusionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXCLUDE() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	ROW() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	TIES() antlr.TerminalNode
	NO() antlr.TerminalNode
	OTHERS() antlr.TerminalNode

	// IsWindow_frame_exclusionContext differentiates from other interfaces.
	IsWindow_frame_exclusionContext()
}

type Window_frame_exclusionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_frame_exclusionContext() *Window_frame_exclusionContext {
	var p = new(Window_frame_exclusionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_window_frame_exclusion
	return p
}

func InitEmptyWindow_frame_exclusionContext(p *Window_frame_exclusionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_window_frame_exclusion
}

func (*Window_frame_exclusionContext) IsWindow_frame_exclusionContext() {}

func NewWindow_frame_exclusionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_frame_exclusionContext {
	var p = new(Window_frame_exclusionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_window_frame_exclusion

	return p
}

func (s *Window_frame_exclusionContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_frame_exclusionContext) EXCLUDE() antlr.TerminalNode {
	return s.GetToken(YQLParserEXCLUDE, 0)
}

func (s *Window_frame_exclusionContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(YQLParserCURRENT, 0)
}

func (s *Window_frame_exclusionContext) ROW() antlr.TerminalNode {
	return s.GetToken(YQLParserROW, 0)
}

func (s *Window_frame_exclusionContext) GROUP() antlr.TerminalNode {
	return s.GetToken(YQLParserGROUP, 0)
}

func (s *Window_frame_exclusionContext) TIES() antlr.TerminalNode {
	return s.GetToken(YQLParserTIES, 0)
}

func (s *Window_frame_exclusionContext) NO() antlr.TerminalNode {
	return s.GetToken(YQLParserNO, 0)
}

func (s *Window_frame_exclusionContext) OTHERS() antlr.TerminalNode {
	return s.GetToken(YQLParserOTHERS, 0)
}

func (s *Window_frame_exclusionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_frame_exclusionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Window_frame_exclusionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterWindow_frame_exclusion(s)
	}
}

func (s *Window_frame_exclusionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitWindow_frame_exclusion(s)
	}
}




func (p *YQLParser) Window_frame_exclusion() (localctx IWindow_frame_exclusionContext) {
	localctx = NewWindow_frame_exclusionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 758, YQLParserRULE_window_frame_exclusion)
	p.SetState(4300)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 463, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4290)
			p.Match(YQLParserEXCLUDE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4291)
			p.Match(YQLParserCURRENT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4292)
			p.Match(YQLParserROW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4293)
			p.Match(YQLParserEXCLUDE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4294)
			p.Match(YQLParserGROUP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4295)
			p.Match(YQLParserEXCLUDE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4296)
			p.Match(YQLParserTIES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4297)
			p.Match(YQLParserEXCLUDE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4298)
			p.Match(YQLParserNO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4299)
			p.Match(YQLParserOTHERS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUse_stmtContext is an interface to support dynamic dispatch.
type IUse_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USE() antlr.TerminalNode
	Cluster_expr() ICluster_exprContext

	// IsUse_stmtContext differentiates from other interfaces.
	IsUse_stmtContext()
}

type Use_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUse_stmtContext() *Use_stmtContext {
	var p = new(Use_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_use_stmt
	return p
}

func InitEmptyUse_stmtContext(p *Use_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_use_stmt
}

func (*Use_stmtContext) IsUse_stmtContext() {}

func NewUse_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Use_stmtContext {
	var p = new(Use_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_use_stmt

	return p
}

func (s *Use_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Use_stmtContext) USE() antlr.TerminalNode {
	return s.GetToken(YQLParserUSE, 0)
}

func (s *Use_stmtContext) Cluster_expr() ICluster_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICluster_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICluster_exprContext)
}

func (s *Use_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Use_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Use_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterUse_stmt(s)
	}
}

func (s *Use_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitUse_stmt(s)
	}
}




func (p *YQLParser) Use_stmt() (localctx IUse_stmtContext) {
	localctx = NewUse_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 760, YQLParserRULE_use_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4302)
		p.Match(YQLParserUSE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4303)
		p.Cluster_expr()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISubselect_stmtContext is an interface to support dynamic dispatch.
type ISubselect_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	RPAREN() antlr.TerminalNode
	Select_unparenthesized_stmt() ISelect_unparenthesized_stmtContext

	// IsSubselect_stmtContext differentiates from other interfaces.
	IsSubselect_stmtContext()
}

type Subselect_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubselect_stmtContext() *Subselect_stmtContext {
	var p = new(Subselect_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_subselect_stmt
	return p
}

func InitEmptySubselect_stmtContext(p *Subselect_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_subselect_stmt
}

func (*Subselect_stmtContext) IsSubselect_stmtContext() {}

func NewSubselect_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subselect_stmtContext {
	var p = new(Subselect_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_subselect_stmt

	return p
}

func (s *Subselect_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Subselect_stmtContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Subselect_stmtContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Subselect_stmtContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Subselect_stmtContext) Select_unparenthesized_stmt() ISelect_unparenthesized_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_unparenthesized_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_unparenthesized_stmtContext)
}

func (s *Subselect_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subselect_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Subselect_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterSubselect_stmt(s)
	}
}

func (s *Subselect_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitSubselect_stmt(s)
	}
}




func (p *YQLParser) Subselect_stmt() (localctx ISubselect_stmtContext) {
	localctx = NewSubselect_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 762, YQLParserRULE_subselect_stmt)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(4310)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserLPAREN:
		{
			p.SetState(4305)
			p.Match(YQLParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4306)
			p.Select_stmt()
		}
		{
			p.SetState(4307)
			p.Match(YQLParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case YQLParserDISCARD, YQLParserFROM, YQLParserPROCESS, YQLParserREDUCE, YQLParserSELECT:
		{
			p.SetState(4309)
			p.Select_unparenthesized_stmt()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// INamed_nodes_stmtContext is an interface to support dynamic dispatch.
type INamed_nodes_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Bind_parameter_list() IBind_parameter_listContext
	EQUALS() antlr.TerminalNode
	Expr() IExprContext
	Subselect_stmt() ISubselect_stmtContext

	// IsNamed_nodes_stmtContext differentiates from other interfaces.
	IsNamed_nodes_stmtContext()
}

type Named_nodes_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamed_nodes_stmtContext() *Named_nodes_stmtContext {
	var p = new(Named_nodes_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_named_nodes_stmt
	return p
}

func InitEmptyNamed_nodes_stmtContext(p *Named_nodes_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_named_nodes_stmt
}

func (*Named_nodes_stmtContext) IsNamed_nodes_stmtContext() {}

func NewNamed_nodes_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Named_nodes_stmtContext {
	var p = new(Named_nodes_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_named_nodes_stmt

	return p
}

func (s *Named_nodes_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Named_nodes_stmtContext) Bind_parameter_list() IBind_parameter_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameter_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameter_listContext)
}

func (s *Named_nodes_stmtContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(YQLParserEQUALS, 0)
}

func (s *Named_nodes_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Named_nodes_stmtContext) Subselect_stmt() ISubselect_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubselect_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubselect_stmtContext)
}

func (s *Named_nodes_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Named_nodes_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Named_nodes_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterNamed_nodes_stmt(s)
	}
}

func (s *Named_nodes_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitNamed_nodes_stmt(s)
	}
}




func (p *YQLParser) Named_nodes_stmt() (localctx INamed_nodes_stmtContext) {
	localctx = NewNamed_nodes_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 764, YQLParserRULE_named_nodes_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4312)
		p.Bind_parameter_list()
	}
	{
		p.SetState(4313)
		p.Match(YQLParserEQUALS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4316)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 465, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4314)
			p.Expr()
		}


	case 2:
		{
			p.SetState(4315)
			p.Subselect_stmt()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICommit_stmtContext is an interface to support dynamic dispatch.
type ICommit_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMIT() antlr.TerminalNode

	// IsCommit_stmtContext differentiates from other interfaces.
	IsCommit_stmtContext()
}

type Commit_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommit_stmtContext() *Commit_stmtContext {
	var p = new(Commit_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_commit_stmt
	return p
}

func InitEmptyCommit_stmtContext(p *Commit_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_commit_stmt
}

func (*Commit_stmtContext) IsCommit_stmtContext() {}

func NewCommit_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Commit_stmtContext {
	var p = new(Commit_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_commit_stmt

	return p
}

func (s *Commit_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Commit_stmtContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMIT, 0)
}

func (s *Commit_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Commit_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Commit_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterCommit_stmt(s)
	}
}

func (s *Commit_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitCommit_stmt(s)
	}
}




func (p *YQLParser) Commit_stmt() (localctx ICommit_stmtContext) {
	localctx = NewCommit_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 766, YQLParserRULE_commit_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4318)
		p.Match(YQLParserCOMMIT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRollback_stmtContext is an interface to support dynamic dispatch.
type IRollback_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROLLBACK() antlr.TerminalNode

	// IsRollback_stmtContext differentiates from other interfaces.
	IsRollback_stmtContext()
}

type Rollback_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRollback_stmtContext() *Rollback_stmtContext {
	var p = new(Rollback_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_rollback_stmt
	return p
}

func InitEmptyRollback_stmtContext(p *Rollback_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_rollback_stmt
}

func (*Rollback_stmtContext) IsRollback_stmtContext() {}

func NewRollback_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rollback_stmtContext {
	var p = new(Rollback_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_rollback_stmt

	return p
}

func (s *Rollback_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Rollback_stmtContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(YQLParserROLLBACK, 0)
}

func (s *Rollback_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rollback_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Rollback_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterRollback_stmt(s)
	}
}

func (s *Rollback_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitRollback_stmt(s)
	}
}




func (p *YQLParser) Rollback_stmt() (localctx IRollback_stmtContext) {
	localctx = NewRollback_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 768, YQLParserRULE_rollback_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4320)
		p.Match(YQLParserROLLBACK)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAnalyze_tableContext is an interface to support dynamic dispatch.
type IAnalyze_tableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Simple_table_ref() ISimple_table_refContext
	LPAREN() antlr.TerminalNode
	Column_list() IColumn_listContext
	RPAREN() antlr.TerminalNode

	// IsAnalyze_tableContext differentiates from other interfaces.
	IsAnalyze_tableContext()
}

type Analyze_tableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnalyze_tableContext() *Analyze_tableContext {
	var p = new(Analyze_tableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_analyze_table
	return p
}

func InitEmptyAnalyze_tableContext(p *Analyze_tableContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_analyze_table
}

func (*Analyze_tableContext) IsAnalyze_tableContext() {}

func NewAnalyze_tableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Analyze_tableContext {
	var p = new(Analyze_tableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_analyze_table

	return p
}

func (s *Analyze_tableContext) GetParser() antlr.Parser { return s.parser }

func (s *Analyze_tableContext) Simple_table_ref() ISimple_table_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_table_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_table_refContext)
}

func (s *Analyze_tableContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserLPAREN, 0)
}

func (s *Analyze_tableContext) Column_list() IColumn_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_listContext)
}

func (s *Analyze_tableContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(YQLParserRPAREN, 0)
}

func (s *Analyze_tableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Analyze_tableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Analyze_tableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAnalyze_table(s)
	}
}

func (s *Analyze_tableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAnalyze_table(s)
	}
}




func (p *YQLParser) Analyze_table() (localctx IAnalyze_tableContext) {
	localctx = NewAnalyze_tableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 770, YQLParserRULE_analyze_table)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4322)
		p.Simple_table_ref()
	}
	p.SetState(4327)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserLPAREN {
		{
			p.SetState(4323)
			p.Match(YQLParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4324)
			p.Column_list()
		}
		{
			p.SetState(4325)
			p.Match(YQLParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAnalyze_table_listContext is an interface to support dynamic dispatch.
type IAnalyze_table_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAnalyze_table() []IAnalyze_tableContext
	Analyze_table(i int) IAnalyze_tableContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAnalyze_table_listContext differentiates from other interfaces.
	IsAnalyze_table_listContext()
}

type Analyze_table_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnalyze_table_listContext() *Analyze_table_listContext {
	var p = new(Analyze_table_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_analyze_table_list
	return p
}

func InitEmptyAnalyze_table_listContext(p *Analyze_table_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_analyze_table_list
}

func (*Analyze_table_listContext) IsAnalyze_table_listContext() {}

func NewAnalyze_table_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Analyze_table_listContext {
	var p = new(Analyze_table_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_analyze_table_list

	return p
}

func (s *Analyze_table_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Analyze_table_listContext) AllAnalyze_table() []IAnalyze_tableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnalyze_tableContext); ok {
			len++
		}
	}

	tst := make([]IAnalyze_tableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnalyze_tableContext); ok {
			tst[i] = t.(IAnalyze_tableContext)
			i++
		}
	}

	return tst
}

func (s *Analyze_table_listContext) Analyze_table(i int) IAnalyze_tableContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyze_tableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyze_tableContext)
}

func (s *Analyze_table_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(YQLParserCOMMA)
}

func (s *Analyze_table_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMA, i)
}

func (s *Analyze_table_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Analyze_table_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Analyze_table_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAnalyze_table_list(s)
	}
}

func (s *Analyze_table_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAnalyze_table_list(s)
	}
}




func (p *YQLParser) Analyze_table_list() (localctx IAnalyze_table_listContext) {
	localctx = NewAnalyze_table_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 772, YQLParserRULE_analyze_table_list)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4329)
		p.Analyze_table()
	}
	p.SetState(4334)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 467, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4330)
				p.Match(YQLParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(4331)
				p.Analyze_table()
			}


		}
		p.SetState(4336)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 467, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(4338)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserCOMMA {
		{
			p.SetState(4337)
			p.Match(YQLParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAnalyze_stmtContext is an interface to support dynamic dispatch.
type IAnalyze_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ANALYZE() antlr.TerminalNode
	Analyze_table_list() IAnalyze_table_listContext

	// IsAnalyze_stmtContext differentiates from other interfaces.
	IsAnalyze_stmtContext()
}

type Analyze_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnalyze_stmtContext() *Analyze_stmtContext {
	var p = new(Analyze_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_analyze_stmt
	return p
}

func InitEmptyAnalyze_stmtContext(p *Analyze_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_analyze_stmt
}

func (*Analyze_stmtContext) IsAnalyze_stmtContext() {}

func NewAnalyze_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Analyze_stmtContext {
	var p = new(Analyze_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_analyze_stmt

	return p
}

func (s *Analyze_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Analyze_stmtContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(YQLParserANALYZE, 0)
}

func (s *Analyze_stmtContext) Analyze_table_list() IAnalyze_table_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyze_table_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyze_table_listContext)
}

func (s *Analyze_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Analyze_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Analyze_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAnalyze_stmt(s)
	}
}

func (s *Analyze_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAnalyze_stmt(s)
	}
}




func (p *YQLParser) Analyze_stmt() (localctx IAnalyze_stmtContext) {
	localctx = NewAnalyze_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 774, YQLParserRULE_analyze_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4340)
		p.Match(YQLParserANALYZE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4341)
		p.Analyze_table_list()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_sequence_stmtContext is an interface to support dynamic dispatch.
type IAlter_sequence_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	SEQUENCE() antlr.TerminalNode
	Object_ref() IObject_refContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	AllAlter_sequence_action() []IAlter_sequence_actionContext
	Alter_sequence_action(i int) IAlter_sequence_actionContext

	// IsAlter_sequence_stmtContext differentiates from other interfaces.
	IsAlter_sequence_stmtContext()
}

type Alter_sequence_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_sequence_stmtContext() *Alter_sequence_stmtContext {
	var p = new(Alter_sequence_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_sequence_stmt
	return p
}

func InitEmptyAlter_sequence_stmtContext(p *Alter_sequence_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_sequence_stmt
}

func (*Alter_sequence_stmtContext) IsAlter_sequence_stmtContext() {}

func NewAlter_sequence_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_sequence_stmtContext {
	var p = new(Alter_sequence_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_sequence_stmt

	return p
}

func (s *Alter_sequence_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_sequence_stmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(YQLParserALTER, 0)
}

func (s *Alter_sequence_stmtContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(YQLParserSEQUENCE, 0)
}

func (s *Alter_sequence_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Alter_sequence_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(YQLParserIF, 0)
}

func (s *Alter_sequence_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(YQLParserEXISTS, 0)
}

func (s *Alter_sequence_stmtContext) AllAlter_sequence_action() []IAlter_sequence_actionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlter_sequence_actionContext); ok {
			len++
		}
	}

	tst := make([]IAlter_sequence_actionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlter_sequence_actionContext); ok {
			tst[i] = t.(IAlter_sequence_actionContext)
			i++
		}
	}

	return tst
}

func (s *Alter_sequence_stmtContext) Alter_sequence_action(i int) IAlter_sequence_actionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_sequence_actionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_sequence_actionContext)
}

func (s *Alter_sequence_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_sequence_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_sequence_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_sequence_stmt(s)
	}
}

func (s *Alter_sequence_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_sequence_stmt(s)
	}
}




func (p *YQLParser) Alter_sequence_stmt() (localctx IAlter_sequence_stmtContext) {
	localctx = NewAlter_sequence_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 776, YQLParserRULE_alter_sequence_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4343)
		p.Match(YQLParserALTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4344)
		p.Match(YQLParserSEQUENCE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4347)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 469, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4345)
			p.Match(YQLParserIF)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4346)
			p.Match(YQLParserEXISTS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(4349)
		p.Object_ref()
	}
	p.SetState(4351)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = _la == YQLParserINCREMENT || _la == YQLParserRESTART || _la == YQLParserSTART {
		{
			p.SetState(4350)
			p.Alter_sequence_action()
		}


		p.SetState(4353)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_sequence_actionContext is an interface to support dynamic dispatch.
type IAlter_sequence_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	START() antlr.TerminalNode
	Integer() IIntegerContext
	WITH() antlr.TerminalNode
	RESTART() antlr.TerminalNode
	INCREMENT() antlr.TerminalNode
	BY() antlr.TerminalNode

	// IsAlter_sequence_actionContext differentiates from other interfaces.
	IsAlter_sequence_actionContext()
}

type Alter_sequence_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_sequence_actionContext() *Alter_sequence_actionContext {
	var p = new(Alter_sequence_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_sequence_action
	return p
}

func InitEmptyAlter_sequence_actionContext(p *Alter_sequence_actionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_alter_sequence_action
}

func (*Alter_sequence_actionContext) IsAlter_sequence_actionContext() {}

func NewAlter_sequence_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_sequence_actionContext {
	var p = new(Alter_sequence_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_alter_sequence_action

	return p
}

func (s *Alter_sequence_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_sequence_actionContext) START() antlr.TerminalNode {
	return s.GetToken(YQLParserSTART, 0)
}

func (s *Alter_sequence_actionContext) Integer() IIntegerContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerContext)
}

func (s *Alter_sequence_actionContext) WITH() antlr.TerminalNode {
	return s.GetToken(YQLParserWITH, 0)
}

func (s *Alter_sequence_actionContext) RESTART() antlr.TerminalNode {
	return s.GetToken(YQLParserRESTART, 0)
}

func (s *Alter_sequence_actionContext) INCREMENT() antlr.TerminalNode {
	return s.GetToken(YQLParserINCREMENT, 0)
}

func (s *Alter_sequence_actionContext) BY() antlr.TerminalNode {
	return s.GetToken(YQLParserBY, 0)
}

func (s *Alter_sequence_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_sequence_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_sequence_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAlter_sequence_action(s)
	}
}

func (s *Alter_sequence_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAlter_sequence_action(s)
	}
}




func (p *YQLParser) Alter_sequence_action() (localctx IAlter_sequence_actionContext) {
	localctx = NewAlter_sequence_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 778, YQLParserRULE_alter_sequence_action)
	var _la int

	p.SetState(4371)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 474, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4355)
			p.Match(YQLParserSTART)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(4357)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserWITH {
			{
				p.SetState(4356)
				p.Match(YQLParserWITH)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(4359)
			p.Integer()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4360)
			p.Match(YQLParserRESTART)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(4362)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserWITH {
			{
				p.SetState(4361)
				p.Match(YQLParserWITH)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(4364)
			p.Integer()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4365)
			p.Match(YQLParserRESTART)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4366)
			p.Match(YQLParserINCREMENT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(4368)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == YQLParserBY {
			{
				p.SetState(4367)
				p.Match(YQLParserBY)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(4370)
			p.Integer()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID_PLAIN() antlr.TerminalNode
	ID_QUOTED() antlr.TerminalNode

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) ID_PLAIN() antlr.TerminalNode {
	return s.GetToken(YQLParserID_PLAIN, 0)
}

func (s *IdentifierContext) ID_QUOTED() antlr.TerminalNode {
	return s.GetToken(YQLParserID_QUOTED, 0)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitIdentifier(s)
	}
}




func (p *YQLParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 780, YQLParserRULE_identifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4373)
		_la = p.GetTokenStream().LA(1)

		if !(_la == YQLParserID_PLAIN || _la == YQLParserID_QUOTED) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIdContext is an interface to support dynamic dispatch.
type IIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Keyword() IKeywordContext

	// IsIdContext differentiates from other interfaces.
	IsIdContext()
}

type IdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdContext() *IdContext {
	var p = new(IdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_id
	return p
}

func InitEmptyIdContext(p *IdContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_id
}

func (*IdContext) IsIdContext() {}

func NewIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdContext {
	var p = new(IdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_id

	return p
}

func (s *IdContext) GetParser() antlr.Parser { return s.parser }

func (s *IdContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdContext) Keyword() IKeywordContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordContext)
}

func (s *IdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterId(s)
	}
}

func (s *IdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitId(s)
	}
}




func (p *YQLParser) Id() (localctx IIdContext) {
	localctx = NewIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 782, YQLParserRULE_id)
	p.SetState(4377)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserID_PLAIN, YQLParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4375)
			p.Identifier()
		}


	case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALL, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserANY, YQLParserARRAY, YQLParserAS, YQLParserASC, YQLParserASSUME, YQLParserASYMMETRIC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBETWEEN, YQLParserBITCAST, YQLParserBY, YQLParserCASCADE, YQLParserCASE, YQLParserCAST, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOLUMN, YQLParserCOLUMNS, YQLParserCOMMIT, YQLParserCOMPACT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCUBE, YQLParserCURRENT, YQLParserCURRENT_DATE, YQLParserCURRENT_TIME, YQLParserCURRENT_TIMESTAMP, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDISTINCT, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserEMPTY_ACTION, YQLParserENCRYPTED, YQLParserEND, YQLParserERASE, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCEPT, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXISTS, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFROM, YQLParserFULL, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserGROUPS, YQLParserHASH, YQLParserHAVING, YQLParserHOP, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTERSECT, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserJSON_EXISTS, YQLParserJSON_QUERY, YQLParserJSON_VALUE, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLIMIT, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOT, YQLParserNOTNULL, YQLParserNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserPROCESS, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserRANGE, YQLParserREDUCE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserRETURN, YQLParserRETURNING, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROLLUP, YQLParserROW, YQLParserROWS, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSCHEMA, YQLParserSECONDS, YQLParserSEEK, YQLParserSELECT, YQLParserSEMI, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSTREAM, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYMMETRIC, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTYPE, YQLParserUNBOUNDED, YQLParserUNCONDITIONAL, YQLParserUNION, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWHEN, YQLParserWHERE, YQLParserWINDOW, YQLParserWITH, YQLParserWITHOUT, YQLParserWRAPPER, YQLParserXOR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4376)
			p.Keyword()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IId_schemaContext is an interface to support dynamic dispatch.
type IId_schemaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Keyword_compat() IKeyword_compatContext
	Keyword_expr_uncompat() IKeyword_expr_uncompatContext
	Keyword_select_uncompat() IKeyword_select_uncompatContext
	Keyword_in_uncompat() IKeyword_in_uncompatContext
	Keyword_window_uncompat() IKeyword_window_uncompatContext
	Keyword_hint_uncompat() IKeyword_hint_uncompatContext

	// IsId_schemaContext differentiates from other interfaces.
	IsId_schemaContext()
}

type Id_schemaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyId_schemaContext() *Id_schemaContext {
	var p = new(Id_schemaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_id_schema
	return p
}

func InitEmptyId_schemaContext(p *Id_schemaContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_id_schema
}

func (*Id_schemaContext) IsId_schemaContext() {}

func NewId_schemaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Id_schemaContext {
	var p = new(Id_schemaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_id_schema

	return p
}

func (s *Id_schemaContext) GetParser() antlr.Parser { return s.parser }

func (s *Id_schemaContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Id_schemaContext) Keyword_compat() IKeyword_compatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_compatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_compatContext)
}

func (s *Id_schemaContext) Keyword_expr_uncompat() IKeyword_expr_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_expr_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_expr_uncompatContext)
}

func (s *Id_schemaContext) Keyword_select_uncompat() IKeyword_select_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_select_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_select_uncompatContext)
}

func (s *Id_schemaContext) Keyword_in_uncompat() IKeyword_in_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_in_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_in_uncompatContext)
}

func (s *Id_schemaContext) Keyword_window_uncompat() IKeyword_window_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_window_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_window_uncompatContext)
}

func (s *Id_schemaContext) Keyword_hint_uncompat() IKeyword_hint_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_hint_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_hint_uncompatContext)
}

func (s *Id_schemaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Id_schemaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Id_schemaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterId_schema(s)
	}
}

func (s *Id_schemaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitId_schema(s)
	}
}




func (p *YQLParser) Id_schema() (localctx IId_schemaContext) {
	localctx = NewId_schemaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 784, YQLParserRULE_id_schema)
	p.SetState(4386)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserID_PLAIN, YQLParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4379)
			p.Identifier()
		}


	case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserARRAY, YQLParserASC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBY, YQLParserCASCADE, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOMMIT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCURRENT, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserENCRYPTED, YQLParserEND, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserHASH, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOTNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROW, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSECONDS, YQLParserSEEK, YQLParserSEMI, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTYPE, YQLParserUNCONDITIONAL, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWITH, YQLParserWRAPPER, YQLParserXOR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4380)
			p.Keyword_compat()
		}


	case YQLParserASYMMETRIC, YQLParserBETWEEN, YQLParserBITCAST, YQLParserCASE, YQLParserCAST, YQLParserCUBE, YQLParserCURRENT_DATE, YQLParserCURRENT_TIME, YQLParserCURRENT_TIMESTAMP, YQLParserEMPTY_ACTION, YQLParserEXISTS, YQLParserFROM, YQLParserFULL, YQLParserHOP, YQLParserJSON_EXISTS, YQLParserJSON_QUERY, YQLParserJSON_VALUE, YQLParserNOT, YQLParserNULL, YQLParserPROCESS, YQLParserREDUCE, YQLParserRETURN, YQLParserRETURNING, YQLParserROLLUP, YQLParserSELECT, YQLParserSYMMETRIC, YQLParserUNBOUNDED, YQLParserWHEN, YQLParserWHERE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4381)
			p.Keyword_expr_uncompat()
		}


	case YQLParserALL, YQLParserAS, YQLParserASSUME, YQLParserDISTINCT, YQLParserEXCEPT, YQLParserHAVING, YQLParserINTERSECT, YQLParserLIMIT, YQLParserUNION, YQLParserWINDOW, YQLParserWITHOUT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4382)
			p.Keyword_select_uncompat()
		}


	case YQLParserCOMPACT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4383)
			p.Keyword_in_uncompat()
		}


	case YQLParserGROUPS, YQLParserRANGE, YQLParserROWS:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4384)
			p.Keyword_window_uncompat()
		}


	case YQLParserCOLUMNS, YQLParserSCHEMA:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4385)
			p.Keyword_hint_uncompat()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IId_exprContext is an interface to support dynamic dispatch.
type IId_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Keyword_compat() IKeyword_compatContext
	Keyword_alter_uncompat() IKeyword_alter_uncompatContext
	Keyword_in_uncompat() IKeyword_in_uncompatContext
	Keyword_window_uncompat() IKeyword_window_uncompatContext
	Keyword_hint_uncompat() IKeyword_hint_uncompatContext

	// IsId_exprContext differentiates from other interfaces.
	IsId_exprContext()
}

type Id_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyId_exprContext() *Id_exprContext {
	var p = new(Id_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_id_expr
	return p
}

func InitEmptyId_exprContext(p *Id_exprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_id_expr
}

func (*Id_exprContext) IsId_exprContext() {}

func NewId_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Id_exprContext {
	var p = new(Id_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_id_expr

	return p
}

func (s *Id_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Id_exprContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Id_exprContext) Keyword_compat() IKeyword_compatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_compatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_compatContext)
}

func (s *Id_exprContext) Keyword_alter_uncompat() IKeyword_alter_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_alter_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_alter_uncompatContext)
}

func (s *Id_exprContext) Keyword_in_uncompat() IKeyword_in_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_in_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_in_uncompatContext)
}

func (s *Id_exprContext) Keyword_window_uncompat() IKeyword_window_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_window_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_window_uncompatContext)
}

func (s *Id_exprContext) Keyword_hint_uncompat() IKeyword_hint_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_hint_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_hint_uncompatContext)
}

func (s *Id_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Id_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Id_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterId_expr(s)
	}
}

func (s *Id_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitId_expr(s)
	}
}




func (p *YQLParser) Id_expr() (localctx IId_exprContext) {
	localctx = NewId_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 786, YQLParserRULE_id_expr)
	p.SetState(4394)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserID_PLAIN, YQLParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4388)
			p.Identifier()
		}


	case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserARRAY, YQLParserASC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBY, YQLParserCASCADE, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOMMIT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCURRENT, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserENCRYPTED, YQLParserEND, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserHASH, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOTNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROW, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSECONDS, YQLParserSEEK, YQLParserSEMI, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTYPE, YQLParserUNCONDITIONAL, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWITH, YQLParserWRAPPER, YQLParserXOR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4389)
			p.Keyword_compat()
		}


	case YQLParserCOLUMN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4390)
			p.Keyword_alter_uncompat()
		}


	case YQLParserCOMPACT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4391)
			p.Keyword_in_uncompat()
		}


	case YQLParserGROUPS, YQLParserRANGE, YQLParserROWS:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4392)
			p.Keyword_window_uncompat()
		}


	case YQLParserCOLUMNS, YQLParserSCHEMA:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4393)
			p.Keyword_hint_uncompat()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IId_expr_inContext is an interface to support dynamic dispatch.
type IId_expr_inContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Keyword_compat() IKeyword_compatContext
	Keyword_alter_uncompat() IKeyword_alter_uncompatContext
	Keyword_window_uncompat() IKeyword_window_uncompatContext
	Keyword_hint_uncompat() IKeyword_hint_uncompatContext

	// IsId_expr_inContext differentiates from other interfaces.
	IsId_expr_inContext()
}

type Id_expr_inContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyId_expr_inContext() *Id_expr_inContext {
	var p = new(Id_expr_inContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_id_expr_in
	return p
}

func InitEmptyId_expr_inContext(p *Id_expr_inContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_id_expr_in
}

func (*Id_expr_inContext) IsId_expr_inContext() {}

func NewId_expr_inContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Id_expr_inContext {
	var p = new(Id_expr_inContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_id_expr_in

	return p
}

func (s *Id_expr_inContext) GetParser() antlr.Parser { return s.parser }

func (s *Id_expr_inContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Id_expr_inContext) Keyword_compat() IKeyword_compatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_compatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_compatContext)
}

func (s *Id_expr_inContext) Keyword_alter_uncompat() IKeyword_alter_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_alter_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_alter_uncompatContext)
}

func (s *Id_expr_inContext) Keyword_window_uncompat() IKeyword_window_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_window_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_window_uncompatContext)
}

func (s *Id_expr_inContext) Keyword_hint_uncompat() IKeyword_hint_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_hint_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_hint_uncompatContext)
}

func (s *Id_expr_inContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Id_expr_inContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Id_expr_inContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterId_expr_in(s)
	}
}

func (s *Id_expr_inContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitId_expr_in(s)
	}
}




func (p *YQLParser) Id_expr_in() (localctx IId_expr_inContext) {
	localctx = NewId_expr_inContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 788, YQLParserRULE_id_expr_in)
	p.SetState(4401)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserID_PLAIN, YQLParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4396)
			p.Identifier()
		}


	case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserARRAY, YQLParserASC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBY, YQLParserCASCADE, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOMMIT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCURRENT, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserENCRYPTED, YQLParserEND, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserHASH, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOTNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROW, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSECONDS, YQLParserSEEK, YQLParserSEMI, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTYPE, YQLParserUNCONDITIONAL, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWITH, YQLParserWRAPPER, YQLParserXOR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4397)
			p.Keyword_compat()
		}


	case YQLParserCOLUMN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4398)
			p.Keyword_alter_uncompat()
		}


	case YQLParserGROUPS, YQLParserRANGE, YQLParserROWS:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4399)
			p.Keyword_window_uncompat()
		}


	case YQLParserCOLUMNS, YQLParserSCHEMA:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4400)
			p.Keyword_hint_uncompat()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IId_windowContext is an interface to support dynamic dispatch.
type IId_windowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Keyword_compat() IKeyword_compatContext
	Keyword_expr_uncompat() IKeyword_expr_uncompatContext
	Keyword_table_uncompat() IKeyword_table_uncompatContext
	Keyword_select_uncompat() IKeyword_select_uncompatContext
	Keyword_alter_uncompat() IKeyword_alter_uncompatContext
	Keyword_in_uncompat() IKeyword_in_uncompatContext
	Keyword_hint_uncompat() IKeyword_hint_uncompatContext

	// IsId_windowContext differentiates from other interfaces.
	IsId_windowContext()
}

type Id_windowContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyId_windowContext() *Id_windowContext {
	var p = new(Id_windowContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_id_window
	return p
}

func InitEmptyId_windowContext(p *Id_windowContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_id_window
}

func (*Id_windowContext) IsId_windowContext() {}

func NewId_windowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Id_windowContext {
	var p = new(Id_windowContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_id_window

	return p
}

func (s *Id_windowContext) GetParser() antlr.Parser { return s.parser }

func (s *Id_windowContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Id_windowContext) Keyword_compat() IKeyword_compatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_compatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_compatContext)
}

func (s *Id_windowContext) Keyword_expr_uncompat() IKeyword_expr_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_expr_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_expr_uncompatContext)
}

func (s *Id_windowContext) Keyword_table_uncompat() IKeyword_table_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_table_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_table_uncompatContext)
}

func (s *Id_windowContext) Keyword_select_uncompat() IKeyword_select_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_select_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_select_uncompatContext)
}

func (s *Id_windowContext) Keyword_alter_uncompat() IKeyword_alter_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_alter_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_alter_uncompatContext)
}

func (s *Id_windowContext) Keyword_in_uncompat() IKeyword_in_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_in_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_in_uncompatContext)
}

func (s *Id_windowContext) Keyword_hint_uncompat() IKeyword_hint_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_hint_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_hint_uncompatContext)
}

func (s *Id_windowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Id_windowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Id_windowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterId_window(s)
	}
}

func (s *Id_windowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitId_window(s)
	}
}




func (p *YQLParser) Id_window() (localctx IId_windowContext) {
	localctx = NewId_windowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 790, YQLParserRULE_id_window)
	p.SetState(4411)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserID_PLAIN, YQLParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4403)
			p.Identifier()
		}


	case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserARRAY, YQLParserASC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBY, YQLParserCASCADE, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOMMIT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCURRENT, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserENCRYPTED, YQLParserEND, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserHASH, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOTNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROW, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSECONDS, YQLParserSEEK, YQLParserSEMI, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTYPE, YQLParserUNCONDITIONAL, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWITH, YQLParserWRAPPER, YQLParserXOR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4404)
			p.Keyword_compat()
		}


	case YQLParserASYMMETRIC, YQLParserBETWEEN, YQLParserBITCAST, YQLParserCASE, YQLParserCAST, YQLParserCUBE, YQLParserCURRENT_DATE, YQLParserCURRENT_TIME, YQLParserCURRENT_TIMESTAMP, YQLParserEMPTY_ACTION, YQLParserEXISTS, YQLParserFROM, YQLParserFULL, YQLParserHOP, YQLParserJSON_EXISTS, YQLParserJSON_QUERY, YQLParserJSON_VALUE, YQLParserNOT, YQLParserNULL, YQLParserPROCESS, YQLParserREDUCE, YQLParserRETURN, YQLParserRETURNING, YQLParserROLLUP, YQLParserSELECT, YQLParserSYMMETRIC, YQLParserUNBOUNDED, YQLParserWHEN, YQLParserWHERE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4405)
			p.Keyword_expr_uncompat()
		}


	case YQLParserANY, YQLParserERASE, YQLParserSTREAM:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4406)
			p.Keyword_table_uncompat()
		}


	case YQLParserALL, YQLParserAS, YQLParserASSUME, YQLParserDISTINCT, YQLParserEXCEPT, YQLParserHAVING, YQLParserINTERSECT, YQLParserLIMIT, YQLParserUNION, YQLParserWINDOW, YQLParserWITHOUT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4407)
			p.Keyword_select_uncompat()
		}


	case YQLParserCOLUMN:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4408)
			p.Keyword_alter_uncompat()
		}


	case YQLParserCOMPACT:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4409)
			p.Keyword_in_uncompat()
		}


	case YQLParserCOLUMNS, YQLParserSCHEMA:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4410)
			p.Keyword_hint_uncompat()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IId_tableContext is an interface to support dynamic dispatch.
type IId_tableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Keyword_compat() IKeyword_compatContext
	Keyword_expr_uncompat() IKeyword_expr_uncompatContext
	Keyword_select_uncompat() IKeyword_select_uncompatContext
	Keyword_in_uncompat() IKeyword_in_uncompatContext
	Keyword_window_uncompat() IKeyword_window_uncompatContext
	Keyword_hint_uncompat() IKeyword_hint_uncompatContext

	// IsId_tableContext differentiates from other interfaces.
	IsId_tableContext()
}

type Id_tableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyId_tableContext() *Id_tableContext {
	var p = new(Id_tableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_id_table
	return p
}

func InitEmptyId_tableContext(p *Id_tableContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_id_table
}

func (*Id_tableContext) IsId_tableContext() {}

func NewId_tableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Id_tableContext {
	var p = new(Id_tableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_id_table

	return p
}

func (s *Id_tableContext) GetParser() antlr.Parser { return s.parser }

func (s *Id_tableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Id_tableContext) Keyword_compat() IKeyword_compatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_compatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_compatContext)
}

func (s *Id_tableContext) Keyword_expr_uncompat() IKeyword_expr_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_expr_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_expr_uncompatContext)
}

func (s *Id_tableContext) Keyword_select_uncompat() IKeyword_select_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_select_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_select_uncompatContext)
}

func (s *Id_tableContext) Keyword_in_uncompat() IKeyword_in_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_in_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_in_uncompatContext)
}

func (s *Id_tableContext) Keyword_window_uncompat() IKeyword_window_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_window_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_window_uncompatContext)
}

func (s *Id_tableContext) Keyword_hint_uncompat() IKeyword_hint_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_hint_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_hint_uncompatContext)
}

func (s *Id_tableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Id_tableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Id_tableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterId_table(s)
	}
}

func (s *Id_tableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitId_table(s)
	}
}




func (p *YQLParser) Id_table() (localctx IId_tableContext) {
	localctx = NewId_tableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 792, YQLParserRULE_id_table)
	p.SetState(4420)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserID_PLAIN, YQLParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4413)
			p.Identifier()
		}


	case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserARRAY, YQLParserASC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBY, YQLParserCASCADE, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOMMIT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCURRENT, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserENCRYPTED, YQLParserEND, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserHASH, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOTNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROW, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSECONDS, YQLParserSEEK, YQLParserSEMI, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTYPE, YQLParserUNCONDITIONAL, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWITH, YQLParserWRAPPER, YQLParserXOR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4414)
			p.Keyword_compat()
		}


	case YQLParserASYMMETRIC, YQLParserBETWEEN, YQLParserBITCAST, YQLParserCASE, YQLParserCAST, YQLParserCUBE, YQLParserCURRENT_DATE, YQLParserCURRENT_TIME, YQLParserCURRENT_TIMESTAMP, YQLParserEMPTY_ACTION, YQLParserEXISTS, YQLParserFROM, YQLParserFULL, YQLParserHOP, YQLParserJSON_EXISTS, YQLParserJSON_QUERY, YQLParserJSON_VALUE, YQLParserNOT, YQLParserNULL, YQLParserPROCESS, YQLParserREDUCE, YQLParserRETURN, YQLParserRETURNING, YQLParserROLLUP, YQLParserSELECT, YQLParserSYMMETRIC, YQLParserUNBOUNDED, YQLParserWHEN, YQLParserWHERE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4415)
			p.Keyword_expr_uncompat()
		}


	case YQLParserALL, YQLParserAS, YQLParserASSUME, YQLParserDISTINCT, YQLParserEXCEPT, YQLParserHAVING, YQLParserINTERSECT, YQLParserLIMIT, YQLParserUNION, YQLParserWINDOW, YQLParserWITHOUT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4416)
			p.Keyword_select_uncompat()
		}


	case YQLParserCOMPACT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4417)
			p.Keyword_in_uncompat()
		}


	case YQLParserGROUPS, YQLParserRANGE, YQLParserROWS:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4418)
			p.Keyword_window_uncompat()
		}


	case YQLParserCOLUMNS, YQLParserSCHEMA:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4419)
			p.Keyword_hint_uncompat()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IId_withoutContext is an interface to support dynamic dispatch.
type IId_withoutContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Keyword_compat() IKeyword_compatContext
	Keyword_table_uncompat() IKeyword_table_uncompatContext
	Keyword_alter_uncompat() IKeyword_alter_uncompatContext
	Keyword_in_uncompat() IKeyword_in_uncompatContext
	Keyword_window_uncompat() IKeyword_window_uncompatContext
	Keyword_hint_uncompat() IKeyword_hint_uncompatContext

	// IsId_withoutContext differentiates from other interfaces.
	IsId_withoutContext()
}

type Id_withoutContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyId_withoutContext() *Id_withoutContext {
	var p = new(Id_withoutContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_id_without
	return p
}

func InitEmptyId_withoutContext(p *Id_withoutContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_id_without
}

func (*Id_withoutContext) IsId_withoutContext() {}

func NewId_withoutContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Id_withoutContext {
	var p = new(Id_withoutContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_id_without

	return p
}

func (s *Id_withoutContext) GetParser() antlr.Parser { return s.parser }

func (s *Id_withoutContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Id_withoutContext) Keyword_compat() IKeyword_compatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_compatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_compatContext)
}

func (s *Id_withoutContext) Keyword_table_uncompat() IKeyword_table_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_table_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_table_uncompatContext)
}

func (s *Id_withoutContext) Keyword_alter_uncompat() IKeyword_alter_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_alter_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_alter_uncompatContext)
}

func (s *Id_withoutContext) Keyword_in_uncompat() IKeyword_in_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_in_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_in_uncompatContext)
}

func (s *Id_withoutContext) Keyword_window_uncompat() IKeyword_window_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_window_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_window_uncompatContext)
}

func (s *Id_withoutContext) Keyword_hint_uncompat() IKeyword_hint_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_hint_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_hint_uncompatContext)
}

func (s *Id_withoutContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Id_withoutContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Id_withoutContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterId_without(s)
	}
}

func (s *Id_withoutContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitId_without(s)
	}
}




func (p *YQLParser) Id_without() (localctx IId_withoutContext) {
	localctx = NewId_withoutContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 794, YQLParserRULE_id_without)
	p.SetState(4429)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserID_PLAIN, YQLParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4422)
			p.Identifier()
		}


	case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserARRAY, YQLParserASC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBY, YQLParserCASCADE, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOMMIT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCURRENT, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserENCRYPTED, YQLParserEND, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserHASH, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOTNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROW, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSECONDS, YQLParserSEEK, YQLParserSEMI, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTYPE, YQLParserUNCONDITIONAL, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWITH, YQLParserWRAPPER, YQLParserXOR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4423)
			p.Keyword_compat()
		}


	case YQLParserANY, YQLParserERASE, YQLParserSTREAM:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4424)
			p.Keyword_table_uncompat()
		}


	case YQLParserCOLUMN:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4425)
			p.Keyword_alter_uncompat()
		}


	case YQLParserCOMPACT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4426)
			p.Keyword_in_uncompat()
		}


	case YQLParserGROUPS, YQLParserRANGE, YQLParserROWS:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4427)
			p.Keyword_window_uncompat()
		}


	case YQLParserCOLUMNS, YQLParserSCHEMA:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4428)
			p.Keyword_hint_uncompat()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IId_hintContext is an interface to support dynamic dispatch.
type IId_hintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Keyword_compat() IKeyword_compatContext
	Keyword_expr_uncompat() IKeyword_expr_uncompatContext
	Keyword_table_uncompat() IKeyword_table_uncompatContext
	Keyword_select_uncompat() IKeyword_select_uncompatContext
	Keyword_alter_uncompat() IKeyword_alter_uncompatContext
	Keyword_in_uncompat() IKeyword_in_uncompatContext
	Keyword_window_uncompat() IKeyword_window_uncompatContext

	// IsId_hintContext differentiates from other interfaces.
	IsId_hintContext()
}

type Id_hintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyId_hintContext() *Id_hintContext {
	var p = new(Id_hintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_id_hint
	return p
}

func InitEmptyId_hintContext(p *Id_hintContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_id_hint
}

func (*Id_hintContext) IsId_hintContext() {}

func NewId_hintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Id_hintContext {
	var p = new(Id_hintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_id_hint

	return p
}

func (s *Id_hintContext) GetParser() antlr.Parser { return s.parser }

func (s *Id_hintContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Id_hintContext) Keyword_compat() IKeyword_compatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_compatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_compatContext)
}

func (s *Id_hintContext) Keyword_expr_uncompat() IKeyword_expr_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_expr_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_expr_uncompatContext)
}

func (s *Id_hintContext) Keyword_table_uncompat() IKeyword_table_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_table_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_table_uncompatContext)
}

func (s *Id_hintContext) Keyword_select_uncompat() IKeyword_select_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_select_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_select_uncompatContext)
}

func (s *Id_hintContext) Keyword_alter_uncompat() IKeyword_alter_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_alter_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_alter_uncompatContext)
}

func (s *Id_hintContext) Keyword_in_uncompat() IKeyword_in_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_in_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_in_uncompatContext)
}

func (s *Id_hintContext) Keyword_window_uncompat() IKeyword_window_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_window_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_window_uncompatContext)
}

func (s *Id_hintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Id_hintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Id_hintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterId_hint(s)
	}
}

func (s *Id_hintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitId_hint(s)
	}
}




func (p *YQLParser) Id_hint() (localctx IId_hintContext) {
	localctx = NewId_hintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 796, YQLParserRULE_id_hint)
	p.SetState(4439)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserID_PLAIN, YQLParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4431)
			p.Identifier()
		}


	case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserARRAY, YQLParserASC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBY, YQLParserCASCADE, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOMMIT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCURRENT, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserENCRYPTED, YQLParserEND, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserHASH, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOTNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROW, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSECONDS, YQLParserSEEK, YQLParserSEMI, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTYPE, YQLParserUNCONDITIONAL, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWITH, YQLParserWRAPPER, YQLParserXOR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4432)
			p.Keyword_compat()
		}


	case YQLParserASYMMETRIC, YQLParserBETWEEN, YQLParserBITCAST, YQLParserCASE, YQLParserCAST, YQLParserCUBE, YQLParserCURRENT_DATE, YQLParserCURRENT_TIME, YQLParserCURRENT_TIMESTAMP, YQLParserEMPTY_ACTION, YQLParserEXISTS, YQLParserFROM, YQLParserFULL, YQLParserHOP, YQLParserJSON_EXISTS, YQLParserJSON_QUERY, YQLParserJSON_VALUE, YQLParserNOT, YQLParserNULL, YQLParserPROCESS, YQLParserREDUCE, YQLParserRETURN, YQLParserRETURNING, YQLParserROLLUP, YQLParserSELECT, YQLParserSYMMETRIC, YQLParserUNBOUNDED, YQLParserWHEN, YQLParserWHERE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4433)
			p.Keyword_expr_uncompat()
		}


	case YQLParserANY, YQLParserERASE, YQLParserSTREAM:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4434)
			p.Keyword_table_uncompat()
		}


	case YQLParserALL, YQLParserAS, YQLParserASSUME, YQLParserDISTINCT, YQLParserEXCEPT, YQLParserHAVING, YQLParserINTERSECT, YQLParserLIMIT, YQLParserUNION, YQLParserWINDOW, YQLParserWITHOUT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4435)
			p.Keyword_select_uncompat()
		}


	case YQLParserCOLUMN:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4436)
			p.Keyword_alter_uncompat()
		}


	case YQLParserCOMPACT:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4437)
			p.Keyword_in_uncompat()
		}


	case YQLParserGROUPS, YQLParserRANGE, YQLParserROWS:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4438)
			p.Keyword_window_uncompat()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IId_as_compatContext is an interface to support dynamic dispatch.
type IId_as_compatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Keyword_as_compat() IKeyword_as_compatContext

	// IsId_as_compatContext differentiates from other interfaces.
	IsId_as_compatContext()
}

type Id_as_compatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyId_as_compatContext() *Id_as_compatContext {
	var p = new(Id_as_compatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_id_as_compat
	return p
}

func InitEmptyId_as_compatContext(p *Id_as_compatContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_id_as_compat
}

func (*Id_as_compatContext) IsId_as_compatContext() {}

func NewId_as_compatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Id_as_compatContext {
	var p = new(Id_as_compatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_id_as_compat

	return p
}

func (s *Id_as_compatContext) GetParser() antlr.Parser { return s.parser }

func (s *Id_as_compatContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Id_as_compatContext) Keyword_as_compat() IKeyword_as_compatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_as_compatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_as_compatContext)
}

func (s *Id_as_compatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Id_as_compatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Id_as_compatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterId_as_compat(s)
	}
}

func (s *Id_as_compatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitId_as_compat(s)
	}
}




func (p *YQLParser) Id_as_compat() (localctx IId_as_compatContext) {
	localctx = NewId_as_compatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 798, YQLParserRULE_id_as_compat)
	p.SetState(4443)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserID_PLAIN, YQLParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4441)
			p.Identifier()
		}


	case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserARRAY, YQLParserASC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBY, YQLParserCASCADE, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOMMIT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCURRENT, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserENCRYPTED, YQLParserEND, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCLUDE, YQLParserEXCLUSIVE, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserHASH, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTO, YQLParserIS, YQLParserLAST, YQLParserLEGACY, YQLParserLIKE, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserREVERT, YQLParserREVOKE, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROW, YQLParserSAVEPOINT, YQLParserSECONDS, YQLParserSEEK, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTYPE, YQLParserUNCONDITIONAL, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserVACUUM, YQLParserVALUES, YQLParserVIRTUAL, YQLParserWRAPPER, YQLParserXOR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4442)
			p.Keyword_as_compat()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAn_idContext is an interface to support dynamic dispatch.
type IAn_idContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id() IIdContext
	STRING_VALUE() antlr.TerminalNode

	// IsAn_idContext differentiates from other interfaces.
	IsAn_idContext()
}

type An_idContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAn_idContext() *An_idContext {
	var p = new(An_idContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_an_id
	return p
}

func InitEmptyAn_idContext(p *An_idContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_an_id
}

func (*An_idContext) IsAn_idContext() {}

func NewAn_idContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *An_idContext {
	var p = new(An_idContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_an_id

	return p
}

func (s *An_idContext) GetParser() antlr.Parser { return s.parser }

func (s *An_idContext) Id() IIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *An_idContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(YQLParserSTRING_VALUE, 0)
}

func (s *An_idContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *An_idContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *An_idContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAn_id(s)
	}
}

func (s *An_idContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAn_id(s)
	}
}




func (p *YQLParser) An_id() (localctx IAn_idContext) {
	localctx = NewAn_idContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 800, YQLParserRULE_an_id)
	p.SetState(4447)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALL, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserANY, YQLParserARRAY, YQLParserAS, YQLParserASC, YQLParserASSUME, YQLParserASYMMETRIC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBETWEEN, YQLParserBITCAST, YQLParserBY, YQLParserCASCADE, YQLParserCASE, YQLParserCAST, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOLUMN, YQLParserCOLUMNS, YQLParserCOMMIT, YQLParserCOMPACT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCUBE, YQLParserCURRENT, YQLParserCURRENT_DATE, YQLParserCURRENT_TIME, YQLParserCURRENT_TIMESTAMP, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDISTINCT, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserEMPTY_ACTION, YQLParserENCRYPTED, YQLParserEND, YQLParserERASE, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCEPT, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXISTS, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFROM, YQLParserFULL, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserGROUPS, YQLParserHASH, YQLParserHAVING, YQLParserHOP, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTERSECT, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserJSON_EXISTS, YQLParserJSON_QUERY, YQLParserJSON_VALUE, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLIMIT, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOT, YQLParserNOTNULL, YQLParserNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserPROCESS, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserRANGE, YQLParserREDUCE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserRETURN, YQLParserRETURNING, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROLLUP, YQLParserROW, YQLParserROWS, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSCHEMA, YQLParserSECONDS, YQLParserSEEK, YQLParserSELECT, YQLParserSEMI, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSTREAM, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYMMETRIC, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTYPE, YQLParserUNBOUNDED, YQLParserUNCONDITIONAL, YQLParserUNION, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWHEN, YQLParserWHERE, YQLParserWINDOW, YQLParserWITH, YQLParserWITHOUT, YQLParserWRAPPER, YQLParserXOR, YQLParserID_PLAIN, YQLParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4445)
			p.Id()
		}


	case YQLParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4446)
			p.Match(YQLParserSTRING_VALUE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAn_id_or_typeContext is an interface to support dynamic dispatch.
type IAn_id_or_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_or_type() IId_or_typeContext
	STRING_VALUE() antlr.TerminalNode

	// IsAn_id_or_typeContext differentiates from other interfaces.
	IsAn_id_or_typeContext()
}

type An_id_or_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAn_id_or_typeContext() *An_id_or_typeContext {
	var p = new(An_id_or_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_an_id_or_type
	return p
}

func InitEmptyAn_id_or_typeContext(p *An_id_or_typeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_an_id_or_type
}

func (*An_id_or_typeContext) IsAn_id_or_typeContext() {}

func NewAn_id_or_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *An_id_or_typeContext {
	var p = new(An_id_or_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_an_id_or_type

	return p
}

func (s *An_id_or_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *An_id_or_typeContext) Id_or_type() IId_or_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_or_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_or_typeContext)
}

func (s *An_id_or_typeContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(YQLParserSTRING_VALUE, 0)
}

func (s *An_id_or_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *An_id_or_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *An_id_or_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAn_id_or_type(s)
	}
}

func (s *An_id_or_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAn_id_or_type(s)
	}
}




func (p *YQLParser) An_id_or_type() (localctx IAn_id_or_typeContext) {
	localctx = NewAn_id_or_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 802, YQLParserRULE_an_id_or_type)
	p.SetState(4451)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALL, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserANY, YQLParserARRAY, YQLParserAS, YQLParserASC, YQLParserASSUME, YQLParserASYMMETRIC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBETWEEN, YQLParserBITCAST, YQLParserBY, YQLParserCALLABLE, YQLParserCASCADE, YQLParserCASE, YQLParserCAST, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOLUMN, YQLParserCOLUMNS, YQLParserCOMMIT, YQLParserCOMPACT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCUBE, YQLParserCURRENT, YQLParserCURRENT_DATE, YQLParserCURRENT_TIME, YQLParserCURRENT_TIMESTAMP, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDICT, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDISTINCT, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserEMPTY_ACTION, YQLParserENCRYPTED, YQLParserEND, YQLParserENUM, YQLParserERASE, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCEPT, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXISTS, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFLOW, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFROM, YQLParserFULL, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserGROUPS, YQLParserHASH, YQLParserHAVING, YQLParserHOP, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTERSECT, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserJSON_EXISTS, YQLParserJSON_QUERY, YQLParserJSON_VALUE, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLIMIT, YQLParserLIST, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOT, YQLParserNOTNULL, YQLParserNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOPTIONAL, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserPROCESS, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserRANGE, YQLParserREDUCE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESOURCE, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserRETURN, YQLParserRETURNING, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROLLUP, YQLParserROW, YQLParserROWS, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSCHEMA, YQLParserSECONDS, YQLParserSEEK, YQLParserSELECT, YQLParserSEMI, YQLParserSET, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSTREAM, YQLParserSTRUCT, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYMMETRIC, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTAGGED, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTUPLE, YQLParserTYPE, YQLParserUNBOUNDED, YQLParserUNCONDITIONAL, YQLParserUNION, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVARIANT, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWHEN, YQLParserWHERE, YQLParserWINDOW, YQLParserWITH, YQLParserWITHOUT, YQLParserWRAPPER, YQLParserXOR, YQLParserID_PLAIN, YQLParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4449)
			p.Id_or_type()
		}


	case YQLParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4450)
			p.Match(YQLParserSTRING_VALUE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAn_id_schemaContext is an interface to support dynamic dispatch.
type IAn_id_schemaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_schema() IId_schemaContext
	STRING_VALUE() antlr.TerminalNode

	// IsAn_id_schemaContext differentiates from other interfaces.
	IsAn_id_schemaContext()
}

type An_id_schemaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAn_id_schemaContext() *An_id_schemaContext {
	var p = new(An_id_schemaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_an_id_schema
	return p
}

func InitEmptyAn_id_schemaContext(p *An_id_schemaContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_an_id_schema
}

func (*An_id_schemaContext) IsAn_id_schemaContext() {}

func NewAn_id_schemaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *An_id_schemaContext {
	var p = new(An_id_schemaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_an_id_schema

	return p
}

func (s *An_id_schemaContext) GetParser() antlr.Parser { return s.parser }

func (s *An_id_schemaContext) Id_schema() IId_schemaContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_schemaContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_schemaContext)
}

func (s *An_id_schemaContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(YQLParserSTRING_VALUE, 0)
}

func (s *An_id_schemaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *An_id_schemaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *An_id_schemaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAn_id_schema(s)
	}
}

func (s *An_id_schemaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAn_id_schema(s)
	}
}




func (p *YQLParser) An_id_schema() (localctx IAn_id_schemaContext) {
	localctx = NewAn_id_schemaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 804, YQLParserRULE_an_id_schema)
	p.SetState(4455)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALL, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserARRAY, YQLParserAS, YQLParserASC, YQLParserASSUME, YQLParserASYMMETRIC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBETWEEN, YQLParserBITCAST, YQLParserBY, YQLParserCASCADE, YQLParserCASE, YQLParserCAST, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOLUMNS, YQLParserCOMMIT, YQLParserCOMPACT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCUBE, YQLParserCURRENT, YQLParserCURRENT_DATE, YQLParserCURRENT_TIME, YQLParserCURRENT_TIMESTAMP, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDISTINCT, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserEMPTY_ACTION, YQLParserENCRYPTED, YQLParserEND, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCEPT, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXISTS, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFROM, YQLParserFULL, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserGROUPS, YQLParserHASH, YQLParserHAVING, YQLParserHOP, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTERSECT, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserJSON_EXISTS, YQLParserJSON_QUERY, YQLParserJSON_VALUE, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLIMIT, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOT, YQLParserNOTNULL, YQLParserNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserPROCESS, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserRANGE, YQLParserREDUCE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserRETURN, YQLParserRETURNING, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROLLUP, YQLParserROW, YQLParserROWS, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSCHEMA, YQLParserSECONDS, YQLParserSEEK, YQLParserSELECT, YQLParserSEMI, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYMMETRIC, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTYPE, YQLParserUNBOUNDED, YQLParserUNCONDITIONAL, YQLParserUNION, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWHEN, YQLParserWHERE, YQLParserWINDOW, YQLParserWITH, YQLParserWITHOUT, YQLParserWRAPPER, YQLParserXOR, YQLParserID_PLAIN, YQLParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4453)
			p.Id_schema()
		}


	case YQLParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4454)
			p.Match(YQLParserSTRING_VALUE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAn_id_exprContext is an interface to support dynamic dispatch.
type IAn_id_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_expr() IId_exprContext
	STRING_VALUE() antlr.TerminalNode

	// IsAn_id_exprContext differentiates from other interfaces.
	IsAn_id_exprContext()
}

type An_id_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAn_id_exprContext() *An_id_exprContext {
	var p = new(An_id_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_an_id_expr
	return p
}

func InitEmptyAn_id_exprContext(p *An_id_exprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_an_id_expr
}

func (*An_id_exprContext) IsAn_id_exprContext() {}

func NewAn_id_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *An_id_exprContext {
	var p = new(An_id_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_an_id_expr

	return p
}

func (s *An_id_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *An_id_exprContext) Id_expr() IId_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_exprContext)
}

func (s *An_id_exprContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(YQLParserSTRING_VALUE, 0)
}

func (s *An_id_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *An_id_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *An_id_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAn_id_expr(s)
	}
}

func (s *An_id_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAn_id_expr(s)
	}
}




func (p *YQLParser) An_id_expr() (localctx IAn_id_exprContext) {
	localctx = NewAn_id_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 806, YQLParserRULE_an_id_expr)
	p.SetState(4459)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserARRAY, YQLParserASC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBY, YQLParserCASCADE, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOLUMN, YQLParserCOLUMNS, YQLParserCOMMIT, YQLParserCOMPACT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCURRENT, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserENCRYPTED, YQLParserEND, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserGROUPS, YQLParserHASH, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOTNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserRANGE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROW, YQLParserROWS, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSCHEMA, YQLParserSECONDS, YQLParserSEEK, YQLParserSEMI, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTYPE, YQLParserUNCONDITIONAL, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWITH, YQLParserWRAPPER, YQLParserXOR, YQLParserID_PLAIN, YQLParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4457)
			p.Id_expr()
		}


	case YQLParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4458)
			p.Match(YQLParserSTRING_VALUE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAn_id_expr_inContext is an interface to support dynamic dispatch.
type IAn_id_expr_inContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_expr_in() IId_expr_inContext
	STRING_VALUE() antlr.TerminalNode

	// IsAn_id_expr_inContext differentiates from other interfaces.
	IsAn_id_expr_inContext()
}

type An_id_expr_inContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAn_id_expr_inContext() *An_id_expr_inContext {
	var p = new(An_id_expr_inContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_an_id_expr_in
	return p
}

func InitEmptyAn_id_expr_inContext(p *An_id_expr_inContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_an_id_expr_in
}

func (*An_id_expr_inContext) IsAn_id_expr_inContext() {}

func NewAn_id_expr_inContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *An_id_expr_inContext {
	var p = new(An_id_expr_inContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_an_id_expr_in

	return p
}

func (s *An_id_expr_inContext) GetParser() antlr.Parser { return s.parser }

func (s *An_id_expr_inContext) Id_expr_in() IId_expr_inContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_expr_inContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_expr_inContext)
}

func (s *An_id_expr_inContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(YQLParserSTRING_VALUE, 0)
}

func (s *An_id_expr_inContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *An_id_expr_inContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *An_id_expr_inContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAn_id_expr_in(s)
	}
}

func (s *An_id_expr_inContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAn_id_expr_in(s)
	}
}




func (p *YQLParser) An_id_expr_in() (localctx IAn_id_expr_inContext) {
	localctx = NewAn_id_expr_inContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 808, YQLParserRULE_an_id_expr_in)
	p.SetState(4463)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserARRAY, YQLParserASC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBY, YQLParserCASCADE, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOLUMN, YQLParserCOLUMNS, YQLParserCOMMIT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCURRENT, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserENCRYPTED, YQLParserEND, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserGROUPS, YQLParserHASH, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOTNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserRANGE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROW, YQLParserROWS, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSCHEMA, YQLParserSECONDS, YQLParserSEEK, YQLParserSEMI, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTYPE, YQLParserUNCONDITIONAL, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWITH, YQLParserWRAPPER, YQLParserXOR, YQLParserID_PLAIN, YQLParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4461)
			p.Id_expr_in()
		}


	case YQLParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4462)
			p.Match(YQLParserSTRING_VALUE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAn_id_windowContext is an interface to support dynamic dispatch.
type IAn_id_windowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_window() IId_windowContext
	STRING_VALUE() antlr.TerminalNode

	// IsAn_id_windowContext differentiates from other interfaces.
	IsAn_id_windowContext()
}

type An_id_windowContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAn_id_windowContext() *An_id_windowContext {
	var p = new(An_id_windowContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_an_id_window
	return p
}

func InitEmptyAn_id_windowContext(p *An_id_windowContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_an_id_window
}

func (*An_id_windowContext) IsAn_id_windowContext() {}

func NewAn_id_windowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *An_id_windowContext {
	var p = new(An_id_windowContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_an_id_window

	return p
}

func (s *An_id_windowContext) GetParser() antlr.Parser { return s.parser }

func (s *An_id_windowContext) Id_window() IId_windowContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_windowContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_windowContext)
}

func (s *An_id_windowContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(YQLParserSTRING_VALUE, 0)
}

func (s *An_id_windowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *An_id_windowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *An_id_windowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAn_id_window(s)
	}
}

func (s *An_id_windowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAn_id_window(s)
	}
}




func (p *YQLParser) An_id_window() (localctx IAn_id_windowContext) {
	localctx = NewAn_id_windowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 810, YQLParserRULE_an_id_window)
	p.SetState(4467)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALL, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserANY, YQLParserARRAY, YQLParserAS, YQLParserASC, YQLParserASSUME, YQLParserASYMMETRIC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBETWEEN, YQLParserBITCAST, YQLParserBY, YQLParserCASCADE, YQLParserCASE, YQLParserCAST, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOLUMN, YQLParserCOLUMNS, YQLParserCOMMIT, YQLParserCOMPACT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCUBE, YQLParserCURRENT, YQLParserCURRENT_DATE, YQLParserCURRENT_TIME, YQLParserCURRENT_TIMESTAMP, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDISTINCT, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserEMPTY_ACTION, YQLParserENCRYPTED, YQLParserEND, YQLParserERASE, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCEPT, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXISTS, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFROM, YQLParserFULL, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserHASH, YQLParserHAVING, YQLParserHOP, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTERSECT, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserJSON_EXISTS, YQLParserJSON_QUERY, YQLParserJSON_VALUE, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLIMIT, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOT, YQLParserNOTNULL, YQLParserNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserPROCESS, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserREDUCE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserRETURN, YQLParserRETURNING, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROLLUP, YQLParserROW, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSCHEMA, YQLParserSECONDS, YQLParserSEEK, YQLParserSELECT, YQLParserSEMI, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSTREAM, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYMMETRIC, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTYPE, YQLParserUNBOUNDED, YQLParserUNCONDITIONAL, YQLParserUNION, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWHEN, YQLParserWHERE, YQLParserWINDOW, YQLParserWITH, YQLParserWITHOUT, YQLParserWRAPPER, YQLParserXOR, YQLParserID_PLAIN, YQLParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4465)
			p.Id_window()
		}


	case YQLParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4466)
			p.Match(YQLParserSTRING_VALUE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAn_id_tableContext is an interface to support dynamic dispatch.
type IAn_id_tableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_table() IId_tableContext
	STRING_VALUE() antlr.TerminalNode

	// IsAn_id_tableContext differentiates from other interfaces.
	IsAn_id_tableContext()
}

type An_id_tableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAn_id_tableContext() *An_id_tableContext {
	var p = new(An_id_tableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_an_id_table
	return p
}

func InitEmptyAn_id_tableContext(p *An_id_tableContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_an_id_table
}

func (*An_id_tableContext) IsAn_id_tableContext() {}

func NewAn_id_tableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *An_id_tableContext {
	var p = new(An_id_tableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_an_id_table

	return p
}

func (s *An_id_tableContext) GetParser() antlr.Parser { return s.parser }

func (s *An_id_tableContext) Id_table() IId_tableContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_tableContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_tableContext)
}

func (s *An_id_tableContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(YQLParserSTRING_VALUE, 0)
}

func (s *An_id_tableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *An_id_tableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *An_id_tableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAn_id_table(s)
	}
}

func (s *An_id_tableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAn_id_table(s)
	}
}




func (p *YQLParser) An_id_table() (localctx IAn_id_tableContext) {
	localctx = NewAn_id_tableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 812, YQLParserRULE_an_id_table)
	p.SetState(4471)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALL, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserARRAY, YQLParserAS, YQLParserASC, YQLParserASSUME, YQLParserASYMMETRIC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBETWEEN, YQLParserBITCAST, YQLParserBY, YQLParserCASCADE, YQLParserCASE, YQLParserCAST, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOLUMNS, YQLParserCOMMIT, YQLParserCOMPACT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCUBE, YQLParserCURRENT, YQLParserCURRENT_DATE, YQLParserCURRENT_TIME, YQLParserCURRENT_TIMESTAMP, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDISTINCT, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserEMPTY_ACTION, YQLParserENCRYPTED, YQLParserEND, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCEPT, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXISTS, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFROM, YQLParserFULL, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserGROUPS, YQLParserHASH, YQLParserHAVING, YQLParserHOP, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTERSECT, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserJSON_EXISTS, YQLParserJSON_QUERY, YQLParserJSON_VALUE, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLIMIT, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOT, YQLParserNOTNULL, YQLParserNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserPROCESS, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserRANGE, YQLParserREDUCE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserRETURN, YQLParserRETURNING, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROLLUP, YQLParserROW, YQLParserROWS, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSCHEMA, YQLParserSECONDS, YQLParserSEEK, YQLParserSELECT, YQLParserSEMI, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYMMETRIC, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTYPE, YQLParserUNBOUNDED, YQLParserUNCONDITIONAL, YQLParserUNION, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWHEN, YQLParserWHERE, YQLParserWINDOW, YQLParserWITH, YQLParserWITHOUT, YQLParserWRAPPER, YQLParserXOR, YQLParserID_PLAIN, YQLParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4469)
			p.Id_table()
		}


	case YQLParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4470)
			p.Match(YQLParserSTRING_VALUE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAn_id_withoutContext is an interface to support dynamic dispatch.
type IAn_id_withoutContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_without() IId_withoutContext
	STRING_VALUE() antlr.TerminalNode

	// IsAn_id_withoutContext differentiates from other interfaces.
	IsAn_id_withoutContext()
}

type An_id_withoutContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAn_id_withoutContext() *An_id_withoutContext {
	var p = new(An_id_withoutContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_an_id_without
	return p
}

func InitEmptyAn_id_withoutContext(p *An_id_withoutContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_an_id_without
}

func (*An_id_withoutContext) IsAn_id_withoutContext() {}

func NewAn_id_withoutContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *An_id_withoutContext {
	var p = new(An_id_withoutContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_an_id_without

	return p
}

func (s *An_id_withoutContext) GetParser() antlr.Parser { return s.parser }

func (s *An_id_withoutContext) Id_without() IId_withoutContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_withoutContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_withoutContext)
}

func (s *An_id_withoutContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(YQLParserSTRING_VALUE, 0)
}

func (s *An_id_withoutContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *An_id_withoutContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *An_id_withoutContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAn_id_without(s)
	}
}

func (s *An_id_withoutContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAn_id_without(s)
	}
}




func (p *YQLParser) An_id_without() (localctx IAn_id_withoutContext) {
	localctx = NewAn_id_withoutContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 814, YQLParserRULE_an_id_without)
	p.SetState(4475)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserANY, YQLParserARRAY, YQLParserASC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBY, YQLParserCASCADE, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOLUMN, YQLParserCOLUMNS, YQLParserCOMMIT, YQLParserCOMPACT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCURRENT, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserENCRYPTED, YQLParserEND, YQLParserERASE, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserGROUPS, YQLParserHASH, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOTNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserRANGE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROW, YQLParserROWS, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSCHEMA, YQLParserSECONDS, YQLParserSEEK, YQLParserSEMI, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSTREAM, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTYPE, YQLParserUNCONDITIONAL, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWITH, YQLParserWRAPPER, YQLParserXOR, YQLParserID_PLAIN, YQLParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4473)
			p.Id_without()
		}


	case YQLParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4474)
			p.Match(YQLParserSTRING_VALUE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAn_id_hintContext is an interface to support dynamic dispatch.
type IAn_id_hintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_hint() IId_hintContext
	STRING_VALUE() antlr.TerminalNode

	// IsAn_id_hintContext differentiates from other interfaces.
	IsAn_id_hintContext()
}

type An_id_hintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAn_id_hintContext() *An_id_hintContext {
	var p = new(An_id_hintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_an_id_hint
	return p
}

func InitEmptyAn_id_hintContext(p *An_id_hintContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_an_id_hint
}

func (*An_id_hintContext) IsAn_id_hintContext() {}

func NewAn_id_hintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *An_id_hintContext {
	var p = new(An_id_hintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_an_id_hint

	return p
}

func (s *An_id_hintContext) GetParser() antlr.Parser { return s.parser }

func (s *An_id_hintContext) Id_hint() IId_hintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_hintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_hintContext)
}

func (s *An_id_hintContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(YQLParserSTRING_VALUE, 0)
}

func (s *An_id_hintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *An_id_hintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *An_id_hintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAn_id_hint(s)
	}
}

func (s *An_id_hintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAn_id_hint(s)
	}
}




func (p *YQLParser) An_id_hint() (localctx IAn_id_hintContext) {
	localctx = NewAn_id_hintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 816, YQLParserRULE_an_id_hint)
	p.SetState(4479)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALL, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserANY, YQLParserARRAY, YQLParserAS, YQLParserASC, YQLParserASSUME, YQLParserASYMMETRIC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBETWEEN, YQLParserBITCAST, YQLParserBY, YQLParserCASCADE, YQLParserCASE, YQLParserCAST, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOLUMN, YQLParserCOMMIT, YQLParserCOMPACT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCUBE, YQLParserCURRENT, YQLParserCURRENT_DATE, YQLParserCURRENT_TIME, YQLParserCURRENT_TIMESTAMP, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDISTINCT, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserEMPTY_ACTION, YQLParserENCRYPTED, YQLParserEND, YQLParserERASE, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCEPT, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXISTS, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFROM, YQLParserFULL, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserGROUPS, YQLParserHASH, YQLParserHAVING, YQLParserHOP, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTERSECT, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserJSON_EXISTS, YQLParserJSON_QUERY, YQLParserJSON_VALUE, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLIMIT, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOT, YQLParserNOTNULL, YQLParserNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserPROCESS, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserRANGE, YQLParserREDUCE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserRETURN, YQLParserRETURNING, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROLLUP, YQLParserROW, YQLParserROWS, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSECONDS, YQLParserSEEK, YQLParserSELECT, YQLParserSEMI, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSTREAM, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYMMETRIC, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTYPE, YQLParserUNBOUNDED, YQLParserUNCONDITIONAL, YQLParserUNION, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWHEN, YQLParserWHERE, YQLParserWINDOW, YQLParserWITH, YQLParserWITHOUT, YQLParserWRAPPER, YQLParserXOR, YQLParserID_PLAIN, YQLParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4477)
			p.Id_hint()
		}


	case YQLParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4478)
			p.Match(YQLParserSTRING_VALUE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAn_id_pureContext is an interface to support dynamic dispatch.
type IAn_id_pureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	STRING_VALUE() antlr.TerminalNode

	// IsAn_id_pureContext differentiates from other interfaces.
	IsAn_id_pureContext()
}

type An_id_pureContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAn_id_pureContext() *An_id_pureContext {
	var p = new(An_id_pureContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_an_id_pure
	return p
}

func InitEmptyAn_id_pureContext(p *An_id_pureContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_an_id_pure
}

func (*An_id_pureContext) IsAn_id_pureContext() {}

func NewAn_id_pureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *An_id_pureContext {
	var p = new(An_id_pureContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_an_id_pure

	return p
}

func (s *An_id_pureContext) GetParser() antlr.Parser { return s.parser }

func (s *An_id_pureContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *An_id_pureContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(YQLParserSTRING_VALUE, 0)
}

func (s *An_id_pureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *An_id_pureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *An_id_pureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAn_id_pure(s)
	}
}

func (s *An_id_pureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAn_id_pure(s)
	}
}




func (p *YQLParser) An_id_pure() (localctx IAn_id_pureContext) {
	localctx = NewAn_id_pureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 818, YQLParserRULE_an_id_pure)
	p.SetState(4483)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserID_PLAIN, YQLParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4481)
			p.Identifier()
		}


	case YQLParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4482)
			p.Match(YQLParserSTRING_VALUE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAn_id_as_compatContext is an interface to support dynamic dispatch.
type IAn_id_as_compatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_as_compat() IId_as_compatContext
	STRING_VALUE() antlr.TerminalNode

	// IsAn_id_as_compatContext differentiates from other interfaces.
	IsAn_id_as_compatContext()
}

type An_id_as_compatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAn_id_as_compatContext() *An_id_as_compatContext {
	var p = new(An_id_as_compatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_an_id_as_compat
	return p
}

func InitEmptyAn_id_as_compatContext(p *An_id_as_compatContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_an_id_as_compat
}

func (*An_id_as_compatContext) IsAn_id_as_compatContext() {}

func NewAn_id_as_compatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *An_id_as_compatContext {
	var p = new(An_id_as_compatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_an_id_as_compat

	return p
}

func (s *An_id_as_compatContext) GetParser() antlr.Parser { return s.parser }

func (s *An_id_as_compatContext) Id_as_compat() IId_as_compatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_as_compatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_as_compatContext)
}

func (s *An_id_as_compatContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(YQLParserSTRING_VALUE, 0)
}

func (s *An_id_as_compatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *An_id_as_compatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *An_id_as_compatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterAn_id_as_compat(s)
	}
}

func (s *An_id_as_compatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitAn_id_as_compat(s)
	}
}




func (p *YQLParser) An_id_as_compat() (localctx IAn_id_as_compatContext) {
	localctx = NewAn_id_as_compatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 820, YQLParserRULE_an_id_as_compat)
	p.SetState(4487)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserARRAY, YQLParserASC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBY, YQLParserCASCADE, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOMMIT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCURRENT, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserENCRYPTED, YQLParserEND, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCLUDE, YQLParserEXCLUSIVE, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserHASH, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTO, YQLParserIS, YQLParserLAST, YQLParserLEGACY, YQLParserLIKE, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserREVERT, YQLParserREVOKE, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROW, YQLParserSAVEPOINT, YQLParserSECONDS, YQLParserSEEK, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTYPE, YQLParserUNCONDITIONAL, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserVACUUM, YQLParserVALUES, YQLParserVIRTUAL, YQLParserWRAPPER, YQLParserXOR, YQLParserID_PLAIN, YQLParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4485)
			p.Id_as_compat()
		}


	case YQLParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4486)
			p.Match(YQLParserSTRING_VALUE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IView_nameContext is an interface to support dynamic dispatch.
type IView_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id() IAn_idContext
	PRIMARY() antlr.TerminalNode
	KEY() antlr.TerminalNode

	// IsView_nameContext differentiates from other interfaces.
	IsView_nameContext()
}

type View_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyView_nameContext() *View_nameContext {
	var p = new(View_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_view_name
	return p
}

func InitEmptyView_nameContext(p *View_nameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_view_name
}

func (*View_nameContext) IsView_nameContext() {}

func NewView_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *View_nameContext {
	var p = new(View_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_view_name

	return p
}

func (s *View_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *View_nameContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *View_nameContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(YQLParserPRIMARY, 0)
}

func (s *View_nameContext) KEY() antlr.TerminalNode {
	return s.GetToken(YQLParserKEY, 0)
}

func (s *View_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *View_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *View_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterView_name(s)
	}
}

func (s *View_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitView_name(s)
	}
}




func (p *YQLParser) View_name() (localctx IView_nameContext) {
	localctx = NewView_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 822, YQLParserRULE_view_name)
	p.SetState(4492)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 495, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4489)
			p.An_id()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4490)
			p.Match(YQLParserPRIMARY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4491)
			p.Match(YQLParserKEY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOpt_id_prefixContext is an interface to support dynamic dispatch.
type IOpt_id_prefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id() IAn_idContext
	DOT() antlr.TerminalNode

	// IsOpt_id_prefixContext differentiates from other interfaces.
	IsOpt_id_prefixContext()
}

type Opt_id_prefixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_id_prefixContext() *Opt_id_prefixContext {
	var p = new(Opt_id_prefixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_opt_id_prefix
	return p
}

func InitEmptyOpt_id_prefixContext(p *Opt_id_prefixContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_opt_id_prefix
}

func (*Opt_id_prefixContext) IsOpt_id_prefixContext() {}

func NewOpt_id_prefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_id_prefixContext {
	var p = new(Opt_id_prefixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_opt_id_prefix

	return p
}

func (s *Opt_id_prefixContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_id_prefixContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Opt_id_prefixContext) DOT() antlr.TerminalNode {
	return s.GetToken(YQLParserDOT, 0)
}

func (s *Opt_id_prefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_id_prefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Opt_id_prefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterOpt_id_prefix(s)
	}
}

func (s *Opt_id_prefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitOpt_id_prefix(s)
	}
}




func (p *YQLParser) Opt_id_prefix() (localctx IOpt_id_prefixContext) {
	localctx = NewOpt_id_prefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 824, YQLParserRULE_opt_id_prefix)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(4497)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 496, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4494)
			p.An_id()
		}
		{
			p.SetState(4495)
			p.Match(YQLParserDOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICluster_exprContext is an interface to support dynamic dispatch.
type ICluster_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Pure_column_or_named() IPure_column_or_namedContext
	ASTERISK() antlr.TerminalNode
	An_id() IAn_idContext
	COLON() antlr.TerminalNode

	// IsCluster_exprContext differentiates from other interfaces.
	IsCluster_exprContext()
}

type Cluster_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCluster_exprContext() *Cluster_exprContext {
	var p = new(Cluster_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_cluster_expr
	return p
}

func InitEmptyCluster_exprContext(p *Cluster_exprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_cluster_expr
}

func (*Cluster_exprContext) IsCluster_exprContext() {}

func NewCluster_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cluster_exprContext {
	var p = new(Cluster_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_cluster_expr

	return p
}

func (s *Cluster_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Cluster_exprContext) Pure_column_or_named() IPure_column_or_namedContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPure_column_or_namedContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPure_column_or_namedContext)
}

func (s *Cluster_exprContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(YQLParserASTERISK, 0)
}

func (s *Cluster_exprContext) An_id() IAn_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Cluster_exprContext) COLON() antlr.TerminalNode {
	return s.GetToken(YQLParserCOLON, 0)
}

func (s *Cluster_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cluster_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Cluster_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterCluster_expr(s)
	}
}

func (s *Cluster_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitCluster_expr(s)
	}
}




func (p *YQLParser) Cluster_expr() (localctx ICluster_exprContext) {
	localctx = NewCluster_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 826, YQLParserRULE_cluster_expr)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(4502)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 497, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4499)
			p.An_id()
		}
		{
			p.SetState(4500)
			p.Match(YQLParserCOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(4506)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserDOLLAR, YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALL, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserANY, YQLParserARRAY, YQLParserAS, YQLParserASC, YQLParserASSUME, YQLParserASYMMETRIC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBETWEEN, YQLParserBITCAST, YQLParserBY, YQLParserCASCADE, YQLParserCASE, YQLParserCAST, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOLUMN, YQLParserCOLUMNS, YQLParserCOMMIT, YQLParserCOMPACT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCUBE, YQLParserCURRENT, YQLParserCURRENT_DATE, YQLParserCURRENT_TIME, YQLParserCURRENT_TIMESTAMP, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDISTINCT, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserEMPTY_ACTION, YQLParserENCRYPTED, YQLParserEND, YQLParserERASE, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCEPT, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXISTS, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFROM, YQLParserFULL, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserGROUPS, YQLParserHASH, YQLParserHAVING, YQLParserHOP, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTERSECT, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserJSON_EXISTS, YQLParserJSON_QUERY, YQLParserJSON_VALUE, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLIMIT, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOT, YQLParserNOTNULL, YQLParserNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserPROCESS, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserRANGE, YQLParserREDUCE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserRETURN, YQLParserRETURNING, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROLLUP, YQLParserROW, YQLParserROWS, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSCHEMA, YQLParserSECONDS, YQLParserSEEK, YQLParserSELECT, YQLParserSEMI, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSTREAM, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYMMETRIC, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTYPE, YQLParserUNBOUNDED, YQLParserUNCONDITIONAL, YQLParserUNION, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWHEN, YQLParserWHERE, YQLParserWINDOW, YQLParserWITH, YQLParserWITHOUT, YQLParserWRAPPER, YQLParserXOR, YQLParserSTRING_VALUE, YQLParserID_PLAIN, YQLParserID_QUOTED:
		{
			p.SetState(4504)
			p.Pure_column_or_named()
		}


	case YQLParserASTERISK:
		{
			p.SetState(4505)
			p.Match(YQLParserASTERISK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IId_or_typeContext is an interface to support dynamic dispatch.
type IId_or_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id() IIdContext
	Type_id() IType_idContext

	// IsId_or_typeContext differentiates from other interfaces.
	IsId_or_typeContext()
}

type Id_or_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyId_or_typeContext() *Id_or_typeContext {
	var p = new(Id_or_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_id_or_type
	return p
}

func InitEmptyId_or_typeContext(p *Id_or_typeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_id_or_type
}

func (*Id_or_typeContext) IsId_or_typeContext() {}

func NewId_or_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Id_or_typeContext {
	var p = new(Id_or_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_id_or_type

	return p
}

func (s *Id_or_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Id_or_typeContext) Id() IIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *Id_or_typeContext) Type_id() IType_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_idContext)
}

func (s *Id_or_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Id_or_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Id_or_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterId_or_type(s)
	}
}

func (s *Id_or_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitId_or_type(s)
	}
}




func (p *YQLParser) Id_or_type() (localctx IId_or_typeContext) {
	localctx = NewId_or_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 828, YQLParserRULE_id_or_type)
	p.SetState(4510)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALL, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserANY, YQLParserARRAY, YQLParserAS, YQLParserASC, YQLParserASSUME, YQLParserASYMMETRIC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBETWEEN, YQLParserBITCAST, YQLParserBY, YQLParserCASCADE, YQLParserCASE, YQLParserCAST, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOLUMN, YQLParserCOLUMNS, YQLParserCOMMIT, YQLParserCOMPACT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCUBE, YQLParserCURRENT, YQLParserCURRENT_DATE, YQLParserCURRENT_TIME, YQLParserCURRENT_TIMESTAMP, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDISTINCT, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserEMPTY_ACTION, YQLParserENCRYPTED, YQLParserEND, YQLParserERASE, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCEPT, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXISTS, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFROM, YQLParserFULL, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserGROUPS, YQLParserHASH, YQLParserHAVING, YQLParserHOP, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTERSECT, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserJSON_EXISTS, YQLParserJSON_QUERY, YQLParserJSON_VALUE, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLIMIT, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOT, YQLParserNOTNULL, YQLParserNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserPROCESS, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserRANGE, YQLParserREDUCE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserRETURN, YQLParserRETURNING, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROLLUP, YQLParserROW, YQLParserROWS, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSCHEMA, YQLParserSECONDS, YQLParserSEEK, YQLParserSELECT, YQLParserSEMI, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSTREAM, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYMMETRIC, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTYPE, YQLParserUNBOUNDED, YQLParserUNCONDITIONAL, YQLParserUNION, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWHEN, YQLParserWHERE, YQLParserWINDOW, YQLParserWITH, YQLParserWITHOUT, YQLParserWRAPPER, YQLParserXOR, YQLParserID_PLAIN, YQLParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4508)
			p.Id()
		}


	case YQLParserCALLABLE, YQLParserDICT, YQLParserENUM, YQLParserFLOW, YQLParserLIST, YQLParserOPTIONAL, YQLParserRESOURCE, YQLParserSET, YQLParserSTRUCT, YQLParserTAGGED, YQLParserTUPLE, YQLParserVARIANT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4509)
			p.Type_id()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOpt_id_prefix_or_typeContext is an interface to support dynamic dispatch.
type IOpt_id_prefix_or_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id_or_type() IAn_id_or_typeContext
	DOT() antlr.TerminalNode

	// IsOpt_id_prefix_or_typeContext differentiates from other interfaces.
	IsOpt_id_prefix_or_typeContext()
}

type Opt_id_prefix_or_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_id_prefix_or_typeContext() *Opt_id_prefix_or_typeContext {
	var p = new(Opt_id_prefix_or_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_opt_id_prefix_or_type
	return p
}

func InitEmptyOpt_id_prefix_or_typeContext(p *Opt_id_prefix_or_typeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_opt_id_prefix_or_type
}

func (*Opt_id_prefix_or_typeContext) IsOpt_id_prefix_or_typeContext() {}

func NewOpt_id_prefix_or_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_id_prefix_or_typeContext {
	var p = new(Opt_id_prefix_or_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_opt_id_prefix_or_type

	return p
}

func (s *Opt_id_prefix_or_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_id_prefix_or_typeContext) An_id_or_type() IAn_id_or_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_or_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_or_typeContext)
}

func (s *Opt_id_prefix_or_typeContext) DOT() antlr.TerminalNode {
	return s.GetToken(YQLParserDOT, 0)
}

func (s *Opt_id_prefix_or_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_id_prefix_or_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Opt_id_prefix_or_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterOpt_id_prefix_or_type(s)
	}
}

func (s *Opt_id_prefix_or_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitOpt_id_prefix_or_type(s)
	}
}




func (p *YQLParser) Opt_id_prefix_or_type() (localctx IOpt_id_prefix_or_typeContext) {
	localctx = NewOpt_id_prefix_or_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 830, YQLParserRULE_opt_id_prefix_or_type)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(4515)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 500, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4512)
			p.An_id_or_type()
		}
		{
			p.SetState(4513)
			p.Match(YQLParserDOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IId_or_atContext is an interface to support dynamic dispatch.
type IId_or_atContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id_or_type() IAn_id_or_typeContext
	COMMAT() antlr.TerminalNode

	// IsId_or_atContext differentiates from other interfaces.
	IsId_or_atContext()
}

type Id_or_atContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyId_or_atContext() *Id_or_atContext {
	var p = new(Id_or_atContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_id_or_at
	return p
}

func InitEmptyId_or_atContext(p *Id_or_atContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_id_or_at
}

func (*Id_or_atContext) IsId_or_atContext() {}

func NewId_or_atContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Id_or_atContext {
	var p = new(Id_or_atContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_id_or_at

	return p
}

func (s *Id_or_atContext) GetParser() antlr.Parser { return s.parser }

func (s *Id_or_atContext) An_id_or_type() IAn_id_or_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_or_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_or_typeContext)
}

func (s *Id_or_atContext) COMMAT() antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMAT, 0)
}

func (s *Id_or_atContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Id_or_atContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Id_or_atContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterId_or_at(s)
	}
}

func (s *Id_or_atContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitId_or_at(s)
	}
}




func (p *YQLParser) Id_or_at() (localctx IId_or_atContext) {
	localctx = NewId_or_atContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 832, YQLParserRULE_id_or_at)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4518)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserCOMMAT {
		{
			p.SetState(4517)
			p.Match(YQLParserCOMMAT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(4520)
		p.An_id_or_type()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IId_table_or_typeContext is an interface to support dynamic dispatch.
type IId_table_or_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id_table() IAn_id_tableContext
	Type_id() IType_idContext

	// IsId_table_or_typeContext differentiates from other interfaces.
	IsId_table_or_typeContext()
}

type Id_table_or_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyId_table_or_typeContext() *Id_table_or_typeContext {
	var p = new(Id_table_or_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_id_table_or_type
	return p
}

func InitEmptyId_table_or_typeContext(p *Id_table_or_typeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_id_table_or_type
}

func (*Id_table_or_typeContext) IsId_table_or_typeContext() {}

func NewId_table_or_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Id_table_or_typeContext {
	var p = new(Id_table_or_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_id_table_or_type

	return p
}

func (s *Id_table_or_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Id_table_or_typeContext) An_id_table() IAn_id_tableContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_tableContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_tableContext)
}

func (s *Id_table_or_typeContext) Type_id() IType_idContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_idContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_idContext)
}

func (s *Id_table_or_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Id_table_or_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Id_table_or_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterId_table_or_type(s)
	}
}

func (s *Id_table_or_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitId_table_or_type(s)
	}
}




func (p *YQLParser) Id_table_or_type() (localctx IId_table_or_typeContext) {
	localctx = NewId_table_or_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 834, YQLParserRULE_id_table_or_type)
	p.SetState(4524)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALL, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserARRAY, YQLParserAS, YQLParserASC, YQLParserASSUME, YQLParserASYMMETRIC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBETWEEN, YQLParserBITCAST, YQLParserBY, YQLParserCASCADE, YQLParserCASE, YQLParserCAST, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOLUMNS, YQLParserCOMMIT, YQLParserCOMPACT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCUBE, YQLParserCURRENT, YQLParserCURRENT_DATE, YQLParserCURRENT_TIME, YQLParserCURRENT_TIMESTAMP, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDISTINCT, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserEMPTY_ACTION, YQLParserENCRYPTED, YQLParserEND, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCEPT, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXISTS, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFROM, YQLParserFULL, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserGROUPS, YQLParserHASH, YQLParserHAVING, YQLParserHOP, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTERSECT, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserJSON_EXISTS, YQLParserJSON_QUERY, YQLParserJSON_VALUE, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLIMIT, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOT, YQLParserNOTNULL, YQLParserNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserPROCESS, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserRANGE, YQLParserREDUCE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserRETURN, YQLParserRETURNING, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROLLUP, YQLParserROW, YQLParserROWS, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSCHEMA, YQLParserSECONDS, YQLParserSEEK, YQLParserSELECT, YQLParserSEMI, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYMMETRIC, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTYPE, YQLParserUNBOUNDED, YQLParserUNCONDITIONAL, YQLParserUNION, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWHEN, YQLParserWHERE, YQLParserWINDOW, YQLParserWITH, YQLParserWITHOUT, YQLParserWRAPPER, YQLParserXOR, YQLParserSTRING_VALUE, YQLParserID_PLAIN, YQLParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4522)
			p.An_id_table()
		}


	case YQLParserCALLABLE, YQLParserDICT, YQLParserENUM, YQLParserFLOW, YQLParserLIST, YQLParserOPTIONAL, YQLParserRESOURCE, YQLParserSET, YQLParserSTRUCT, YQLParserTAGGED, YQLParserTUPLE, YQLParserVARIANT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4523)
			p.Type_id()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IId_table_or_atContext is an interface to support dynamic dispatch.
type IId_table_or_atContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_table_or_type() IId_table_or_typeContext
	COMMAT() antlr.TerminalNode

	// IsId_table_or_atContext differentiates from other interfaces.
	IsId_table_or_atContext()
}

type Id_table_or_atContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyId_table_or_atContext() *Id_table_or_atContext {
	var p = new(Id_table_or_atContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_id_table_or_at
	return p
}

func InitEmptyId_table_or_atContext(p *Id_table_or_atContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_id_table_or_at
}

func (*Id_table_or_atContext) IsId_table_or_atContext() {}

func NewId_table_or_atContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Id_table_or_atContext {
	var p = new(Id_table_or_atContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_id_table_or_at

	return p
}

func (s *Id_table_or_atContext) GetParser() antlr.Parser { return s.parser }

func (s *Id_table_or_atContext) Id_table_or_type() IId_table_or_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_table_or_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_table_or_typeContext)
}

func (s *Id_table_or_atContext) COMMAT() antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMAT, 0)
}

func (s *Id_table_or_atContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Id_table_or_atContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Id_table_or_atContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterId_table_or_at(s)
	}
}

func (s *Id_table_or_atContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitId_table_or_at(s)
	}
}




func (p *YQLParser) Id_table_or_at() (localctx IId_table_or_atContext) {
	localctx = NewId_table_or_atContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 836, YQLParserRULE_id_table_or_at)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4527)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == YQLParserCOMMAT {
		{
			p.SetState(4526)
			p.Match(YQLParserCOMMAT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(4529)
		p.Id_table_or_type()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IKeywordContext is an interface to support dynamic dispatch.
type IKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Keyword_compat() IKeyword_compatContext
	Keyword_expr_uncompat() IKeyword_expr_uncompatContext
	Keyword_table_uncompat() IKeyword_table_uncompatContext
	Keyword_select_uncompat() IKeyword_select_uncompatContext
	Keyword_alter_uncompat() IKeyword_alter_uncompatContext
	Keyword_in_uncompat() IKeyword_in_uncompatContext
	Keyword_window_uncompat() IKeyword_window_uncompatContext
	Keyword_hint_uncompat() IKeyword_hint_uncompatContext

	// IsKeywordContext differentiates from other interfaces.
	IsKeywordContext()
}

type KeywordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordContext() *KeywordContext {
	var p = new(KeywordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_keyword
	return p
}

func InitEmptyKeywordContext(p *KeywordContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_keyword
}

func (*KeywordContext) IsKeywordContext() {}

func NewKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordContext {
	var p = new(KeywordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_keyword

	return p
}

func (s *KeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordContext) Keyword_compat() IKeyword_compatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_compatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_compatContext)
}

func (s *KeywordContext) Keyword_expr_uncompat() IKeyword_expr_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_expr_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_expr_uncompatContext)
}

func (s *KeywordContext) Keyword_table_uncompat() IKeyword_table_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_table_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_table_uncompatContext)
}

func (s *KeywordContext) Keyword_select_uncompat() IKeyword_select_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_select_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_select_uncompatContext)
}

func (s *KeywordContext) Keyword_alter_uncompat() IKeyword_alter_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_alter_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_alter_uncompatContext)
}

func (s *KeywordContext) Keyword_in_uncompat() IKeyword_in_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_in_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_in_uncompatContext)
}

func (s *KeywordContext) Keyword_window_uncompat() IKeyword_window_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_window_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_window_uncompatContext)
}

func (s *KeywordContext) Keyword_hint_uncompat() IKeyword_hint_uncompatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_hint_uncompatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_hint_uncompatContext)
}

func (s *KeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *KeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterKeyword(s)
	}
}

func (s *KeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitKeyword(s)
	}
}




func (p *YQLParser) Keyword() (localctx IKeywordContext) {
	localctx = NewKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 838, YQLParserRULE_keyword)
	p.SetState(4539)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case YQLParserABORT, YQLParserACTION, YQLParserADD, YQLParserAFTER, YQLParserALTER, YQLParserANALYZE, YQLParserAND, YQLParserANSI, YQLParserARRAY, YQLParserASC, YQLParserASYNC, YQLParserAT, YQLParserATTACH, YQLParserATTRIBUTES, YQLParserAUTOINCREMENT, YQLParserBACKUP, YQLParserCOLLECTION, YQLParserBEFORE, YQLParserBEGIN, YQLParserBERNOULLI, YQLParserBY, YQLParserCASCADE, YQLParserCHANGEFEED, YQLParserCHECK, YQLParserCLASSIFIER, YQLParserCOLLATE, YQLParserCOMMIT, YQLParserCONDITIONAL, YQLParserCONFLICT, YQLParserCONNECT, YQLParserCONSTRAINT, YQLParserCONSUMER, YQLParserCOVER, YQLParserCREATE, YQLParserCROSS, YQLParserCURRENT, YQLParserDATA, YQLParserDATABASE, YQLParserDECIMAL, YQLParserDECLARE, YQLParserDEFAULT, YQLParserDEFERRABLE, YQLParserDEFERRED, YQLParserDEFINE, YQLParserDELETE, YQLParserDESC, YQLParserDESCRIBE, YQLParserDETACH, YQLParserDIRECTORY, YQLParserDISABLE, YQLParserDISCARD, YQLParserDO, YQLParserDROP, YQLParserEACH, YQLParserELSE, YQLParserEMPTY, YQLParserENCRYPTED, YQLParserEND, YQLParserERROR, YQLParserESCAPE, YQLParserEVALUATE, YQLParserEXCLUDE, YQLParserEXCLUSION, YQLParserEXCLUSIVE, YQLParserEXPLAIN, YQLParserEXPORT, YQLParserEXTERNAL, YQLParserFAIL, YQLParserFAMILY, YQLParserFILTER, YQLParserFIRST, YQLParserFLATTEN, YQLParserFOLLOWING, YQLParserFOR, YQLParserFOREIGN, YQLParserFUNCTION, YQLParserGLOB, YQLParserGLOBAL, YQLParserGRANT, YQLParserGROUP, YQLParserGROUPING, YQLParserHASH, YQLParserIF, YQLParserIGNORE, YQLParserILIKE, YQLParserIMMEDIATE, YQLParserIMPORT, YQLParserIN, YQLParserINCREMENT, YQLParserINCREMENTAL, YQLParserINDEX, YQLParserINDEXED, YQLParserINHERITS, YQLParserINITIAL, YQLParserINITIALLY, YQLParserINNER, YQLParserINSERT, YQLParserINSTEAD, YQLParserINTO, YQLParserIS, YQLParserISNULL, YQLParserJOIN, YQLParserKEY, YQLParserLAST, YQLParserLEFT, YQLParserLEGACY, YQLParserLIKE, YQLParserLOCAL, YQLParserLOGIN, YQLParserMANAGE, YQLParserMATCH, YQLParserMATCHES, YQLParserMATCH_RECOGNIZE, YQLParserMEASURES, YQLParserMICROSECONDS, YQLParserMILLISECONDS, YQLParserMODIFY, YQLParserNANOSECONDS, YQLParserNATURAL, YQLParserNEXT, YQLParserNO, YQLParserNOLOGIN, YQLParserNOTNULL, YQLParserNULLS, YQLParserOBJECT, YQLParserOF, YQLParserOFFSET, YQLParserOMIT, YQLParserON, YQLParserONE, YQLParserONLY, YQLParserOPTION, YQLParserOR, YQLParserORDER, YQLParserOTHERS, YQLParserOUTER, YQLParserOVER, YQLParserPARALLEL, YQLParserPARTITION, YQLParserPASSING, YQLParserPASSWORD, YQLParserPAST, YQLParserPATTERN, YQLParserPER, YQLParserPERMUTE, YQLParserPLAN, YQLParserPOOL, YQLParserPRAGMA, YQLParserPRECEDING, YQLParserPRESORT, YQLParserPRIMARY, YQLParserPRIVILEGES, YQLParserQUERY, YQLParserQUEUE, YQLParserRAISE, YQLParserREFERENCES, YQLParserREGEXP, YQLParserREINDEX, YQLParserRELEASE, YQLParserREMOVE, YQLParserRENAME, YQLParserREPLACE, YQLParserREPLICATION, YQLParserRESET, YQLParserRESPECT, YQLParserRESTART, YQLParserRESTORE, YQLParserRESTRICT, YQLParserRESULT, YQLParserREVERT, YQLParserREVOKE, YQLParserRIGHT, YQLParserRLIKE, YQLParserROLLBACK, YQLParserROW, YQLParserSAMPLE, YQLParserSAVEPOINT, YQLParserSECONDS, YQLParserSEEK, YQLParserSEMI, YQLParserSETS, YQLParserSHOW, YQLParserTSKIP, YQLParserSEQUENCE, YQLParserSOURCE, YQLParserSTART, YQLParserSUBQUERY, YQLParserSUBSET, YQLParserSYMBOLS, YQLParserSYNC, YQLParserSYSTEM, YQLParserTABLE, YQLParserTABLES, YQLParserTABLESAMPLE, YQLParserTABLESTORE, YQLParserTEMP, YQLParserTEMPORARY, YQLParserTHEN, YQLParserTIES, YQLParserTO, YQLParserTOPIC, YQLParserTRANSACTION, YQLParserTRIGGER, YQLParserTYPE, YQLParserUNCONDITIONAL, YQLParserUNIQUE, YQLParserUNKNOWN, YQLParserUNMATCHED, YQLParserUPDATE, YQLParserUPSERT, YQLParserUSE, YQLParserUSER, YQLParserUSING, YQLParserVACUUM, YQLParserVALUES, YQLParserVIEW, YQLParserVIRTUAL, YQLParserWITH, YQLParserWRAPPER, YQLParserXOR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4531)
			p.Keyword_compat()
		}


	case YQLParserASYMMETRIC, YQLParserBETWEEN, YQLParserBITCAST, YQLParserCASE, YQLParserCAST, YQLParserCUBE, YQLParserCURRENT_DATE, YQLParserCURRENT_TIME, YQLParserCURRENT_TIMESTAMP, YQLParserEMPTY_ACTION, YQLParserEXISTS, YQLParserFROM, YQLParserFULL, YQLParserHOP, YQLParserJSON_EXISTS, YQLParserJSON_QUERY, YQLParserJSON_VALUE, YQLParserNOT, YQLParserNULL, YQLParserPROCESS, YQLParserREDUCE, YQLParserRETURN, YQLParserRETURNING, YQLParserROLLUP, YQLParserSELECT, YQLParserSYMMETRIC, YQLParserUNBOUNDED, YQLParserWHEN, YQLParserWHERE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4532)
			p.Keyword_expr_uncompat()
		}


	case YQLParserANY, YQLParserERASE, YQLParserSTREAM:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4533)
			p.Keyword_table_uncompat()
		}


	case YQLParserALL, YQLParserAS, YQLParserASSUME, YQLParserDISTINCT, YQLParserEXCEPT, YQLParserHAVING, YQLParserINTERSECT, YQLParserLIMIT, YQLParserUNION, YQLParserWINDOW, YQLParserWITHOUT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4534)
			p.Keyword_select_uncompat()
		}


	case YQLParserCOLUMN:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4535)
			p.Keyword_alter_uncompat()
		}


	case YQLParserCOMPACT:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4536)
			p.Keyword_in_uncompat()
		}


	case YQLParserGROUPS, YQLParserRANGE, YQLParserROWS:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4537)
			p.Keyword_window_uncompat()
		}


	case YQLParserCOLUMNS, YQLParserSCHEMA:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4538)
			p.Keyword_hint_uncompat()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IKeyword_expr_uncompatContext is an interface to support dynamic dispatch.
type IKeyword_expr_uncompatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASYMMETRIC() antlr.TerminalNode
	BETWEEN() antlr.TerminalNode
	BITCAST() antlr.TerminalNode
	CASE() antlr.TerminalNode
	CAST() antlr.TerminalNode
	CUBE() antlr.TerminalNode
	CURRENT_DATE() antlr.TerminalNode
	CURRENT_TIME() antlr.TerminalNode
	CURRENT_TIMESTAMP() antlr.TerminalNode
	EMPTY_ACTION() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	FROM() antlr.TerminalNode
	FULL() antlr.TerminalNode
	HOP() antlr.TerminalNode
	JSON_EXISTS() antlr.TerminalNode
	JSON_VALUE() antlr.TerminalNode
	JSON_QUERY() antlr.TerminalNode
	NOT() antlr.TerminalNode
	NULL() antlr.TerminalNode
	PROCESS() antlr.TerminalNode
	REDUCE() antlr.TerminalNode
	RETURN() antlr.TerminalNode
	RETURNING() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	SELECT() antlr.TerminalNode
	SYMMETRIC() antlr.TerminalNode
	UNBOUNDED() antlr.TerminalNode
	WHEN() antlr.TerminalNode
	WHERE() antlr.TerminalNode

	// IsKeyword_expr_uncompatContext differentiates from other interfaces.
	IsKeyword_expr_uncompatContext()
}

type Keyword_expr_uncompatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyword_expr_uncompatContext() *Keyword_expr_uncompatContext {
	var p = new(Keyword_expr_uncompatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_keyword_expr_uncompat
	return p
}

func InitEmptyKeyword_expr_uncompatContext(p *Keyword_expr_uncompatContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_keyword_expr_uncompat
}

func (*Keyword_expr_uncompatContext) IsKeyword_expr_uncompatContext() {}

func NewKeyword_expr_uncompatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Keyword_expr_uncompatContext {
	var p = new(Keyword_expr_uncompatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_keyword_expr_uncompat

	return p
}

func (s *Keyword_expr_uncompatContext) GetParser() antlr.Parser { return s.parser }

func (s *Keyword_expr_uncompatContext) ASYMMETRIC() antlr.TerminalNode {
	return s.GetToken(YQLParserASYMMETRIC, 0)
}

func (s *Keyword_expr_uncompatContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(YQLParserBETWEEN, 0)
}

func (s *Keyword_expr_uncompatContext) BITCAST() antlr.TerminalNode {
	return s.GetToken(YQLParserBITCAST, 0)
}

func (s *Keyword_expr_uncompatContext) CASE() antlr.TerminalNode {
	return s.GetToken(YQLParserCASE, 0)
}

func (s *Keyword_expr_uncompatContext) CAST() antlr.TerminalNode {
	return s.GetToken(YQLParserCAST, 0)
}

func (s *Keyword_expr_uncompatContext) CUBE() antlr.TerminalNode {
	return s.GetToken(YQLParserCUBE, 0)
}

func (s *Keyword_expr_uncompatContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(YQLParserCURRENT_DATE, 0)
}

func (s *Keyword_expr_uncompatContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(YQLParserCURRENT_TIME, 0)
}

func (s *Keyword_expr_uncompatContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(YQLParserCURRENT_TIMESTAMP, 0)
}

func (s *Keyword_expr_uncompatContext) EMPTY_ACTION() antlr.TerminalNode {
	return s.GetToken(YQLParserEMPTY_ACTION, 0)
}

func (s *Keyword_expr_uncompatContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(YQLParserEXISTS, 0)
}

func (s *Keyword_expr_uncompatContext) FROM() antlr.TerminalNode {
	return s.GetToken(YQLParserFROM, 0)
}

func (s *Keyword_expr_uncompatContext) FULL() antlr.TerminalNode {
	return s.GetToken(YQLParserFULL, 0)
}

func (s *Keyword_expr_uncompatContext) HOP() antlr.TerminalNode {
	return s.GetToken(YQLParserHOP, 0)
}

func (s *Keyword_expr_uncompatContext) JSON_EXISTS() antlr.TerminalNode {
	return s.GetToken(YQLParserJSON_EXISTS, 0)
}

func (s *Keyword_expr_uncompatContext) JSON_VALUE() antlr.TerminalNode {
	return s.GetToken(YQLParserJSON_VALUE, 0)
}

func (s *Keyword_expr_uncompatContext) JSON_QUERY() antlr.TerminalNode {
	return s.GetToken(YQLParserJSON_QUERY, 0)
}

func (s *Keyword_expr_uncompatContext) NOT() antlr.TerminalNode {
	return s.GetToken(YQLParserNOT, 0)
}

func (s *Keyword_expr_uncompatContext) NULL() antlr.TerminalNode {
	return s.GetToken(YQLParserNULL, 0)
}

func (s *Keyword_expr_uncompatContext) PROCESS() antlr.TerminalNode {
	return s.GetToken(YQLParserPROCESS, 0)
}

func (s *Keyword_expr_uncompatContext) REDUCE() antlr.TerminalNode {
	return s.GetToken(YQLParserREDUCE, 0)
}

func (s *Keyword_expr_uncompatContext) RETURN() antlr.TerminalNode {
	return s.GetToken(YQLParserRETURN, 0)
}

func (s *Keyword_expr_uncompatContext) RETURNING() antlr.TerminalNode {
	return s.GetToken(YQLParserRETURNING, 0)
}

func (s *Keyword_expr_uncompatContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(YQLParserROLLUP, 0)
}

func (s *Keyword_expr_uncompatContext) SELECT() antlr.TerminalNode {
	return s.GetToken(YQLParserSELECT, 0)
}

func (s *Keyword_expr_uncompatContext) SYMMETRIC() antlr.TerminalNode {
	return s.GetToken(YQLParserSYMMETRIC, 0)
}

func (s *Keyword_expr_uncompatContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(YQLParserUNBOUNDED, 0)
}

func (s *Keyword_expr_uncompatContext) WHEN() antlr.TerminalNode {
	return s.GetToken(YQLParserWHEN, 0)
}

func (s *Keyword_expr_uncompatContext) WHERE() antlr.TerminalNode {
	return s.GetToken(YQLParserWHERE, 0)
}

func (s *Keyword_expr_uncompatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Keyword_expr_uncompatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Keyword_expr_uncompatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterKeyword_expr_uncompat(s)
	}
}

func (s *Keyword_expr_uncompatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitKeyword_expr_uncompat(s)
	}
}




func (p *YQLParser) Keyword_expr_uncompat() (localctx IKeyword_expr_uncompatContext) {
	localctx = NewKeyword_expr_uncompatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 840, YQLParserRULE_keyword_expr_uncompat)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4541)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la - 52)) & ^0x3f) == 0 && ((int64(1) << (_la - 52)) & 4611687014860206081) != 0) || ((int64((_la - 126)) & ^0x3f) == 0 && ((int64(1) << (_la - 126)) & 985162452090881) != 0) || ((int64((_la - 198)) & ^0x3f) == 0 && ((int64(1) << (_la - 198)) & 4719772692952121349) != 0) || ((int64((_la - 268)) & ^0x3f) == 0 && ((int64(1) << (_la - 268)) & 1688858450214913) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IKeyword_table_uncompatContext is an interface to support dynamic dispatch.
type IKeyword_table_uncompatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ANY() antlr.TerminalNode
	ERASE() antlr.TerminalNode
	STREAM() antlr.TerminalNode

	// IsKeyword_table_uncompatContext differentiates from other interfaces.
	IsKeyword_table_uncompatContext()
}

type Keyword_table_uncompatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyword_table_uncompatContext() *Keyword_table_uncompatContext {
	var p = new(Keyword_table_uncompatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_keyword_table_uncompat
	return p
}

func InitEmptyKeyword_table_uncompatContext(p *Keyword_table_uncompatContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_keyword_table_uncompat
}

func (*Keyword_table_uncompatContext) IsKeyword_table_uncompatContext() {}

func NewKeyword_table_uncompatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Keyword_table_uncompatContext {
	var p = new(Keyword_table_uncompatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_keyword_table_uncompat

	return p
}

func (s *Keyword_table_uncompatContext) GetParser() antlr.Parser { return s.parser }

func (s *Keyword_table_uncompatContext) ANY() antlr.TerminalNode {
	return s.GetToken(YQLParserANY, 0)
}

func (s *Keyword_table_uncompatContext) ERASE() antlr.TerminalNode {
	return s.GetToken(YQLParserERASE, 0)
}

func (s *Keyword_table_uncompatContext) STREAM() antlr.TerminalNode {
	return s.GetToken(YQLParserSTREAM, 0)
}

func (s *Keyword_table_uncompatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Keyword_table_uncompatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Keyword_table_uncompatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterKeyword_table_uncompat(s)
	}
}

func (s *Keyword_table_uncompatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitKeyword_table_uncompat(s)
	}
}




func (p *YQLParser) Keyword_table_uncompat() (localctx IKeyword_table_uncompatContext) {
	localctx = NewKeyword_table_uncompatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 842, YQLParserRULE_keyword_table_uncompat)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4543)
		_la = p.GetTokenStream().LA(1)

		if !(_la == YQLParserANY || _la == YQLParserERASE || _la == YQLParserSTREAM) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IKeyword_select_uncompatContext is an interface to support dynamic dispatch.
type IKeyword_select_uncompatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL() antlr.TerminalNode
	AS() antlr.TerminalNode
	ASSUME() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode
	EXCEPT() antlr.TerminalNode
	HAVING() antlr.TerminalNode
	INTERSECT() antlr.TerminalNode
	LIMIT() antlr.TerminalNode
	UNION() antlr.TerminalNode
	WINDOW() antlr.TerminalNode
	WITHOUT() antlr.TerminalNode

	// IsKeyword_select_uncompatContext differentiates from other interfaces.
	IsKeyword_select_uncompatContext()
}

type Keyword_select_uncompatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyword_select_uncompatContext() *Keyword_select_uncompatContext {
	var p = new(Keyword_select_uncompatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_keyword_select_uncompat
	return p
}

func InitEmptyKeyword_select_uncompatContext(p *Keyword_select_uncompatContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_keyword_select_uncompat
}

func (*Keyword_select_uncompatContext) IsKeyword_select_uncompatContext() {}

func NewKeyword_select_uncompatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Keyword_select_uncompatContext {
	var p = new(Keyword_select_uncompatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_keyword_select_uncompat

	return p
}

func (s *Keyword_select_uncompatContext) GetParser() antlr.Parser { return s.parser }

func (s *Keyword_select_uncompatContext) ALL() antlr.TerminalNode {
	return s.GetToken(YQLParserALL, 0)
}

func (s *Keyword_select_uncompatContext) AS() antlr.TerminalNode {
	return s.GetToken(YQLParserAS, 0)
}

func (s *Keyword_select_uncompatContext) ASSUME() antlr.TerminalNode {
	return s.GetToken(YQLParserASSUME, 0)
}

func (s *Keyword_select_uncompatContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(YQLParserDISTINCT, 0)
}

func (s *Keyword_select_uncompatContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(YQLParserEXCEPT, 0)
}

func (s *Keyword_select_uncompatContext) HAVING() antlr.TerminalNode {
	return s.GetToken(YQLParserHAVING, 0)
}

func (s *Keyword_select_uncompatContext) INTERSECT() antlr.TerminalNode {
	return s.GetToken(YQLParserINTERSECT, 0)
}

func (s *Keyword_select_uncompatContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(YQLParserLIMIT, 0)
}

func (s *Keyword_select_uncompatContext) UNION() antlr.TerminalNode {
	return s.GetToken(YQLParserUNION, 0)
}

func (s *Keyword_select_uncompatContext) WINDOW() antlr.TerminalNode {
	return s.GetToken(YQLParserWINDOW, 0)
}

func (s *Keyword_select_uncompatContext) WITHOUT() antlr.TerminalNode {
	return s.GetToken(YQLParserWITHOUT, 0)
}

func (s *Keyword_select_uncompatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Keyword_select_uncompatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Keyword_select_uncompatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterKeyword_select_uncompat(s)
	}
}

func (s *Keyword_select_uncompatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitKeyword_select_uncompat(s)
	}
}




func (p *YQLParser) Keyword_select_uncompat() (localctx IKeyword_select_uncompatContext) {
	localctx = NewKeyword_select_uncompatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 844, YQLParserRULE_keyword_select_uncompat)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4545)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 2819147813617664) != 0) || ((int64((_la - 108)) & ^0x3f) == 0 && ((int64(1) << (_la - 108)) & 1152925902653374465) != 0) || _la == YQLParserLIMIT || ((int64((_la - 303)) & ^0x3f) == 0 && ((int64(1) << (_la - 303)) & 327681) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IKeyword_alter_uncompatContext is an interface to support dynamic dispatch.
type IKeyword_alter_uncompatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLUMN() antlr.TerminalNode

	// IsKeyword_alter_uncompatContext differentiates from other interfaces.
	IsKeyword_alter_uncompatContext()
}

type Keyword_alter_uncompatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyword_alter_uncompatContext() *Keyword_alter_uncompatContext {
	var p = new(Keyword_alter_uncompatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_keyword_alter_uncompat
	return p
}

func InitEmptyKeyword_alter_uncompatContext(p *Keyword_alter_uncompatContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_keyword_alter_uncompat
}

func (*Keyword_alter_uncompatContext) IsKeyword_alter_uncompatContext() {}

func NewKeyword_alter_uncompatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Keyword_alter_uncompatContext {
	var p = new(Keyword_alter_uncompatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_keyword_alter_uncompat

	return p
}

func (s *Keyword_alter_uncompatContext) GetParser() antlr.Parser { return s.parser }

func (s *Keyword_alter_uncompatContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(YQLParserCOLUMN, 0)
}

func (s *Keyword_alter_uncompatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Keyword_alter_uncompatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Keyword_alter_uncompatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterKeyword_alter_uncompat(s)
	}
}

func (s *Keyword_alter_uncompatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitKeyword_alter_uncompat(s)
	}
}




func (p *YQLParser) Keyword_alter_uncompat() (localctx IKeyword_alter_uncompatContext) {
	localctx = NewKeyword_alter_uncompatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 846, YQLParserRULE_keyword_alter_uncompat)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4547)
		p.Match(YQLParserCOLUMN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IKeyword_in_uncompatContext is an interface to support dynamic dispatch.
type IKeyword_in_uncompatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMPACT() antlr.TerminalNode

	// IsKeyword_in_uncompatContext differentiates from other interfaces.
	IsKeyword_in_uncompatContext()
}

type Keyword_in_uncompatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyword_in_uncompatContext() *Keyword_in_uncompatContext {
	var p = new(Keyword_in_uncompatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_keyword_in_uncompat
	return p
}

func InitEmptyKeyword_in_uncompatContext(p *Keyword_in_uncompatContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_keyword_in_uncompat
}

func (*Keyword_in_uncompatContext) IsKeyword_in_uncompatContext() {}

func NewKeyword_in_uncompatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Keyword_in_uncompatContext {
	var p = new(Keyword_in_uncompatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_keyword_in_uncompat

	return p
}

func (s *Keyword_in_uncompatContext) GetParser() antlr.Parser { return s.parser }

func (s *Keyword_in_uncompatContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(YQLParserCOMPACT, 0)
}

func (s *Keyword_in_uncompatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Keyword_in_uncompatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Keyword_in_uncompatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterKeyword_in_uncompat(s)
	}
}

func (s *Keyword_in_uncompatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitKeyword_in_uncompat(s)
	}
}




func (p *YQLParser) Keyword_in_uncompat() (localctx IKeyword_in_uncompatContext) {
	localctx = NewKeyword_in_uncompatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 848, YQLParserRULE_keyword_in_uncompat)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4549)
		p.Match(YQLParserCOMPACT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IKeyword_window_uncompatContext is an interface to support dynamic dispatch.
type IKeyword_window_uncompatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GROUPS() antlr.TerminalNode
	RANGE() antlr.TerminalNode
	ROWS() antlr.TerminalNode

	// IsKeyword_window_uncompatContext differentiates from other interfaces.
	IsKeyword_window_uncompatContext()
}

type Keyword_window_uncompatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyword_window_uncompatContext() *Keyword_window_uncompatContext {
	var p = new(Keyword_window_uncompatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_keyword_window_uncompat
	return p
}

func InitEmptyKeyword_window_uncompatContext(p *Keyword_window_uncompatContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_keyword_window_uncompat
}

func (*Keyword_window_uncompatContext) IsKeyword_window_uncompatContext() {}

func NewKeyword_window_uncompatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Keyword_window_uncompatContext {
	var p = new(Keyword_window_uncompatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_keyword_window_uncompat

	return p
}

func (s *Keyword_window_uncompatContext) GetParser() antlr.Parser { return s.parser }

func (s *Keyword_window_uncompatContext) GROUPS() antlr.TerminalNode {
	return s.GetToken(YQLParserGROUPS, 0)
}

func (s *Keyword_window_uncompatContext) RANGE() antlr.TerminalNode {
	return s.GetToken(YQLParserRANGE, 0)
}

func (s *Keyword_window_uncompatContext) ROWS() antlr.TerminalNode {
	return s.GetToken(YQLParserROWS, 0)
}

func (s *Keyword_window_uncompatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Keyword_window_uncompatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Keyword_window_uncompatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterKeyword_window_uncompat(s)
	}
}

func (s *Keyword_window_uncompatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitKeyword_window_uncompat(s)
	}
}




func (p *YQLParser) Keyword_window_uncompat() (localctx IKeyword_window_uncompatContext) {
	localctx = NewKeyword_window_uncompatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 850, YQLParserRULE_keyword_window_uncompat)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4551)
		_la = p.GetTokenStream().LA(1)

		if !(_la == YQLParserGROUPS || _la == YQLParserRANGE || _la == YQLParserROWS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IKeyword_hint_uncompatContext is an interface to support dynamic dispatch.
type IKeyword_hint_uncompatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SCHEMA() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode

	// IsKeyword_hint_uncompatContext differentiates from other interfaces.
	IsKeyword_hint_uncompatContext()
}

type Keyword_hint_uncompatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyword_hint_uncompatContext() *Keyword_hint_uncompatContext {
	var p = new(Keyword_hint_uncompatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_keyword_hint_uncompat
	return p
}

func InitEmptyKeyword_hint_uncompatContext(p *Keyword_hint_uncompatContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_keyword_hint_uncompat
}

func (*Keyword_hint_uncompatContext) IsKeyword_hint_uncompatContext() {}

func NewKeyword_hint_uncompatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Keyword_hint_uncompatContext {
	var p = new(Keyword_hint_uncompatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_keyword_hint_uncompat

	return p
}

func (s *Keyword_hint_uncompatContext) GetParser() antlr.Parser { return s.parser }

func (s *Keyword_hint_uncompatContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(YQLParserSCHEMA, 0)
}

func (s *Keyword_hint_uncompatContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(YQLParserCOLUMNS, 0)
}

func (s *Keyword_hint_uncompatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Keyword_hint_uncompatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Keyword_hint_uncompatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterKeyword_hint_uncompat(s)
	}
}

func (s *Keyword_hint_uncompatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitKeyword_hint_uncompat(s)
	}
}




func (p *YQLParser) Keyword_hint_uncompat() (localctx IKeyword_hint_uncompatContext) {
	localctx = NewKeyword_hint_uncompatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 852, YQLParserRULE_keyword_hint_uncompat)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4553)
		_la = p.GetTokenStream().LA(1)

		if !(_la == YQLParserCOLUMNS || _la == YQLParserSCHEMA) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IKeyword_as_compatContext is an interface to support dynamic dispatch.
type IKeyword_as_compatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ABORT() antlr.TerminalNode
	ACTION() antlr.TerminalNode
	ADD() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	ALTER() antlr.TerminalNode
	ANALYZE() antlr.TerminalNode
	AND() antlr.TerminalNode
	ANSI() antlr.TerminalNode
	ARRAY() antlr.TerminalNode
	ASC() antlr.TerminalNode
	ASYNC() antlr.TerminalNode
	AT() antlr.TerminalNode
	ATTACH() antlr.TerminalNode
	ATTRIBUTES() antlr.TerminalNode
	AUTOINCREMENT() antlr.TerminalNode
	BACKUP() antlr.TerminalNode
	BEFORE() antlr.TerminalNode
	BEGIN() antlr.TerminalNode
	BERNOULLI() antlr.TerminalNode
	BY() antlr.TerminalNode
	CASCADE() antlr.TerminalNode
	CHANGEFEED() antlr.TerminalNode
	CHECK() antlr.TerminalNode
	CLASSIFIER() antlr.TerminalNode
	COLLECTION() antlr.TerminalNode
	COMMIT() antlr.TerminalNode
	CONDITIONAL() antlr.TerminalNode
	CONFLICT() antlr.TerminalNode
	CONNECT() antlr.TerminalNode
	CONSTRAINT() antlr.TerminalNode
	CONSUMER() antlr.TerminalNode
	COVER() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	DATA() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	DECIMAL() antlr.TerminalNode
	DECLARE() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	DEFERRABLE() antlr.TerminalNode
	DEFERRED() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	DESC() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode
	DETACH() antlr.TerminalNode
	DIRECTORY() antlr.TerminalNode
	DISABLE() antlr.TerminalNode
	DISCARD() antlr.TerminalNode
	DROP() antlr.TerminalNode
	EACH() antlr.TerminalNode
	ELSE() antlr.TerminalNode
	EMPTY() antlr.TerminalNode
	ENCRYPTED() antlr.TerminalNode
	END() antlr.TerminalNode
	ERROR() antlr.TerminalNode
	ESCAPE() antlr.TerminalNode
	EVALUATE() antlr.TerminalNode
	EXCLUDE() antlr.TerminalNode
	EXCLUSIVE() antlr.TerminalNode
	EXPLAIN() antlr.TerminalNode
	EXPORT() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	FAIL() antlr.TerminalNode
	FAMILY() antlr.TerminalNode
	FILTER() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	FLATTEN() antlr.TerminalNode
	FOLLOWING() antlr.TerminalNode
	FOR() antlr.TerminalNode
	FOREIGN() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	GLOB() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	GRANT() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	GROUPING() antlr.TerminalNode
	HASH() antlr.TerminalNode
	IF() antlr.TerminalNode
	IGNORE() antlr.TerminalNode
	ILIKE() antlr.TerminalNode
	IMMEDIATE() antlr.TerminalNode
	IMPORT() antlr.TerminalNode
	IN() antlr.TerminalNode
	INCREMENT() antlr.TerminalNode
	INCREMENTAL() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	INDEXED() antlr.TerminalNode
	INHERITS() antlr.TerminalNode
	INITIAL() antlr.TerminalNode
	INITIALLY() antlr.TerminalNode
	INSERT() antlr.TerminalNode
	INSTEAD() antlr.TerminalNode
	INTO() antlr.TerminalNode
	IS() antlr.TerminalNode
	LAST() antlr.TerminalNode
	LEGACY() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	LOGIN() antlr.TerminalNode
	MANAGE() antlr.TerminalNode
	MATCH() antlr.TerminalNode
	MATCHES() antlr.TerminalNode
	MATCH_RECOGNIZE() antlr.TerminalNode
	MEASURES() antlr.TerminalNode
	MICROSECONDS() antlr.TerminalNode
	MILLISECONDS() antlr.TerminalNode
	MODIFY() antlr.TerminalNode
	NANOSECONDS() antlr.TerminalNode
	NEXT() antlr.TerminalNode
	NO() antlr.TerminalNode
	NOLOGIN() antlr.TerminalNode
	NULLS() antlr.TerminalNode
	OBJECT() antlr.TerminalNode
	OF() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	OMIT() antlr.TerminalNode
	ONE() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	OPTION() antlr.TerminalNode
	OR() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	OTHERS() antlr.TerminalNode
	PARALLEL() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	PASSING() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	PAST() antlr.TerminalNode
	PATTERN() antlr.TerminalNode
	PER() antlr.TerminalNode
	PERMUTE() antlr.TerminalNode
	PLAN() antlr.TerminalNode
	POOL() antlr.TerminalNode
	PRAGMA() antlr.TerminalNode
	PRECEDING() antlr.TerminalNode
	PRIMARY() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode
	QUERY() antlr.TerminalNode
	QUEUE() antlr.TerminalNode
	RAISE() antlr.TerminalNode
	REFERENCES() antlr.TerminalNode
	REGEXP() antlr.TerminalNode
	REINDEX() antlr.TerminalNode
	RELEASE() antlr.TerminalNode
	REMOVE() antlr.TerminalNode
	RENAME() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	REPLICATION() antlr.TerminalNode
	RESET() antlr.TerminalNode
	RESPECT() antlr.TerminalNode
	RESTART() antlr.TerminalNode
	RESTORE() antlr.TerminalNode
	RESTRICT() antlr.TerminalNode
	REVERT() antlr.TerminalNode
	REVOKE() antlr.TerminalNode
	RLIKE() antlr.TerminalNode
	ROLLBACK() antlr.TerminalNode
	ROW() antlr.TerminalNode
	SAVEPOINT() antlr.TerminalNode
	SECONDS() antlr.TerminalNode
	SEEK() antlr.TerminalNode
	SETS() antlr.TerminalNode
	SHOW() antlr.TerminalNode
	TSKIP() antlr.TerminalNode
	SEQUENCE() antlr.TerminalNode
	SOURCE() antlr.TerminalNode
	START() antlr.TerminalNode
	SUBQUERY() antlr.TerminalNode
	SUBSET() antlr.TerminalNode
	SYMBOLS() antlr.TerminalNode
	SYNC() antlr.TerminalNode
	SYSTEM() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	TABLESAMPLE() antlr.TerminalNode
	TABLESTORE() antlr.TerminalNode
	TEMP() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	THEN() antlr.TerminalNode
	TIES() antlr.TerminalNode
	TO() antlr.TerminalNode
	TOPIC() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	TRIGGER() antlr.TerminalNode
	TYPE() antlr.TerminalNode
	UNCONDITIONAL() antlr.TerminalNode
	UNIQUE() antlr.TerminalNode
	UNKNOWN() antlr.TerminalNode
	UNMATCHED() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	UPSERT() antlr.TerminalNode
	USE() antlr.TerminalNode
	USER() antlr.TerminalNode
	VACUUM() antlr.TerminalNode
	VALUES() antlr.TerminalNode
	VIRTUAL() antlr.TerminalNode
	WRAPPER() antlr.TerminalNode
	XOR() antlr.TerminalNode

	// IsKeyword_as_compatContext differentiates from other interfaces.
	IsKeyword_as_compatContext()
}

type Keyword_as_compatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyword_as_compatContext() *Keyword_as_compatContext {
	var p = new(Keyword_as_compatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_keyword_as_compat
	return p
}

func InitEmptyKeyword_as_compatContext(p *Keyword_as_compatContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_keyword_as_compat
}

func (*Keyword_as_compatContext) IsKeyword_as_compatContext() {}

func NewKeyword_as_compatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Keyword_as_compatContext {
	var p = new(Keyword_as_compatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_keyword_as_compat

	return p
}

func (s *Keyword_as_compatContext) GetParser() antlr.Parser { return s.parser }

func (s *Keyword_as_compatContext) ABORT() antlr.TerminalNode {
	return s.GetToken(YQLParserABORT, 0)
}

func (s *Keyword_as_compatContext) ACTION() antlr.TerminalNode {
	return s.GetToken(YQLParserACTION, 0)
}

func (s *Keyword_as_compatContext) ADD() antlr.TerminalNode {
	return s.GetToken(YQLParserADD, 0)
}

func (s *Keyword_as_compatContext) AFTER() antlr.TerminalNode {
	return s.GetToken(YQLParserAFTER, 0)
}

func (s *Keyword_as_compatContext) ALTER() antlr.TerminalNode {
	return s.GetToken(YQLParserALTER, 0)
}

func (s *Keyword_as_compatContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(YQLParserANALYZE, 0)
}

func (s *Keyword_as_compatContext) AND() antlr.TerminalNode {
	return s.GetToken(YQLParserAND, 0)
}

func (s *Keyword_as_compatContext) ANSI() antlr.TerminalNode {
	return s.GetToken(YQLParserANSI, 0)
}

func (s *Keyword_as_compatContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(YQLParserARRAY, 0)
}

func (s *Keyword_as_compatContext) ASC() antlr.TerminalNode {
	return s.GetToken(YQLParserASC, 0)
}

func (s *Keyword_as_compatContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(YQLParserASYNC, 0)
}

func (s *Keyword_as_compatContext) AT() antlr.TerminalNode {
	return s.GetToken(YQLParserAT, 0)
}

func (s *Keyword_as_compatContext) ATTACH() antlr.TerminalNode {
	return s.GetToken(YQLParserATTACH, 0)
}

func (s *Keyword_as_compatContext) ATTRIBUTES() antlr.TerminalNode {
	return s.GetToken(YQLParserATTRIBUTES, 0)
}

func (s *Keyword_as_compatContext) AUTOINCREMENT() antlr.TerminalNode {
	return s.GetToken(YQLParserAUTOINCREMENT, 0)
}

func (s *Keyword_as_compatContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(YQLParserBACKUP, 0)
}

func (s *Keyword_as_compatContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(YQLParserBEFORE, 0)
}

func (s *Keyword_as_compatContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(YQLParserBEGIN, 0)
}

func (s *Keyword_as_compatContext) BERNOULLI() antlr.TerminalNode {
	return s.GetToken(YQLParserBERNOULLI, 0)
}

func (s *Keyword_as_compatContext) BY() antlr.TerminalNode {
	return s.GetToken(YQLParserBY, 0)
}

func (s *Keyword_as_compatContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(YQLParserCASCADE, 0)
}

func (s *Keyword_as_compatContext) CHANGEFEED() antlr.TerminalNode {
	return s.GetToken(YQLParserCHANGEFEED, 0)
}

func (s *Keyword_as_compatContext) CHECK() antlr.TerminalNode {
	return s.GetToken(YQLParserCHECK, 0)
}

func (s *Keyword_as_compatContext) CLASSIFIER() antlr.TerminalNode {
	return s.GetToken(YQLParserCLASSIFIER, 0)
}

func (s *Keyword_as_compatContext) COLLECTION() antlr.TerminalNode {
	return s.GetToken(YQLParserCOLLECTION, 0)
}

func (s *Keyword_as_compatContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMIT, 0)
}

func (s *Keyword_as_compatContext) CONDITIONAL() antlr.TerminalNode {
	return s.GetToken(YQLParserCONDITIONAL, 0)
}

func (s *Keyword_as_compatContext) CONFLICT() antlr.TerminalNode {
	return s.GetToken(YQLParserCONFLICT, 0)
}

func (s *Keyword_as_compatContext) CONNECT() antlr.TerminalNode {
	return s.GetToken(YQLParserCONNECT, 0)
}

func (s *Keyword_as_compatContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(YQLParserCONSTRAINT, 0)
}

func (s *Keyword_as_compatContext) CONSUMER() antlr.TerminalNode {
	return s.GetToken(YQLParserCONSUMER, 0)
}

func (s *Keyword_as_compatContext) COVER() antlr.TerminalNode {
	return s.GetToken(YQLParserCOVER, 0)
}

func (s *Keyword_as_compatContext) CREATE() antlr.TerminalNode {
	return s.GetToken(YQLParserCREATE, 0)
}

func (s *Keyword_as_compatContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(YQLParserCURRENT, 0)
}

func (s *Keyword_as_compatContext) DATA() antlr.TerminalNode {
	return s.GetToken(YQLParserDATA, 0)
}

func (s *Keyword_as_compatContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(YQLParserDATABASE, 0)
}

func (s *Keyword_as_compatContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(YQLParserDECIMAL, 0)
}

func (s *Keyword_as_compatContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(YQLParserDECLARE, 0)
}

func (s *Keyword_as_compatContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(YQLParserDEFAULT, 0)
}

func (s *Keyword_as_compatContext) DEFERRABLE() antlr.TerminalNode {
	return s.GetToken(YQLParserDEFERRABLE, 0)
}

func (s *Keyword_as_compatContext) DEFERRED() antlr.TerminalNode {
	return s.GetToken(YQLParserDEFERRED, 0)
}

func (s *Keyword_as_compatContext) DELETE() antlr.TerminalNode {
	return s.GetToken(YQLParserDELETE, 0)
}

func (s *Keyword_as_compatContext) DESC() antlr.TerminalNode {
	return s.GetToken(YQLParserDESC, 0)
}

func (s *Keyword_as_compatContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(YQLParserDESCRIBE, 0)
}

func (s *Keyword_as_compatContext) DETACH() antlr.TerminalNode {
	return s.GetToken(YQLParserDETACH, 0)
}

func (s *Keyword_as_compatContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(YQLParserDIRECTORY, 0)
}

func (s *Keyword_as_compatContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(YQLParserDISABLE, 0)
}

func (s *Keyword_as_compatContext) DISCARD() antlr.TerminalNode {
	return s.GetToken(YQLParserDISCARD, 0)
}

func (s *Keyword_as_compatContext) DROP() antlr.TerminalNode {
	return s.GetToken(YQLParserDROP, 0)
}

func (s *Keyword_as_compatContext) EACH() antlr.TerminalNode {
	return s.GetToken(YQLParserEACH, 0)
}

func (s *Keyword_as_compatContext) ELSE() antlr.TerminalNode {
	return s.GetToken(YQLParserELSE, 0)
}

func (s *Keyword_as_compatContext) EMPTY() antlr.TerminalNode {
	return s.GetToken(YQLParserEMPTY, 0)
}

func (s *Keyword_as_compatContext) ENCRYPTED() antlr.TerminalNode {
	return s.GetToken(YQLParserENCRYPTED, 0)
}

func (s *Keyword_as_compatContext) END() antlr.TerminalNode {
	return s.GetToken(YQLParserEND, 0)
}

func (s *Keyword_as_compatContext) ERROR() antlr.TerminalNode {
	return s.GetToken(YQLParserERROR, 0)
}

func (s *Keyword_as_compatContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(YQLParserESCAPE, 0)
}

func (s *Keyword_as_compatContext) EVALUATE() antlr.TerminalNode {
	return s.GetToken(YQLParserEVALUATE, 0)
}

func (s *Keyword_as_compatContext) EXCLUDE() antlr.TerminalNode {
	return s.GetToken(YQLParserEXCLUDE, 0)
}

func (s *Keyword_as_compatContext) EXCLUSIVE() antlr.TerminalNode {
	return s.GetToken(YQLParserEXCLUSIVE, 0)
}

func (s *Keyword_as_compatContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(YQLParserEXPLAIN, 0)
}

func (s *Keyword_as_compatContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(YQLParserEXPORT, 0)
}

func (s *Keyword_as_compatContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(YQLParserEXTERNAL, 0)
}

func (s *Keyword_as_compatContext) FAIL() antlr.TerminalNode {
	return s.GetToken(YQLParserFAIL, 0)
}

func (s *Keyword_as_compatContext) FAMILY() antlr.TerminalNode {
	return s.GetToken(YQLParserFAMILY, 0)
}

func (s *Keyword_as_compatContext) FILTER() antlr.TerminalNode {
	return s.GetToken(YQLParserFILTER, 0)
}

func (s *Keyword_as_compatContext) FIRST() antlr.TerminalNode {
	return s.GetToken(YQLParserFIRST, 0)
}

func (s *Keyword_as_compatContext) FLATTEN() antlr.TerminalNode {
	return s.GetToken(YQLParserFLATTEN, 0)
}

func (s *Keyword_as_compatContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(YQLParserFOLLOWING, 0)
}

func (s *Keyword_as_compatContext) FOR() antlr.TerminalNode {
	return s.GetToken(YQLParserFOR, 0)
}

func (s *Keyword_as_compatContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(YQLParserFOREIGN, 0)
}

func (s *Keyword_as_compatContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(YQLParserFUNCTION, 0)
}

func (s *Keyword_as_compatContext) GLOB() antlr.TerminalNode {
	return s.GetToken(YQLParserGLOB, 0)
}

func (s *Keyword_as_compatContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(YQLParserGLOBAL, 0)
}

func (s *Keyword_as_compatContext) GRANT() antlr.TerminalNode {
	return s.GetToken(YQLParserGRANT, 0)
}

func (s *Keyword_as_compatContext) GROUP() antlr.TerminalNode {
	return s.GetToken(YQLParserGROUP, 0)
}

func (s *Keyword_as_compatContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(YQLParserGROUPING, 0)
}

func (s *Keyword_as_compatContext) HASH() antlr.TerminalNode {
	return s.GetToken(YQLParserHASH, 0)
}

func (s *Keyword_as_compatContext) IF() antlr.TerminalNode {
	return s.GetToken(YQLParserIF, 0)
}

func (s *Keyword_as_compatContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(YQLParserIGNORE, 0)
}

func (s *Keyword_as_compatContext) ILIKE() antlr.TerminalNode {
	return s.GetToken(YQLParserILIKE, 0)
}

func (s *Keyword_as_compatContext) IMMEDIATE() antlr.TerminalNode {
	return s.GetToken(YQLParserIMMEDIATE, 0)
}

func (s *Keyword_as_compatContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(YQLParserIMPORT, 0)
}

func (s *Keyword_as_compatContext) IN() antlr.TerminalNode {
	return s.GetToken(YQLParserIN, 0)
}

func (s *Keyword_as_compatContext) INCREMENT() antlr.TerminalNode {
	return s.GetToken(YQLParserINCREMENT, 0)
}

func (s *Keyword_as_compatContext) INCREMENTAL() antlr.TerminalNode {
	return s.GetToken(YQLParserINCREMENTAL, 0)
}

func (s *Keyword_as_compatContext) INDEX() antlr.TerminalNode {
	return s.GetToken(YQLParserINDEX, 0)
}

func (s *Keyword_as_compatContext) INDEXED() antlr.TerminalNode {
	return s.GetToken(YQLParserINDEXED, 0)
}

func (s *Keyword_as_compatContext) INHERITS() antlr.TerminalNode {
	return s.GetToken(YQLParserINHERITS, 0)
}

func (s *Keyword_as_compatContext) INITIAL() antlr.TerminalNode {
	return s.GetToken(YQLParserINITIAL, 0)
}

func (s *Keyword_as_compatContext) INITIALLY() antlr.TerminalNode {
	return s.GetToken(YQLParserINITIALLY, 0)
}

func (s *Keyword_as_compatContext) INSERT() antlr.TerminalNode {
	return s.GetToken(YQLParserINSERT, 0)
}

func (s *Keyword_as_compatContext) INSTEAD() antlr.TerminalNode {
	return s.GetToken(YQLParserINSTEAD, 0)
}

func (s *Keyword_as_compatContext) INTO() antlr.TerminalNode {
	return s.GetToken(YQLParserINTO, 0)
}

func (s *Keyword_as_compatContext) IS() antlr.TerminalNode {
	return s.GetToken(YQLParserIS, 0)
}

func (s *Keyword_as_compatContext) LAST() antlr.TerminalNode {
	return s.GetToken(YQLParserLAST, 0)
}

func (s *Keyword_as_compatContext) LEGACY() antlr.TerminalNode {
	return s.GetToken(YQLParserLEGACY, 0)
}

func (s *Keyword_as_compatContext) LIKE() antlr.TerminalNode {
	return s.GetToken(YQLParserLIKE, 0)
}

func (s *Keyword_as_compatContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(YQLParserLOCAL, 0)
}

func (s *Keyword_as_compatContext) LOGIN() antlr.TerminalNode {
	return s.GetToken(YQLParserLOGIN, 0)
}

func (s *Keyword_as_compatContext) MANAGE() antlr.TerminalNode {
	return s.GetToken(YQLParserMANAGE, 0)
}

func (s *Keyword_as_compatContext) MATCH() antlr.TerminalNode {
	return s.GetToken(YQLParserMATCH, 0)
}

func (s *Keyword_as_compatContext) MATCHES() antlr.TerminalNode {
	return s.GetToken(YQLParserMATCHES, 0)
}

func (s *Keyword_as_compatContext) MATCH_RECOGNIZE() antlr.TerminalNode {
	return s.GetToken(YQLParserMATCH_RECOGNIZE, 0)
}

func (s *Keyword_as_compatContext) MEASURES() antlr.TerminalNode {
	return s.GetToken(YQLParserMEASURES, 0)
}

func (s *Keyword_as_compatContext) MICROSECONDS() antlr.TerminalNode {
	return s.GetToken(YQLParserMICROSECONDS, 0)
}

func (s *Keyword_as_compatContext) MILLISECONDS() antlr.TerminalNode {
	return s.GetToken(YQLParserMILLISECONDS, 0)
}

func (s *Keyword_as_compatContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(YQLParserMODIFY, 0)
}

func (s *Keyword_as_compatContext) NANOSECONDS() antlr.TerminalNode {
	return s.GetToken(YQLParserNANOSECONDS, 0)
}

func (s *Keyword_as_compatContext) NEXT() antlr.TerminalNode {
	return s.GetToken(YQLParserNEXT, 0)
}

func (s *Keyword_as_compatContext) NO() antlr.TerminalNode {
	return s.GetToken(YQLParserNO, 0)
}

func (s *Keyword_as_compatContext) NOLOGIN() antlr.TerminalNode {
	return s.GetToken(YQLParserNOLOGIN, 0)
}

func (s *Keyword_as_compatContext) NULLS() antlr.TerminalNode {
	return s.GetToken(YQLParserNULLS, 0)
}

func (s *Keyword_as_compatContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(YQLParserOBJECT, 0)
}

func (s *Keyword_as_compatContext) OF() antlr.TerminalNode {
	return s.GetToken(YQLParserOF, 0)
}

func (s *Keyword_as_compatContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(YQLParserOFFSET, 0)
}

func (s *Keyword_as_compatContext) OMIT() antlr.TerminalNode {
	return s.GetToken(YQLParserOMIT, 0)
}

func (s *Keyword_as_compatContext) ONE() antlr.TerminalNode {
	return s.GetToken(YQLParserONE, 0)
}

func (s *Keyword_as_compatContext) ONLY() antlr.TerminalNode {
	return s.GetToken(YQLParserONLY, 0)
}

func (s *Keyword_as_compatContext) OPTION() antlr.TerminalNode {
	return s.GetToken(YQLParserOPTION, 0)
}

func (s *Keyword_as_compatContext) OR() antlr.TerminalNode {
	return s.GetToken(YQLParserOR, 0)
}

func (s *Keyword_as_compatContext) ORDER() antlr.TerminalNode {
	return s.GetToken(YQLParserORDER, 0)
}

func (s *Keyword_as_compatContext) OTHERS() antlr.TerminalNode {
	return s.GetToken(YQLParserOTHERS, 0)
}

func (s *Keyword_as_compatContext) PARALLEL() antlr.TerminalNode {
	return s.GetToken(YQLParserPARALLEL, 0)
}

func (s *Keyword_as_compatContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(YQLParserPARTITION, 0)
}

func (s *Keyword_as_compatContext) PASSING() antlr.TerminalNode {
	return s.GetToken(YQLParserPASSING, 0)
}

func (s *Keyword_as_compatContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(YQLParserPASSWORD, 0)
}

func (s *Keyword_as_compatContext) PAST() antlr.TerminalNode {
	return s.GetToken(YQLParserPAST, 0)
}

func (s *Keyword_as_compatContext) PATTERN() antlr.TerminalNode {
	return s.GetToken(YQLParserPATTERN, 0)
}

func (s *Keyword_as_compatContext) PER() antlr.TerminalNode {
	return s.GetToken(YQLParserPER, 0)
}

func (s *Keyword_as_compatContext) PERMUTE() antlr.TerminalNode {
	return s.GetToken(YQLParserPERMUTE, 0)
}

func (s *Keyword_as_compatContext) PLAN() antlr.TerminalNode {
	return s.GetToken(YQLParserPLAN, 0)
}

func (s *Keyword_as_compatContext) POOL() antlr.TerminalNode {
	return s.GetToken(YQLParserPOOL, 0)
}

func (s *Keyword_as_compatContext) PRAGMA() antlr.TerminalNode {
	return s.GetToken(YQLParserPRAGMA, 0)
}

func (s *Keyword_as_compatContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(YQLParserPRECEDING, 0)
}

func (s *Keyword_as_compatContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(YQLParserPRIMARY, 0)
}

func (s *Keyword_as_compatContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(YQLParserPRIVILEGES, 0)
}

func (s *Keyword_as_compatContext) QUERY() antlr.TerminalNode {
	return s.GetToken(YQLParserQUERY, 0)
}

func (s *Keyword_as_compatContext) QUEUE() antlr.TerminalNode {
	return s.GetToken(YQLParserQUEUE, 0)
}

func (s *Keyword_as_compatContext) RAISE() antlr.TerminalNode {
	return s.GetToken(YQLParserRAISE, 0)
}

func (s *Keyword_as_compatContext) REFERENCES() antlr.TerminalNode {
	return s.GetToken(YQLParserREFERENCES, 0)
}

func (s *Keyword_as_compatContext) REGEXP() antlr.TerminalNode {
	return s.GetToken(YQLParserREGEXP, 0)
}

func (s *Keyword_as_compatContext) REINDEX() antlr.TerminalNode {
	return s.GetToken(YQLParserREINDEX, 0)
}

func (s *Keyword_as_compatContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(YQLParserRELEASE, 0)
}

func (s *Keyword_as_compatContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(YQLParserREMOVE, 0)
}

func (s *Keyword_as_compatContext) RENAME() antlr.TerminalNode {
	return s.GetToken(YQLParserRENAME, 0)
}

func (s *Keyword_as_compatContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(YQLParserREPLACE, 0)
}

func (s *Keyword_as_compatContext) REPLICATION() antlr.TerminalNode {
	return s.GetToken(YQLParserREPLICATION, 0)
}

func (s *Keyword_as_compatContext) RESET() antlr.TerminalNode {
	return s.GetToken(YQLParserRESET, 0)
}

func (s *Keyword_as_compatContext) RESPECT() antlr.TerminalNode {
	return s.GetToken(YQLParserRESPECT, 0)
}

func (s *Keyword_as_compatContext) RESTART() antlr.TerminalNode {
	return s.GetToken(YQLParserRESTART, 0)
}

func (s *Keyword_as_compatContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(YQLParserRESTORE, 0)
}

func (s *Keyword_as_compatContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(YQLParserRESTRICT, 0)
}

func (s *Keyword_as_compatContext) REVERT() antlr.TerminalNode {
	return s.GetToken(YQLParserREVERT, 0)
}

func (s *Keyword_as_compatContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(YQLParserREVOKE, 0)
}

func (s *Keyword_as_compatContext) RLIKE() antlr.TerminalNode {
	return s.GetToken(YQLParserRLIKE, 0)
}

func (s *Keyword_as_compatContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(YQLParserROLLBACK, 0)
}

func (s *Keyword_as_compatContext) ROW() antlr.TerminalNode {
	return s.GetToken(YQLParserROW, 0)
}

func (s *Keyword_as_compatContext) SAVEPOINT() antlr.TerminalNode {
	return s.GetToken(YQLParserSAVEPOINT, 0)
}

func (s *Keyword_as_compatContext) SECONDS() antlr.TerminalNode {
	return s.GetToken(YQLParserSECONDS, 0)
}

func (s *Keyword_as_compatContext) SEEK() antlr.TerminalNode {
	return s.GetToken(YQLParserSEEK, 0)
}

func (s *Keyword_as_compatContext) SETS() antlr.TerminalNode {
	return s.GetToken(YQLParserSETS, 0)
}

func (s *Keyword_as_compatContext) SHOW() antlr.TerminalNode {
	return s.GetToken(YQLParserSHOW, 0)
}

func (s *Keyword_as_compatContext) TSKIP() antlr.TerminalNode {
	return s.GetToken(YQLParserTSKIP, 0)
}

func (s *Keyword_as_compatContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(YQLParserSEQUENCE, 0)
}

func (s *Keyword_as_compatContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(YQLParserSOURCE, 0)
}

func (s *Keyword_as_compatContext) START() antlr.TerminalNode {
	return s.GetToken(YQLParserSTART, 0)
}

func (s *Keyword_as_compatContext) SUBQUERY() antlr.TerminalNode {
	return s.GetToken(YQLParserSUBQUERY, 0)
}

func (s *Keyword_as_compatContext) SUBSET() antlr.TerminalNode {
	return s.GetToken(YQLParserSUBSET, 0)
}

func (s *Keyword_as_compatContext) SYMBOLS() antlr.TerminalNode {
	return s.GetToken(YQLParserSYMBOLS, 0)
}

func (s *Keyword_as_compatContext) SYNC() antlr.TerminalNode {
	return s.GetToken(YQLParserSYNC, 0)
}

func (s *Keyword_as_compatContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(YQLParserSYSTEM, 0)
}

func (s *Keyword_as_compatContext) TABLE() antlr.TerminalNode {
	return s.GetToken(YQLParserTABLE, 0)
}

func (s *Keyword_as_compatContext) TABLES() antlr.TerminalNode {
	return s.GetToken(YQLParserTABLES, 0)
}

func (s *Keyword_as_compatContext) TABLESAMPLE() antlr.TerminalNode {
	return s.GetToken(YQLParserTABLESAMPLE, 0)
}

func (s *Keyword_as_compatContext) TABLESTORE() antlr.TerminalNode {
	return s.GetToken(YQLParserTABLESTORE, 0)
}

func (s *Keyword_as_compatContext) TEMP() antlr.TerminalNode {
	return s.GetToken(YQLParserTEMP, 0)
}

func (s *Keyword_as_compatContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(YQLParserTEMPORARY, 0)
}

func (s *Keyword_as_compatContext) THEN() antlr.TerminalNode {
	return s.GetToken(YQLParserTHEN, 0)
}

func (s *Keyword_as_compatContext) TIES() antlr.TerminalNode {
	return s.GetToken(YQLParserTIES, 0)
}

func (s *Keyword_as_compatContext) TO() antlr.TerminalNode {
	return s.GetToken(YQLParserTO, 0)
}

func (s *Keyword_as_compatContext) TOPIC() antlr.TerminalNode {
	return s.GetToken(YQLParserTOPIC, 0)
}

func (s *Keyword_as_compatContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(YQLParserTRANSACTION, 0)
}

func (s *Keyword_as_compatContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(YQLParserTRIGGER, 0)
}

func (s *Keyword_as_compatContext) TYPE() antlr.TerminalNode {
	return s.GetToken(YQLParserTYPE, 0)
}

func (s *Keyword_as_compatContext) UNCONDITIONAL() antlr.TerminalNode {
	return s.GetToken(YQLParserUNCONDITIONAL, 0)
}

func (s *Keyword_as_compatContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(YQLParserUNIQUE, 0)
}

func (s *Keyword_as_compatContext) UNKNOWN() antlr.TerminalNode {
	return s.GetToken(YQLParserUNKNOWN, 0)
}

func (s *Keyword_as_compatContext) UNMATCHED() antlr.TerminalNode {
	return s.GetToken(YQLParserUNMATCHED, 0)
}

func (s *Keyword_as_compatContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(YQLParserUPDATE, 0)
}

func (s *Keyword_as_compatContext) UPSERT() antlr.TerminalNode {
	return s.GetToken(YQLParserUPSERT, 0)
}

func (s *Keyword_as_compatContext) USE() antlr.TerminalNode {
	return s.GetToken(YQLParserUSE, 0)
}

func (s *Keyword_as_compatContext) USER() antlr.TerminalNode {
	return s.GetToken(YQLParserUSER, 0)
}

func (s *Keyword_as_compatContext) VACUUM() antlr.TerminalNode {
	return s.GetToken(YQLParserVACUUM, 0)
}

func (s *Keyword_as_compatContext) VALUES() antlr.TerminalNode {
	return s.GetToken(YQLParserVALUES, 0)
}

func (s *Keyword_as_compatContext) VIRTUAL() antlr.TerminalNode {
	return s.GetToken(YQLParserVIRTUAL, 0)
}

func (s *Keyword_as_compatContext) WRAPPER() antlr.TerminalNode {
	return s.GetToken(YQLParserWRAPPER, 0)
}

func (s *Keyword_as_compatContext) XOR() antlr.TerminalNode {
	return s.GetToken(YQLParserXOR, 0)
}

func (s *Keyword_as_compatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Keyword_as_compatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Keyword_as_compatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterKeyword_as_compat(s)
	}
}

func (s *Keyword_as_compatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitKeyword_as_compat(s)
	}
}




func (p *YQLParser) Keyword_as_compat() (localctx IKeyword_as_compatContext) {
	localctx = NewKeyword_as_compatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 854, YQLParserRULE_keyword_as_compat)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4555)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la - 38)) & ^0x3f) == 0 && ((int64(1) << (_la - 38)) & -2322451620569311761) != 0) || ((int64((_la - 102)) & ^0x3f) == 0 && ((int64(1) << (_la - 102)) & 9222456400807882555) != 0) || ((int64((_la - 166)) & ^0x3f) == 0 && ((int64(1) << (_la - 166)) & -4612549165388503013) != 0) || ((int64((_la - 230)) & ^0x3f) == 0 && ((int64(1) << (_la - 230)) & -581388537023307875) != 0) || ((int64((_la - 294)) & ^0x3f) == 0 && ((int64(1) << (_la - 294)) & 810417487) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IKeyword_compatContext is an interface to support dynamic dispatch.
type IKeyword_compatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ABORT() antlr.TerminalNode
	ACTION() antlr.TerminalNode
	ADD() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	ALTER() antlr.TerminalNode
	ANALYZE() antlr.TerminalNode
	AND() antlr.TerminalNode
	ANSI() antlr.TerminalNode
	ARRAY() antlr.TerminalNode
	ASC() antlr.TerminalNode
	ASYNC() antlr.TerminalNode
	AT() antlr.TerminalNode
	ATTACH() antlr.TerminalNode
	ATTRIBUTES() antlr.TerminalNode
	AUTOINCREMENT() antlr.TerminalNode
	BACKUP() antlr.TerminalNode
	BEFORE() antlr.TerminalNode
	BEGIN() antlr.TerminalNode
	BERNOULLI() antlr.TerminalNode
	BY() antlr.TerminalNode
	CASCADE() antlr.TerminalNode
	CHANGEFEED() antlr.TerminalNode
	CHECK() antlr.TerminalNode
	CLASSIFIER() antlr.TerminalNode
	COLLATE() antlr.TerminalNode
	COLLECTION() antlr.TerminalNode
	COMMIT() antlr.TerminalNode
	CONDITIONAL() antlr.TerminalNode
	CONFLICT() antlr.TerminalNode
	CONNECT() antlr.TerminalNode
	CONSTRAINT() antlr.TerminalNode
	CONSUMER() antlr.TerminalNode
	COVER() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	CROSS() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	DATA() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	DECIMAL() antlr.TerminalNode
	DECLARE() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	DEFERRABLE() antlr.TerminalNode
	DEFERRED() antlr.TerminalNode
	DEFINE() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	DESC() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode
	DETACH() antlr.TerminalNode
	DIRECTORY() antlr.TerminalNode
	DISABLE() antlr.TerminalNode
	DISCARD() antlr.TerminalNode
	DO() antlr.TerminalNode
	DROP() antlr.TerminalNode
	EACH() antlr.TerminalNode
	ELSE() antlr.TerminalNode
	EMPTY() antlr.TerminalNode
	ENCRYPTED() antlr.TerminalNode
	END() antlr.TerminalNode
	ERROR() antlr.TerminalNode
	ESCAPE() antlr.TerminalNode
	EVALUATE() antlr.TerminalNode
	EXCLUDE() antlr.TerminalNode
	EXCLUSION() antlr.TerminalNode
	EXCLUSIVE() antlr.TerminalNode
	EXPLAIN() antlr.TerminalNode
	EXPORT() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	FAIL() antlr.TerminalNode
	FAMILY() antlr.TerminalNode
	FILTER() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	FLATTEN() antlr.TerminalNode
	FOLLOWING() antlr.TerminalNode
	FOR() antlr.TerminalNode
	FOREIGN() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	GLOB() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	GRANT() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	GROUPING() antlr.TerminalNode
	HASH() antlr.TerminalNode
	IF() antlr.TerminalNode
	IGNORE() antlr.TerminalNode
	ILIKE() antlr.TerminalNode
	IMMEDIATE() antlr.TerminalNode
	IMPORT() antlr.TerminalNode
	IN() antlr.TerminalNode
	INCREMENT() antlr.TerminalNode
	INCREMENTAL() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	INDEXED() antlr.TerminalNode
	INHERITS() antlr.TerminalNode
	INITIAL() antlr.TerminalNode
	INITIALLY() antlr.TerminalNode
	INNER() antlr.TerminalNode
	INSERT() antlr.TerminalNode
	INSTEAD() antlr.TerminalNode
	INTO() antlr.TerminalNode
	IS() antlr.TerminalNode
	ISNULL() antlr.TerminalNode
	JOIN() antlr.TerminalNode
	KEY() antlr.TerminalNode
	LAST() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	LEGACY() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	LOGIN() antlr.TerminalNode
	MANAGE() antlr.TerminalNode
	MATCH() antlr.TerminalNode
	MATCHES() antlr.TerminalNode
	MATCH_RECOGNIZE() antlr.TerminalNode
	MEASURES() antlr.TerminalNode
	MICROSECONDS() antlr.TerminalNode
	MILLISECONDS() antlr.TerminalNode
	MODIFY() antlr.TerminalNode
	NANOSECONDS() antlr.TerminalNode
	NATURAL() antlr.TerminalNode
	NEXT() antlr.TerminalNode
	NO() antlr.TerminalNode
	NOLOGIN() antlr.TerminalNode
	NOTNULL() antlr.TerminalNode
	NULLS() antlr.TerminalNode
	OBJECT() antlr.TerminalNode
	OF() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	OMIT() antlr.TerminalNode
	ON() antlr.TerminalNode
	ONE() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	OPTION() antlr.TerminalNode
	OR() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	OTHERS() antlr.TerminalNode
	OUTER() antlr.TerminalNode
	OVER() antlr.TerminalNode
	PARALLEL() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	PASSING() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	PAST() antlr.TerminalNode
	PATTERN() antlr.TerminalNode
	PER() antlr.TerminalNode
	PERMUTE() antlr.TerminalNode
	PLAN() antlr.TerminalNode
	POOL() antlr.TerminalNode
	PRAGMA() antlr.TerminalNode
	PRECEDING() antlr.TerminalNode
	PRESORT() antlr.TerminalNode
	PRIMARY() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode
	QUERY() antlr.TerminalNode
	QUEUE() antlr.TerminalNode
	RAISE() antlr.TerminalNode
	REFERENCES() antlr.TerminalNode
	REGEXP() antlr.TerminalNode
	REINDEX() antlr.TerminalNode
	RELEASE() antlr.TerminalNode
	REMOVE() antlr.TerminalNode
	RENAME() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	REPLICATION() antlr.TerminalNode
	RESET() antlr.TerminalNode
	RESPECT() antlr.TerminalNode
	RESTART() antlr.TerminalNode
	RESTORE() antlr.TerminalNode
	RESTRICT() antlr.TerminalNode
	RESULT() antlr.TerminalNode
	REVERT() antlr.TerminalNode
	REVOKE() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	RLIKE() antlr.TerminalNode
	ROLLBACK() antlr.TerminalNode
	ROW() antlr.TerminalNode
	SAMPLE() antlr.TerminalNode
	SAVEPOINT() antlr.TerminalNode
	SECONDS() antlr.TerminalNode
	SEEK() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	SETS() antlr.TerminalNode
	SHOW() antlr.TerminalNode
	TSKIP() antlr.TerminalNode
	SEQUENCE() antlr.TerminalNode
	SOURCE() antlr.TerminalNode
	START() antlr.TerminalNode
	SUBQUERY() antlr.TerminalNode
	SUBSET() antlr.TerminalNode
	SYMBOLS() antlr.TerminalNode
	SYNC() antlr.TerminalNode
	SYSTEM() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	TABLESAMPLE() antlr.TerminalNode
	TABLESTORE() antlr.TerminalNode
	TEMP() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	THEN() antlr.TerminalNode
	TIES() antlr.TerminalNode
	TO() antlr.TerminalNode
	TOPIC() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	TRIGGER() antlr.TerminalNode
	TYPE() antlr.TerminalNode
	UNCONDITIONAL() antlr.TerminalNode
	UNIQUE() antlr.TerminalNode
	UNKNOWN() antlr.TerminalNode
	UNMATCHED() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	UPSERT() antlr.TerminalNode
	USE() antlr.TerminalNode
	USER() antlr.TerminalNode
	USING() antlr.TerminalNode
	VACUUM() antlr.TerminalNode
	VALUES() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	VIRTUAL() antlr.TerminalNode
	WITH() antlr.TerminalNode
	WRAPPER() antlr.TerminalNode
	XOR() antlr.TerminalNode

	// IsKeyword_compatContext differentiates from other interfaces.
	IsKeyword_compatContext()
}

type Keyword_compatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyword_compatContext() *Keyword_compatContext {
	var p = new(Keyword_compatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_keyword_compat
	return p
}

func InitEmptyKeyword_compatContext(p *Keyword_compatContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_keyword_compat
}

func (*Keyword_compatContext) IsKeyword_compatContext() {}

func NewKeyword_compatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Keyword_compatContext {
	var p = new(Keyword_compatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_keyword_compat

	return p
}

func (s *Keyword_compatContext) GetParser() antlr.Parser { return s.parser }

func (s *Keyword_compatContext) ABORT() antlr.TerminalNode {
	return s.GetToken(YQLParserABORT, 0)
}

func (s *Keyword_compatContext) ACTION() antlr.TerminalNode {
	return s.GetToken(YQLParserACTION, 0)
}

func (s *Keyword_compatContext) ADD() antlr.TerminalNode {
	return s.GetToken(YQLParserADD, 0)
}

func (s *Keyword_compatContext) AFTER() antlr.TerminalNode {
	return s.GetToken(YQLParserAFTER, 0)
}

func (s *Keyword_compatContext) ALTER() antlr.TerminalNode {
	return s.GetToken(YQLParserALTER, 0)
}

func (s *Keyword_compatContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(YQLParserANALYZE, 0)
}

func (s *Keyword_compatContext) AND() antlr.TerminalNode {
	return s.GetToken(YQLParserAND, 0)
}

func (s *Keyword_compatContext) ANSI() antlr.TerminalNode {
	return s.GetToken(YQLParserANSI, 0)
}

func (s *Keyword_compatContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(YQLParserARRAY, 0)
}

func (s *Keyword_compatContext) ASC() antlr.TerminalNode {
	return s.GetToken(YQLParserASC, 0)
}

func (s *Keyword_compatContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(YQLParserASYNC, 0)
}

func (s *Keyword_compatContext) AT() antlr.TerminalNode {
	return s.GetToken(YQLParserAT, 0)
}

func (s *Keyword_compatContext) ATTACH() antlr.TerminalNode {
	return s.GetToken(YQLParserATTACH, 0)
}

func (s *Keyword_compatContext) ATTRIBUTES() antlr.TerminalNode {
	return s.GetToken(YQLParserATTRIBUTES, 0)
}

func (s *Keyword_compatContext) AUTOINCREMENT() antlr.TerminalNode {
	return s.GetToken(YQLParserAUTOINCREMENT, 0)
}

func (s *Keyword_compatContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(YQLParserBACKUP, 0)
}

func (s *Keyword_compatContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(YQLParserBEFORE, 0)
}

func (s *Keyword_compatContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(YQLParserBEGIN, 0)
}

func (s *Keyword_compatContext) BERNOULLI() antlr.TerminalNode {
	return s.GetToken(YQLParserBERNOULLI, 0)
}

func (s *Keyword_compatContext) BY() antlr.TerminalNode {
	return s.GetToken(YQLParserBY, 0)
}

func (s *Keyword_compatContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(YQLParserCASCADE, 0)
}

func (s *Keyword_compatContext) CHANGEFEED() antlr.TerminalNode {
	return s.GetToken(YQLParserCHANGEFEED, 0)
}

func (s *Keyword_compatContext) CHECK() antlr.TerminalNode {
	return s.GetToken(YQLParserCHECK, 0)
}

func (s *Keyword_compatContext) CLASSIFIER() antlr.TerminalNode {
	return s.GetToken(YQLParserCLASSIFIER, 0)
}

func (s *Keyword_compatContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(YQLParserCOLLATE, 0)
}

func (s *Keyword_compatContext) COLLECTION() antlr.TerminalNode {
	return s.GetToken(YQLParserCOLLECTION, 0)
}

func (s *Keyword_compatContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(YQLParserCOMMIT, 0)
}

func (s *Keyword_compatContext) CONDITIONAL() antlr.TerminalNode {
	return s.GetToken(YQLParserCONDITIONAL, 0)
}

func (s *Keyword_compatContext) CONFLICT() antlr.TerminalNode {
	return s.GetToken(YQLParserCONFLICT, 0)
}

func (s *Keyword_compatContext) CONNECT() antlr.TerminalNode {
	return s.GetToken(YQLParserCONNECT, 0)
}

func (s *Keyword_compatContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(YQLParserCONSTRAINT, 0)
}

func (s *Keyword_compatContext) CONSUMER() antlr.TerminalNode {
	return s.GetToken(YQLParserCONSUMER, 0)
}

func (s *Keyword_compatContext) COVER() antlr.TerminalNode {
	return s.GetToken(YQLParserCOVER, 0)
}

func (s *Keyword_compatContext) CREATE() antlr.TerminalNode {
	return s.GetToken(YQLParserCREATE, 0)
}

func (s *Keyword_compatContext) CROSS() antlr.TerminalNode {
	return s.GetToken(YQLParserCROSS, 0)
}

func (s *Keyword_compatContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(YQLParserCURRENT, 0)
}

func (s *Keyword_compatContext) DATA() antlr.TerminalNode {
	return s.GetToken(YQLParserDATA, 0)
}

func (s *Keyword_compatContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(YQLParserDATABASE, 0)
}

func (s *Keyword_compatContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(YQLParserDECIMAL, 0)
}

func (s *Keyword_compatContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(YQLParserDECLARE, 0)
}

func (s *Keyword_compatContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(YQLParserDEFAULT, 0)
}

func (s *Keyword_compatContext) DEFERRABLE() antlr.TerminalNode {
	return s.GetToken(YQLParserDEFERRABLE, 0)
}

func (s *Keyword_compatContext) DEFERRED() antlr.TerminalNode {
	return s.GetToken(YQLParserDEFERRED, 0)
}

func (s *Keyword_compatContext) DEFINE() antlr.TerminalNode {
	return s.GetToken(YQLParserDEFINE, 0)
}

func (s *Keyword_compatContext) DELETE() antlr.TerminalNode {
	return s.GetToken(YQLParserDELETE, 0)
}

func (s *Keyword_compatContext) DESC() antlr.TerminalNode {
	return s.GetToken(YQLParserDESC, 0)
}

func (s *Keyword_compatContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(YQLParserDESCRIBE, 0)
}

func (s *Keyword_compatContext) DETACH() antlr.TerminalNode {
	return s.GetToken(YQLParserDETACH, 0)
}

func (s *Keyword_compatContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(YQLParserDIRECTORY, 0)
}

func (s *Keyword_compatContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(YQLParserDISABLE, 0)
}

func (s *Keyword_compatContext) DISCARD() antlr.TerminalNode {
	return s.GetToken(YQLParserDISCARD, 0)
}

func (s *Keyword_compatContext) DO() antlr.TerminalNode {
	return s.GetToken(YQLParserDO, 0)
}

func (s *Keyword_compatContext) DROP() antlr.TerminalNode {
	return s.GetToken(YQLParserDROP, 0)
}

func (s *Keyword_compatContext) EACH() antlr.TerminalNode {
	return s.GetToken(YQLParserEACH, 0)
}

func (s *Keyword_compatContext) ELSE() antlr.TerminalNode {
	return s.GetToken(YQLParserELSE, 0)
}

func (s *Keyword_compatContext) EMPTY() antlr.TerminalNode {
	return s.GetToken(YQLParserEMPTY, 0)
}

func (s *Keyword_compatContext) ENCRYPTED() antlr.TerminalNode {
	return s.GetToken(YQLParserENCRYPTED, 0)
}

func (s *Keyword_compatContext) END() antlr.TerminalNode {
	return s.GetToken(YQLParserEND, 0)
}

func (s *Keyword_compatContext) ERROR() antlr.TerminalNode {
	return s.GetToken(YQLParserERROR, 0)
}

func (s *Keyword_compatContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(YQLParserESCAPE, 0)
}

func (s *Keyword_compatContext) EVALUATE() antlr.TerminalNode {
	return s.GetToken(YQLParserEVALUATE, 0)
}

func (s *Keyword_compatContext) EXCLUDE() antlr.TerminalNode {
	return s.GetToken(YQLParserEXCLUDE, 0)
}

func (s *Keyword_compatContext) EXCLUSION() antlr.TerminalNode {
	return s.GetToken(YQLParserEXCLUSION, 0)
}

func (s *Keyword_compatContext) EXCLUSIVE() antlr.TerminalNode {
	return s.GetToken(YQLParserEXCLUSIVE, 0)
}

func (s *Keyword_compatContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(YQLParserEXPLAIN, 0)
}

func (s *Keyword_compatContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(YQLParserEXPORT, 0)
}

func (s *Keyword_compatContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(YQLParserEXTERNAL, 0)
}

func (s *Keyword_compatContext) FAIL() antlr.TerminalNode {
	return s.GetToken(YQLParserFAIL, 0)
}

func (s *Keyword_compatContext) FAMILY() antlr.TerminalNode {
	return s.GetToken(YQLParserFAMILY, 0)
}

func (s *Keyword_compatContext) FILTER() antlr.TerminalNode {
	return s.GetToken(YQLParserFILTER, 0)
}

func (s *Keyword_compatContext) FIRST() antlr.TerminalNode {
	return s.GetToken(YQLParserFIRST, 0)
}

func (s *Keyword_compatContext) FLATTEN() antlr.TerminalNode {
	return s.GetToken(YQLParserFLATTEN, 0)
}

func (s *Keyword_compatContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(YQLParserFOLLOWING, 0)
}

func (s *Keyword_compatContext) FOR() antlr.TerminalNode {
	return s.GetToken(YQLParserFOR, 0)
}

func (s *Keyword_compatContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(YQLParserFOREIGN, 0)
}

func (s *Keyword_compatContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(YQLParserFUNCTION, 0)
}

func (s *Keyword_compatContext) GLOB() antlr.TerminalNode {
	return s.GetToken(YQLParserGLOB, 0)
}

func (s *Keyword_compatContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(YQLParserGLOBAL, 0)
}

func (s *Keyword_compatContext) GRANT() antlr.TerminalNode {
	return s.GetToken(YQLParserGRANT, 0)
}

func (s *Keyword_compatContext) GROUP() antlr.TerminalNode {
	return s.GetToken(YQLParserGROUP, 0)
}

func (s *Keyword_compatContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(YQLParserGROUPING, 0)
}

func (s *Keyword_compatContext) HASH() antlr.TerminalNode {
	return s.GetToken(YQLParserHASH, 0)
}

func (s *Keyword_compatContext) IF() antlr.TerminalNode {
	return s.GetToken(YQLParserIF, 0)
}

func (s *Keyword_compatContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(YQLParserIGNORE, 0)
}

func (s *Keyword_compatContext) ILIKE() antlr.TerminalNode {
	return s.GetToken(YQLParserILIKE, 0)
}

func (s *Keyword_compatContext) IMMEDIATE() antlr.TerminalNode {
	return s.GetToken(YQLParserIMMEDIATE, 0)
}

func (s *Keyword_compatContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(YQLParserIMPORT, 0)
}

func (s *Keyword_compatContext) IN() antlr.TerminalNode {
	return s.GetToken(YQLParserIN, 0)
}

func (s *Keyword_compatContext) INCREMENT() antlr.TerminalNode {
	return s.GetToken(YQLParserINCREMENT, 0)
}

func (s *Keyword_compatContext) INCREMENTAL() antlr.TerminalNode {
	return s.GetToken(YQLParserINCREMENTAL, 0)
}

func (s *Keyword_compatContext) INDEX() antlr.TerminalNode {
	return s.GetToken(YQLParserINDEX, 0)
}

func (s *Keyword_compatContext) INDEXED() antlr.TerminalNode {
	return s.GetToken(YQLParserINDEXED, 0)
}

func (s *Keyword_compatContext) INHERITS() antlr.TerminalNode {
	return s.GetToken(YQLParserINHERITS, 0)
}

func (s *Keyword_compatContext) INITIAL() antlr.TerminalNode {
	return s.GetToken(YQLParserINITIAL, 0)
}

func (s *Keyword_compatContext) INITIALLY() antlr.TerminalNode {
	return s.GetToken(YQLParserINITIALLY, 0)
}

func (s *Keyword_compatContext) INNER() antlr.TerminalNode {
	return s.GetToken(YQLParserINNER, 0)
}

func (s *Keyword_compatContext) INSERT() antlr.TerminalNode {
	return s.GetToken(YQLParserINSERT, 0)
}

func (s *Keyword_compatContext) INSTEAD() antlr.TerminalNode {
	return s.GetToken(YQLParserINSTEAD, 0)
}

func (s *Keyword_compatContext) INTO() antlr.TerminalNode {
	return s.GetToken(YQLParserINTO, 0)
}

func (s *Keyword_compatContext) IS() antlr.TerminalNode {
	return s.GetToken(YQLParserIS, 0)
}

func (s *Keyword_compatContext) ISNULL() antlr.TerminalNode {
	return s.GetToken(YQLParserISNULL, 0)
}

func (s *Keyword_compatContext) JOIN() antlr.TerminalNode {
	return s.GetToken(YQLParserJOIN, 0)
}

func (s *Keyword_compatContext) KEY() antlr.TerminalNode {
	return s.GetToken(YQLParserKEY, 0)
}

func (s *Keyword_compatContext) LAST() antlr.TerminalNode {
	return s.GetToken(YQLParserLAST, 0)
}

func (s *Keyword_compatContext) LEFT() antlr.TerminalNode {
	return s.GetToken(YQLParserLEFT, 0)
}

func (s *Keyword_compatContext) LEGACY() antlr.TerminalNode {
	return s.GetToken(YQLParserLEGACY, 0)
}

func (s *Keyword_compatContext) LIKE() antlr.TerminalNode {
	return s.GetToken(YQLParserLIKE, 0)
}

func (s *Keyword_compatContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(YQLParserLOCAL, 0)
}

func (s *Keyword_compatContext) LOGIN() antlr.TerminalNode {
	return s.GetToken(YQLParserLOGIN, 0)
}

func (s *Keyword_compatContext) MANAGE() antlr.TerminalNode {
	return s.GetToken(YQLParserMANAGE, 0)
}

func (s *Keyword_compatContext) MATCH() antlr.TerminalNode {
	return s.GetToken(YQLParserMATCH, 0)
}

func (s *Keyword_compatContext) MATCHES() antlr.TerminalNode {
	return s.GetToken(YQLParserMATCHES, 0)
}

func (s *Keyword_compatContext) MATCH_RECOGNIZE() antlr.TerminalNode {
	return s.GetToken(YQLParserMATCH_RECOGNIZE, 0)
}

func (s *Keyword_compatContext) MEASURES() antlr.TerminalNode {
	return s.GetToken(YQLParserMEASURES, 0)
}

func (s *Keyword_compatContext) MICROSECONDS() antlr.TerminalNode {
	return s.GetToken(YQLParserMICROSECONDS, 0)
}

func (s *Keyword_compatContext) MILLISECONDS() antlr.TerminalNode {
	return s.GetToken(YQLParserMILLISECONDS, 0)
}

func (s *Keyword_compatContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(YQLParserMODIFY, 0)
}

func (s *Keyword_compatContext) NANOSECONDS() antlr.TerminalNode {
	return s.GetToken(YQLParserNANOSECONDS, 0)
}

func (s *Keyword_compatContext) NATURAL() antlr.TerminalNode {
	return s.GetToken(YQLParserNATURAL, 0)
}

func (s *Keyword_compatContext) NEXT() antlr.TerminalNode {
	return s.GetToken(YQLParserNEXT, 0)
}

func (s *Keyword_compatContext) NO() antlr.TerminalNode {
	return s.GetToken(YQLParserNO, 0)
}

func (s *Keyword_compatContext) NOLOGIN() antlr.TerminalNode {
	return s.GetToken(YQLParserNOLOGIN, 0)
}

func (s *Keyword_compatContext) NOTNULL() antlr.TerminalNode {
	return s.GetToken(YQLParserNOTNULL, 0)
}

func (s *Keyword_compatContext) NULLS() antlr.TerminalNode {
	return s.GetToken(YQLParserNULLS, 0)
}

func (s *Keyword_compatContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(YQLParserOBJECT, 0)
}

func (s *Keyword_compatContext) OF() antlr.TerminalNode {
	return s.GetToken(YQLParserOF, 0)
}

func (s *Keyword_compatContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(YQLParserOFFSET, 0)
}

func (s *Keyword_compatContext) OMIT() antlr.TerminalNode {
	return s.GetToken(YQLParserOMIT, 0)
}

func (s *Keyword_compatContext) ON() antlr.TerminalNode {
	return s.GetToken(YQLParserON, 0)
}

func (s *Keyword_compatContext) ONE() antlr.TerminalNode {
	return s.GetToken(YQLParserONE, 0)
}

func (s *Keyword_compatContext) ONLY() antlr.TerminalNode {
	return s.GetToken(YQLParserONLY, 0)
}

func (s *Keyword_compatContext) OPTION() antlr.TerminalNode {
	return s.GetToken(YQLParserOPTION, 0)
}

func (s *Keyword_compatContext) OR() antlr.TerminalNode {
	return s.GetToken(YQLParserOR, 0)
}

func (s *Keyword_compatContext) ORDER() antlr.TerminalNode {
	return s.GetToken(YQLParserORDER, 0)
}

func (s *Keyword_compatContext) OTHERS() antlr.TerminalNode {
	return s.GetToken(YQLParserOTHERS, 0)
}

func (s *Keyword_compatContext) OUTER() antlr.TerminalNode {
	return s.GetToken(YQLParserOUTER, 0)
}

func (s *Keyword_compatContext) OVER() antlr.TerminalNode {
	return s.GetToken(YQLParserOVER, 0)
}

func (s *Keyword_compatContext) PARALLEL() antlr.TerminalNode {
	return s.GetToken(YQLParserPARALLEL, 0)
}

func (s *Keyword_compatContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(YQLParserPARTITION, 0)
}

func (s *Keyword_compatContext) PASSING() antlr.TerminalNode {
	return s.GetToken(YQLParserPASSING, 0)
}

func (s *Keyword_compatContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(YQLParserPASSWORD, 0)
}

func (s *Keyword_compatContext) PAST() antlr.TerminalNode {
	return s.GetToken(YQLParserPAST, 0)
}

func (s *Keyword_compatContext) PATTERN() antlr.TerminalNode {
	return s.GetToken(YQLParserPATTERN, 0)
}

func (s *Keyword_compatContext) PER() antlr.TerminalNode {
	return s.GetToken(YQLParserPER, 0)
}

func (s *Keyword_compatContext) PERMUTE() antlr.TerminalNode {
	return s.GetToken(YQLParserPERMUTE, 0)
}

func (s *Keyword_compatContext) PLAN() antlr.TerminalNode {
	return s.GetToken(YQLParserPLAN, 0)
}

func (s *Keyword_compatContext) POOL() antlr.TerminalNode {
	return s.GetToken(YQLParserPOOL, 0)
}

func (s *Keyword_compatContext) PRAGMA() antlr.TerminalNode {
	return s.GetToken(YQLParserPRAGMA, 0)
}

func (s *Keyword_compatContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(YQLParserPRECEDING, 0)
}

func (s *Keyword_compatContext) PRESORT() antlr.TerminalNode {
	return s.GetToken(YQLParserPRESORT, 0)
}

func (s *Keyword_compatContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(YQLParserPRIMARY, 0)
}

func (s *Keyword_compatContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(YQLParserPRIVILEGES, 0)
}

func (s *Keyword_compatContext) QUERY() antlr.TerminalNode {
	return s.GetToken(YQLParserQUERY, 0)
}

func (s *Keyword_compatContext) QUEUE() antlr.TerminalNode {
	return s.GetToken(YQLParserQUEUE, 0)
}

func (s *Keyword_compatContext) RAISE() antlr.TerminalNode {
	return s.GetToken(YQLParserRAISE, 0)
}

func (s *Keyword_compatContext) REFERENCES() antlr.TerminalNode {
	return s.GetToken(YQLParserREFERENCES, 0)
}

func (s *Keyword_compatContext) REGEXP() antlr.TerminalNode {
	return s.GetToken(YQLParserREGEXP, 0)
}

func (s *Keyword_compatContext) REINDEX() antlr.TerminalNode {
	return s.GetToken(YQLParserREINDEX, 0)
}

func (s *Keyword_compatContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(YQLParserRELEASE, 0)
}

func (s *Keyword_compatContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(YQLParserREMOVE, 0)
}

func (s *Keyword_compatContext) RENAME() antlr.TerminalNode {
	return s.GetToken(YQLParserRENAME, 0)
}

func (s *Keyword_compatContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(YQLParserREPLACE, 0)
}

func (s *Keyword_compatContext) REPLICATION() antlr.TerminalNode {
	return s.GetToken(YQLParserREPLICATION, 0)
}

func (s *Keyword_compatContext) RESET() antlr.TerminalNode {
	return s.GetToken(YQLParserRESET, 0)
}

func (s *Keyword_compatContext) RESPECT() antlr.TerminalNode {
	return s.GetToken(YQLParserRESPECT, 0)
}

func (s *Keyword_compatContext) RESTART() antlr.TerminalNode {
	return s.GetToken(YQLParserRESTART, 0)
}

func (s *Keyword_compatContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(YQLParserRESTORE, 0)
}

func (s *Keyword_compatContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(YQLParserRESTRICT, 0)
}

func (s *Keyword_compatContext) RESULT() antlr.TerminalNode {
	return s.GetToken(YQLParserRESULT, 0)
}

func (s *Keyword_compatContext) REVERT() antlr.TerminalNode {
	return s.GetToken(YQLParserREVERT, 0)
}

func (s *Keyword_compatContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(YQLParserREVOKE, 0)
}

func (s *Keyword_compatContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(YQLParserRIGHT, 0)
}

func (s *Keyword_compatContext) RLIKE() antlr.TerminalNode {
	return s.GetToken(YQLParserRLIKE, 0)
}

func (s *Keyword_compatContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(YQLParserROLLBACK, 0)
}

func (s *Keyword_compatContext) ROW() antlr.TerminalNode {
	return s.GetToken(YQLParserROW, 0)
}

func (s *Keyword_compatContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(YQLParserSAMPLE, 0)
}

func (s *Keyword_compatContext) SAVEPOINT() antlr.TerminalNode {
	return s.GetToken(YQLParserSAVEPOINT, 0)
}

func (s *Keyword_compatContext) SECONDS() antlr.TerminalNode {
	return s.GetToken(YQLParserSECONDS, 0)
}

func (s *Keyword_compatContext) SEEK() antlr.TerminalNode {
	return s.GetToken(YQLParserSEEK, 0)
}

func (s *Keyword_compatContext) SEMI() antlr.TerminalNode {
	return s.GetToken(YQLParserSEMI, 0)
}

func (s *Keyword_compatContext) SETS() antlr.TerminalNode {
	return s.GetToken(YQLParserSETS, 0)
}

func (s *Keyword_compatContext) SHOW() antlr.TerminalNode {
	return s.GetToken(YQLParserSHOW, 0)
}

func (s *Keyword_compatContext) TSKIP() antlr.TerminalNode {
	return s.GetToken(YQLParserTSKIP, 0)
}

func (s *Keyword_compatContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(YQLParserSEQUENCE, 0)
}

func (s *Keyword_compatContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(YQLParserSOURCE, 0)
}

func (s *Keyword_compatContext) START() antlr.TerminalNode {
	return s.GetToken(YQLParserSTART, 0)
}

func (s *Keyword_compatContext) SUBQUERY() antlr.TerminalNode {
	return s.GetToken(YQLParserSUBQUERY, 0)
}

func (s *Keyword_compatContext) SUBSET() antlr.TerminalNode {
	return s.GetToken(YQLParserSUBSET, 0)
}

func (s *Keyword_compatContext) SYMBOLS() antlr.TerminalNode {
	return s.GetToken(YQLParserSYMBOLS, 0)
}

func (s *Keyword_compatContext) SYNC() antlr.TerminalNode {
	return s.GetToken(YQLParserSYNC, 0)
}

func (s *Keyword_compatContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(YQLParserSYSTEM, 0)
}

func (s *Keyword_compatContext) TABLE() antlr.TerminalNode {
	return s.GetToken(YQLParserTABLE, 0)
}

func (s *Keyword_compatContext) TABLES() antlr.TerminalNode {
	return s.GetToken(YQLParserTABLES, 0)
}

func (s *Keyword_compatContext) TABLESAMPLE() antlr.TerminalNode {
	return s.GetToken(YQLParserTABLESAMPLE, 0)
}

func (s *Keyword_compatContext) TABLESTORE() antlr.TerminalNode {
	return s.GetToken(YQLParserTABLESTORE, 0)
}

func (s *Keyword_compatContext) TEMP() antlr.TerminalNode {
	return s.GetToken(YQLParserTEMP, 0)
}

func (s *Keyword_compatContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(YQLParserTEMPORARY, 0)
}

func (s *Keyword_compatContext) THEN() antlr.TerminalNode {
	return s.GetToken(YQLParserTHEN, 0)
}

func (s *Keyword_compatContext) TIES() antlr.TerminalNode {
	return s.GetToken(YQLParserTIES, 0)
}

func (s *Keyword_compatContext) TO() antlr.TerminalNode {
	return s.GetToken(YQLParserTO, 0)
}

func (s *Keyword_compatContext) TOPIC() antlr.TerminalNode {
	return s.GetToken(YQLParserTOPIC, 0)
}

func (s *Keyword_compatContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(YQLParserTRANSACTION, 0)
}

func (s *Keyword_compatContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(YQLParserTRIGGER, 0)
}

func (s *Keyword_compatContext) TYPE() antlr.TerminalNode {
	return s.GetToken(YQLParserTYPE, 0)
}

func (s *Keyword_compatContext) UNCONDITIONAL() antlr.TerminalNode {
	return s.GetToken(YQLParserUNCONDITIONAL, 0)
}

func (s *Keyword_compatContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(YQLParserUNIQUE, 0)
}

func (s *Keyword_compatContext) UNKNOWN() antlr.TerminalNode {
	return s.GetToken(YQLParserUNKNOWN, 0)
}

func (s *Keyword_compatContext) UNMATCHED() antlr.TerminalNode {
	return s.GetToken(YQLParserUNMATCHED, 0)
}

func (s *Keyword_compatContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(YQLParserUPDATE, 0)
}

func (s *Keyword_compatContext) UPSERT() antlr.TerminalNode {
	return s.GetToken(YQLParserUPSERT, 0)
}

func (s *Keyword_compatContext) USE() antlr.TerminalNode {
	return s.GetToken(YQLParserUSE, 0)
}

func (s *Keyword_compatContext) USER() antlr.TerminalNode {
	return s.GetToken(YQLParserUSER, 0)
}

func (s *Keyword_compatContext) USING() antlr.TerminalNode {
	return s.GetToken(YQLParserUSING, 0)
}

func (s *Keyword_compatContext) VACUUM() antlr.TerminalNode {
	return s.GetToken(YQLParserVACUUM, 0)
}

func (s *Keyword_compatContext) VALUES() antlr.TerminalNode {
	return s.GetToken(YQLParserVALUES, 0)
}

func (s *Keyword_compatContext) VIEW() antlr.TerminalNode {
	return s.GetToken(YQLParserVIEW, 0)
}

func (s *Keyword_compatContext) VIRTUAL() antlr.TerminalNode {
	return s.GetToken(YQLParserVIRTUAL, 0)
}

func (s *Keyword_compatContext) WITH() antlr.TerminalNode {
	return s.GetToken(YQLParserWITH, 0)
}

func (s *Keyword_compatContext) WRAPPER() antlr.TerminalNode {
	return s.GetToken(YQLParserWRAPPER, 0)
}

func (s *Keyword_compatContext) XOR() antlr.TerminalNode {
	return s.GetToken(YQLParserXOR, 0)
}

func (s *Keyword_compatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Keyword_compatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Keyword_compatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterKeyword_compat(s)
	}
}

func (s *Keyword_compatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitKeyword_compat(s)
	}
}




func (p *YQLParser) Keyword_compat() (localctx IKeyword_compatContext) {
	localctx = NewKeyword_compatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 856, YQLParserRULE_keyword_compat)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4557)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la - 38)) & ^0x3f) == 0 && ((int64(1) << (_la - 38)) & -16327067659430417) != 0) || ((int64((_la - 102)) & ^0x3f) == 0 && ((int64(1) << (_la - 102)) & -915636042698821) != 0) || ((int64((_la - 166)) & ^0x3f) == 0 && ((int64(1) << (_la - 166)) & -17613660980101) != 0) || ((int64((_la - 230)) & ^0x3f) == 0 && ((int64(1) << (_la - 230)) & -581387978539147363) != 0) || ((int64((_la - 294)) & ^0x3f) == 0 && ((int64(1) << (_la - 294)) & 879754575) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IType_idContext is an interface to support dynamic dispatch.
type IType_idContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPTIONAL() antlr.TerminalNode
	TUPLE() antlr.TerminalNode
	STRUCT() antlr.TerminalNode
	VARIANT() antlr.TerminalNode
	LIST() antlr.TerminalNode
	FLOW() antlr.TerminalNode
	DICT() antlr.TerminalNode
	SET() antlr.TerminalNode
	ENUM() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	TAGGED() antlr.TerminalNode
	CALLABLE() antlr.TerminalNode

	// IsType_idContext differentiates from other interfaces.
	IsType_idContext()
}

type Type_idContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_idContext() *Type_idContext {
	var p = new(Type_idContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_id
	return p
}

func InitEmptyType_idContext(p *Type_idContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_type_id
}

func (*Type_idContext) IsType_idContext() {}

func NewType_idContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_idContext {
	var p = new(Type_idContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_type_id

	return p
}

func (s *Type_idContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_idContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(YQLParserOPTIONAL, 0)
}

func (s *Type_idContext) TUPLE() antlr.TerminalNode {
	return s.GetToken(YQLParserTUPLE, 0)
}

func (s *Type_idContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(YQLParserSTRUCT, 0)
}

func (s *Type_idContext) VARIANT() antlr.TerminalNode {
	return s.GetToken(YQLParserVARIANT, 0)
}

func (s *Type_idContext) LIST() antlr.TerminalNode {
	return s.GetToken(YQLParserLIST, 0)
}

func (s *Type_idContext) FLOW() antlr.TerminalNode {
	return s.GetToken(YQLParserFLOW, 0)
}

func (s *Type_idContext) DICT() antlr.TerminalNode {
	return s.GetToken(YQLParserDICT, 0)
}

func (s *Type_idContext) SET() antlr.TerminalNode {
	return s.GetToken(YQLParserSET, 0)
}

func (s *Type_idContext) ENUM() antlr.TerminalNode {
	return s.GetToken(YQLParserENUM, 0)
}

func (s *Type_idContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(YQLParserRESOURCE, 0)
}

func (s *Type_idContext) TAGGED() antlr.TerminalNode {
	return s.GetToken(YQLParserTAGGED, 0)
}

func (s *Type_idContext) CALLABLE() antlr.TerminalNode {
	return s.GetToken(YQLParserCALLABLE, 0)
}

func (s *Type_idContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_idContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Type_idContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterType_id(s)
	}
}

func (s *Type_idContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitType_id(s)
	}
}




func (p *YQLParser) Type_id() (localctx IType_idContext) {
	localctx = NewType_idContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 858, YQLParserRULE_type_id)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4559)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la - 67)) & ^0x3f) == 0 && ((int64(1) << (_la - 67)) & 1126037345796097) != 0) || _la == YQLParserFLOW || _la == YQLParserLIST || ((int64((_la - 210)) & ^0x3f) == 0 && ((int64(1) << (_la - 210)) & 1152921642045800449) != 0) || ((int64((_la - 278)) & ^0x3f) == 0 && ((int64(1) << (_la - 278)) & 68721575937) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBool_valueContext is an interface to support dynamic dispatch.
type IBool_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsBool_valueContext differentiates from other interfaces.
	IsBool_valueContext()
}

type Bool_valueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_valueContext() *Bool_valueContext {
	var p = new(Bool_valueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_bool_value
	return p
}

func InitEmptyBool_valueContext(p *Bool_valueContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_bool_value
}

func (*Bool_valueContext) IsBool_valueContext() {}

func NewBool_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_valueContext {
	var p = new(Bool_valueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_bool_value

	return p
}

func (s *Bool_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Bool_valueContext) TRUE() antlr.TerminalNode {
	return s.GetToken(YQLParserTRUE, 0)
}

func (s *Bool_valueContext) FALSE() antlr.TerminalNode {
	return s.GetToken(YQLParserFALSE, 0)
}

func (s *Bool_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Bool_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterBool_value(s)
	}
}

func (s *Bool_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitBool_value(s)
	}
}




func (p *YQLParser) Bool_value() (localctx IBool_valueContext) {
	localctx = NewBool_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 860, YQLParserRULE_bool_value)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4561)
		_la = p.GetTokenStream().LA(1)

		if !(_la == YQLParserFALSE || _la == YQLParserTRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRealContext is an interface to support dynamic dispatch.
type IRealContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REAL() antlr.TerminalNode

	// IsRealContext differentiates from other interfaces.
	IsRealContext()
}

type RealContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRealContext() *RealContext {
	var p = new(RealContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_real
	return p
}

func InitEmptyRealContext(p *RealContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_real
}

func (*RealContext) IsRealContext() {}

func NewRealContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RealContext {
	var p = new(RealContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_real

	return p
}

func (s *RealContext) GetParser() antlr.Parser { return s.parser }

func (s *RealContext) REAL() antlr.TerminalNode {
	return s.GetToken(YQLParserREAL, 0)
}

func (s *RealContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RealContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RealContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterReal(s)
	}
}

func (s *RealContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitReal(s)
	}
}




func (p *YQLParser) Real_() (localctx IRealContext) {
	localctx = NewRealContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 862, YQLParserRULE_real)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4563)
		p.Match(YQLParserREAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIntegerContext is an interface to support dynamic dispatch.
type IIntegerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DIGITS() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsIntegerContext differentiates from other interfaces.
	IsIntegerContext()
}

type IntegerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntegerContext() *IntegerContext {
	var p = new(IntegerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_integer
	return p
}

func InitEmptyIntegerContext(p *IntegerContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = YQLParserRULE_integer
}

func (*IntegerContext) IsIntegerContext() {}

func NewIntegerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntegerContext {
	var p = new(IntegerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = YQLParserRULE_integer

	return p
}

func (s *IntegerContext) GetParser() antlr.Parser { return s.parser }

func (s *IntegerContext) DIGITS() antlr.TerminalNode {
	return s.GetToken(YQLParserDIGITS, 0)
}

func (s *IntegerContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(YQLParserINTEGER_VALUE, 0)
}

func (s *IntegerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IntegerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.EnterInteger(s)
	}
}

func (s *IntegerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(YQLListener); ok {
		listenerT.ExitInteger(s)
	}
}




func (p *YQLParser) Integer() (localctx IIntegerContext) {
	localctx = NewIntegerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 864, YQLParserRULE_integer)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4565)
		_la = p.GetTokenStream().LA(1)

		if !(_la == YQLParserDIGITS || _la == YQLParserINTEGER_VALUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


